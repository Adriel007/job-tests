{"version":3,"file":"video-lazy.min.js","sources":["../src/video-lazy.js"],"sourcesContent":["/**\n * @license\n * Video.js 8.3.0 <http://videojs.com/>\n * Copyright Brightcove, Inc. <https://www.brightcove.com/>\n * Available under Apache License Version 2.0\n * <https://github.com/videojs/video.js/blob/main/LICENSE>\n *\n * Includes vtt.js <https://github.com/mozilla/vtt.js>\n * Available under Apache License Version 2.0\n * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>\n */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n        typeof define === 'function' && define.amd ? define(factory) :\n            (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.videojs = factory());\n})(this, (function () { 'use strict';\n\n    var version$5 = \"8.3.0\";\n\n    /**\n     * An Object that contains lifecycle hooks as keys which point to an array\n     * of functions that are run when a lifecycle is triggered\n     *\n     * @private\n     */\n    const hooks_ = {};\n\n    /**\n     * Get a list of hooks for a specific lifecycle\n     *\n     * @param  {string} type\n     *         the lifecycle to get hooks from\n     *\n     * @param  {Function|Function[]} [fn]\n     *         Optionally add a hook (or hooks) to the lifecycle that your are getting.\n     *\n     * @return {Array}\n     *         an array of hooks, or an empty array if there are none.\n     */\n    const hooks = function (type, fn) {\n        hooks_[type] = hooks_[type] || [];\n        if (fn) {\n            hooks_[type] = hooks_[type].concat(fn);\n        }\n        return hooks_[type];\n    };\n\n    /**\n     * Add a function hook to a specific videojs lifecycle.\n     *\n     * @param {string} type\n     *        the lifecycle to hook the function to.\n     *\n     * @param {Function|Function[]}\n     *        The function or array of functions to attach.\n     */\n    const hook = function (type, fn) {\n        hooks(type, fn);\n    };\n\n    /**\n     * Remove a hook from a specific videojs lifecycle.\n     *\n     * @param  {string} type\n     *         the lifecycle that the function hooked to\n     *\n     * @param  {Function} fn\n     *         The hooked function to remove\n     *\n     * @return {boolean}\n     *         The function that was removed or undef\n     */\n    const removeHook = function (type, fn) {\n        const index = hooks(type).indexOf(fn);\n        if (index <= -1) {\n            return false;\n        }\n        hooks_[type] = hooks_[type].slice();\n        hooks_[type].splice(index, 1);\n        return true;\n    };\n\n    /**\n     * Add a function hook that will only run once to a specific videojs lifecycle.\n     *\n     * @param {string} type\n     *        the lifecycle to hook the function to.\n     *\n     * @param {Function|Function[]}\n     *        The function or array of functions to attach.\n     */\n    const hookOnce = function (type, fn) {\n        hooks(type, [].concat(fn).map(original => {\n            const wrapper = (...args) => {\n                removeHook(type, wrapper);\n                return original(...args);\n            };\n            return wrapper;\n        }));\n    };\n\n    /**\n     * @file fullscreen-api.js\n     * @module fullscreen-api\n     */\n\n    /**\n     * Store the browser-specific methods for the fullscreen API.\n     *\n     * @type {Object}\n     * @see [Specification]{@link https://fullscreen.spec.whatwg.org}\n     * @see [Map Approach From Screenfull.js]{@link https://github.com/sindresorhus/screenfull.js}\n     */\n    const FullscreenApi = {\n        prefixed: true\n    };\n\n    // browser API methods\n    const apiMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror', 'fullscreen'],\n        // WebKit\n        ['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror', '-webkit-full-screen'],\n        // Mozilla\n        ['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror', '-moz-full-screen'],\n        // Microsoft\n        ['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError', '-ms-fullscreen']];\n    const specApi = apiMap[0];\n    let browserApi;\n\n    // determine the supported set of functions\n    for (let i = 0; i < apiMap.length; i++) {\n        // check for exitFullscreen function\n        if (apiMap[i][1] in document) {\n            browserApi = apiMap[i];\n            break;\n        }\n    }\n\n    // map the browser API names to the spec API names\n    if (browserApi) {\n        for (let i = 0; i < browserApi.length; i++) {\n            FullscreenApi[specApi[i]] = browserApi[i];\n        }\n        FullscreenApi.prefixed = browserApi[0] !== specApi[0];\n    }\n\n    /**\n     * @file create-logger.js\n     * @module create-logger\n     */\n\n        // This is the private tracking variable for the logging history.\n    let history = [];\n\n    /**\n     * Log messages to the console and history based on the type of message\n     *\n     * @private\n     * @param  {string} type\n     *         The name of the console method to use.\n     *\n     * @param  {Array} args\n     *         The arguments to be passed to the matching console method.\n     */\n    const LogByTypeFactory = (name, log) => (type, level, args) => {\n        const lvl = log.levels[level];\n        const lvlRegExp = new RegExp(`^(${lvl})$`);\n        if (type !== 'log') {\n            // Add the type to the front of the message when it's not \"log\".\n            args.unshift(type.toUpperCase() + ':');\n        }\n\n        // Add console prefix after adding to history.\n        args.unshift(name + ':');\n\n        // Add a clone of the args at this point to history.\n        if (history) {\n            history.push([].concat(args));\n\n            // only store 1000 history entries\n            const splice = history.length - 1000;\n            history.splice(0, splice > 0 ? splice : 0);\n        }\n\n        // If there's no console then don't try to output messages, but they will\n        // still be stored in history.\n        if (!window.console) {\n            return;\n        }\n\n        // Was setting these once outside of this function, but containing them\n        // in the function makes it easier to test cases where console doesn't exist\n        // when the module is executed.\n        let fn = window.console[type];\n        if (!fn && type === 'debug') {\n            // Certain browsers don't have support for console.debug. For those, we\n            // should default to the closest comparable log.\n            fn = window.console.info || window.console.log;\n        }\n\n        // Bail out if there's no console or if this type is not allowed by the\n        // current logging level.\n        if (!fn || !lvl || !lvlRegExp.test(type)) {\n            return;\n        }\n        fn[Array.isArray(args) ? 'apply' : 'call'](window.console, args);\n    };\n    function createLogger$1(name) {\n        // This is the private tracking variable for logging level.\n        let level = 'info';\n\n        // the curried logByType bound to the specific log and history\n        let logByType;\n\n        /**\n         * Logs plain debug messages. Similar to `console.log`.\n         *\n         * Due to [limitations](https://github.com/jsdoc3/jsdoc/issues/955#issuecomment-313829149)\n         * of our JSDoc template, we cannot properly document this as both a function\n         * and a namespace, so its function signature is documented here.\n         *\n         * #### Arguments\n         * ##### *args\n         * *[]\n         *\n         * Any combination of values that could be passed to `console.log()`.\n         *\n         * #### Return Value\n         *\n         * `undefined`\n         *\n         * @namespace\n         * @param    {...*} args\n         *           One or more messages or objects that should be logged.\n         */\n        const log = function (...args) {\n            logByType('log', level, args);\n        };\n\n        // This is the logByType helper that the logging methods below use\n        logByType = LogByTypeFactory(name, log);\n\n        /**\n         * Create a new sublogger which chains the old name to the new name.\n         *\n         * For example, doing `videojs.log.createLogger('player')` and then using that logger will log the following:\n         * ```js\n         *  mylogger('foo');\n         *  // > VIDEOJS: player: foo\n         * ```\n         *\n         * @param {string} name\n         *        The name to add call the new logger\n         * @return {Object}\n         */\n        log.createLogger = subname => createLogger$1(name + ': ' + subname);\n\n        /**\n         * Enumeration of available logging levels, where the keys are the level names\n         * and the values are `|`-separated strings containing logging methods allowed\n         * in that logging level. These strings are used to create a regular expression\n         * matching the function name being called.\n         *\n         * Levels provided by Video.js are:\n         *\n         * - `off`: Matches no calls. Any value that can be cast to `false` will have\n         *   this effect. The most restrictive.\n         * - `all`: Matches only Video.js-provided functions (`debug`, `log`,\n         *   `log.warn`, and `log.error`).\n         * - `debug`: Matches `log.debug`, `log`, `log.warn`, and `log.error` calls.\n         * - `info` (default): Matches `log`, `log.warn`, and `log.error` calls.\n         * - `warn`: Matches `log.warn` and `log.error` calls.\n         * - `error`: Matches only `log.error` calls.\n         *\n         * @type {Object}\n         */\n        log.levels = {\n            all: 'debug|log|warn|error',\n            off: '',\n            debug: 'debug|log|warn|error',\n            info: 'log|warn|error',\n            warn: 'warn|error',\n            error: 'error',\n            DEFAULT: level\n        };\n\n        /**\n         * Get or set the current logging level.\n         *\n         * If a string matching a key from {@link module:log.levels} is provided, acts\n         * as a setter.\n         *\n         * @param  {string} [lvl]\n         *         Pass a valid level to set a new logging level.\n         *\n         * @return {string}\n         *         The current logging level.\n         */\n        log.level = lvl => {\n            if (typeof lvl === 'string') {\n                if (!log.levels.hasOwnProperty(lvl)) {\n                    throw new Error(`\"${lvl}\" in not a valid log level`);\n                }\n                level = lvl;\n            }\n            return level;\n        };\n\n        /**\n         * Returns an array containing everything that has been logged to the history.\n         *\n         * This array is a shallow clone of the internal history record. However, its\n         * contents are _not_ cloned; so, mutating objects inside this array will\n         * mutate them in history.\n         *\n         * @return {Array}\n         */\n        log.history = () => history ? [].concat(history) : [];\n\n        /**\n         * Allows you to filter the history by the given logger name\n         *\n         * @param {string} fname\n         *        The name to filter by\n         *\n         * @return {Array}\n         *         The filtered list to return\n         */\n        log.history.filter = fname => {\n            return (history || []).filter(historyItem => {\n                // if the first item in each historyItem includes `fname`, then it's a match\n                return new RegExp(`.*${fname}.*`).test(historyItem[0]);\n            });\n        };\n\n        /**\n         * Clears the internal history tracking, but does not prevent further history\n         * tracking.\n         */\n        log.history.clear = () => {\n            if (history) {\n                history.length = 0;\n            }\n        };\n\n        /**\n         * Disable history tracking if it is currently enabled.\n         */\n        log.history.disable = () => {\n            if (history !== null) {\n                history.length = 0;\n                history = null;\n            }\n        };\n\n        /**\n         * Enable history tracking if it is currently disabled.\n         */\n        log.history.enable = () => {\n            if (history === null) {\n                history = [];\n            }\n        };\n\n        /**\n         * Logs error messages. Similar to `console.error`.\n         *\n         * @param {...*} args\n         *        One or more messages or objects that should be logged as an error\n         */\n        log.error = (...args) => logByType('error', level, args);\n\n        /**\n         * Logs warning messages. Similar to `console.warn`.\n         *\n         * @param {...*} args\n         *        One or more messages or objects that should be logged as a warning.\n         */\n        log.warn = (...args) => logByType('warn', level, args);\n\n        /**\n         * Logs debug messages. Similar to `console.debug`, but may also act as a comparable\n         * log if `console.debug` is not available\n         *\n         * @param {...*} args\n         *        One or more messages or objects that should be logged as debug.\n         */\n        log.debug = (...args) => logByType('debug', level, args);\n        return log;\n    }\n\n    /**\n     * @file log.js\n     * @module log\n     */\n    const log$1 = createLogger$1('VIDEOJS');\n    const createLogger = log$1.createLogger;\n\n    /**\n     * @file obj.js\n     * @module obj\n     */\n\n    /**\n     * @callback obj:EachCallback\n     *\n     * @param {*} value\n     *        The current key for the object that is being iterated over.\n     *\n     * @param {string} key\n     *        The current key-value for object that is being iterated over\n     */\n\n    /**\n     * @callback obj:ReduceCallback\n     *\n     * @param {*} accum\n     *        The value that is accumulating over the reduce loop.\n     *\n     * @param {*} value\n     *        The current key for the object that is being iterated over.\n     *\n     * @param {string} key\n     *        The current key-value for object that is being iterated over\n     *\n     * @return {*}\n     *         The new accumulated value.\n     */\n    const toString$1 = Object.prototype.toString;\n\n    /**\n     * Get the keys of an Object\n     *\n     * @param {Object}\n     *        The Object to get the keys from\n     *\n     * @return {string[]}\n     *         An array of the keys from the object. Returns an empty array if the\n     *         object passed in was invalid or had no keys.\n     *\n     * @private\n     */\n    const keys = function (object) {\n        return isObject$1(object) ? Object.keys(object) : [];\n    };\n\n    /**\n     * Array-like iteration for objects.\n     *\n     * @param {Object} object\n     *        The object to iterate over\n     *\n     * @param {obj:EachCallback} fn\n     *        The callback function which is called for each key in the object.\n     */\n    function each(object, fn) {\n        keys(object).forEach(key => fn(object[key], key));\n    }\n\n    /**\n     * Array-like reduce for objects.\n     *\n     * @param {Object} object\n     *        The Object that you want to reduce.\n     *\n     * @param {Function} fn\n     *         A callback function which is called for each key in the object. It\n     *         receives the accumulated value and the per-iteration value and key\n     *         as arguments.\n     *\n     * @param {*} [initial = 0]\n     *        Starting value\n     *\n     * @return {*}\n     *         The final accumulated value.\n     */\n    function reduce(object, fn, initial = 0) {\n        return keys(object).reduce((accum, key) => fn(accum, object[key], key), initial);\n    }\n\n    /**\n     * Returns whether a value is an object of any kind - including DOM nodes,\n     * arrays, regular expressions, etc. Not functions, though.\n     *\n     * This avoids the gotcha where using `typeof` on a `null` value\n     * results in `'object'`.\n     *\n     * @param  {Object} value\n     * @return {boolean}\n     */\n    function isObject$1(value) {\n        return !!value && typeof value === 'object';\n    }\n\n    /**\n     * Returns whether an object appears to be a \"plain\" object - that is, a\n     * direct instance of `Object`.\n     *\n     * @param  {Object} value\n     * @return {boolean}\n     */\n    function isPlain(value) {\n        return isObject$1(value) && toString$1.call(value) === '[object Object]' && value.constructor === Object;\n    }\n\n    /**\n     * Merge two objects recursively.\n     *\n     * Performs a deep merge like\n     * {@link https://lodash.com/docs/4.17.10#merge|lodash.merge}, but only merges\n     * plain objects (not arrays, elements, or anything else).\n     *\n     * Non-plain object values will be copied directly from the right-most\n     * argument.\n     *\n     * @param   {Object[]} sources\n     *          One or more objects to merge into a new object.\n     *\n     * @return {Object}\n     *          A new object that is the merged result of all sources.\n     */\n    function merge$2(...sources) {\n        const result = {};\n        sources.forEach(source => {\n            if (!source) {\n                return;\n            }\n            each(source, (value, key) => {\n                if (!isPlain(value)) {\n                    result[key] = value;\n                    return;\n                }\n                if (!isPlain(result[key])) {\n                    result[key] = {};\n                }\n                result[key] = merge$2(result[key], value);\n            });\n        });\n        return result;\n    }\n\n    /**\n     * Object.defineProperty but \"lazy\", which means that the value is only set after\n     * it is retrieved the first time, rather than being set right away.\n     *\n     * @param {Object} obj the object to set the property on\n     * @param {string} key the key for the property to set\n     * @param {Function} getValue the function used to get the value when it is needed.\n     * @param {boolean} setter whether a setter should be allowed or not\n     */\n    function defineLazyProperty(obj, key, getValue, setter = true) {\n        const set = value => Object.defineProperty(obj, key, {\n            value,\n            enumerable: true,\n            writable: true\n        });\n        const options = {\n            configurable: true,\n            enumerable: true,\n            get() {\n                const value = getValue();\n                set(value);\n                return value;\n            }\n        };\n        if (setter) {\n            options.set = set;\n        }\n        return Object.defineProperty(obj, key, options);\n    }\n\n    var Obj = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        each: each,\n        reduce: reduce,\n        isObject: isObject$1,\n        isPlain: isPlain,\n        merge: merge$2,\n        defineLazyProperty: defineLazyProperty\n    });\n\n    /**\n     * @file browser.js\n     * @module browser\n     */\n\n    /**\n     * Whether or not this device is an iPod.\n     *\n     * @static\n     * @type {Boolean}\n     */\n    let IS_IPOD = false;\n\n    /**\n     * The detected iOS version - or `null`.\n     *\n     * @static\n     * @type {string|null}\n     */\n    let IOS_VERSION = null;\n\n    /**\n     * Whether or not this is an Android device.\n     *\n     * @static\n     * @type {Boolean}\n     */\n    let IS_ANDROID = false;\n\n    /**\n     * The detected Android version - or `null` if not Android or indeterminable.\n     *\n     * @static\n     * @type {number|string|null}\n     */\n    let ANDROID_VERSION;\n\n    /**\n     * Whether or not this is Mozilla Firefox.\n     *\n     * @static\n     * @type {Boolean}\n     */\n    let IS_FIREFOX = false;\n\n    /**\n     * Whether or not this is Microsoft Edge.\n     *\n     * @static\n     * @type {Boolean}\n     */\n    let IS_EDGE = false;\n\n    /**\n     * Whether or not this is any Chromium Browser\n     *\n     * @static\n     * @type {Boolean}\n     */\n    let IS_CHROMIUM = false;\n\n    /**\n     * Whether or not this is any Chromium browser that is not Edge.\n     *\n     * This will also be `true` for Chrome on iOS, which will have different support\n     * as it is actually Safari under the hood.\n     *\n     * Deprecated, as the behaviour to not match Edge was to prevent Legacy Edge's UA matching.\n     * IS_CHROMIUM should be used instead.\n     * \"Chromium but not Edge\" could be explicitly tested with IS_CHROMIUM && !IS_EDGE\n     *\n     * @static\n     * @deprecated\n     * @type {Boolean}\n     */\n    let IS_CHROME = false;\n\n    /**\n     * The detected Chromium version - or `null`.\n     *\n     * @static\n     * @type {number|null}\n     */\n    let CHROMIUM_VERSION = null;\n\n    /**\n     * The detected Google Chrome version - or `null`.\n     * This has always been the _Chromium_ version, i.e. would return on Chromium Edge.\n     * Deprecated, use CHROMIUM_VERSION instead.\n     *\n     * @static\n     * @deprecated\n     * @type {number|null}\n     */\n    let CHROME_VERSION = null;\n\n    /**\n     * The detected Internet Explorer version - or `null`.\n     *\n     * @static\n     * @deprecated\n     * @type {number|null}\n     */\n    let IE_VERSION = null;\n\n    /**\n     * Whether or not this is desktop Safari.\n     *\n     * @static\n     * @type {Boolean}\n     */\n    let IS_SAFARI = false;\n\n    /**\n     * Whether or not this is a Windows machine.\n     *\n     * @static\n     * @type {Boolean}\n     */\n    let IS_WINDOWS = false;\n\n    /**\n     * Whether or not this device is an iPad.\n     *\n     * @static\n     * @type {Boolean}\n     */\n    let IS_IPAD = false;\n\n    /**\n     * Whether or not this device is an iPhone.\n     *\n     * @static\n     * @type {Boolean}\n     */\n        // The Facebook app's UIWebView identifies as both an iPhone and iPad, so\n        // to identify iPhones, we need to exclude iPads.\n        // http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/\n    let IS_IPHONE = false;\n\n    /**\n     * Whether or not this device is touch-enabled.\n     *\n     * @static\n     * @const\n     * @type {Boolean}\n     */\n    const TOUCH_ENABLED = Boolean(isReal() && ('ontouchstart' in window || window.navigator.maxTouchPoints || window.DocumentTouch && window.document instanceof window.DocumentTouch));\n    const UAD = window.navigator && window.navigator.userAgentData;\n    if (UAD) {\n        // If userAgentData is present, use it instead of userAgent to avoid warnings\n        // Currently only implemented on Chromium\n        // userAgentData does not expose Android version, so ANDROID_VERSION remains `null`\n\n        IS_ANDROID = UAD.platform === 'Android';\n        IS_EDGE = Boolean(UAD.brands.find(b => b.brand === 'Microsoft Edge'));\n        IS_CHROMIUM = Boolean(UAD.brands.find(b => b.brand === 'Chromium'));\n        IS_CHROME = !IS_EDGE && IS_CHROMIUM;\n        CHROMIUM_VERSION = CHROME_VERSION = (UAD.brands.find(b => b.brand === 'Chromium') || {}).version || null;\n        IS_WINDOWS = UAD.platform === 'Windows';\n    }\n\n    // If the browser is not Chromium, either userAgentData is not present which could be an old Chromium browser,\n    //  or it's a browser that has added userAgentData since that we don't have tests for yet. In either case,\n    // the checks need to be made agiainst the regular userAgent string.\n    if (!IS_CHROMIUM) {\n        const USER_AGENT = window.navigator && window.navigator.userAgent || '';\n        IS_IPOD = /iPod/i.test(USER_AGENT);\n        IOS_VERSION = function () {\n            const match = USER_AGENT.match(/OS (\\d+)_/i);\n            if (match && match[1]) {\n                return match[1];\n            }\n            return null;\n        }();\n        IS_ANDROID = /Android/i.test(USER_AGENT);\n        ANDROID_VERSION = function () {\n            // This matches Android Major.Minor.Patch versions\n            // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned\n            const match = USER_AGENT.match(/Android (\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))*/i);\n            if (!match) {\n                return null;\n            }\n            const major = match[1] && parseFloat(match[1]);\n            const minor = match[2] && parseFloat(match[2]);\n            if (major && minor) {\n                return parseFloat(match[1] + '.' + match[2]);\n            } else if (major) {\n                return major;\n            }\n            return null;\n        }();\n        IS_FIREFOX = /Firefox/i.test(USER_AGENT);\n        IS_EDGE = /Edg/i.test(USER_AGENT);\n        IS_CHROMIUM = /Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT);\n        IS_CHROME = !IS_EDGE && IS_CHROMIUM;\n        CHROMIUM_VERSION = CHROME_VERSION = function () {\n            const match = USER_AGENT.match(/(Chrome|CriOS)\\/(\\d+)/);\n            if (match && match[2]) {\n                return parseFloat(match[2]);\n            }\n            return null;\n        }();\n        IE_VERSION = function () {\n            const result = /MSIE\\s(\\d+)\\.\\d/.exec(USER_AGENT);\n            let version = result && parseFloat(result[1]);\n            if (!version && /Trident\\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {\n                // IE 11 has a different user agent string than other IE versions\n                version = 11.0;\n            }\n            return version;\n        }();\n        IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;\n        IS_WINDOWS = /Windows/i.test(USER_AGENT);\n        IS_IPAD = /iPad/i.test(USER_AGENT) || IS_SAFARI && TOUCH_ENABLED && !/iPhone/i.test(USER_AGENT);\n        IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;\n    }\n\n    /**\n     * Whether or not this is an iOS device.\n     *\n     * @static\n     * @const\n     * @type {Boolean}\n     */\n    const IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;\n\n    /**\n     * Whether or not this is any flavor of Safari - including iOS.\n     *\n     * @static\n     * @const\n     * @type {Boolean}\n     */\n    const IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;\n\n    var browser = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        get IS_IPOD () { return IS_IPOD; },\n        get IOS_VERSION () { return IOS_VERSION; },\n        get IS_ANDROID () { return IS_ANDROID; },\n        get ANDROID_VERSION () { return ANDROID_VERSION; },\n        get IS_FIREFOX () { return IS_FIREFOX; },\n        get IS_EDGE () { return IS_EDGE; },\n        get IS_CHROMIUM () { return IS_CHROMIUM; },\n        get IS_CHROME () { return IS_CHROME; },\n        get CHROMIUM_VERSION () { return CHROMIUM_VERSION; },\n        get CHROME_VERSION () { return CHROME_VERSION; },\n        get IE_VERSION () { return IE_VERSION; },\n        get IS_SAFARI () { return IS_SAFARI; },\n        get IS_WINDOWS () { return IS_WINDOWS; },\n        get IS_IPAD () { return IS_IPAD; },\n        get IS_IPHONE () { return IS_IPHONE; },\n        TOUCH_ENABLED: TOUCH_ENABLED,\n        IS_IOS: IS_IOS,\n        IS_ANY_SAFARI: IS_ANY_SAFARI\n    });\n\n    /**\n     * @file dom.js\n     * @module dom\n     */\n\n    /**\n     * Detect if a value is a string with any non-whitespace characters.\n     *\n     * @private\n     * @param  {string} str\n     *         The string to check\n     *\n     * @return {boolean}\n     *         Will be `true` if the string is non-blank, `false` otherwise.\n     *\n     */\n    function isNonBlankString(str) {\n        // we use str.trim as it will trim any whitespace characters\n        // from the front or back of non-whitespace characters. aka\n        // Any string that contains non-whitespace characters will\n        // still contain them after `trim` but whitespace only strings\n        // will have a length of 0, failing this check.\n        return typeof str === 'string' && Boolean(str.trim());\n    }\n\n    /**\n     * Throws an error if the passed string has whitespace. This is used by\n     * class methods to be relatively consistent with the classList API.\n     *\n     * @private\n     * @param  {string} str\n     *         The string to check for whitespace.\n     *\n     * @throws {Error}\n     *         Throws an error if there is whitespace in the string.\n     */\n    function throwIfWhitespace(str) {\n        // str.indexOf instead of regex because str.indexOf is faster performance wise.\n        if (str.indexOf(' ') >= 0) {\n            throw new Error('class has illegal whitespace characters');\n        }\n    }\n\n    /**\n     * Whether the current DOM interface appears to be real (i.e. not simulated).\n     *\n     * @return {boolean}\n     *         Will be `true` if the DOM appears to be real, `false` otherwise.\n     */\n    function isReal() {\n        // Both document and window will never be undefined thanks to `global`.\n        return document === window.document;\n    }\n\n    /**\n     * Determines, via duck typing, whether or not a value is a DOM element.\n     *\n     * @param  {*} value\n     *         The value to check.\n     *\n     * @return {boolean}\n     *         Will be `true` if the value is a DOM element, `false` otherwise.\n     */\n    function isEl(value) {\n        return isObject$1(value) && value.nodeType === 1;\n    }\n\n    /**\n     * Determines if the current DOM is embedded in an iframe.\n     *\n     * @return {boolean}\n     *         Will be `true` if the DOM is embedded in an iframe, `false`\n     *         otherwise.\n     */\n    function isInFrame() {\n        // We need a try/catch here because Safari will throw errors when attempting\n        // to get either `parent` or `self`\n        try {\n            return window.parent !== window.self;\n        } catch (x) {\n            return true;\n        }\n    }\n\n    /**\n     * Creates functions to query the DOM using a given method.\n     *\n     * @private\n     * @param   {string} method\n     *          The method to create the query with.\n     *\n     * @return  {Function}\n     *          The query method\n     */\n    function createQuerier(method) {\n        return function (selector, context) {\n            if (!isNonBlankString(selector)) {\n                return document[method](null);\n            }\n            if (isNonBlankString(context)) {\n                context = document.querySelector(context);\n            }\n            const ctx = isEl(context) ? context : document;\n            return ctx[method] && ctx[method](selector);\n        };\n    }\n\n    /**\n     * Creates an element and applies properties, attributes, and inserts content.\n     *\n     * @param  {string} [tagName='div']\n     *         Name of tag to be created.\n     *\n     * @param  {Object} [properties={}]\n     *         Element properties to be applied.\n     *\n     * @param  {Object} [attributes={}]\n     *         Element attributes to be applied.\n     *\n     * @param {ContentDescriptor} [content]\n     *        A content descriptor object.\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    function createEl(tagName = 'div', properties = {}, attributes = {}, content) {\n        const el = document.createElement(tagName);\n        Object.getOwnPropertyNames(properties).forEach(function (propName) {\n            const val = properties[propName];\n\n            // Handle textContent since it's not supported everywhere and we have a\n            // method for it.\n            if (propName === 'textContent') {\n                textContent(el, val);\n            } else if (el[propName] !== val || propName === 'tabIndex') {\n                el[propName] = val;\n            }\n        });\n        Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n            el.setAttribute(attrName, attributes[attrName]);\n        });\n        if (content) {\n            appendContent(el, content);\n        }\n        return el;\n    }\n\n    /**\n     * Injects text into an element, replacing any existing contents entirely.\n     *\n     * @param  {Element} el\n     *         The element to add text content into\n     *\n     * @param  {string} text\n     *         The text content to add.\n     *\n     * @return {Element}\n     *         The element with added text content.\n     */\n    function textContent(el, text) {\n        if (typeof el.textContent === 'undefined') {\n            el.innerText = text;\n        } else {\n            el.textContent = text;\n        }\n        return el;\n    }\n\n    /**\n     * Insert an element as the first child node of another\n     *\n     * @param {Element} child\n     *        Element to insert\n     *\n     * @param {Element} parent\n     *        Element to insert child into\n     */\n    function prependTo(child, parent) {\n        if (parent.firstChild) {\n            parent.insertBefore(child, parent.firstChild);\n        } else {\n            parent.appendChild(child);\n        }\n    }\n\n    /**\n     * Check if an element has a class name.\n     *\n     * @param  {Element} element\n     *         Element to check\n     *\n     * @param  {string} classToCheck\n     *         Class name to check for\n     *\n     * @return {boolean}\n     *         Will be `true` if the element has a class, `false` otherwise.\n     *\n     * @throws {Error}\n     *         Throws an error if `classToCheck` has white space.\n     */\n    function hasClass(element, classToCheck) {\n        throwIfWhitespace(classToCheck);\n        return element.classList.contains(classToCheck);\n    }\n\n    /**\n     * Add a class name to an element.\n     *\n     * @param  {Element} element\n     *         Element to add class name to.\n     *\n     * @param  {...string} classesToAdd\n     *         One or more class name to add.\n     *\n     * @return {Element}\n     *         The DOM element with the added class name.\n     */\n    function addClass(element, ...classesToAdd) {\n        element.classList.add(...classesToAdd.reduce((prev, current) => prev.concat(current.split(/\\s+/)), []));\n        return element;\n    }\n\n    /**\n     * Remove a class name from an element.\n     *\n     * @param  {Element} element\n     *         Element to remove a class name from.\n     *\n     * @param  {...string} classesToRemove\n     *         One or more class name to remove.\n     *\n     * @return {Element}\n     *         The DOM element with class name removed.\n     */\n    function removeClass(element, ...classesToRemove) {\n        // Protect in case the player gets disposed\n        if (!element) {\n            log$1.warn(\"removeClass was called with an element that doesn't exist\");\n            return null;\n        }\n        element.classList.remove(...classesToRemove.reduce((prev, current) => prev.concat(current.split(/\\s+/)), []));\n        return element;\n    }\n\n    /**\n     * The callback definition for toggleClass.\n     *\n     * @callback module:dom~PredicateCallback\n     * @param    {Element} element\n     *           The DOM element of the Component.\n     *\n     * @param    {string} classToToggle\n     *           The `className` that wants to be toggled\n     *\n     * @return   {boolean|undefined}\n     *           If `true` is returned, the `classToToggle` will be added to the\n     *           `element`. If `false`, the `classToToggle` will be removed from\n     *           the `element`. If `undefined`, the callback will be ignored.\n     */\n\n    /**\n     * Adds or removes a class name to/from an element depending on an optional\n     * condition or the presence/absence of the class name.\n     *\n     * @param  {Element} element\n     *         The element to toggle a class name on.\n     *\n     * @param  {string} classToToggle\n     *         The class that should be toggled.\n     *\n     * @param  {boolean|module:dom~PredicateCallback} [predicate]\n     *         See the return value for {@link module:dom~PredicateCallback}\n     *\n     * @return {Element}\n     *         The element with a class that has been toggled.\n     */\n    function toggleClass(element, classToToggle, predicate) {\n        if (typeof predicate === 'function') {\n            predicate = predicate(element, classToToggle);\n        }\n        if (typeof predicate !== 'boolean') {\n            predicate = undefined;\n        }\n        classToToggle.split(/\\s+/).forEach(className => element.classList.toggle(className, predicate));\n        return element;\n    }\n\n    /**\n     * Apply attributes to an HTML element.\n     *\n     * @param {Element} el\n     *        Element to add attributes to.\n     *\n     * @param {Object} [attributes]\n     *        Attributes to be applied.\n     */\n    function setAttributes(el, attributes) {\n        Object.getOwnPropertyNames(attributes).forEach(function (attrName) {\n            const attrValue = attributes[attrName];\n            if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {\n                el.removeAttribute(attrName);\n            } else {\n                el.setAttribute(attrName, attrValue === true ? '' : attrValue);\n            }\n        });\n    }\n\n    /**\n     * Get an element's attribute values, as defined on the HTML tag.\n     *\n     * Attributes are not the same as properties. They're defined on the tag\n     * or with setAttribute.\n     *\n     * @param  {Element} tag\n     *         Element from which to get tag attributes.\n     *\n     * @return {Object}\n     *         All attributes of the element. Boolean attributes will be `true` or\n     *         `false`, others will be strings.\n     */\n    function getAttributes(tag) {\n        const obj = {};\n\n        // known boolean attributes\n        // we can check for matching boolean properties, but not all browsers\n        // and not all tags know about these attributes, so, we still want to check them manually\n        const knownBooleans = ',' + 'autoplay,controls,playsinline,loop,muted,default,defaultMuted' + ',';\n        if (tag && tag.attributes && tag.attributes.length > 0) {\n            const attrs = tag.attributes;\n            for (let i = attrs.length - 1; i >= 0; i--) {\n                const attrName = attrs[i].name;\n                let attrVal = attrs[i].value;\n\n                // check for known booleans\n                // the matching element property will return a value for typeof\n                if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {\n                    // the value of an included boolean attribute is typically an empty\n                    // string ('') which would equal false if we just check for a false value.\n                    // we also don't want support bad code like autoplay='false'\n                    attrVal = attrVal !== null ? true : false;\n                }\n                obj[attrName] = attrVal;\n            }\n        }\n        return obj;\n    }\n\n    /**\n     * Get the value of an element's attribute.\n     *\n     * @param {Element} el\n     *        A DOM element.\n     *\n     * @param {string} attribute\n     *        Attribute to get the value of.\n     *\n     * @return {string}\n     *         The value of the attribute.\n     */\n    function getAttribute(el, attribute) {\n        return el.getAttribute(attribute);\n    }\n\n    /**\n     * Set the value of an element's attribute.\n     *\n     * @param {Element} el\n     *        A DOM element.\n     *\n     * @param {string} attribute\n     *        Attribute to set.\n     *\n     * @param {string} value\n     *        Value to set the attribute to.\n     */\n    function setAttribute(el, attribute, value) {\n        el.setAttribute(attribute, value);\n    }\n\n    /**\n     * Remove an element's attribute.\n     *\n     * @param {Element} el\n     *        A DOM element.\n     *\n     * @param {string} attribute\n     *        Attribute to remove.\n     */\n    function removeAttribute(el, attribute) {\n        el.removeAttribute(attribute);\n    }\n\n    /**\n     * Attempt to block the ability to select text.\n     */\n    function blockTextSelection() {\n        document.body.focus();\n        document.onselectstart = function () {\n            return false;\n        };\n    }\n\n    /**\n     * Turn off text selection blocking.\n     */\n    function unblockTextSelection() {\n        document.onselectstart = function () {\n            return true;\n        };\n    }\n\n    /**\n     * Identical to the native `getBoundingClientRect` function, but ensures that\n     * the method is supported at all (it is in all browsers we claim to support)\n     * and that the element is in the DOM before continuing.\n     *\n     * This wrapper function also shims properties which are not provided by some\n     * older browsers (namely, IE8).\n     *\n     * Additionally, some browsers do not support adding properties to a\n     * `ClientRect`/`DOMRect` object; so, we shallow-copy it with the standard\n     * properties (except `x` and `y` which are not widely supported). This helps\n     * avoid implementations where keys are non-enumerable.\n     *\n     * @param  {Element} el\n     *         Element whose `ClientRect` we want to calculate.\n     *\n     * @return {Object|undefined}\n     *         Always returns a plain object - or `undefined` if it cannot.\n     */\n    function getBoundingClientRect(el) {\n        if (el && el.getBoundingClientRect && el.parentNode) {\n            const rect = el.getBoundingClientRect();\n            const result = {};\n            ['bottom', 'height', 'left', 'right', 'top', 'width'].forEach(k => {\n                if (rect[k] !== undefined) {\n                    result[k] = rect[k];\n                }\n            });\n            if (!result.height) {\n                result.height = parseFloat(computedStyle(el, 'height'));\n            }\n            if (!result.width) {\n                result.width = parseFloat(computedStyle(el, 'width'));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Represents the position of a DOM element on the page.\n     *\n     * @typedef  {Object} module:dom~Position\n     *\n     * @property {number} left\n     *           Pixels to the left.\n     *\n     * @property {number} top\n     *           Pixels from the top.\n     */\n\n    /**\n     * Get the position of an element in the DOM.\n     *\n     * Uses `getBoundingClientRect` technique from John Resig.\n     *\n     * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/\n     *\n     * @param  {Element} el\n     *         Element from which to get offset.\n     *\n     * @return {module:dom~Position}\n     *         The position of the element that was passed in.\n     */\n    function findPosition(el) {\n        if (!el || el && !el.offsetParent) {\n            return {\n                left: 0,\n                top: 0,\n                width: 0,\n                height: 0\n            };\n        }\n        const width = el.offsetWidth;\n        const height = el.offsetHeight;\n        let left = 0;\n        let top = 0;\n        while (el.offsetParent && el !== document[FullscreenApi.fullscreenElement]) {\n            left += el.offsetLeft;\n            top += el.offsetTop;\n            el = el.offsetParent;\n        }\n        return {\n            left,\n            top,\n            width,\n            height\n        };\n    }\n\n    /**\n     * Represents x and y coordinates for a DOM element or mouse pointer.\n     *\n     * @typedef  {Object} module:dom~Coordinates\n     *\n     * @property {number} x\n     *           x coordinate in pixels\n     *\n     * @property {number} y\n     *           y coordinate in pixels\n     */\n\n    /**\n     * Get the pointer position within an element.\n     *\n     * The base on the coordinates are the bottom left of the element.\n     *\n     * @param  {Element} el\n     *         Element on which to get the pointer position on.\n     *\n     * @param  {Event} event\n     *         Event object.\n     *\n     * @return {module:dom~Coordinates}\n     *         A coordinates object corresponding to the mouse position.\n     *\n     */\n    function getPointerPosition(el, event) {\n        const translated = {\n            x: 0,\n            y: 0\n        };\n        if (IS_IOS) {\n            let item = el;\n            while (item && item.nodeName.toLowerCase() !== 'html') {\n                const transform = computedStyle(item, 'transform');\n                if (/^matrix/.test(transform)) {\n                    const values = transform.slice(7, -1).split(/,\\s/).map(Number);\n                    translated.x += values[4];\n                    translated.y += values[5];\n                } else if (/^matrix3d/.test(transform)) {\n                    const values = transform.slice(9, -1).split(/,\\s/).map(Number);\n                    translated.x += values[12];\n                    translated.y += values[13];\n                }\n                item = item.parentNode;\n            }\n        }\n        const position = {};\n        const boxTarget = findPosition(event.target);\n        const box = findPosition(el);\n        const boxW = box.width;\n        const boxH = box.height;\n        let offsetY = event.offsetY - (box.top - boxTarget.top);\n        let offsetX = event.offsetX - (box.left - boxTarget.left);\n        if (event.changedTouches) {\n            offsetX = event.changedTouches[0].pageX - box.left;\n            offsetY = event.changedTouches[0].pageY + box.top;\n            if (IS_IOS) {\n                offsetX -= translated.x;\n                offsetY -= translated.y;\n            }\n        }\n        position.y = 1 - Math.max(0, Math.min(1, offsetY / boxH));\n        position.x = Math.max(0, Math.min(1, offsetX / boxW));\n        return position;\n    }\n\n    /**\n     * Determines, via duck typing, whether or not a value is a text node.\n     *\n     * @param  {*} value\n     *         Check if this value is a text node.\n     *\n     * @return {boolean}\n     *         Will be `true` if the value is a text node, `false` otherwise.\n     */\n    function isTextNode$1(value) {\n        return isObject$1(value) && value.nodeType === 3;\n    }\n\n    /**\n     * Empties the contents of an element.\n     *\n     * @param  {Element} el\n     *         The element to empty children from\n     *\n     * @return {Element}\n     *         The element with no children\n     */\n    function emptyEl(el) {\n        while (el.firstChild) {\n            el.removeChild(el.firstChild);\n        }\n        return el;\n    }\n\n    /**\n     * This is a mixed value that describes content to be injected into the DOM\n     * via some method. It can be of the following types:\n     *\n     * Type       | Description\n     * -----------|-------------\n     * `string`   | The value will be normalized into a text node.\n     * `Element`  | The value will be accepted as-is.\n     * `Text`     | A TextNode. The value will be accepted as-is.\n     * `Array`    | A one-dimensional array of strings, elements, text nodes, or functions. These functions should return a string, element, or text node (any other return value, like an array, will be ignored).\n     * `Function` | A function, which is expected to return a string, element, text node, or array - any of the other possible values described above. This means that a content descriptor could be a function that returns an array of functions, but those second-level functions must return strings, elements, or text nodes.\n     *\n     * @typedef {string|Element|Text|Array|Function} ContentDescriptor\n     */\n\n    /**\n     * Normalizes content for eventual insertion into the DOM.\n     *\n     * This allows a wide range of content definition methods, but helps protect\n     * from falling into the trap of simply writing to `innerHTML`, which could\n     * be an XSS concern.\n     *\n     * The content for an element can be passed in multiple types and\n     * combinations, whose behavior is as follows:\n     *\n     * @param {ContentDescriptor} content\n     *        A content descriptor value.\n     *\n     * @return {Array}\n     *         All of the content that was passed in, normalized to an array of\n     *         elements or text nodes.\n     */\n    function normalizeContent(content) {\n        // First, invoke content if it is a function. If it produces an array,\n        // that needs to happen before normalization.\n        if (typeof content === 'function') {\n            content = content();\n        }\n\n        // Next up, normalize to an array, so one or many items can be normalized,\n        // filtered, and returned.\n        return (Array.isArray(content) ? content : [content]).map(value => {\n            // First, invoke value if it is a function to produce a new value,\n            // which will be subsequently normalized to a Node of some kind.\n            if (typeof value === 'function') {\n                value = value();\n            }\n            if (isEl(value) || isTextNode$1(value)) {\n                return value;\n            }\n            if (typeof value === 'string' && /\\S/.test(value)) {\n                return document.createTextNode(value);\n            }\n        }).filter(value => value);\n    }\n\n    /**\n     * Normalizes and appends content to an element.\n     *\n     * @param  {Element} el\n     *         Element to append normalized content to.\n     *\n     * @param {ContentDescriptor} content\n     *        A content descriptor value.\n     *\n     * @return {Element}\n     *         The element with appended normalized content.\n     */\n    function appendContent(el, content) {\n        normalizeContent(content).forEach(node => el.appendChild(node));\n        return el;\n    }\n\n    /**\n     * Normalizes and inserts content into an element; this is identical to\n     * `appendContent()`, except it empties the element first.\n     *\n     * @param {Element} el\n     *        Element to insert normalized content into.\n     *\n     * @param {ContentDescriptor} content\n     *        A content descriptor value.\n     *\n     * @return {Element}\n     *         The element with inserted normalized content.\n     */\n    function insertContent(el, content) {\n        return appendContent(emptyEl(el), content);\n    }\n\n    /**\n     * Check if an event was a single left click.\n     *\n     * @param  {Event} event\n     *         Event object.\n     *\n     * @return {boolean}\n     *         Will be `true` if a single left click, `false` otherwise.\n     */\n    function isSingleLeftClick(event) {\n        // Note: if you create something draggable, be sure to\n        // call it on both `mousedown` and `mousemove` event,\n        // otherwise `mousedown` should be enough for a button\n\n        if (event.button === undefined && event.buttons === undefined) {\n            // Why do we need `buttons` ?\n            // Because, middle mouse sometimes have this:\n            // e.button === 0 and e.buttons === 4\n            // Furthermore, we want to prevent combination click, something like\n            // HOLD middlemouse then left click, that would be\n            // e.button === 0, e.buttons === 5\n            // just `button` is not gonna work\n\n            // Alright, then what this block does ?\n            // this is for chrome `simulate mobile devices`\n            // I want to support this as well\n\n            return true;\n        }\n        if (event.button === 0 && event.buttons === undefined) {\n            // Touch screen, sometimes on some specific device, `buttons`\n            // doesn't have anything (safari on ios, blackberry...)\n\n            return true;\n        }\n\n        // `mouseup` event on a single left click has\n        // `button` and `buttons` equal to 0\n        if (event.type === 'mouseup' && event.button === 0 && event.buttons === 0) {\n            return true;\n        }\n        if (event.button !== 0 || event.buttons !== 1) {\n            // This is the reason we have those if else block above\n            // if any special case we can catch and let it slide\n            // we do it above, when get to here, this definitely\n            // is-not-left-click\n\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Finds a single DOM element matching `selector` within the optional\n     * `context` of another DOM element (defaulting to `document`).\n     *\n     * @param  {string} selector\n     *         A valid CSS selector, which will be passed to `querySelector`.\n     *\n     * @param  {Element|String} [context=document]\n     *         A DOM element within which to query. Can also be a selector\n     *         string in which case the first matching element will be used\n     *         as context. If missing (or no element matches selector), falls\n     *         back to `document`.\n     *\n     * @return {Element|null}\n     *         The element that was found or null.\n     */\n    const $ = createQuerier('querySelector');\n\n    /**\n     * Finds a all DOM elements matching `selector` within the optional\n     * `context` of another DOM element (defaulting to `document`).\n     *\n     * @param  {string} selector\n     *         A valid CSS selector, which will be passed to `querySelectorAll`.\n     *\n     * @param  {Element|String} [context=document]\n     *         A DOM element within which to query. Can also be a selector\n     *         string in which case the first matching element will be used\n     *         as context. If missing (or no element matches selector), falls\n     *         back to `document`.\n     *\n     * @return {NodeList}\n     *         A element list of elements that were found. Will be empty if none\n     *         were found.\n     *\n     */\n    const $$ = createQuerier('querySelectorAll');\n\n    /**\n     * A safe getComputedStyle.\n     *\n     * This is needed because in Firefox, if the player is loaded in an iframe with\n     * `display:none`, then `getComputedStyle` returns `null`, so, we do a\n     * null-check to make sure that the player doesn't break in these cases.\n     *\n     * @param    {Element} el\n     *           The element you want the computed style of\n     *\n     * @param    {string} prop\n     *           The property name you want\n     *\n     * @see      https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n     */\n    function computedStyle(el, prop) {\n        if (!el || !prop) {\n            return '';\n        }\n        if (typeof window.getComputedStyle === 'function') {\n            let computedStyleValue;\n            try {\n                computedStyleValue = window.getComputedStyle(el);\n            } catch (e) {\n                return '';\n            }\n            return computedStyleValue ? computedStyleValue.getPropertyValue(prop) || computedStyleValue[prop] : '';\n        }\n        return '';\n    }\n\n    var Dom = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        isReal: isReal,\n        isEl: isEl,\n        isInFrame: isInFrame,\n        createEl: createEl,\n        textContent: textContent,\n        prependTo: prependTo,\n        hasClass: hasClass,\n        addClass: addClass,\n        removeClass: removeClass,\n        toggleClass: toggleClass,\n        setAttributes: setAttributes,\n        getAttributes: getAttributes,\n        getAttribute: getAttribute,\n        setAttribute: setAttribute,\n        removeAttribute: removeAttribute,\n        blockTextSelection: blockTextSelection,\n        unblockTextSelection: unblockTextSelection,\n        getBoundingClientRect: getBoundingClientRect,\n        findPosition: findPosition,\n        getPointerPosition: getPointerPosition,\n        isTextNode: isTextNode$1,\n        emptyEl: emptyEl,\n        normalizeContent: normalizeContent,\n        appendContent: appendContent,\n        insertContent: insertContent,\n        isSingleLeftClick: isSingleLeftClick,\n        $: $,\n        $$: $$,\n        computedStyle: computedStyle\n    });\n\n    /**\n     * @file setup.js - Functions for setting up a player without\n     * user interaction based on the data-setup `attribute` of the video tag.\n     *\n     * @module setup\n     */\n    let _windowLoaded = false;\n    let videojs$1;\n\n    /**\n     * Set up any tags that have a data-setup `attribute` when the player is started.\n     */\n    const autoSetup = function () {\n        if (videojs$1.options.autoSetup === false) {\n            return;\n        }\n        const vids = Array.prototype.slice.call(document.getElementsByTagName('video'));\n        const audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));\n        const divs = Array.prototype.slice.call(document.getElementsByTagName('video-js'));\n        const mediaEls = vids.concat(audios, divs);\n\n        // Check if any media elements exist\n        if (mediaEls && mediaEls.length > 0) {\n            for (let i = 0, e = mediaEls.length; i < e; i++) {\n                const mediaEl = mediaEls[i];\n\n                // Check if element exists, has getAttribute func.\n                if (mediaEl && mediaEl.getAttribute) {\n                    // Make sure this player hasn't already been set up.\n                    if (mediaEl.player === undefined) {\n                        const options = mediaEl.getAttribute('data-setup');\n\n                        // Check if data-setup attr exists.\n                        // We only auto-setup if they've added the data-setup attr.\n                        if (options !== null) {\n                            // Create new video.js instance.\n                            videojs$1(mediaEl);\n                        }\n                    }\n\n                    // If getAttribute isn't defined, we need to wait for the DOM.\n                } else {\n                    autoSetupTimeout(1);\n                    break;\n                }\n            }\n\n            // No videos were found, so keep looping unless page is finished loading.\n        } else if (!_windowLoaded) {\n            autoSetupTimeout(1);\n        }\n    };\n\n    /**\n     * Wait until the page is loaded before running autoSetup. This will be called in\n     * autoSetup if `hasLoaded` returns false.\n     *\n     * @param {number} wait\n     *        How long to wait in ms\n     *\n     * @param {module:videojs} [vjs]\n     *        The videojs library function\n     */\n    function autoSetupTimeout(wait, vjs) {\n        // Protect against breakage in non-browser environments\n        if (!isReal()) {\n            return;\n        }\n        if (vjs) {\n            videojs$1 = vjs;\n        }\n        window.setTimeout(autoSetup, wait);\n    }\n\n    /**\n     * Used to set the internal tracking of window loaded state to true.\n     *\n     * @private\n     */\n    function setWindowLoaded() {\n        _windowLoaded = true;\n        window.removeEventListener('load', setWindowLoaded);\n    }\n    if (isReal()) {\n        if (document.readyState === 'complete') {\n            setWindowLoaded();\n        } else {\n            /**\n             * Listen for the load event on window, and set _windowLoaded to true.\n             *\n             * We use a standard event listener here to avoid incrementing the GUID\n             * before any players are created.\n             *\n             * @listens load\n             */\n            window.addEventListener('load', setWindowLoaded);\n        }\n    }\n\n    /**\n     * @file stylesheet.js\n     * @module stylesheet\n     */\n\n    /**\n     * Create a DOM style element given a className for it.\n     *\n     * @param {string} className\n     *        The className to add to the created style element.\n     *\n     * @return {Element}\n     *         The element that was created.\n     */\n    const createStyleElement = function (className) {\n        const style = document.createElement('style');\n        style.className = className;\n        return style;\n    };\n\n    /**\n     * Add text to a DOM element.\n     *\n     * @param {Element} el\n     *        The Element to add text content to.\n     *\n     * @param {string} content\n     *        The text to add to the element.\n     */\n    const setTextContent = function (el, content) {\n        if (el.styleSheet) {\n            el.styleSheet.cssText = content;\n        } else {\n            el.textContent = content;\n        }\n    };\n\n    /**\n     * @file dom-data.js\n     * @module dom-data\n     */\n\n    /**\n     * Element Data Store.\n     *\n     * Allows for binding data to an element without putting it directly on the\n     * element. Ex. Event listeners are stored here.\n     * (also from jsninja.com, slightly modified and updated for closure compiler)\n     *\n     * @type {Object}\n     * @private\n     */\n    var DomData = new WeakMap();\n\n    /**\n     * @file guid.js\n     * @module guid\n     */\n\n        // Default value for GUIDs. This allows us to reset the GUID counter in tests.\n        //\n        // The initial GUID is 3 because some users have come to rely on the first\n        // default player ID ending up as `vjs_video_3`.\n        //\n        // See: https://github.com/videojs/video.js/pull/6216\n    const _initialGuid = 3;\n\n    /**\n     * Unique ID for an element or function\n     *\n     * @type {Number}\n     */\n    let _guid = _initialGuid;\n\n    /**\n     * Get a unique auto-incrementing ID by number that has not been returned before.\n     *\n     * @return {number}\n     *         A new unique ID.\n     */\n    function newGUID() {\n        return _guid++;\n    }\n\n    /**\n     * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)\n     * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)\n     * This should work very similarly to jQuery's events, however it's based off the book version which isn't as\n     * robust as jquery's, so there's probably some differences.\n     *\n     * @file events.js\n     * @module events\n     */\n\n    /**\n     * Clean up the listener cache and dispatchers\n     *\n     * @param {Element|Object} elem\n     *        Element to clean up\n     *\n     * @param {string} type\n     *        Type of event to clean up\n     */\n    function _cleanUpEvents(elem, type) {\n        if (!DomData.has(elem)) {\n            return;\n        }\n        const data = DomData.get(elem);\n\n        // Remove the events of a particular type if there are none left\n        if (data.handlers[type].length === 0) {\n            delete data.handlers[type];\n            // data.handlers[type] = null;\n            // Setting to null was causing an error with data.handlers\n\n            // Remove the meta-handler from the element\n            if (elem.removeEventListener) {\n                elem.removeEventListener(type, data.dispatcher, false);\n            } else if (elem.detachEvent) {\n                elem.detachEvent('on' + type, data.dispatcher);\n            }\n        }\n\n        // Remove the events object if there are no types left\n        if (Object.getOwnPropertyNames(data.handlers).length <= 0) {\n            delete data.handlers;\n            delete data.dispatcher;\n            delete data.disabled;\n        }\n\n        // Finally remove the element data if there is no data left\n        if (Object.getOwnPropertyNames(data).length === 0) {\n            DomData.delete(elem);\n        }\n    }\n\n    /**\n     * Loops through an array of event types and calls the requested method for each type.\n     *\n     * @param {Function} fn\n     *        The event method we want to use.\n     *\n     * @param {Element|Object} elem\n     *        Element or object to bind listeners to\n     *\n     * @param {string} type\n     *        Type of event to bind to.\n     *\n     * @param {Function} callback\n     *        Event listener.\n     */\n    function _handleMultipleEvents(fn, elem, types, callback) {\n        types.forEach(function (type) {\n            // Call the event method for each one of the types\n            fn(elem, type, callback);\n        });\n    }\n\n    /**\n     * Fix a native event to have standard property values\n     *\n     * @param {Object} event\n     *        Event object to fix.\n     *\n     * @return {Object}\n     *         Fixed event object.\n     */\n    function fixEvent(event) {\n        if (event.fixed_) {\n            return event;\n        }\n        function returnTrue() {\n            return true;\n        }\n        function returnFalse() {\n            return false;\n        }\n\n        // Test if fixing up is needed\n        // Used to check if !event.stopPropagation instead of isPropagationStopped\n        // But native events return true for stopPropagation, but don't have\n        // other expected methods like isPropagationStopped. Seems to be a problem\n        // with the Javascript Ninja code. So we're just overriding all events now.\n        if (!event || !event.isPropagationStopped || !event.isImmediatePropagationStopped) {\n            const old = event || window.event;\n            event = {};\n            // Clone the old object so that we can modify the values event = {};\n            // IE8 Doesn't like when you mess with native event properties\n            // Firefox returns false for event.hasOwnProperty('type') and other props\n            //  which makes copying more difficult.\n            // TODO: Probably best to create a whitelist of event props\n            for (const key in old) {\n                // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y\n                // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation\n                // and webkitMovementX/Y\n                // Lighthouse complains if Event.path is copied\n                if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY' && key !== 'path') {\n                    // Chrome 32+ warns if you try to copy deprecated returnValue, but\n                    // we still want to if preventDefault isn't supported (IE8).\n                    if (!(key === 'returnValue' && old.preventDefault)) {\n                        event[key] = old[key];\n                    }\n                }\n            }\n\n            // The event occurred on this element\n            if (!event.target) {\n                event.target = event.srcElement || document;\n            }\n\n            // Handle which other element the event is related to\n            if (!event.relatedTarget) {\n                event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;\n            }\n\n            // Stop the default browser action\n            event.preventDefault = function () {\n                if (old.preventDefault) {\n                    old.preventDefault();\n                }\n                event.returnValue = false;\n                old.returnValue = false;\n                event.defaultPrevented = true;\n            };\n            event.defaultPrevented = false;\n\n            // Stop the event from bubbling\n            event.stopPropagation = function () {\n                if (old.stopPropagation) {\n                    old.stopPropagation();\n                }\n                event.cancelBubble = true;\n                old.cancelBubble = true;\n                event.isPropagationStopped = returnTrue;\n            };\n            event.isPropagationStopped = returnFalse;\n\n            // Stop the event from bubbling and executing other handlers\n            event.stopImmediatePropagation = function () {\n                if (old.stopImmediatePropagation) {\n                    old.stopImmediatePropagation();\n                }\n                event.isImmediatePropagationStopped = returnTrue;\n                event.stopPropagation();\n            };\n            event.isImmediatePropagationStopped = returnFalse;\n\n            // Handle mouse position\n            if (event.clientX !== null && event.clientX !== undefined) {\n                const doc = document.documentElement;\n                const body = document.body;\n                event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n                event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n            }\n\n            // Handle key presses\n            event.which = event.charCode || event.keyCode;\n\n            // Fix button for mouse clicks:\n            // 0 == left; 1 == middle; 2 == right\n            if (event.button !== null && event.button !== undefined) {\n                // The following is disabled because it does not pass videojs-standard\n                // and... yikes.\n                /* eslint-disable */\n                event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;\n                /* eslint-enable */\n            }\n        }\n\n        event.fixed_ = true;\n        // Returns fixed-up instance\n        return event;\n    }\n\n    /**\n     * Whether passive event listeners are supported\n     */\n    let _supportsPassive;\n    const supportsPassive = function () {\n        if (typeof _supportsPassive !== 'boolean') {\n            _supportsPassive = false;\n            try {\n                const opts = Object.defineProperty({}, 'passive', {\n                    get() {\n                        _supportsPassive = true;\n                    }\n                });\n                window.addEventListener('test', null, opts);\n                window.removeEventListener('test', null, opts);\n            } catch (e) {\n                // disregard\n            }\n        }\n        return _supportsPassive;\n    };\n\n    /**\n     * Touch events Chrome expects to be passive\n     */\n    const passiveEvents = ['touchstart', 'touchmove'];\n\n    /**\n     * Add an event listener to element\n     * It stores the handler function in a separate cache object\n     * and adds a generic handler to the element's event,\n     * along with a unique id (guid) to the element.\n     *\n     * @param {Element|Object} elem\n     *        Element or object to bind listeners to\n     *\n     * @param {string|string[]} type\n     *        Type of event to bind to.\n     *\n     * @param {Function} fn\n     *        Event listener.\n     */\n    function on(elem, type, fn) {\n        if (Array.isArray(type)) {\n            return _handleMultipleEvents(on, elem, type, fn);\n        }\n        if (!DomData.has(elem)) {\n            DomData.set(elem, {});\n        }\n        const data = DomData.get(elem);\n\n        // We need a place to store all our handler data\n        if (!data.handlers) {\n            data.handlers = {};\n        }\n        if (!data.handlers[type]) {\n            data.handlers[type] = [];\n        }\n        if (!fn.guid) {\n            fn.guid = newGUID();\n        }\n        data.handlers[type].push(fn);\n        if (!data.dispatcher) {\n            data.disabled = false;\n            data.dispatcher = function (event, hash) {\n                if (data.disabled) {\n                    return;\n                }\n                event = fixEvent(event);\n                const handlers = data.handlers[event.type];\n                if (handlers) {\n                    // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.\n                    const handlersCopy = handlers.slice(0);\n                    for (let m = 0, n = handlersCopy.length; m < n; m++) {\n                        if (event.isImmediatePropagationStopped()) {\n                            break;\n                        } else {\n                            try {\n                                handlersCopy[m].call(elem, event, hash);\n                            } catch (e) {\n                                log$1.error(e);\n                            }\n                        }\n                    }\n                }\n            };\n        }\n        if (data.handlers[type].length === 1) {\n            if (elem.addEventListener) {\n                let options = false;\n                if (supportsPassive() && passiveEvents.indexOf(type) > -1) {\n                    options = {\n                        passive: true\n                    };\n                }\n                elem.addEventListener(type, data.dispatcher, options);\n            } else if (elem.attachEvent) {\n                elem.attachEvent('on' + type, data.dispatcher);\n            }\n        }\n    }\n\n    /**\n     * Removes event listeners from an element\n     *\n     * @param {Element|Object} elem\n     *        Object to remove listeners from.\n     *\n     * @param {string|string[]} [type]\n     *        Type of listener to remove. Don't include to remove all events from element.\n     *\n     * @param {Function} [fn]\n     *        Specific listener to remove. Don't include to remove listeners for an event\n     *        type.\n     */\n    function off(elem, type, fn) {\n        // Don't want to add a cache object through getElData if not needed\n        if (!DomData.has(elem)) {\n            return;\n        }\n        const data = DomData.get(elem);\n\n        // If no events exist, nothing to unbind\n        if (!data.handlers) {\n            return;\n        }\n        if (Array.isArray(type)) {\n            return _handleMultipleEvents(off, elem, type, fn);\n        }\n\n        // Utility function\n        const removeType = function (el, t) {\n            data.handlers[t] = [];\n            _cleanUpEvents(el, t);\n        };\n\n        // Are we removing all bound events?\n        if (type === undefined) {\n            for (const t in data.handlers) {\n                if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) {\n                    removeType(elem, t);\n                }\n            }\n            return;\n        }\n        const handlers = data.handlers[type];\n\n        // If no handlers exist, nothing to unbind\n        if (!handlers) {\n            return;\n        }\n\n        // If no listener was provided, remove all listeners for type\n        if (!fn) {\n            removeType(elem, type);\n            return;\n        }\n\n        // We're only removing a single handler\n        if (fn.guid) {\n            for (let n = 0; n < handlers.length; n++) {\n                if (handlers[n].guid === fn.guid) {\n                    handlers.splice(n--, 1);\n                }\n            }\n        }\n        _cleanUpEvents(elem, type);\n    }\n\n    /**\n     * Trigger an event for an element\n     *\n     * @param {Element|Object} elem\n     *        Element to trigger an event on\n     *\n     * @param {EventTarget~Event|string} event\n     *        A string (the type) or an event object with a type attribute\n     *\n     * @param {Object} [hash]\n     *        data hash to pass along with the event\n     *\n     * @return {boolean|undefined}\n     *         Returns the opposite of `defaultPrevented` if default was\n     *         prevented. Otherwise, returns `undefined`\n     */\n    function trigger(elem, event, hash) {\n        // Fetches element data and a reference to the parent (for bubbling).\n        // Don't want to add a data object to cache for every parent,\n        // so checking hasElData first.\n        const elemData = DomData.has(elem) ? DomData.get(elem) : {};\n        const parent = elem.parentNode || elem.ownerDocument;\n        // type = event.type || event,\n        // handler;\n\n        // If an event name was passed as a string, creates an event out of it\n        if (typeof event === 'string') {\n            event = {\n                type: event,\n                target: elem\n            };\n        } else if (!event.target) {\n            event.target = elem;\n        }\n\n        // Normalizes the event properties.\n        event = fixEvent(event);\n\n        // If the passed element has a dispatcher, executes the established handlers.\n        if (elemData.dispatcher) {\n            elemData.dispatcher.call(elem, event, hash);\n        }\n\n        // Unless explicitly stopped or the event does not bubble (e.g. media events)\n        // recursively calls this function to bubble the event up the DOM.\n        if (parent && !event.isPropagationStopped() && event.bubbles === true) {\n            trigger.call(null, parent, event, hash);\n\n            // If at the top of the DOM, triggers the default action unless disabled.\n        } else if (!parent && !event.defaultPrevented && event.target && event.target[event.type]) {\n            if (!DomData.has(event.target)) {\n                DomData.set(event.target, {});\n            }\n            const targetData = DomData.get(event.target);\n\n            // Checks if the target has a default action for this event.\n            if (event.target[event.type]) {\n                // Temporarily disables event dispatching on the target as we have already executed the handler.\n                targetData.disabled = true;\n                // Executes the default action.\n                if (typeof event.target[event.type] === 'function') {\n                    event.target[event.type]();\n                }\n                // Re-enables event dispatching.\n                targetData.disabled = false;\n            }\n        }\n\n        // Inform the triggerer if the default was prevented by returning false\n        return !event.defaultPrevented;\n    }\n\n    /**\n     * Trigger a listener only once for an event.\n     *\n     * @param {Element|Object} elem\n     *        Element or object to bind to.\n     *\n     * @param {string|string[]} type\n     *        Name/type of event\n     *\n     * @param {Event~EventListener} fn\n     *        Event listener function\n     */\n    function one(elem, type, fn) {\n        if (Array.isArray(type)) {\n            return _handleMultipleEvents(one, elem, type, fn);\n        }\n        const func = function () {\n            off(elem, type, func);\n            fn.apply(this, arguments);\n        };\n\n        // copy the guid to the new function so it can removed using the original function's ID\n        func.guid = fn.guid = fn.guid || newGUID();\n        on(elem, type, func);\n    }\n\n    /**\n     * Trigger a listener only once and then turn if off for all\n     * configured events\n     *\n     * @param {Element|Object} elem\n     *        Element or object to bind to.\n     *\n     * @param {string|string[]} type\n     *        Name/type of event\n     *\n     * @param {Event~EventListener} fn\n     *        Event listener function\n     */\n    function any(elem, type, fn) {\n        const func = function () {\n            off(elem, type, func);\n            fn.apply(this, arguments);\n        };\n\n        // copy the guid to the new function so it can removed using the original function's ID\n        func.guid = fn.guid = fn.guid || newGUID();\n\n        // multiple ons, but one off for everything\n        on(elem, type, func);\n    }\n\n    var Events = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        fixEvent: fixEvent,\n        on: on,\n        off: off,\n        trigger: trigger,\n        one: one,\n        any: any\n    });\n\n    /**\n     * @file fn.js\n     * @module fn\n     */\n    const UPDATE_REFRESH_INTERVAL = 30;\n\n    /**\n     * A private, internal-only function for changing the context of a function.\n     *\n     * It also stores a unique id on the function so it can be easily removed from\n     * events.\n     *\n     * @private\n     * @function\n     * @param    {*} context\n     *           The object to bind as scope.\n     *\n     * @param    {Function} fn\n     *           The function to be bound to a scope.\n     *\n     * @param    {number} [uid]\n     *           An optional unique ID for the function to be set\n     *\n     * @return   {Function}\n     *           The new function that will be bound into the context given\n     */\n    const bind_ = function (context, fn, uid) {\n        // Make sure the function has a unique ID\n        if (!fn.guid) {\n            fn.guid = newGUID();\n        }\n\n        // Create the new function that changes the context\n        const bound = fn.bind(context);\n\n        // Allow for the ability to individualize this function\n        // Needed in the case where multiple objects might share the same prototype\n        // IF both items add an event listener with the same function, then you try to remove just one\n        // it will remove both because they both have the same guid.\n        // when using this, you need to use the bind method when you remove the listener as well.\n        // currently used in text tracks\n        bound.guid = uid ? uid + '_' + fn.guid : fn.guid;\n        return bound;\n    };\n\n    /**\n     * Wraps the given function, `fn`, with a new function that only invokes `fn`\n     * at most once per every `wait` milliseconds.\n     *\n     * @function\n     * @param    {Function} fn\n     *           The function to be throttled.\n     *\n     * @param    {number}   wait\n     *           The number of milliseconds by which to throttle.\n     *\n     * @return   {Function}\n     */\n    const throttle = function (fn, wait) {\n        let last = window.performance.now();\n        const throttled = function (...args) {\n            const now = window.performance.now();\n            if (now - last >= wait) {\n                fn(...args);\n                last = now;\n            }\n        };\n        return throttled;\n    };\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked.\n     *\n     * Inspired by lodash and underscore implementations.\n     *\n     * @function\n     * @param    {Function} func\n     *           The function to wrap with debounce behavior.\n     *\n     * @param    {number} wait\n     *           The number of milliseconds to wait after the last invocation.\n     *\n     * @param    {boolean} [immediate]\n     *           Whether or not to invoke the function immediately upon creation.\n     *\n     * @param    {Object} [context=window]\n     *           The \"context\" in which the debounced function should debounce. For\n     *           example, if this function should be tied to a Video.js player,\n     *           the player can be passed here. Alternatively, defaults to the\n     *           global `window` object.\n     *\n     * @return   {Function}\n     *           A debounced function.\n     */\n    const debounce = function (func, wait, immediate, context = window) {\n        let timeout;\n        const cancel = () => {\n            context.clearTimeout(timeout);\n            timeout = null;\n        };\n\n        /* eslint-disable consistent-this */\n        const debounced = function () {\n            const self = this;\n            const args = arguments;\n            let later = function () {\n                timeout = null;\n                later = null;\n                if (!immediate) {\n                    func.apply(self, args);\n                }\n            };\n            if (!timeout && immediate) {\n                func.apply(self, args);\n            }\n            context.clearTimeout(timeout);\n            timeout = context.setTimeout(later, wait);\n        };\n        /* eslint-enable consistent-this */\n\n        debounced.cancel = cancel;\n        return debounced;\n    };\n\n    var Fn = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        UPDATE_REFRESH_INTERVAL: UPDATE_REFRESH_INTERVAL,\n        bind_: bind_,\n        throttle: throttle,\n        debounce: debounce\n    });\n\n    /**\n     * @file src/js/event-target.js\n     */\n    let EVENT_MAP;\n\n    /**\n     * `EventTarget` is a class that can have the same API as the DOM `EventTarget`. It\n     * adds shorthand functions that wrap around lengthy functions. For example:\n     * the `on` function is a wrapper around `addEventListener`.\n     *\n     * @see [EventTarget Spec]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}\n     * @class EventTarget\n     */\n    class EventTarget$2 {\n        /**\n         * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a\n         * function that will get called when an event with a certain name gets triggered.\n         *\n         * @param {string|string[]} type\n         *        An event name or an array of event names.\n         *\n         * @param {Function} fn\n         *        The function to call with `EventTarget`s\n         */\n        on(type, fn) {\n            // Remove the addEventListener alias before calling Events.on\n            // so we don't get into an infinite type loop\n            const ael = this.addEventListener;\n            this.addEventListener = () => {};\n            on(this, type, fn);\n            this.addEventListener = ael;\n        }\n        /**\n         * Removes an `event listener` for a specific event from an instance of `EventTarget`.\n         * This makes it so that the `event listener` will no longer get called when the\n         * named event happens.\n         *\n         * @param {string|string[]} type\n         *        An event name or an array of event names.\n         *\n         * @param {Function} fn\n         *        The function to remove.\n         */\n        off(type, fn) {\n            off(this, type, fn);\n        }\n        /**\n         * This function will add an `event listener` that gets triggered only once. After the\n         * first trigger it will get removed. This is like adding an `event listener`\n         * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.\n         *\n         * @param {string|string[]} type\n         *        An event name or an array of event names.\n         *\n         * @param {Function} fn\n         *        The function to be called once for each event name.\n         */\n        one(type, fn) {\n            // Remove the addEventListener aliasing Events.on\n            // so we don't get into an infinite type loop\n            const ael = this.addEventListener;\n            this.addEventListener = () => {};\n            one(this, type, fn);\n            this.addEventListener = ael;\n        }\n        /**\n         * This function will add an `event listener` that gets triggered only once and is\n         * removed from all events. This is like adding an array of `event listener`s\n         * with {@link EventTarget#on} that calls {@link EventTarget#off} on all events the\n         * first time it is triggered.\n         *\n         * @param {string|string[]} type\n         *        An event name or an array of event names.\n         *\n         * @param {Function} fn\n         *        The function to be called once for each event name.\n         */\n        any(type, fn) {\n            // Remove the addEventListener aliasing Events.on\n            // so we don't get into an infinite type loop\n            const ael = this.addEventListener;\n            this.addEventListener = () => {};\n            any(this, type, fn);\n            this.addEventListener = ael;\n        }\n        /**\n         * This function causes an event to happen. This will then cause any `event listeners`\n         * that are waiting for that event, to get called. If there are no `event listeners`\n         * for an event then nothing will happen.\n         *\n         * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.\n         * Trigger will also call the `on` + `uppercaseEventName` function.\n         *\n         * Example:\n         * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call\n         * `onClick` if it exists.\n         *\n         * @param {string|EventTarget~Event|Object} event\n         *        The name of the event, an `Event`, or an object with a key of type set to\n         *        an event name.\n         */\n        trigger(event) {\n            const type = event.type || event;\n\n            // deprecation\n            // In a future version we should default target to `this`\n            // similar to how we default the target to `elem` in\n            // `Events.trigger`. Right now the default `target` will be\n            // `document` due to the `Event.fixEvent` call.\n            if (typeof event === 'string') {\n                event = {\n                    type\n                };\n            }\n            event = fixEvent(event);\n            if (this.allowedEvents_[type] && this['on' + type]) {\n                this['on' + type](event);\n            }\n            trigger(this, event);\n        }\n        queueTrigger(event) {\n            // only set up EVENT_MAP if it'll be used\n            if (!EVENT_MAP) {\n                EVENT_MAP = new Map();\n            }\n            const type = event.type || event;\n            let map = EVENT_MAP.get(this);\n            if (!map) {\n                map = new Map();\n                EVENT_MAP.set(this, map);\n            }\n            const oldTimeout = map.get(type);\n            map.delete(type);\n            window.clearTimeout(oldTimeout);\n            const timeout = window.setTimeout(() => {\n                map.delete(type);\n                // if we cleared out all timeouts for the current target, delete its map\n                if (map.size === 0) {\n                    map = null;\n                    EVENT_MAP.delete(this);\n                }\n                this.trigger(event);\n            }, 0);\n            map.set(type, timeout);\n        }\n    }\n\n    /**\n     * A Custom DOM event.\n     *\n     * @typedef {CustomEvent} Event\n     * @see [Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}\n     */\n\n    /**\n     * All event listeners should follow the following format.\n     *\n     * @callback EventTarget~EventListener\n     * @this {EventTarget}\n     *\n     * @param {Event} event\n     *        the event that triggered this function\n     *\n     * @param {Object} [hash]\n     *        hash of data sent during the event\n     */\n\n    /**\n     * An object containing event names as keys and booleans as values.\n     *\n     * > NOTE: If an event name is set to a true value here {@link EventTarget#trigger}\n     *         will have extra functionality. See that function for more information.\n     *\n     * @property EventTarget.prototype.allowedEvents_\n     * @private\n     */\n    EventTarget$2.prototype.allowedEvents_ = {};\n\n    /**\n     * An alias of {@link EventTarget#on}. Allows `EventTarget` to mimic\n     * the standard DOM API.\n     *\n     * @function\n     * @see {@link EventTarget#on}\n     */\n    EventTarget$2.prototype.addEventListener = EventTarget$2.prototype.on;\n\n    /**\n     * An alias of {@link EventTarget#off}. Allows `EventTarget` to mimic\n     * the standard DOM API.\n     *\n     * @function\n     * @see {@link EventTarget#off}\n     */\n    EventTarget$2.prototype.removeEventListener = EventTarget$2.prototype.off;\n\n    /**\n     * An alias of {@link EventTarget#trigger}. Allows `EventTarget` to mimic\n     * the standard DOM API.\n     *\n     * @function\n     * @see {@link EventTarget#trigger}\n     */\n    EventTarget$2.prototype.dispatchEvent = EventTarget$2.prototype.trigger;\n\n    /**\n     * @file mixins/evented.js\n     * @module evented\n     */\n    const objName = obj => {\n        if (typeof obj.name === 'function') {\n            return obj.name();\n        }\n        if (typeof obj.name === 'string') {\n            return obj.name;\n        }\n        if (obj.name_) {\n            return obj.name_;\n        }\n        if (obj.constructor && obj.constructor.name) {\n            return obj.constructor.name;\n        }\n        return typeof obj;\n    };\n\n    /**\n     * Returns whether or not an object has had the evented mixin applied.\n     *\n     * @param  {Object} object\n     *         An object to test.\n     *\n     * @return {boolean}\n     *         Whether or not the object appears to be evented.\n     */\n    const isEvented = object => object instanceof EventTarget$2 || !!object.eventBusEl_ && ['on', 'one', 'off', 'trigger'].every(k => typeof object[k] === 'function');\n\n    /**\n     * Adds a callback to run after the evented mixin applied.\n     *\n     * @param  {Object} object\n     *         An object to Add\n     * @param  {Function} callback\n     *         The callback to run.\n     */\n    const addEventedCallback = (target, callback) => {\n        if (isEvented(target)) {\n            callback();\n        } else {\n            if (!target.eventedCallbacks) {\n                target.eventedCallbacks = [];\n            }\n            target.eventedCallbacks.push(callback);\n        }\n    };\n\n    /**\n     * Whether a value is a valid event type - non-empty string or array.\n     *\n     * @private\n     * @param  {string|Array} type\n     *         The type value to test.\n     *\n     * @return {boolean}\n     *         Whether or not the type is a valid event type.\n     */\n    const isValidEventType = type =>\n        // The regex here verifies that the `type` contains at least one non-\n        // whitespace character.\n        typeof type === 'string' && /\\S/.test(type) || Array.isArray(type) && !!type.length;\n\n    /**\n     * Validates a value to determine if it is a valid event target. Throws if not.\n     *\n     * @private\n     * @throws {Error}\n     *         If the target does not appear to be a valid event target.\n     *\n     * @param  {Object} target\n     *         The object to test.\n     *\n     * @param  {Object} obj\n     *         The evented object we are validating for\n     *\n     * @param  {string} fnName\n     *         The name of the evented mixin function that called this.\n     */\n    const validateTarget = (target, obj, fnName) => {\n        if (!target || !target.nodeName && !isEvented(target)) {\n            throw new Error(`Invalid target for ${objName(obj)}#${fnName}; must be a DOM node or evented object.`);\n        }\n    };\n\n    /**\n     * Validates a value to determine if it is a valid event target. Throws if not.\n     *\n     * @private\n     * @throws {Error}\n     *         If the type does not appear to be a valid event type.\n     *\n     * @param  {string|Array} type\n     *         The type to test.\n     *\n     * @param  {Object} obj\n     *         The evented object we are validating for\n     *\n     * @param  {string} fnName\n     *         The name of the evented mixin function that called this.\n     */\n    const validateEventType = (type, obj, fnName) => {\n        if (!isValidEventType(type)) {\n            throw new Error(`Invalid event type for ${objName(obj)}#${fnName}; must be a non-empty string or array.`);\n        }\n    };\n\n    /**\n     * Validates a value to determine if it is a valid listener. Throws if not.\n     *\n     * @private\n     * @throws {Error}\n     *         If the listener is not a function.\n     *\n     * @param  {Function} listener\n     *         The listener to test.\n     *\n     * @param  {Object} obj\n     *         The evented object we are validating for\n     *\n     * @param  {string} fnName\n     *         The name of the evented mixin function that called this.\n     */\n    const validateListener = (listener, obj, fnName) => {\n        if (typeof listener !== 'function') {\n            throw new Error(`Invalid listener for ${objName(obj)}#${fnName}; must be a function.`);\n        }\n    };\n\n    /**\n     * Takes an array of arguments given to `on()` or `one()`, validates them, and\n     * normalizes them into an object.\n     *\n     * @private\n     * @param  {Object} self\n     *         The evented object on which `on()` or `one()` was called. This\n     *         object will be bound as the `this` value for the listener.\n     *\n     * @param  {Array} args\n     *         An array of arguments passed to `on()` or `one()`.\n     *\n     * @param  {string} fnName\n     *         The name of the evented mixin function that called this.\n     *\n     * @return {Object}\n     *         An object containing useful values for `on()` or `one()` calls.\n     */\n    const normalizeListenArgs = (self, args, fnName) => {\n        // If the number of arguments is less than 3, the target is always the\n        // evented object itself.\n        const isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;\n        let target;\n        let type;\n        let listener;\n        if (isTargetingSelf) {\n            target = self.eventBusEl_;\n\n            // Deal with cases where we got 3 arguments, but we are still listening to\n            // the evented object itself.\n            if (args.length >= 3) {\n                args.shift();\n            }\n            [type, listener] = args;\n        } else {\n            [target, type, listener] = args;\n        }\n        validateTarget(target, self, fnName);\n        validateEventType(type, self, fnName);\n        validateListener(listener, self, fnName);\n        listener = bind_(self, listener);\n        return {\n            isTargetingSelf,\n            target,\n            type,\n            listener\n        };\n    };\n\n    /**\n     * Adds the listener to the event type(s) on the target, normalizing for\n     * the type of target.\n     *\n     * @private\n     * @param  {Element|Object} target\n     *         A DOM node or evented object.\n     *\n     * @param  {string} method\n     *         The event binding method to use (\"on\" or \"one\").\n     *\n     * @param  {string|Array} type\n     *         One or more event type(s).\n     *\n     * @param  {Function} listener\n     *         A listener function.\n     */\n    const listen = (target, method, type, listener) => {\n        validateTarget(target, target, method);\n        if (target.nodeName) {\n            Events[method](target, type, listener);\n        } else {\n            target[method](type, listener);\n        }\n    };\n\n    /**\n     * Contains methods that provide event capabilities to an object which is passed\n     * to {@link module:evented|evented}.\n     *\n     * @mixin EventedMixin\n     */\n    const EventedMixin = {\n        /**\n         * Add a listener to an event (or events) on this object or another evented\n         * object.\n         *\n         * @param  {string|Array|Element|Object} targetOrType\n         *         If this is a string or array, it represents the event type(s)\n         *         that will trigger the listener.\n         *\n         *         Another evented object can be passed here instead, which will\n         *         cause the listener to listen for events on _that_ object.\n         *\n         *         In either case, the listener's `this` value will be bound to\n         *         this object.\n         *\n         * @param  {string|Array|Function} typeOrListener\n         *         If the first argument was a string or array, this should be the\n         *         listener function. Otherwise, this is a string or array of event\n         *         type(s).\n         *\n         * @param  {Function} [listener]\n         *         If the first argument was another evented object, this will be\n         *         the listener function.\n         */\n        on(...args) {\n            const {\n                isTargetingSelf,\n                target,\n                type,\n                listener\n            } = normalizeListenArgs(this, args, 'on');\n            listen(target, 'on', type, listener);\n\n            // If this object is listening to another evented object.\n            if (!isTargetingSelf) {\n                // If this object is disposed, remove the listener.\n                const removeListenerOnDispose = () => this.off(target, type, listener);\n\n                // Use the same function ID as the listener so we can remove it later it\n                // using the ID of the original listener.\n                removeListenerOnDispose.guid = listener.guid;\n\n                // Add a listener to the target's dispose event as well. This ensures\n                // that if the target is disposed BEFORE this object, we remove the\n                // removal listener that was just added. Otherwise, we create a memory leak.\n                const removeRemoverOnTargetDispose = () => this.off('dispose', removeListenerOnDispose);\n\n                // Use the same function ID as the listener so we can remove it later\n                // it using the ID of the original listener.\n                removeRemoverOnTargetDispose.guid = listener.guid;\n                listen(this, 'on', 'dispose', removeListenerOnDispose);\n                listen(target, 'on', 'dispose', removeRemoverOnTargetDispose);\n            }\n        },\n        /**\n         * Add a listener to an event (or events) on this object or another evented\n         * object. The listener will be called once per event and then removed.\n         *\n         * @param  {string|Array|Element|Object} targetOrType\n         *         If this is a string or array, it represents the event type(s)\n         *         that will trigger the listener.\n         *\n         *         Another evented object can be passed here instead, which will\n         *         cause the listener to listen for events on _that_ object.\n         *\n         *         In either case, the listener's `this` value will be bound to\n         *         this object.\n         *\n         * @param  {string|Array|Function} typeOrListener\n         *         If the first argument was a string or array, this should be the\n         *         listener function. Otherwise, this is a string or array of event\n         *         type(s).\n         *\n         * @param  {Function} [listener]\n         *         If the first argument was another evented object, this will be\n         *         the listener function.\n         */\n        one(...args) {\n            const {\n                isTargetingSelf,\n                target,\n                type,\n                listener\n            } = normalizeListenArgs(this, args, 'one');\n\n            // Targeting this evented object.\n            if (isTargetingSelf) {\n                listen(target, 'one', type, listener);\n\n                // Targeting another evented object.\n            } else {\n                // TODO: This wrapper is incorrect! It should only\n                //       remove the wrapper for the event type that called it.\n                //       Instead all listeners are removed on the first trigger!\n                //       see https://github.com/videojs/video.js/issues/5962\n                const wrapper = (...largs) => {\n                    this.off(target, type, wrapper);\n                    listener.apply(null, largs);\n                };\n\n                // Use the same function ID as the listener so we can remove it later\n                // it using the ID of the original listener.\n                wrapper.guid = listener.guid;\n                listen(target, 'one', type, wrapper);\n            }\n        },\n        /**\n         * Add a listener to an event (or events) on this object or another evented\n         * object. The listener will only be called once for the first event that is triggered\n         * then removed.\n         *\n         * @param  {string|Array|Element|Object} targetOrType\n         *         If this is a string or array, it represents the event type(s)\n         *         that will trigger the listener.\n         *\n         *         Another evented object can be passed here instead, which will\n         *         cause the listener to listen for events on _that_ object.\n         *\n         *         In either case, the listener's `this` value will be bound to\n         *         this object.\n         *\n         * @param  {string|Array|Function} typeOrListener\n         *         If the first argument was a string or array, this should be the\n         *         listener function. Otherwise, this is a string or array of event\n         *         type(s).\n         *\n         * @param  {Function} [listener]\n         *         If the first argument was another evented object, this will be\n         *         the listener function.\n         */\n        any(...args) {\n            const {\n                isTargetingSelf,\n                target,\n                type,\n                listener\n            } = normalizeListenArgs(this, args, 'any');\n\n            // Targeting this evented object.\n            if (isTargetingSelf) {\n                listen(target, 'any', type, listener);\n\n                // Targeting another evented object.\n            } else {\n                const wrapper = (...largs) => {\n                    this.off(target, type, wrapper);\n                    listener.apply(null, largs);\n                };\n\n                // Use the same function ID as the listener so we can remove it later\n                // it using the ID of the original listener.\n                wrapper.guid = listener.guid;\n                listen(target, 'any', type, wrapper);\n            }\n        },\n        /**\n         * Removes listener(s) from event(s) on an evented object.\n         *\n         * @param  {string|Array|Element|Object} [targetOrType]\n         *         If this is a string or array, it represents the event type(s).\n         *\n         *         Another evented object can be passed here instead, in which case\n         *         ALL 3 arguments are _required_.\n         *\n         * @param  {string|Array|Function} [typeOrListener]\n         *         If the first argument was a string or array, this may be the\n         *         listener function. Otherwise, this is a string or array of event\n         *         type(s).\n         *\n         * @param  {Function} [listener]\n         *         If the first argument was another evented object, this will be\n         *         the listener function; otherwise, _all_ listeners bound to the\n         *         event type(s) will be removed.\n         */\n        off(targetOrType, typeOrListener, listener) {\n            // Targeting this evented object.\n            if (!targetOrType || isValidEventType(targetOrType)) {\n                off(this.eventBusEl_, targetOrType, typeOrListener);\n\n                // Targeting another evented object.\n            } else {\n                const target = targetOrType;\n                const type = typeOrListener;\n\n                // Fail fast and in a meaningful way!\n                validateTarget(target, this, 'off');\n                validateEventType(type, this, 'off');\n                validateListener(listener, this, 'off');\n\n                // Ensure there's at least a guid, even if the function hasn't been used\n                listener = bind_(this, listener);\n\n                // Remove the dispose listener on this evented object, which was given\n                // the same guid as the event listener in on().\n                this.off('dispose', listener);\n                if (target.nodeName) {\n                    off(target, type, listener);\n                    off(target, 'dispose', listener);\n                } else if (isEvented(target)) {\n                    target.off(type, listener);\n                    target.off('dispose', listener);\n                }\n            }\n        },\n        /**\n         * Fire an event on this evented object, causing its listeners to be called.\n         *\n         * @param   {string|Object} event\n         *          An event type or an object with a type property.\n         *\n         * @param   {Object} [hash]\n         *          An additional object to pass along to listeners.\n         *\n         * @return {boolean}\n         *          Whether or not the default behavior was prevented.\n         */\n        trigger(event, hash) {\n            validateTarget(this.eventBusEl_, this, 'trigger');\n            const type = event && typeof event !== 'string' ? event.type : event;\n            if (!isValidEventType(type)) {\n                throw new Error(`Invalid event type for ${objName(this)}#trigger; ` + 'must be a non-empty string or object with a type key that has a non-empty value.');\n            }\n            return trigger(this.eventBusEl_, event, hash);\n        }\n    };\n\n    /**\n     * Applies {@link module:evented~EventedMixin|EventedMixin} to a target object.\n     *\n     * @param  {Object} target\n     *         The object to which to add event methods.\n     *\n     * @param  {Object} [options={}]\n     *         Options for customizing the mixin behavior.\n     *\n     * @param  {string} [options.eventBusKey]\n     *         By default, adds a `eventBusEl_` DOM element to the target object,\n     *         which is used as an event bus. If the target object already has a\n     *         DOM element that should be used, pass its key here.\n     *\n     * @return {Object}\n     *         The target object.\n     */\n    function evented(target, options = {}) {\n        const {\n            eventBusKey\n        } = options;\n\n        // Set or create the eventBusEl_.\n        if (eventBusKey) {\n            if (!target[eventBusKey].nodeName) {\n                throw new Error(`The eventBusKey \"${eventBusKey}\" does not refer to an element.`);\n            }\n            target.eventBusEl_ = target[eventBusKey];\n        } else {\n            target.eventBusEl_ = createEl('span', {\n                className: 'vjs-event-bus'\n            });\n        }\n        Object.assign(target, EventedMixin);\n        if (target.eventedCallbacks) {\n            target.eventedCallbacks.forEach(callback => {\n                callback();\n            });\n        }\n\n        // When any evented object is disposed, it removes all its listeners.\n        target.on('dispose', () => {\n            target.off();\n            [target, target.el_, target.eventBusEl_].forEach(function (val) {\n                if (val && DomData.has(val)) {\n                    DomData.delete(val);\n                }\n            });\n            window.setTimeout(() => {\n                target.eventBusEl_ = null;\n            }, 0);\n        });\n        return target;\n    }\n\n    /**\n     * @file mixins/stateful.js\n     * @module stateful\n     */\n\n    /**\n     * Contains methods that provide statefulness to an object which is passed\n     * to {@link module:stateful}.\n     *\n     * @mixin StatefulMixin\n     */\n    const StatefulMixin = {\n        /**\n         * A hash containing arbitrary keys and values representing the state of\n         * the object.\n         *\n         * @type {Object}\n         */\n        state: {},\n        /**\n         * Set the state of an object by mutating its\n         * {@link module:stateful~StatefulMixin.state|state} object in place.\n         *\n         * @fires   module:stateful~StatefulMixin#statechanged\n         * @param   {Object|Function} stateUpdates\n         *          A new set of properties to shallow-merge into the plugin state.\n         *          Can be a plain object or a function returning a plain object.\n         *\n         * @return {Object|undefined}\n         *          An object containing changes that occurred. If no changes\n         *          occurred, returns `undefined`.\n         */\n        setState(stateUpdates) {\n            // Support providing the `stateUpdates` state as a function.\n            if (typeof stateUpdates === 'function') {\n                stateUpdates = stateUpdates();\n            }\n            let changes;\n            each(stateUpdates, (value, key) => {\n                // Record the change if the value is different from what's in the\n                // current state.\n                if (this.state[key] !== value) {\n                    changes = changes || {};\n                    changes[key] = {\n                        from: this.state[key],\n                        to: value\n                    };\n                }\n                this.state[key] = value;\n            });\n\n            // Only trigger \"statechange\" if there were changes AND we have a trigger\n            // function. This allows us to not require that the target object be an\n            // evented object.\n            if (changes && isEvented(this)) {\n                /**\n                 * An event triggered on an object that is both\n                 * {@link module:stateful|stateful} and {@link module:evented|evented}\n                 * indicating that its state has changed.\n                 *\n                 * @event    module:stateful~StatefulMixin#statechanged\n                 * @type     {Object}\n                 * @property {Object} changes\n                 *           A hash containing the properties that were changed and\n                 *           the values they were changed `from` and `to`.\n                 */\n                this.trigger({\n                    changes,\n                    type: 'statechanged'\n                });\n            }\n            return changes;\n        }\n    };\n\n    /**\n     * Applies {@link module:stateful~StatefulMixin|StatefulMixin} to a target\n     * object.\n     *\n     * If the target object is {@link module:evented|evented} and has a\n     * `handleStateChanged` method, that method will be automatically bound to the\n     * `statechanged` event on itself.\n     *\n     * @param   {Object} target\n     *          The object to be made stateful.\n     *\n     * @param   {Object} [defaultState]\n     *          A default set of properties to populate the newly-stateful object's\n     *          `state` property.\n     *\n     * @return {Object}\n     *          Returns the `target`.\n     */\n    function stateful(target, defaultState) {\n        Object.assign(target, StatefulMixin);\n\n        // This happens after the mixing-in because we need to replace the `state`\n        // added in that step.\n        target.state = Object.assign({}, target.state, defaultState);\n\n        // Auto-bind the `handleStateChanged` method of the target object if it exists.\n        if (typeof target.handleStateChanged === 'function' && isEvented(target)) {\n            target.on('statechanged', target.handleStateChanged);\n        }\n        return target;\n    }\n\n    /**\n     * @file str.js\n     * @module to-lower-case\n     */\n\n    /**\n     * Lowercase the first letter of a string.\n     *\n     * @param {string} string\n     *        String to be lowercased\n     *\n     * @return {string}\n     *         The string with a lowercased first letter\n     */\n    const toLowerCase = function (string) {\n        if (typeof string !== 'string') {\n            return string;\n        }\n        return string.replace(/./, w => w.toLowerCase());\n    };\n\n    /**\n     * Uppercase the first letter of a string.\n     *\n     * @param {string} string\n     *        String to be uppercased\n     *\n     * @return {string}\n     *         The string with an uppercased first letter\n     */\n    const toTitleCase$1 = function (string) {\n        if (typeof string !== 'string') {\n            return string;\n        }\n        return string.replace(/./, w => w.toUpperCase());\n    };\n\n    /**\n     * Compares the TitleCase versions of the two strings for equality.\n     *\n     * @param {string} str1\n     *        The first string to compare\n     *\n     * @param {string} str2\n     *        The second string to compare\n     *\n     * @return {boolean}\n     *         Whether the TitleCase versions of the strings are equal\n     */\n    const titleCaseEquals = function (str1, str2) {\n        return toTitleCase$1(str1) === toTitleCase$1(str2);\n    };\n\n    var Str = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        toLowerCase: toLowerCase,\n        toTitleCase: toTitleCase$1,\n        titleCaseEquals: titleCaseEquals\n    });\n\n    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n    function unwrapExports (x) {\n        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n    }\n\n    function createCommonjsModule(fn, module) {\n        return module = { exports: {} }, fn(module, module.exports), module.exports;\n    }\n\n    var keycode = createCommonjsModule(function (module, exports) {\n        // Source: http://jsfiddle.net/vWx8V/\n        // http://stackoverflow.com/questions/5603195/full-list-of-javascript-keycodes\n\n        /**\n         * Conenience method returns corresponding value for given keyName or keyCode.\n         *\n         * @param {Mixed} keyCode {Number} or keyName {String}\n         * @return {Mixed}\n         * @api public\n         */\n\n        function keyCode(searchInput) {\n            // Keyboard Events\n            if (searchInput && 'object' === typeof searchInput) {\n                var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;\n                if (hasKeyCode) searchInput = hasKeyCode;\n            }\n\n            // Numbers\n            if ('number' === typeof searchInput) return names[searchInput];\n\n            // Everything else (cast to string)\n            var search = String(searchInput);\n\n            // check codes\n            var foundNamedKey = codes[search.toLowerCase()];\n            if (foundNamedKey) return foundNamedKey;\n\n            // check aliases\n            var foundNamedKey = aliases[search.toLowerCase()];\n            if (foundNamedKey) return foundNamedKey;\n\n            // weird character?\n            if (search.length === 1) return search.charCodeAt(0);\n            return undefined;\n        }\n\n        /**\n         * Compares a keyboard event with a given keyCode or keyName.\n         *\n         * @param {Event} event Keyboard event that should be tested\n         * @param {Mixed} keyCode {Number} or keyName {String}\n         * @return {Boolean}\n         * @api public\n         */\n        keyCode.isEventKey = function isEventKey(event, nameOrCode) {\n            if (event && 'object' === typeof event) {\n                var keyCode = event.which || event.keyCode || event.charCode;\n                if (keyCode === null || keyCode === undefined) {\n                    return false;\n                }\n                if (typeof nameOrCode === 'string') {\n                    // check codes\n                    var foundNamedKey = codes[nameOrCode.toLowerCase()];\n                    if (foundNamedKey) {\n                        return foundNamedKey === keyCode;\n                    }\n\n                    // check aliases\n                    var foundNamedKey = aliases[nameOrCode.toLowerCase()];\n                    if (foundNamedKey) {\n                        return foundNamedKey === keyCode;\n                    }\n                } else if (typeof nameOrCode === 'number') {\n                    return nameOrCode === keyCode;\n                }\n                return false;\n            }\n        };\n        exports = module.exports = keyCode;\n\n        /**\n         * Get by name\n         *\n         *   exports.code['enter'] // => 13\n         */\n\n        var codes = exports.code = exports.codes = {\n            'backspace': 8,\n            'tab': 9,\n            'enter': 13,\n            'shift': 16,\n            'ctrl': 17,\n            'alt': 18,\n            'pause/break': 19,\n            'caps lock': 20,\n            'esc': 27,\n            'space': 32,\n            'page up': 33,\n            'page down': 34,\n            'end': 35,\n            'home': 36,\n            'left': 37,\n            'up': 38,\n            'right': 39,\n            'down': 40,\n            'insert': 45,\n            'delete': 46,\n            'command': 91,\n            'left command': 91,\n            'right command': 93,\n            'numpad *': 106,\n            'numpad +': 107,\n            'numpad -': 109,\n            'numpad .': 110,\n            'numpad /': 111,\n            'num lock': 144,\n            'scroll lock': 145,\n            'my computer': 182,\n            'my calculator': 183,\n            ';': 186,\n            '=': 187,\n            ',': 188,\n            '-': 189,\n            '.': 190,\n            '/': 191,\n            '`': 192,\n            '[': 219,\n            '\\\\': 220,\n            ']': 221,\n            \"'\": 222\n        };\n\n        // Helper aliases\n\n        var aliases = exports.aliases = {\n            'windows': 91,\n            '⇧': 16,\n            '⌥': 18,\n            '⌃': 17,\n            '⌘': 91,\n            'ctl': 17,\n            'control': 17,\n            'option': 18,\n            'pause': 19,\n            'break': 19,\n            'caps': 20,\n            'return': 13,\n            'escape': 27,\n            'spc': 32,\n            'spacebar': 32,\n            'pgup': 33,\n            'pgdn': 34,\n            'ins': 45,\n            'del': 46,\n            'cmd': 91\n        };\n\n        /*!\n     * Programatically add the following\n     */\n\n        // lower case chars\n        for (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32;\n\n        // numbers\n        for (var i = 48; i < 58; i++) codes[i - 48] = i;\n\n        // function keys\n        for (i = 1; i < 13; i++) codes['f' + i] = i + 111;\n\n        // numpad keys\n        for (i = 0; i < 10; i++) codes['numpad ' + i] = i + 96;\n\n        /**\n         * Get by code\n         *\n         *   exports.name[13] // => 'Enter'\n         */\n\n        var names = exports.names = exports.title = {}; // title for backward compat\n\n        // Create reverse mapping\n        for (i in codes) names[codes[i]] = i;\n\n        // Add aliases\n        for (var alias in aliases) {\n            codes[alias] = aliases[alias];\n        }\n    });\n    keycode.code;\n    keycode.codes;\n    keycode.aliases;\n    keycode.names;\n    keycode.title;\n\n    /**\n     * Player Component - Base class for all UI objects\n     *\n     * @file component.js\n     */\n\n    /**\n     * Base class for all UI Components.\n     * Components are UI objects which represent both a javascript object and an element\n     * in the DOM. They can be children of other components, and can have\n     * children themselves.\n     *\n     * Components can also use methods from {@link EventTarget}\n     */\n    class Component$1 {\n        /**\n         * A callback that is called when a component is ready. Does not have any\n         * parameters and any callback value will be ignored.\n         *\n         * @callback ReadyCallback\n         * @this Component\n         */\n\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of component options.\n         *\n         * @param {Object[]} [options.children]\n         *        An array of children objects to initialize this component with. Children objects have\n         *        a name property that will be used if more than one component of the same type needs to be\n         *        added.\n         *\n         * @param  {string} [options.className]\n         *         A class or space separated list of classes to add the component\n         *\n         * @param {ReadyCallback} [ready]\n         *        Function that gets called when the `Component` is ready.\n         */\n        constructor(player, options, ready) {\n            // The component might be the player itself and we can't pass `this` to super\n            if (!player && this.play) {\n                this.player_ = player = this; // eslint-disable-line\n            } else {\n                this.player_ = player;\n            }\n            this.isDisposed_ = false;\n\n            // Hold the reference to the parent component via `addChild` method\n            this.parentComponent_ = null;\n\n            // Make a copy of prototype.options_ to protect against overriding defaults\n            this.options_ = merge$2({}, this.options_);\n\n            // Updated options with supplied options\n            options = this.options_ = merge$2(this.options_, options);\n\n            // Get ID from options or options element if one is supplied\n            this.id_ = options.id || options.el && options.el.id;\n\n            // If there was no ID from the options, generate one\n            if (!this.id_) {\n                // Don't require the player ID function in the case of mock players\n                const id = player && player.id && player.id() || 'no_player';\n                this.id_ = `${id}_component_${newGUID()}`;\n            }\n            this.name_ = options.name || null;\n\n            // Create element if one wasn't provided in options\n            if (options.el) {\n                this.el_ = options.el;\n            } else if (options.createEl !== false) {\n                this.el_ = this.createEl();\n            }\n            if (options.className && this.el_) {\n                options.className.split(' ').forEach(c => this.addClass(c));\n            }\n\n            // Remove the placeholder event methods. If the component is evented, the\n            // real methods are added next\n            ['on', 'off', 'one', 'any', 'trigger'].forEach(fn => {\n                this[fn] = undefined;\n            });\n\n            // if evented is anything except false, we want to mixin in evented\n            if (options.evented !== false) {\n                // Make this an evented object and use `el_`, if available, as its event bus\n                evented(this, {\n                    eventBusKey: this.el_ ? 'el_' : null\n                });\n                this.handleLanguagechange = this.handleLanguagechange.bind(this);\n                this.on(this.player_, 'languagechange', this.handleLanguagechange);\n            }\n            stateful(this, this.constructor.defaultState);\n            this.children_ = [];\n            this.childIndex_ = {};\n            this.childNameIndex_ = {};\n            this.setTimeoutIds_ = new Set();\n            this.setIntervalIds_ = new Set();\n            this.rafIds_ = new Set();\n            this.namedRafs_ = new Map();\n            this.clearingTimersOnDispose_ = false;\n\n            // Add any child components in options\n            if (options.initChildren !== false) {\n                this.initChildren();\n            }\n\n            // Don't want to trigger ready here or it will go before init is actually\n            // finished for all children that run this constructor\n            this.ready(ready);\n            if (options.reportTouchActivity !== false) {\n                this.enableTouchActivity();\n            }\n        }\n\n        // `on`, `off`, `one`, `any` and `trigger` are here so tsc includes them in definitions.\n        // They are replaced or removed in the constructor\n\n        /**\n         * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a\n         * function that will get called when an event with a certain name gets triggered.\n         *\n         * @param {string|string[]} type\n         *        An event name or an array of event names.\n         *\n         * @param {Function} fn\n         *        The function to call with `EventTarget`s\n         */\n        on(type, fn) {}\n\n        /**\n         * Removes an `event listener` for a specific event from an instance of `EventTarget`.\n         * This makes it so that the `event listener` will no longer get called when the\n         * named event happens.\n         *\n         * @param {string|string[]} type\n         *        An event name or an array of event names.\n         *\n         * @param {Function} fn\n         *        The function to remove.\n         */\n        off(type, fn) {}\n\n        /**\n         * This function will add an `event listener` that gets triggered only once. After the\n         * first trigger it will get removed. This is like adding an `event listener`\n         * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.\n         *\n         * @param {string|string[]} type\n         *        An event name or an array of event names.\n         *\n         * @param {Function} fn\n         *        The function to be called once for each event name.\n         */\n        one(type, fn) {}\n\n        /**\n         * This function will add an `event listener` that gets triggered only once and is\n         * removed from all events. This is like adding an array of `event listener`s\n         * with {@link EventTarget#on} that calls {@link EventTarget#off} on all events the\n         * first time it is triggered.\n         *\n         * @param {string|string[]} type\n         *        An event name or an array of event names.\n         *\n         * @param {Function} fn\n         *        The function to be called once for each event name.\n         */\n        any(type, fn) {}\n\n        /**\n         * This function causes an event to happen. This will then cause any `event listeners`\n         * that are waiting for that event, to get called. If there are no `event listeners`\n         * for an event then nothing will happen.\n         *\n         * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.\n         * Trigger will also call the `on` + `uppercaseEventName` function.\n         *\n         * Example:\n         * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call\n         * `onClick` if it exists.\n         *\n         * @param {string|Event|Object} event\n         *        The name of the event, an `Event`, or an object with a key of type set to\n         *        an event name.\n         */\n        trigger(event) {}\n\n        /**\n         * Dispose of the `Component` and all child components.\n         *\n         * @fires Component#dispose\n         *\n         * @param {Object} options\n         * @param {Element} options.originalEl element with which to replace player element\n         */\n        dispose(options = {}) {\n            // Bail out if the component has already been disposed.\n            if (this.isDisposed_) {\n                return;\n            }\n            if (this.readyQueue_) {\n                this.readyQueue_.length = 0;\n            }\n\n            /**\n             * Triggered when a `Component` is disposed.\n             *\n             * @event Component#dispose\n             * @type {Event}\n             *\n             * @property {boolean} [bubbles=false]\n             *           set to false so that the dispose event does not\n             *           bubble up\n             */\n            this.trigger({\n                type: 'dispose',\n                bubbles: false\n            });\n            this.isDisposed_ = true;\n\n            // Dispose all children.\n            if (this.children_) {\n                for (let i = this.children_.length - 1; i >= 0; i--) {\n                    if (this.children_[i].dispose) {\n                        this.children_[i].dispose();\n                    }\n                }\n            }\n\n            // Delete child references\n            this.children_ = null;\n            this.childIndex_ = null;\n            this.childNameIndex_ = null;\n            this.parentComponent_ = null;\n            if (this.el_) {\n                // Remove element from DOM\n                if (this.el_.parentNode) {\n                    if (options.restoreEl) {\n                        this.el_.parentNode.replaceChild(options.restoreEl, this.el_);\n                    } else {\n                        this.el_.parentNode.removeChild(this.el_);\n                    }\n                }\n                this.el_ = null;\n            }\n\n            // remove reference to the player after disposing of the element\n            this.player_ = null;\n        }\n\n        /**\n         * Determine whether or not this component has been disposed.\n         *\n         * @return {boolean}\n         *         If the component has been disposed, will be `true`. Otherwise, `false`.\n         */\n        isDisposed() {\n            return Boolean(this.isDisposed_);\n        }\n\n        /**\n         * Return the {@link Player} that the `Component` has attached to.\n         *\n         * @return { import('./player').default }\n         *         The player that this `Component` has attached to.\n         */\n        player() {\n            return this.player_;\n        }\n\n        /**\n         * Deep merge of options objects with new options.\n         * > Note: When both `obj` and `options` contain properties whose values are objects.\n         *         The two properties get merged using {@link module:obj.merge}\n         *\n         * @param {Object} obj\n         *        The object that contains new options.\n         *\n         * @return {Object}\n         *         A new object of `this.options_` and `obj` merged together.\n         */\n        options(obj) {\n            if (!obj) {\n                return this.options_;\n            }\n            this.options_ = merge$2(this.options_, obj);\n            return this.options_;\n        }\n\n        /**\n         * Get the `Component`s DOM element\n         *\n         * @return {Element}\n         *         The DOM element for this `Component`.\n         */\n        el() {\n            return this.el_;\n        }\n\n        /**\n         * Create the `Component`s DOM element.\n         *\n         * @param {string} [tagName]\n         *        Element's DOM node type. e.g. 'div'\n         *\n         * @param {Object} [properties]\n         *        An object of properties that should be set.\n         *\n         * @param {Object} [attributes]\n         *        An object of attributes that should be set.\n         *\n         * @return {Element}\n         *         The element that gets created.\n         */\n        createEl(tagName, properties, attributes) {\n            return createEl(tagName, properties, attributes);\n        }\n\n        /**\n         * Localize a string given the string in english.\n         *\n         * If tokens are provided, it'll try and run a simple token replacement on the provided string.\n         * The tokens it looks for look like `{1}` with the index being 1-indexed into the tokens array.\n         *\n         * If a `defaultValue` is provided, it'll use that over `string`,\n         * if a value isn't found in provided language files.\n         * This is useful if you want to have a descriptive key for token replacement\n         * but have a succinct localized string and not require `en.json` to be included.\n         *\n         * Currently, it is used for the progress bar timing.\n         * ```js\n         * {\n         *   \"progress bar timing: currentTime={1} duration={2}\": \"{1} of {2}\"\n         * }\n         * ```\n         * It is then used like so:\n         * ```js\n         * this.localize('progress bar timing: currentTime={1} duration{2}',\n         *               [this.player_.currentTime(), this.player_.duration()],\n         *               '{1} of {2}');\n         * ```\n         *\n         * Which outputs something like: `01:23 of 24:56`.\n         *\n         *\n         * @param {string} string\n         *        The string to localize and the key to lookup in the language files.\n         * @param {string[]} [tokens]\n         *        If the current item has token replacements, provide the tokens here.\n         * @param {string} [defaultValue]\n         *        Defaults to `string`. Can be a default value to use for token replacement\n         *        if the lookup key is needed to be separate.\n         *\n         * @return {string}\n         *         The localized string or if no localization exists the english string.\n         */\n        localize(string, tokens, defaultValue = string) {\n            const code = this.player_.language && this.player_.language();\n            const languages = this.player_.languages && this.player_.languages();\n            const language = languages && languages[code];\n            const primaryCode = code && code.split('-')[0];\n            const primaryLang = languages && languages[primaryCode];\n            let localizedString = defaultValue;\n            if (language && language[string]) {\n                localizedString = language[string];\n            } else if (primaryLang && primaryLang[string]) {\n                localizedString = primaryLang[string];\n            }\n            if (tokens) {\n                localizedString = localizedString.replace(/\\{(\\d+)\\}/g, function (match, index) {\n                    const value = tokens[index - 1];\n                    let ret = value;\n                    if (typeof value === 'undefined') {\n                        ret = match;\n                    }\n                    return ret;\n                });\n            }\n            return localizedString;\n        }\n\n        /**\n         * Handles language change for the player in components. Should be overridden by sub-components.\n         *\n         * @abstract\n         */\n        handleLanguagechange() {}\n\n        /**\n         * Return the `Component`s DOM element. This is where children get inserted.\n         * This will usually be the the same as the element returned in {@link Component#el}.\n         *\n         * @return {Element}\n         *         The content element for this `Component`.\n         */\n        contentEl() {\n            return this.contentEl_ || this.el_;\n        }\n\n        /**\n         * Get this `Component`s ID\n         *\n         * @return {string}\n         *         The id of this `Component`\n         */\n        id() {\n            return this.id_;\n        }\n\n        /**\n         * Get the `Component`s name. The name gets used to reference the `Component`\n         * and is set during registration.\n         *\n         * @return {string}\n         *         The name of this `Component`.\n         */\n        name() {\n            return this.name_;\n        }\n\n        /**\n         * Get an array of all child components\n         *\n         * @return {Array}\n         *         The children\n         */\n        children() {\n            return this.children_;\n        }\n\n        /**\n         * Returns the child `Component` with the given `id`.\n         *\n         * @param {string} id\n         *        The id of the child `Component` to get.\n         *\n         * @return {Component|undefined}\n         *         The child `Component` with the given `id` or undefined.\n         */\n        getChildById(id) {\n            return this.childIndex_[id];\n        }\n\n        /**\n         * Returns the child `Component` with the given `name`.\n         *\n         * @param {string} name\n         *        The name of the child `Component` to get.\n         *\n         * @return {Component|undefined}\n         *         The child `Component` with the given `name` or undefined.\n         */\n        getChild(name) {\n            if (!name) {\n                return;\n            }\n            return this.childNameIndex_[name];\n        }\n\n        /**\n         * Returns the descendant `Component` following the givent\n         * descendant `names`. For instance ['foo', 'bar', 'baz'] would\n         * try to get 'foo' on the current component, 'bar' on the 'foo'\n         * component and 'baz' on the 'bar' component and return undefined\n         * if any of those don't exist.\n         *\n         * @param {...string[]|...string} names\n         *        The name of the child `Component` to get.\n         *\n         * @return {Component|undefined}\n         *         The descendant `Component` following the given descendant\n         *         `names` or undefined.\n         */\n        getDescendant(...names) {\n            // flatten array argument into the main array\n            names = names.reduce((acc, n) => acc.concat(n), []);\n            let currentChild = this;\n            for (let i = 0; i < names.length; i++) {\n                currentChild = currentChild.getChild(names[i]);\n                if (!currentChild || !currentChild.getChild) {\n                    return;\n                }\n            }\n            return currentChild;\n        }\n\n        /**\n         * Add a child `Component` inside the current `Component`.\n         *\n         *\n         * @param {string|Component} child\n         *        The name or instance of a child to add.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of options that will get passed to children of\n         *        the child.\n         *\n         * @param {number} [index=this.children_.length]\n         *        The index to attempt to add a child into.\n         *\n         * @return {Component}\n         *         The `Component` that gets added as a child. When using a string the\n         *         `Component` will get created by this process.\n         */\n        addChild(child, options = {}, index = this.children_.length) {\n            let component;\n            let componentName;\n\n            // If child is a string, create component with options\n            if (typeof child === 'string') {\n                componentName = toTitleCase$1(child);\n                const componentClassName = options.componentClass || componentName;\n\n                // Set name through options\n                options.name = componentName;\n\n                // Create a new object & element for this controls set\n                // If there's no .player_, this is a player\n                const ComponentClass = Component$1.getComponent(componentClassName);\n                if (!ComponentClass) {\n                    throw new Error(`Component ${componentClassName} does not exist`);\n                }\n\n                // data stored directly on the videojs object may be\n                // misidentified as a component to retain\n                // backwards-compatibility with 4.x. check to make sure the\n                // component class can be instantiated.\n                if (typeof ComponentClass !== 'function') {\n                    return null;\n                }\n                component = new ComponentClass(this.player_ || this, options);\n\n                // child is a component instance\n            } else {\n                component = child;\n            }\n            if (component.parentComponent_) {\n                component.parentComponent_.removeChild(component);\n            }\n            this.children_.splice(index, 0, component);\n            component.parentComponent_ = this;\n            if (typeof component.id === 'function') {\n                this.childIndex_[component.id()] = component;\n            }\n\n            // If a name wasn't used to create the component, check if we can use the\n            // name function of the component\n            componentName = componentName || component.name && toTitleCase$1(component.name());\n            if (componentName) {\n                this.childNameIndex_[componentName] = component;\n                this.childNameIndex_[toLowerCase(componentName)] = component;\n            }\n\n            // Add the UI object's element to the container div (box)\n            // Having an element is not required\n            if (typeof component.el === 'function' && component.el()) {\n                // If inserting before a component, insert before that component's element\n                let refNode = null;\n                if (this.children_[index + 1]) {\n                    // Most children are components, but the video tech is an HTML element\n                    if (this.children_[index + 1].el_) {\n                        refNode = this.children_[index + 1].el_;\n                    } else if (isEl(this.children_[index + 1])) {\n                        refNode = this.children_[index + 1];\n                    }\n                }\n                this.contentEl().insertBefore(component.el(), refNode);\n            }\n\n            // Return so it can stored on parent object if desired.\n            return component;\n        }\n\n        /**\n         * Remove a child `Component` from this `Component`s list of children. Also removes\n         * the child `Component`s element from this `Component`s element.\n         *\n         * @param {Component} component\n         *        The child `Component` to remove.\n         */\n        removeChild(component) {\n            if (typeof component === 'string') {\n                component = this.getChild(component);\n            }\n            if (!component || !this.children_) {\n                return;\n            }\n            let childFound = false;\n            for (let i = this.children_.length - 1; i >= 0; i--) {\n                if (this.children_[i] === component) {\n                    childFound = true;\n                    this.children_.splice(i, 1);\n                    break;\n                }\n            }\n            if (!childFound) {\n                return;\n            }\n            component.parentComponent_ = null;\n            this.childIndex_[component.id()] = null;\n            this.childNameIndex_[toTitleCase$1(component.name())] = null;\n            this.childNameIndex_[toLowerCase(component.name())] = null;\n            const compEl = component.el();\n            if (compEl && compEl.parentNode === this.contentEl()) {\n                this.contentEl().removeChild(component.el());\n            }\n        }\n\n        /**\n         * Add and initialize default child `Component`s based upon options.\n         */\n        initChildren() {\n            const children = this.options_.children;\n            if (children) {\n                // `this` is `parent`\n                const parentOptions = this.options_;\n                const handleAdd = child => {\n                    const name = child.name;\n                    let opts = child.opts;\n\n                    // Allow options for children to be set at the parent options\n                    // e.g. videojs(id, { controlBar: false });\n                    // instead of videojs(id, { children: { controlBar: false });\n                    if (parentOptions[name] !== undefined) {\n                        opts = parentOptions[name];\n                    }\n\n                    // Allow for disabling default components\n                    // e.g. options['children']['posterImage'] = false\n                    if (opts === false) {\n                        return;\n                    }\n\n                    // Allow options to be passed as a simple boolean if no configuration\n                    // is necessary.\n                    if (opts === true) {\n                        opts = {};\n                    }\n\n                    // We also want to pass the original player options\n                    // to each component as well so they don't need to\n                    // reach back into the player for options later.\n                    opts.playerOptions = this.options_.playerOptions;\n\n                    // Create and add the child component.\n                    // Add a direct reference to the child by name on the parent instance.\n                    // If two of the same component are used, different names should be supplied\n                    // for each\n                    const newChild = this.addChild(name, opts);\n                    if (newChild) {\n                        this[name] = newChild;\n                    }\n                };\n\n                // Allow for an array of children details to passed in the options\n                let workingChildren;\n                const Tech = Component$1.getComponent('Tech');\n                if (Array.isArray(children)) {\n                    workingChildren = children;\n                } else {\n                    workingChildren = Object.keys(children);\n                }\n                workingChildren\n                    // children that are in this.options_ but also in workingChildren  would\n                    // give us extra children we do not want. So, we want to filter them out.\n                    .concat(Object.keys(this.options_).filter(function (child) {\n                        return !workingChildren.some(function (wchild) {\n                            if (typeof wchild === 'string') {\n                                return child === wchild;\n                            }\n                            return child === wchild.name;\n                        });\n                    })).map(child => {\n                    let name;\n                    let opts;\n                    if (typeof child === 'string') {\n                        name = child;\n                        opts = children[name] || this.options_[name] || {};\n                    } else {\n                        name = child.name;\n                        opts = child;\n                    }\n                    return {\n                        name,\n                        opts\n                    };\n                }).filter(child => {\n                    // we have to make sure that child.name isn't in the techOrder since\n                    // techs are registered as Components but can't aren't compatible\n                    // See https://github.com/videojs/video.js/issues/2772\n                    const c = Component$1.getComponent(child.opts.componentClass || toTitleCase$1(child.name));\n                    return c && !Tech.isTech(c);\n                }).forEach(handleAdd);\n            }\n        }\n\n        /**\n         * Builds the default DOM class name. Should be overridden by sub-components.\n         *\n         * @return {string}\n         *         The DOM class name for this object.\n         *\n         * @abstract\n         */\n        buildCSSClass() {\n            // Child classes can include a function that does:\n            // return 'CLASS NAME' + this._super();\n            return '';\n        }\n\n        /**\n         * Bind a listener to the component's ready state.\n         * Different from event listeners in that if the ready event has already happened\n         * it will trigger the function immediately.\n         *\n         * @param {ReadyCallback} fn\n         *        Function that gets called when the `Component` is ready.\n         *\n         * @return {Component}\n         *         Returns itself; method can be chained.\n         */\n        ready(fn, sync = false) {\n            if (!fn) {\n                return;\n            }\n            if (!this.isReady_) {\n                this.readyQueue_ = this.readyQueue_ || [];\n                this.readyQueue_.push(fn);\n                return;\n            }\n            if (sync) {\n                fn.call(this);\n            } else {\n                // Call the function asynchronously by default for consistency\n                this.setTimeout(fn, 1);\n            }\n        }\n\n        /**\n         * Trigger all the ready listeners for this `Component`.\n         *\n         * @fires Component#ready\n         */\n        triggerReady() {\n            this.isReady_ = true;\n\n            // Ensure ready is triggered asynchronously\n            this.setTimeout(function () {\n                const readyQueue = this.readyQueue_;\n\n                // Reset Ready Queue\n                this.readyQueue_ = [];\n                if (readyQueue && readyQueue.length > 0) {\n                    readyQueue.forEach(function (fn) {\n                        fn.call(this);\n                    }, this);\n                }\n\n                // Allow for using event listeners also\n                /**\n                 * Triggered when a `Component` is ready.\n                 *\n                 * @event Component#ready\n                 * @type {Event}\n                 */\n                this.trigger('ready');\n            }, 1);\n        }\n\n        /**\n         * Find a single DOM element matching a `selector`. This can be within the `Component`s\n         * `contentEl()` or another custom context.\n         *\n         * @param {string} selector\n         *        A valid CSS selector, which will be passed to `querySelector`.\n         *\n         * @param {Element|string} [context=this.contentEl()]\n         *        A DOM element within which to query. Can also be a selector string in\n         *        which case the first matching element will get used as context. If\n         *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n         *        nothing it falls back to `document`.\n         *\n         * @return {Element|null}\n         *         the dom element that was found, or null\n         *\n         * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n         */\n        $(selector, context) {\n            return $(selector, context || this.contentEl());\n        }\n\n        /**\n         * Finds all DOM element matching a `selector`. This can be within the `Component`s\n         * `contentEl()` or another custom context.\n         *\n         * @param {string} selector\n         *        A valid CSS selector, which will be passed to `querySelectorAll`.\n         *\n         * @param {Element|string} [context=this.contentEl()]\n         *        A DOM element within which to query. Can also be a selector string in\n         *        which case the first matching element will get used as context. If\n         *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns\n         *        nothing it falls back to `document`.\n         *\n         * @return {NodeList}\n         *         a list of dom elements that were found\n         *\n         * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)\n         */\n        $$(selector, context) {\n            return $$(selector, context || this.contentEl());\n        }\n\n        /**\n         * Check if a component's element has a CSS class name.\n         *\n         * @param {string} classToCheck\n         *        CSS class name to check.\n         *\n         * @return {boolean}\n         *         - True if the `Component` has the class.\n         *         - False if the `Component` does not have the class`\n         */\n        hasClass(classToCheck) {\n            return hasClass(this.el_, classToCheck);\n        }\n\n        /**\n         * Add a CSS class name to the `Component`s element.\n         *\n         * @param {...string} classesToAdd\n         *        One or more CSS class name to add.\n         */\n        addClass(...classesToAdd) {\n            addClass(this.el_, ...classesToAdd);\n        }\n\n        /**\n         * Remove a CSS class name from the `Component`s element.\n         *\n         * @param {...string} classesToRemove\n         *        One or more CSS class name to remove.\n         */\n        removeClass(...classesToRemove) {\n            removeClass(this.el_, ...classesToRemove);\n        }\n\n        /**\n         * Add or remove a CSS class name from the component's element.\n         * - `classToToggle` gets added when {@link Component#hasClass} would return false.\n         * - `classToToggle` gets removed when {@link Component#hasClass} would return true.\n         *\n         * @param  {string} classToToggle\n         *         The class to add or remove based on (@link Component#hasClass}\n         *\n         * @param  {boolean|Dom~predicate} [predicate]\n         *         An {@link Dom~predicate} function or a boolean\n         */\n        toggleClass(classToToggle, predicate) {\n            toggleClass(this.el_, classToToggle, predicate);\n        }\n\n        /**\n         * Show the `Component`s element if it is hidden by removing the\n         * 'vjs-hidden' class name from it.\n         */\n        show() {\n            this.removeClass('vjs-hidden');\n        }\n\n        /**\n         * Hide the `Component`s element if it is currently showing by adding the\n         * 'vjs-hidden` class name to it.\n         */\n        hide() {\n            this.addClass('vjs-hidden');\n        }\n\n        /**\n         * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'\n         * class name to it. Used during fadeIn/fadeOut.\n         *\n         * @private\n         */\n        lockShowing() {\n            this.addClass('vjs-lock-showing');\n        }\n\n        /**\n         * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'\n         * class name from it. Used during fadeIn/fadeOut.\n         *\n         * @private\n         */\n        unlockShowing() {\n            this.removeClass('vjs-lock-showing');\n        }\n\n        /**\n         * Get the value of an attribute on the `Component`s element.\n         *\n         * @param {string} attribute\n         *        Name of the attribute to get the value from.\n         *\n         * @return {string|null}\n         *         - The value of the attribute that was asked for.\n         *         - Can be an empty string on some browsers if the attribute does not exist\n         *           or has no value\n         *         - Most browsers will return null if the attribute does not exist or has\n         *           no value.\n         *\n         * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}\n         */\n        getAttribute(attribute) {\n            return getAttribute(this.el_, attribute);\n        }\n\n        /**\n         * Set the value of an attribute on the `Component`'s element\n         *\n         * @param {string} attribute\n         *        Name of the attribute to set.\n         *\n         * @param {string} value\n         *        Value to set the attribute to.\n         *\n         * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}\n         */\n        setAttribute(attribute, value) {\n            setAttribute(this.el_, attribute, value);\n        }\n\n        /**\n         * Remove an attribute from the `Component`s element.\n         *\n         * @param {string} attribute\n         *        Name of the attribute to remove.\n         *\n         * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}\n         */\n        removeAttribute(attribute) {\n            removeAttribute(this.el_, attribute);\n        }\n\n        /**\n         * Get or set the width of the component based upon the CSS styles.\n         * See {@link Component#dimension} for more detailed information.\n         *\n         * @param {number|string} [num]\n         *        The width that you want to set postfixed with '%', 'px' or nothing.\n         *\n         * @param {boolean} [skipListeners]\n         *        Skip the componentresize event trigger\n         *\n         * @return {number|string}\n         *         The width when getting, zero if there is no width. Can be a string\n         *           postpixed with '%' or 'px'.\n         */\n        width(num, skipListeners) {\n            return this.dimension('width', num, skipListeners);\n        }\n\n        /**\n         * Get or set the height of the component based upon the CSS styles.\n         * See {@link Component#dimension} for more detailed information.\n         *\n         * @param {number|string} [num]\n         *        The height that you want to set postfixed with '%', 'px' or nothing.\n         *\n         * @param {boolean} [skipListeners]\n         *        Skip the componentresize event trigger\n         *\n         * @return {number|string}\n         *         The width when getting, zero if there is no width. Can be a string\n         *         postpixed with '%' or 'px'.\n         */\n        height(num, skipListeners) {\n            return this.dimension('height', num, skipListeners);\n        }\n\n        /**\n         * Set both the width and height of the `Component` element at the same time.\n         *\n         * @param  {number|string} width\n         *         Width to set the `Component`s element to.\n         *\n         * @param  {number|string} height\n         *         Height to set the `Component`s element to.\n         */\n        dimensions(width, height) {\n            // Skip componentresize listeners on width for optimization\n            this.width(width, true);\n            this.height(height);\n        }\n\n        /**\n         * Get or set width or height of the `Component` element. This is the shared code\n         * for the {@link Component#width} and {@link Component#height}.\n         *\n         * Things to know:\n         * - If the width or height in an number this will return the number postfixed with 'px'.\n         * - If the width/height is a percent this will return the percent postfixed with '%'\n         * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function\n         *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.\n         *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}\n         *   for more information\n         * - If you want the computed style of the component, use {@link Component#currentWidth}\n         *   and {@link {Component#currentHeight}\n         *\n         * @fires Component#componentresize\n         *\n         * @param {string} widthOrHeight\n         8        'width' or 'height'\n         *\n         * @param  {number|string} [num]\n         8         New dimension\n         *\n         * @param  {boolean} [skipListeners]\n         *         Skip componentresize event trigger\n         *\n         * @return {number}\n         *         The dimension when getting or 0 if unset\n         */\n        dimension(widthOrHeight, num, skipListeners) {\n            if (num !== undefined) {\n                // Set to zero if null or literally NaN (NaN !== NaN)\n                if (num === null || num !== num) {\n                    num = 0;\n                }\n\n                // Check if using css width/height (% or px) and adjust\n                if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {\n                    this.el_.style[widthOrHeight] = num;\n                } else if (num === 'auto') {\n                    this.el_.style[widthOrHeight] = '';\n                } else {\n                    this.el_.style[widthOrHeight] = num + 'px';\n                }\n\n                // skipListeners allows us to avoid triggering the resize event when setting both width and height\n                if (!skipListeners) {\n                    /**\n                     * Triggered when a component is resized.\n                     *\n                     * @event Component#componentresize\n                     * @type {Event}\n                     */\n                    this.trigger('componentresize');\n                }\n                return;\n            }\n\n            // Not setting a value, so getting it\n            // Make sure element exists\n            if (!this.el_) {\n                return 0;\n            }\n\n            // Get dimension value from style\n            const val = this.el_.style[widthOrHeight];\n            const pxIndex = val.indexOf('px');\n            if (pxIndex !== -1) {\n                // Return the pixel value with no 'px'\n                return parseInt(val.slice(0, pxIndex), 10);\n            }\n\n            // No px so using % or no style was set, so falling back to offsetWidth/height\n            // If component has display:none, offset will return 0\n            // TODO: handle display:none and no dimension style using px\n            return parseInt(this.el_['offset' + toTitleCase$1(widthOrHeight)], 10);\n        }\n\n        /**\n         * Get the computed width or the height of the component's element.\n         *\n         * Uses `window.getComputedStyle`.\n         *\n         * @param {string} widthOrHeight\n         *        A string containing 'width' or 'height'. Whichever one you want to get.\n         *\n         * @return {number}\n         *         The dimension that gets asked for or 0 if nothing was set\n         *         for that dimension.\n         */\n        currentDimension(widthOrHeight) {\n            let computedWidthOrHeight = 0;\n            if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {\n                throw new Error('currentDimension only accepts width or height value');\n            }\n            computedWidthOrHeight = computedStyle(this.el_, widthOrHeight);\n\n            // remove 'px' from variable and parse as integer\n            computedWidthOrHeight = parseFloat(computedWidthOrHeight);\n\n            // if the computed value is still 0, it's possible that the browser is lying\n            // and we want to check the offset values.\n            // This code also runs wherever getComputedStyle doesn't exist.\n            if (computedWidthOrHeight === 0 || isNaN(computedWidthOrHeight)) {\n                const rule = `offset${toTitleCase$1(widthOrHeight)}`;\n                computedWidthOrHeight = this.el_[rule];\n            }\n            return computedWidthOrHeight;\n        }\n\n        /**\n         * An object that contains width and height values of the `Component`s\n         * computed style. Uses `window.getComputedStyle`.\n         *\n         * @typedef {Object} Component~DimensionObject\n         *\n         * @property {number} width\n         *           The width of the `Component`s computed style.\n         *\n         * @property {number} height\n         *           The height of the `Component`s computed style.\n         */\n\n        /**\n         * Get an object that contains computed width and height values of the\n         * component's element.\n         *\n         * Uses `window.getComputedStyle`.\n         *\n         * @return {Component~DimensionObject}\n         *         The computed dimensions of the component's element.\n         */\n        currentDimensions() {\n            return {\n                width: this.currentDimension('width'),\n                height: this.currentDimension('height')\n            };\n        }\n\n        /**\n         * Get the computed width of the component's element.\n         *\n         * Uses `window.getComputedStyle`.\n         *\n         * @return {number}\n         *         The computed width of the component's element.\n         */\n        currentWidth() {\n            return this.currentDimension('width');\n        }\n\n        /**\n         * Get the computed height of the component's element.\n         *\n         * Uses `window.getComputedStyle`.\n         *\n         * @return {number}\n         *         The computed height of the component's element.\n         */\n        currentHeight() {\n            return this.currentDimension('height');\n        }\n\n        /**\n         * Set the focus to this component\n         */\n        focus() {\n            this.el_.focus();\n        }\n\n        /**\n         * Remove the focus from this component\n         */\n        blur() {\n            this.el_.blur();\n        }\n\n        /**\n         * When this Component receives a `keydown` event which it does not process,\n         *  it passes the event to the Player for handling.\n         *\n         * @param {KeyboardEvent} event\n         *        The `keydown` event that caused this function to be called.\n         */\n        handleKeyDown(event) {\n            if (this.player_) {\n                // We only stop propagation here because we want unhandled events to fall\n                // back to the browser. Exclude Tab for focus trapping.\n                if (!keycode.isEventKey(event, 'Tab')) {\n                    event.stopPropagation();\n                }\n                this.player_.handleKeyDown(event);\n            }\n        }\n\n        /**\n         * Many components used to have a `handleKeyPress` method, which was poorly\n         * named because it listened to a `keydown` event. This method name now\n         * delegates to `handleKeyDown`. This means anyone calling `handleKeyPress`\n         * will not see their method calls stop working.\n         *\n         * @param {Event} event\n         *        The event that caused this function to be called.\n         */\n        handleKeyPress(event) {\n            this.handleKeyDown(event);\n        }\n\n        /**\n         * Emit a 'tap' events when touch event support gets detected. This gets used to\n         * support toggling the controls through a tap on the video. They get enabled\n         * because every sub-component would have extra overhead otherwise.\n         *\n         * @private\n         * @fires Component#tap\n         * @listens Component#touchstart\n         * @listens Component#touchmove\n         * @listens Component#touchleave\n         * @listens Component#touchcancel\n         * @listens Component#touchend\n         */\n        emitTapEvents() {\n            // Track the start time so we can determine how long the touch lasted\n            let touchStart = 0;\n            let firstTouch = null;\n\n            // Maximum movement allowed during a touch event to still be considered a tap\n            // Other popular libs use anywhere from 2 (hammer.js) to 15,\n            // so 10 seems like a nice, round number.\n            const tapMovementThreshold = 10;\n\n            // The maximum length a touch can be while still being considered a tap\n            const touchTimeThreshold = 200;\n            let couldBeTap;\n            this.on('touchstart', function (event) {\n                // If more than one finger, don't consider treating this as a click\n                if (event.touches.length === 1) {\n                    // Copy pageX/pageY from the object\n                    firstTouch = {\n                        pageX: event.touches[0].pageX,\n                        pageY: event.touches[0].pageY\n                    };\n                    // Record start time so we can detect a tap vs. \"touch and hold\"\n                    touchStart = window.performance.now();\n                    // Reset couldBeTap tracking\n                    couldBeTap = true;\n                }\n            });\n            this.on('touchmove', function (event) {\n                // If more than one finger, don't consider treating this as a click\n                if (event.touches.length > 1) {\n                    couldBeTap = false;\n                } else if (firstTouch) {\n                    // Some devices will throw touchmoves for all but the slightest of taps.\n                    // So, if we moved only a small distance, this could still be a tap\n                    const xdiff = event.touches[0].pageX - firstTouch.pageX;\n                    const ydiff = event.touches[0].pageY - firstTouch.pageY;\n                    const touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n                    if (touchDistance > tapMovementThreshold) {\n                        couldBeTap = false;\n                    }\n                }\n            });\n            const noTap = function () {\n                couldBeTap = false;\n            };\n\n            // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s\n            this.on('touchleave', noTap);\n            this.on('touchcancel', noTap);\n\n            // When the touch ends, measure how long it took and trigger the appropriate\n            // event\n            this.on('touchend', function (event) {\n                firstTouch = null;\n                // Proceed only if the touchmove/leave/cancel event didn't happen\n                if (couldBeTap === true) {\n                    // Measure how long the touch lasted\n                    const touchTime = window.performance.now() - touchStart;\n\n                    // Make sure the touch was less than the threshold to be considered a tap\n                    if (touchTime < touchTimeThreshold) {\n                        // Don't let browser turn this into a click\n                        event.preventDefault();\n                        /**\n                         * Triggered when a `Component` is tapped.\n                         *\n                         * @event Component#tap\n                         * @type {MouseEvent}\n                         */\n                        this.trigger('tap');\n                        // It may be good to copy the touchend event object and change the\n                        // type to tap, if the other event properties aren't exact after\n                        // Events.fixEvent runs (e.g. event.target)\n                    }\n                }\n            });\n        }\n\n        /**\n         * This function reports user activity whenever touch events happen. This can get\n         * turned off by any sub-components that wants touch events to act another way.\n         *\n         * Report user touch activity when touch events occur. User activity gets used to\n         * determine when controls should show/hide. It is simple when it comes to mouse\n         * events, because any mouse event should show the controls. So we capture mouse\n         * events that bubble up to the player and report activity when that happens.\n         * With touch events it isn't as easy as `touchstart` and `touchend` toggle player\n         * controls. So touch events can't help us at the player level either.\n         *\n         * User activity gets checked asynchronously. So what could happen is a tap event\n         * on the video turns the controls off. Then the `touchend` event bubbles up to\n         * the player. Which, if it reported user activity, would turn the controls right\n         * back on. We also don't want to completely block touch events from bubbling up.\n         * Furthermore a `touchmove` event and anything other than a tap, should not turn\n         * controls back on.\n         *\n         * @listens Component#touchstart\n         * @listens Component#touchmove\n         * @listens Component#touchend\n         * @listens Component#touchcancel\n         */\n        enableTouchActivity() {\n            // Don't continue if the root player doesn't support reporting user activity\n            if (!this.player() || !this.player().reportUserActivity) {\n                return;\n            }\n\n            // listener for reporting that the user is active\n            const report = bind_(this.player(), this.player().reportUserActivity);\n            let touchHolding;\n            this.on('touchstart', function () {\n                report();\n                // For as long as the they are touching the device or have their mouse down,\n                // we consider them active even if they're not moving their finger or mouse.\n                // So we want to continue to update that they are active\n                this.clearInterval(touchHolding);\n                // report at the same interval as activityCheck\n                touchHolding = this.setInterval(report, 250);\n            });\n            const touchEnd = function (event) {\n                report();\n                // stop the interval that maintains activity if the touch is holding\n                this.clearInterval(touchHolding);\n            };\n            this.on('touchmove', report);\n            this.on('touchend', touchEnd);\n            this.on('touchcancel', touchEnd);\n        }\n\n        /**\n         * A callback that has no parameters and is bound into `Component`s context.\n         *\n         * @callback Component~GenericCallback\n         * @this Component\n         */\n\n        /**\n         * Creates a function that runs after an `x` millisecond timeout. This function is a\n         * wrapper around `window.setTimeout`. There are a few reasons to use this one\n         * instead though:\n         * 1. It gets cleared via  {@link Component#clearTimeout} when\n         *    {@link Component#dispose} gets called.\n         * 2. The function callback will gets turned into a {@link Component~GenericCallback}\n         *\n         * > Note: You can't use `window.clearTimeout` on the id returned by this function. This\n         *         will cause its dispose listener not to get cleaned up! Please use\n         *         {@link Component#clearTimeout} or {@link Component#dispose} instead.\n         *\n         * @param {Component~GenericCallback} fn\n         *        The function that will be run after `timeout`.\n         *\n         * @param {number} timeout\n         *        Timeout in milliseconds to delay before executing the specified function.\n         *\n         * @return {number}\n         *         Returns a timeout ID that gets used to identify the timeout. It can also\n         *         get used in {@link Component#clearTimeout} to clear the timeout that\n         *         was set.\n         *\n         * @listens Component#dispose\n         * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}\n         */\n        setTimeout(fn, timeout) {\n            // declare as variables so they are properly available in timeout function\n            // eslint-disable-next-line\n            var timeoutId;\n            fn = bind_(this, fn);\n            this.clearTimersOnDispose_();\n            timeoutId = window.setTimeout(() => {\n                if (this.setTimeoutIds_.has(timeoutId)) {\n                    this.setTimeoutIds_.delete(timeoutId);\n                }\n                fn();\n            }, timeout);\n            this.setTimeoutIds_.add(timeoutId);\n            return timeoutId;\n        }\n\n        /**\n         * Clears a timeout that gets created via `window.setTimeout` or\n         * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}\n         * use this function instead of `window.clearTimout`. If you don't your dispose\n         * listener will not get cleaned up until {@link Component#dispose}!\n         *\n         * @param {number} timeoutId\n         *        The id of the timeout to clear. The return value of\n         *        {@link Component#setTimeout} or `window.setTimeout`.\n         *\n         * @return {number}\n         *         Returns the timeout id that was cleared.\n         *\n         * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}\n         */\n        clearTimeout(timeoutId) {\n            if (this.setTimeoutIds_.has(timeoutId)) {\n                this.setTimeoutIds_.delete(timeoutId);\n                window.clearTimeout(timeoutId);\n            }\n            return timeoutId;\n        }\n\n        /**\n         * Creates a function that gets run every `x` milliseconds. This function is a wrapper\n         * around `window.setInterval`. There are a few reasons to use this one instead though.\n         * 1. It gets cleared via  {@link Component#clearInterval} when\n         *    {@link Component#dispose} gets called.\n         * 2. The function callback will be a {@link Component~GenericCallback}\n         *\n         * @param {Component~GenericCallback} fn\n         *        The function to run every `x` seconds.\n         *\n         * @param {number} interval\n         *        Execute the specified function every `x` milliseconds.\n         *\n         * @return {number}\n         *         Returns an id that can be used to identify the interval. It can also be be used in\n         *         {@link Component#clearInterval} to clear the interval.\n         *\n         * @listens Component#dispose\n         * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}\n         */\n        setInterval(fn, interval) {\n            fn = bind_(this, fn);\n            this.clearTimersOnDispose_();\n            const intervalId = window.setInterval(fn, interval);\n            this.setIntervalIds_.add(intervalId);\n            return intervalId;\n        }\n\n        /**\n         * Clears an interval that gets created via `window.setInterval` or\n         * {@link Component#setInterval}. If you set an interval via {@link Component#setInterval}\n         * use this function instead of `window.clearInterval`. If you don't your dispose\n         * listener will not get cleaned up until {@link Component#dispose}!\n         *\n         * @param {number} intervalId\n         *        The id of the interval to clear. The return value of\n         *        {@link Component#setInterval} or `window.setInterval`.\n         *\n         * @return {number}\n         *         Returns the interval id that was cleared.\n         *\n         * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}\n         */\n        clearInterval(intervalId) {\n            if (this.setIntervalIds_.has(intervalId)) {\n                this.setIntervalIds_.delete(intervalId);\n                window.clearInterval(intervalId);\n            }\n            return intervalId;\n        }\n\n        /**\n         * Queues up a callback to be passed to requestAnimationFrame (rAF), but\n         * with a few extra bonuses:\n         *\n         * - Supports browsers that do not support rAF by falling back to\n         *   {@link Component#setTimeout}.\n         *\n         * - The callback is turned into a {@link Component~GenericCallback} (i.e.\n         *   bound to the component).\n         *\n         * - Automatic cancellation of the rAF callback is handled if the component\n         *   is disposed before it is called.\n         *\n         * @param  {Component~GenericCallback} fn\n         *         A function that will be bound to this component and executed just\n         *         before the browser's next repaint.\n         *\n         * @return {number}\n         *         Returns an rAF ID that gets used to identify the timeout. It can\n         *         also be used in {@link Component#cancelAnimationFrame} to cancel\n         *         the animation frame callback.\n         *\n         * @listens Component#dispose\n         * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}\n         */\n        requestAnimationFrame(fn) {\n            this.clearTimersOnDispose_();\n\n            // declare as variables so they are properly available in rAF function\n            // eslint-disable-next-line\n            var id;\n            fn = bind_(this, fn);\n            id = window.requestAnimationFrame(() => {\n                if (this.rafIds_.has(id)) {\n                    this.rafIds_.delete(id);\n                }\n                fn();\n            });\n            this.rafIds_.add(id);\n            return id;\n        }\n\n        /**\n         * Request an animation frame, but only one named animation\n         * frame will be queued. Another will never be added until\n         * the previous one finishes.\n         *\n         * @param {string} name\n         *        The name to give this requestAnimationFrame\n         *\n         * @param  {Component~GenericCallback} fn\n         *         A function that will be bound to this component and executed just\n         *         before the browser's next repaint.\n         */\n        requestNamedAnimationFrame(name, fn) {\n            if (this.namedRafs_.has(name)) {\n                return;\n            }\n            this.clearTimersOnDispose_();\n            fn = bind_(this, fn);\n            const id = this.requestAnimationFrame(() => {\n                fn();\n                if (this.namedRafs_.has(name)) {\n                    this.namedRafs_.delete(name);\n                }\n            });\n            this.namedRafs_.set(name, id);\n            return name;\n        }\n\n        /**\n         * Cancels a current named animation frame if it exists.\n         *\n         * @param {string} name\n         *        The name of the requestAnimationFrame to cancel.\n         */\n        cancelNamedAnimationFrame(name) {\n            if (!this.namedRafs_.has(name)) {\n                return;\n            }\n            this.cancelAnimationFrame(this.namedRafs_.get(name));\n            this.namedRafs_.delete(name);\n        }\n\n        /**\n         * Cancels a queued callback passed to {@link Component#requestAnimationFrame}\n         * (rAF).\n         *\n         * If you queue an rAF callback via {@link Component#requestAnimationFrame},\n         * use this function instead of `window.cancelAnimationFrame`. If you don't,\n         * your dispose listener will not get cleaned up until {@link Component#dispose}!\n         *\n         * @param {number} id\n         *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.\n         *\n         * @return {number}\n         *         Returns the rAF ID that was cleared.\n         *\n         * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}\n         */\n        cancelAnimationFrame(id) {\n            if (this.rafIds_.has(id)) {\n                this.rafIds_.delete(id);\n                window.cancelAnimationFrame(id);\n            }\n            return id;\n        }\n\n        /**\n         * A function to setup `requestAnimationFrame`, `setTimeout`,\n         * and `setInterval`, clearing on dispose.\n         *\n         * > Previously each timer added and removed dispose listeners on it's own.\n         * For better performance it was decided to batch them all, and use `Set`s\n         * to track outstanding timer ids.\n         *\n         * @private\n         */\n        clearTimersOnDispose_() {\n            if (this.clearingTimersOnDispose_) {\n                return;\n            }\n            this.clearingTimersOnDispose_ = true;\n            this.one('dispose', () => {\n                [['namedRafs_', 'cancelNamedAnimationFrame'], ['rafIds_', 'cancelAnimationFrame'], ['setTimeoutIds_', 'clearTimeout'], ['setIntervalIds_', 'clearInterval']].forEach(([idName, cancelName]) => {\n                    // for a `Set` key will actually be the value again\n                    // so forEach((val, val) =>` but for maps we want to use\n                    // the key.\n                    this[idName].forEach((val, key) => this[cancelName](key));\n                });\n                this.clearingTimersOnDispose_ = false;\n            });\n        }\n\n        /**\n         * Register a `Component` with `videojs` given the name and the component.\n         *\n         * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s\n         *         should be registered using {@link Tech.registerTech} or\n         *         {@link videojs:videojs.registerTech}.\n         *\n         * > NOTE: This function can also be seen on videojs as\n         *         {@link videojs:videojs.registerComponent}.\n         *\n         * @param {string} name\n         *        The name of the `Component` to register.\n         *\n         * @param {Component} ComponentToRegister\n         *        The `Component` class to register.\n         *\n         * @return {Component}\n         *         The `Component` that was registered.\n         */\n        static registerComponent(name, ComponentToRegister) {\n            if (typeof name !== 'string' || !name) {\n                throw new Error(`Illegal component name, \"${name}\"; must be a non-empty string.`);\n            }\n            const Tech = Component$1.getComponent('Tech');\n\n            // We need to make sure this check is only done if Tech has been registered.\n            const isTech = Tech && Tech.isTech(ComponentToRegister);\n            const isComp = Component$1 === ComponentToRegister || Component$1.prototype.isPrototypeOf(ComponentToRegister.prototype);\n            if (isTech || !isComp) {\n                let reason;\n                if (isTech) {\n                    reason = 'techs must be registered using Tech.registerTech()';\n                } else {\n                    reason = 'must be a Component subclass';\n                }\n                throw new Error(`Illegal component, \"${name}\"; ${reason}.`);\n            }\n            name = toTitleCase$1(name);\n            if (!Component$1.components_) {\n                Component$1.components_ = {};\n            }\n            const Player = Component$1.getComponent('Player');\n            if (name === 'Player' && Player && Player.players) {\n                const players = Player.players;\n                const playerNames = Object.keys(players);\n\n                // If we have players that were disposed, then their name will still be\n                // in Players.players. So, we must loop through and verify that the value\n                // for each item is not null. This allows registration of the Player component\n                // after all players have been disposed or before any were created.\n                if (players && playerNames.length > 0 && playerNames.map(pname => players[pname]).every(Boolean)) {\n                    throw new Error('Can not register Player component after player has been created.');\n                }\n            }\n            Component$1.components_[name] = ComponentToRegister;\n            Component$1.components_[toLowerCase(name)] = ComponentToRegister;\n            return ComponentToRegister;\n        }\n\n        /**\n         * Get a `Component` based on the name it was registered with.\n         *\n         * @param {string} name\n         *        The Name of the component to get.\n         *\n         * @return {Component}\n         *         The `Component` that got registered under the given name.\n         */\n        static getComponent(name) {\n            if (!name || !Component$1.components_) {\n                return;\n            }\n            return Component$1.components_[name];\n        }\n    }\n    Component$1.registerComponent('Component', Component$1);\n\n    /**\n     * @file time.js\n     * @module time\n     */\n\n    /**\n     * Returns the time for the specified index at the start or end\n     * of a TimeRange object.\n     *\n     * @typedef    {Function} TimeRangeIndex\n     *\n     * @param      {number} [index=0]\n     *             The range number to return the time for.\n     *\n     * @return     {number}\n     *             The time offset at the specified index.\n     *\n     * @deprecated The index argument must be provided.\n     *             In the future, leaving it out will throw an error.\n     */\n\n    /**\n     * An object that contains ranges of time, which mimics {@link TimeRanges}.\n     *\n     * @typedef  {Object} TimeRange\n     *\n     * @property {number} length\n     *           The number of time ranges represented by this object.\n     *\n     * @property {module:time~TimeRangeIndex} start\n     *           Returns the time offset at which a specified time range begins.\n     *\n     * @property {module:time~TimeRangeIndex} end\n     *           Returns the time offset at which a specified time range ends.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges\n     */\n\n    /**\n     * Check if any of the time ranges are over the maximum index.\n     *\n     * @private\n     * @param   {string} fnName\n     *          The function name to use for logging\n     *\n     * @param   {number} index\n     *          The index to check\n     *\n     * @param   {number} maxIndex\n     *          The maximum possible index\n     *\n     * @throws  {Error} if the timeRanges provided are over the maxIndex\n     */\n    function rangeCheck(fnName, index, maxIndex) {\n        if (typeof index !== 'number' || index < 0 || index > maxIndex) {\n            throw new Error(`Failed to execute '${fnName}' on 'TimeRanges': The index provided (${index}) is non-numeric or out of bounds (0-${maxIndex}).`);\n        }\n    }\n\n    /**\n     * Get the time for the specified index at the start or end\n     * of a TimeRange object.\n     *\n     * @private\n     * @param      {string} fnName\n     *             The function name to use for logging\n     *\n     * @param      {string} valueIndex\n     *             The property that should be used to get the time. should be\n     *             'start' or 'end'\n     *\n     * @param      {Array} ranges\n     *             An array of time ranges\n     *\n     * @param      {Array} [rangeIndex=0]\n     *             The index to start the search at\n     *\n     * @return     {number}\n     *             The time that offset at the specified index.\n     *\n     * @deprecated rangeIndex must be set to a value, in the future this will throw an error.\n     * @throws     {Error} if rangeIndex is more than the length of ranges\n     */\n    function getRange(fnName, valueIndex, ranges, rangeIndex) {\n        rangeCheck(fnName, rangeIndex, ranges.length - 1);\n        return ranges[rangeIndex][valueIndex];\n    }\n\n    /**\n     * Create a time range object given ranges of time.\n     *\n     * @private\n     * @param   {Array} [ranges]\n     *          An array of time ranges.\n     *\n     * @return  {TimeRange}\n     */\n    function createTimeRangesObj(ranges) {\n        let timeRangesObj;\n        if (ranges === undefined || ranges.length === 0) {\n            timeRangesObj = {\n                length: 0,\n                start() {\n                    throw new Error('This TimeRanges object is empty');\n                },\n                end() {\n                    throw new Error('This TimeRanges object is empty');\n                }\n            };\n        } else {\n            timeRangesObj = {\n                length: ranges.length,\n                start: getRange.bind(null, 'start', 0, ranges),\n                end: getRange.bind(null, 'end', 1, ranges)\n            };\n        }\n        if (window.Symbol && window.Symbol.iterator) {\n            timeRangesObj[window.Symbol.iterator] = () => (ranges || []).values();\n        }\n        return timeRangesObj;\n    }\n\n    /**\n     * Create a `TimeRange` object which mimics an\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges|HTML5 TimeRanges instance}.\n     *\n     * @param {number|Array[]} start\n     *        The start of a single range (a number) or an array of ranges (an\n     *        array of arrays of two numbers each).\n     *\n     * @param {number} end\n     *        The end of a single range. Cannot be used with the array form of\n     *        the `start` argument.\n     *\n     * @return {TimeRange}\n     */\n    function createTimeRanges$1(start, end) {\n        if (Array.isArray(start)) {\n            return createTimeRangesObj(start);\n        } else if (start === undefined || end === undefined) {\n            return createTimeRangesObj();\n        }\n        return createTimeRangesObj([[start, end]]);\n    }\n\n    /**\n     * Format seconds as a time string, H:MM:SS or M:SS. Supplying a guide (in\n     * seconds) will force a number of leading zeros to cover the length of the\n     * guide.\n     *\n     * @private\n     * @param  {number} seconds\n     *         Number of seconds to be turned into a string\n     *\n     * @param  {number} guide\n     *         Number (in seconds) to model the string after\n     *\n     * @return {string}\n     *         Time formatted as H:MM:SS or M:SS\n     */\n    const defaultImplementation = function (seconds, guide) {\n        seconds = seconds < 0 ? 0 : seconds;\n        let s = Math.floor(seconds % 60);\n        let m = Math.floor(seconds / 60 % 60);\n        let h = Math.floor(seconds / 3600);\n        const gm = Math.floor(guide / 60 % 60);\n        const gh = Math.floor(guide / 3600);\n\n        // handle invalid times\n        if (isNaN(seconds) || seconds === Infinity) {\n            // '-' is false for all relational operators (e.g. <, >=) so this setting\n            // will add the minimum number of fields specified by the guide\n            h = m = s = '-';\n        }\n\n        // Check if we need to show hours\n        h = h > 0 || gh > 0 ? h + ':' : '';\n\n        // If hours are showing, we may need to add a leading zero.\n        // Always show at least one digit of minutes.\n        m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';\n\n        // Check if leading zero is need for seconds\n        s = s < 10 ? '0' + s : s;\n        return h + m + s;\n    };\n\n    // Internal pointer to the current implementation.\n    let implementation = defaultImplementation;\n\n    /**\n     * Replaces the default formatTime implementation with a custom implementation.\n     *\n     * @param {Function} customImplementation\n     *        A function which will be used in place of the default formatTime\n     *        implementation. Will receive the current time in seconds and the\n     *        guide (in seconds) as arguments.\n     */\n    function setFormatTime(customImplementation) {\n        implementation = customImplementation;\n    }\n\n    /**\n     * Resets formatTime to the default implementation.\n     */\n    function resetFormatTime() {\n        implementation = defaultImplementation;\n    }\n\n    /**\n     * Delegates to either the default time formatting function or a custom\n     * function supplied via `setFormatTime`.\n     *\n     * Formats seconds as a time string (H:MM:SS or M:SS). Supplying a\n     * guide (in seconds) will force a number of leading zeros to cover the\n     * length of the guide.\n     *\n     * @example  formatTime(125, 600) === \"02:05\"\n     * @param    {number} seconds\n     *           Number of seconds to be turned into a string\n     *\n     * @param    {number} guide\n     *           Number (in seconds) to model the string after\n     *\n     * @return   {string}\n     *           Time formatted as H:MM:SS or M:SS\n     */\n    function formatTime(seconds, guide = seconds) {\n        return implementation(seconds, guide);\n    }\n\n    var Time = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        createTimeRanges: createTimeRanges$1,\n        createTimeRange: createTimeRanges$1,\n        setFormatTime: setFormatTime,\n        resetFormatTime: resetFormatTime,\n        formatTime: formatTime\n    });\n\n    /**\n     * @file buffer.js\n     * @module buffer\n     */\n\n    /**\n     * Compute the percentage of the media that has been buffered.\n     *\n     * @param { import('./time').TimeRange } buffered\n     *        The current `TimeRanges` object representing buffered time ranges\n     *\n     * @param {number} duration\n     *        Total duration of the media\n     *\n     * @return {number}\n     *         Percent buffered of the total duration in decimal form.\n     */\n    function bufferedPercent(buffered, duration) {\n        let bufferedDuration = 0;\n        let start;\n        let end;\n        if (!duration) {\n            return 0;\n        }\n        if (!buffered || !buffered.length) {\n            buffered = createTimeRanges$1(0, 0);\n        }\n        for (let i = 0; i < buffered.length; i++) {\n            start = buffered.start(i);\n            end = buffered.end(i);\n\n            // buffered end can be bigger than duration by a very small fraction\n            if (end > duration) {\n                end = duration;\n            }\n            bufferedDuration += end - start;\n        }\n        return bufferedDuration / duration;\n    }\n\n    /**\n     * @file media-error.js\n     */\n\n    /**\n     * A Custom `MediaError` class which mimics the standard HTML5 `MediaError` class.\n     *\n     * @param {number|string|Object|MediaError} value\n     *        This can be of multiple types:\n     *        - number: should be a standard error code\n     *        - string: an error message (the code will be 0)\n     *        - Object: arbitrary properties\n     *        - `MediaError` (native): used to populate a video.js `MediaError` object\n     *        - `MediaError` (video.js): will return itself if it's already a\n     *          video.js `MediaError` object.\n     *\n     * @see [MediaError Spec]{@link https://dev.w3.org/html5/spec-author-view/video.html#mediaerror}\n     * @see [Encrypted MediaError Spec]{@link https://www.w3.org/TR/2013/WD-encrypted-media-20130510/#error-codes}\n     *\n     * @class MediaError\n     */\n    function MediaError(value) {\n        // Allow redundant calls to this constructor to avoid having `instanceof`\n        // checks peppered around the code.\n        if (value instanceof MediaError) {\n            return value;\n        }\n        if (typeof value === 'number') {\n            this.code = value;\n        } else if (typeof value === 'string') {\n            // default code is zero, so this is a custom error\n            this.message = value;\n        } else if (isObject$1(value)) {\n            // We assign the `code` property manually because native `MediaError` objects\n            // do not expose it as an own/enumerable property of the object.\n            if (typeof value.code === 'number') {\n                this.code = value.code;\n            }\n            Object.assign(this, value);\n        }\n        if (!this.message) {\n            this.message = MediaError.defaultMessages[this.code] || '';\n        }\n    }\n\n    /**\n     * The error code that refers two one of the defined `MediaError` types\n     *\n     * @type {Number}\n     */\n    MediaError.prototype.code = 0;\n\n    /**\n     * An optional message that to show with the error. Message is not part of the HTML5\n     * video spec but allows for more informative custom errors.\n     *\n     * @type {String}\n     */\n    MediaError.prototype.message = '';\n\n    /**\n     * An optional status code that can be set by plugins to allow even more detail about\n     * the error. For example a plugin might provide a specific HTTP status code and an\n     * error message for that code. Then when the plugin gets that error this class will\n     * know how to display an error message for it. This allows a custom message to show\n     * up on the `Player` error overlay.\n     *\n     * @type {Array}\n     */\n    MediaError.prototype.status = null;\n\n    /**\n     * Errors indexed by the W3C standard. The order **CANNOT CHANGE**! See the\n     * specification listed under {@link MediaError} for more information.\n     *\n     * @enum {array}\n     * @readonly\n     * @property {string} 0 - MEDIA_ERR_CUSTOM\n     * @property {string} 1 - MEDIA_ERR_ABORTED\n     * @property {string} 2 - MEDIA_ERR_NETWORK\n     * @property {string} 3 - MEDIA_ERR_DECODE\n     * @property {string} 4 - MEDIA_ERR_SRC_NOT_SUPPORTED\n     * @property {string} 5 - MEDIA_ERR_ENCRYPTED\n     */\n    MediaError.errorTypes = ['MEDIA_ERR_CUSTOM', 'MEDIA_ERR_ABORTED', 'MEDIA_ERR_NETWORK', 'MEDIA_ERR_DECODE', 'MEDIA_ERR_SRC_NOT_SUPPORTED', 'MEDIA_ERR_ENCRYPTED'];\n\n    /**\n     * The default `MediaError` messages based on the {@link MediaError.errorTypes}.\n     *\n     * @type {Array}\n     * @constant\n     */\n    MediaError.defaultMessages = {\n        1: 'You aborted the media playback',\n        2: 'A network error caused the media download to fail part-way.',\n        3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',\n        4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',\n        5: 'The media is encrypted and we do not have the keys to decrypt it.'\n    };\n\n    // Add types as properties on MediaError\n    // e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;\n    for (let errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {\n        MediaError[MediaError.errorTypes[errNum]] = errNum;\n        // values should be accessible on both the class and instance\n        MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;\n    }\n\n    var tuple = SafeParseTuple;\n    function SafeParseTuple(obj, reviver) {\n        var json;\n        var error = null;\n        try {\n            json = JSON.parse(obj, reviver);\n        } catch (err) {\n            error = err;\n        }\n        return [error, json];\n    }\n\n    /**\n     * Returns whether an object is `Promise`-like (i.e. has a `then` method).\n     *\n     * @param  {Object}  value\n     *         An object that may or may not be `Promise`-like.\n     *\n     * @return {boolean}\n     *         Whether or not the object is `Promise`-like.\n     */\n    function isPromise(value) {\n        return value !== undefined && value !== null && typeof value.then === 'function';\n    }\n\n    /**\n     * Silence a Promise-like object.\n     *\n     * This is useful for avoiding non-harmful, but potentially confusing \"uncaught\n     * play promise\" rejection error messages.\n     *\n     * @param  {Object} value\n     *         An object that may or may not be `Promise`-like.\n     */\n    function silencePromise(value) {\n        if (isPromise(value)) {\n            value.then(null, e => {});\n        }\n    }\n\n    /**\n     * @file text-track-list-converter.js Utilities for capturing text track state and\n     * re-creating tracks based on a capture.\n     *\n     * @module text-track-list-converter\n     */\n\n    /**\n     * Examine a single {@link TextTrack} and return a JSON-compatible javascript object that\n     * represents the {@link TextTrack}'s state.\n     *\n     * @param {TextTrack} track\n     *        The text track to query.\n     *\n     * @return {Object}\n     *         A serializable javascript representation of the TextTrack.\n     * @private\n     */\n    const trackToJson_ = function (track) {\n        const ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce((acc, prop, i) => {\n            if (track[prop]) {\n                acc[prop] = track[prop];\n            }\n            return acc;\n        }, {\n            cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {\n                return {\n                    startTime: cue.startTime,\n                    endTime: cue.endTime,\n                    text: cue.text,\n                    id: cue.id\n                };\n            })\n        });\n        return ret;\n    };\n\n    /**\n     * Examine a {@link Tech} and return a JSON-compatible javascript array that represents the\n     * state of all {@link TextTrack}s currently configured. The return array is compatible with\n     * {@link text-track-list-converter:jsonToTextTracks}.\n     *\n     * @param { import('../tech/tech').default } tech\n     *        The tech object to query\n     *\n     * @return {Array}\n     *         A serializable javascript representation of the {@link Tech}s\n     *         {@link TextTrackList}.\n     */\n    const textTracksToJson = function (tech) {\n        const trackEls = tech.$$('track');\n        const trackObjs = Array.prototype.map.call(trackEls, t => t.track);\n        const tracks = Array.prototype.map.call(trackEls, function (trackEl) {\n            const json = trackToJson_(trackEl.track);\n            if (trackEl.src) {\n                json.src = trackEl.src;\n            }\n            return json;\n        });\n        return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {\n            return trackObjs.indexOf(track) === -1;\n        }).map(trackToJson_));\n    };\n\n    /**\n     * Create a set of remote {@link TextTrack}s on a {@link Tech} based on an array of javascript\n     * object {@link TextTrack} representations.\n     *\n     * @param {Array} json\n     *        An array of `TextTrack` representation objects, like those that would be\n     *        produced by `textTracksToJson`.\n     *\n     * @param {Tech} tech\n     *        The `Tech` to create the `TextTrack`s on.\n     */\n    const jsonToTextTracks = function (json, tech) {\n        json.forEach(function (track) {\n            const addedTrack = tech.addRemoteTextTrack(track).track;\n            if (!track.src && track.cues) {\n                track.cues.forEach(cue => addedTrack.addCue(cue));\n            }\n        });\n        return tech.textTracks();\n    };\n    var textTrackConverter = {\n        textTracksToJson,\n        jsonToTextTracks,\n        trackToJson_\n    };\n\n    /**\n     * @file modal-dialog.js\n     */\n    const MODAL_CLASS_NAME = 'vjs-modal-dialog';\n\n    /**\n     * The `ModalDialog` displays over the video and its controls, which blocks\n     * interaction with the player until it is closed.\n     *\n     * Modal dialogs include a \"Close\" button and will close when that button\n     * is activated - or when ESC is pressed anywhere.\n     *\n     * @extends Component\n     */\n    class ModalDialog extends Component$1 {\n        /**\n         * Create an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param { import('./utils/dom').ContentDescriptor} [options.content=undefined]\n         *        Provide customized content for this modal.\n         *\n         * @param {string} [options.description]\n         *        A text description for the modal, primarily for accessibility.\n         *\n         * @param {boolean} [options.fillAlways=false]\n         *        Normally, modals are automatically filled only the first time\n         *        they open. This tells the modal to refresh its content\n         *        every time it opens.\n         *\n         * @param {string} [options.label]\n         *        A text label for the modal, primarily for accessibility.\n         *\n         * @param {boolean} [options.pauseOnOpen=true]\n         *        If `true`, playback will will be paused if playing when\n         *        the modal opens, and resumed when it closes.\n         *\n         * @param {boolean} [options.temporary=true]\n         *        If `true`, the modal can only be opened once; it will be\n         *        disposed as soon as it's closed.\n         *\n         * @param {boolean} [options.uncloseable=false]\n         *        If `true`, the user will not be able to close the modal\n         *        through the UI in the normal ways. Programmatic closing is\n         *        still possible.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.handleKeyDown_ = e => this.handleKeyDown(e);\n            this.close_ = e => this.close(e);\n            this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = false;\n            this.closeable(!this.options_.uncloseable);\n            this.content(this.options_.content);\n\n            // Make sure the contentEl is defined AFTER any children are initialized\n            // because we only want the contents of the modal in the contentEl\n            // (not the UI elements like the close button).\n            this.contentEl_ = createEl('div', {\n                className: `${MODAL_CLASS_NAME}-content`\n            }, {\n                role: 'document'\n            });\n            this.descEl_ = createEl('p', {\n                className: `${MODAL_CLASS_NAME}-description vjs-control-text`,\n                id: this.el().getAttribute('aria-describedby')\n            });\n            textContent(this.descEl_, this.description());\n            this.el_.appendChild(this.descEl_);\n            this.el_.appendChild(this.contentEl_);\n        }\n\n        /**\n         * Create the `ModalDialog`'s DOM element\n         *\n         * @return {Element}\n         *         The DOM element that gets created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: this.buildCSSClass(),\n                tabIndex: -1\n            }, {\n                'aria-describedby': `${this.id()}_description`,\n                'aria-hidden': 'true',\n                'aria-label': this.label(),\n                'role': 'dialog'\n            });\n        }\n        dispose() {\n            this.contentEl_ = null;\n            this.descEl_ = null;\n            this.previouslyActiveEl_ = null;\n            super.dispose();\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `${MODAL_CLASS_NAME} vjs-hidden ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Returns the label string for this modal. Primarily used for accessibility.\n         *\n         * @return {string}\n         *         the localized or raw label of this modal.\n         */\n        label() {\n            return this.localize(this.options_.label || 'Modal Window');\n        }\n\n        /**\n         * Returns the description string for this modal. Primarily used for\n         * accessibility.\n         *\n         * @return {string}\n         *         The localized or raw description of this modal.\n         */\n        description() {\n            let desc = this.options_.description || this.localize('This is a modal window.');\n\n            // Append a universal closeability message if the modal is closeable.\n            if (this.closeable()) {\n                desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');\n            }\n            return desc;\n        }\n\n        /**\n         * Opens the modal.\n         *\n         * @fires ModalDialog#beforemodalopen\n         * @fires ModalDialog#modalopen\n         */\n        open() {\n            if (!this.opened_) {\n                const player = this.player();\n\n                /**\n                 * Fired just before a `ModalDialog` is opened.\n                 *\n                 * @event ModalDialog#beforemodalopen\n                 * @type {Event}\n                 */\n                this.trigger('beforemodalopen');\n                this.opened_ = true;\n\n                // Fill content if the modal has never opened before and\n                // never been filled.\n                if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {\n                    this.fill();\n                }\n\n                // If the player was playing, pause it and take note of its previously\n                // playing state.\n                this.wasPlaying_ = !player.paused();\n                if (this.options_.pauseOnOpen && this.wasPlaying_) {\n                    player.pause();\n                }\n                this.on('keydown', this.handleKeyDown_);\n\n                // Hide controls and note if they were enabled.\n                this.hadControls_ = player.controls();\n                player.controls(false);\n                this.show();\n                this.conditionalFocus_();\n                this.el().setAttribute('aria-hidden', 'false');\n\n                /**\n                 * Fired just after a `ModalDialog` is opened.\n                 *\n                 * @event ModalDialog#modalopen\n                 * @type {Event}\n                 */\n                this.trigger('modalopen');\n                this.hasBeenOpened_ = true;\n            }\n        }\n\n        /**\n         * If the `ModalDialog` is currently open or closed.\n         *\n         * @param  {boolean} [value]\n         *         If given, it will open (`true`) or close (`false`) the modal.\n         *\n         * @return {boolean}\n         *         the current open state of the modaldialog\n         */\n        opened(value) {\n            if (typeof value === 'boolean') {\n                this[value ? 'open' : 'close']();\n            }\n            return this.opened_;\n        }\n\n        /**\n         * Closes the modal, does nothing if the `ModalDialog` is\n         * not open.\n         *\n         * @fires ModalDialog#beforemodalclose\n         * @fires ModalDialog#modalclose\n         */\n        close() {\n            if (!this.opened_) {\n                return;\n            }\n            const player = this.player();\n\n            /**\n             * Fired just before a `ModalDialog` is closed.\n             *\n             * @event ModalDialog#beforemodalclose\n             * @type {Event}\n             */\n            this.trigger('beforemodalclose');\n            this.opened_ = false;\n            if (this.wasPlaying_ && this.options_.pauseOnOpen) {\n                player.play();\n            }\n            this.off('keydown', this.handleKeyDown_);\n            if (this.hadControls_) {\n                player.controls(true);\n            }\n            this.hide();\n            this.el().setAttribute('aria-hidden', 'true');\n\n            /**\n             * Fired just after a `ModalDialog` is closed.\n             *\n             * @event ModalDialog#modalclose\n             * @type {Event}\n             */\n            this.trigger('modalclose');\n            this.conditionalBlur_();\n            if (this.options_.temporary) {\n                this.dispose();\n            }\n        }\n\n        /**\n         * Check to see if the `ModalDialog` is closeable via the UI.\n         *\n         * @param  {boolean} [value]\n         *         If given as a boolean, it will set the `closeable` option.\n         *\n         * @return {boolean}\n         *         Returns the final value of the closable option.\n         */\n        closeable(value) {\n            if (typeof value === 'boolean') {\n                const closeable = this.closeable_ = !!value;\n                let close = this.getChild('closeButton');\n\n                // If this is being made closeable and has no close button, add one.\n                if (closeable && !close) {\n                    // The close button should be a child of the modal - not its\n                    // content element, so temporarily change the content element.\n                    const temp = this.contentEl_;\n                    this.contentEl_ = this.el_;\n                    close = this.addChild('closeButton', {\n                        controlText: 'Close Modal Dialog'\n                    });\n                    this.contentEl_ = temp;\n                    this.on(close, 'close', this.close_);\n                }\n\n                // If this is being made uncloseable and has a close button, remove it.\n                if (!closeable && close) {\n                    this.off(close, 'close', this.close_);\n                    this.removeChild(close);\n                    close.dispose();\n                }\n            }\n            return this.closeable_;\n        }\n\n        /**\n         * Fill the modal's content element with the modal's \"content\" option.\n         * The content element will be emptied before this change takes place.\n         */\n        fill() {\n            this.fillWith(this.content());\n        }\n\n        /**\n         * Fill the modal's content element with arbitrary content.\n         * The content element will be emptied before this change takes place.\n         *\n         * @fires ModalDialog#beforemodalfill\n         * @fires ModalDialog#modalfill\n         *\n         * @param { import('./utils/dom').ContentDescriptor} [content]\n         *        The same rules apply to this as apply to the `content` option.\n         */\n        fillWith(content) {\n            const contentEl = this.contentEl();\n            const parentEl = contentEl.parentNode;\n            const nextSiblingEl = contentEl.nextSibling;\n\n            /**\n             * Fired just before a `ModalDialog` is filled with content.\n             *\n             * @event ModalDialog#beforemodalfill\n             * @type {Event}\n             */\n            this.trigger('beforemodalfill');\n            this.hasBeenFilled_ = true;\n\n            // Detach the content element from the DOM before performing\n            // manipulation to avoid modifying the live DOM multiple times.\n            parentEl.removeChild(contentEl);\n            this.empty();\n            insertContent(contentEl, content);\n            /**\n             * Fired just after a `ModalDialog` is filled with content.\n             *\n             * @event ModalDialog#modalfill\n             * @type {Event}\n             */\n            this.trigger('modalfill');\n\n            // Re-inject the re-filled content element.\n            if (nextSiblingEl) {\n                parentEl.insertBefore(contentEl, nextSiblingEl);\n            } else {\n                parentEl.appendChild(contentEl);\n            }\n\n            // make sure that the close button is last in the dialog DOM\n            const closeButton = this.getChild('closeButton');\n            if (closeButton) {\n                parentEl.appendChild(closeButton.el_);\n            }\n        }\n\n        /**\n         * Empties the content element. This happens anytime the modal is filled.\n         *\n         * @fires ModalDialog#beforemodalempty\n         * @fires ModalDialog#modalempty\n         */\n        empty() {\n            /**\n             * Fired just before a `ModalDialog` is emptied.\n             *\n             * @event ModalDialog#beforemodalempty\n             * @type {Event}\n             */\n            this.trigger('beforemodalempty');\n            emptyEl(this.contentEl());\n\n            /**\n             * Fired just after a `ModalDialog` is emptied.\n             *\n             * @event ModalDialog#modalempty\n             * @type {Event}\n             */\n            this.trigger('modalempty');\n        }\n\n        /**\n         * Gets or sets the modal content, which gets normalized before being\n         * rendered into the DOM.\n         *\n         * This does not update the DOM or fill the modal, but it is called during\n         * that process.\n         *\n         * @param  { import('./utils/dom').ContentDescriptor} [value]\n         *         If defined, sets the internal content value to be used on the\n         *         next call(s) to `fill`. This value is normalized before being\n         *         inserted. To \"clear\" the internal content value, pass `null`.\n         *\n         * @return { import('./utils/dom').ContentDescriptor}\n         *         The current content of the modal dialog\n         */\n        content(value) {\n            if (typeof value !== 'undefined') {\n                this.content_ = value;\n            }\n            return this.content_;\n        }\n\n        /**\n         * conditionally focus the modal dialog if focus was previously on the player.\n         *\n         * @private\n         */\n        conditionalFocus_() {\n            const activeEl = document.activeElement;\n            const playerEl = this.player_.el_;\n            this.previouslyActiveEl_ = null;\n            if (playerEl.contains(activeEl) || playerEl === activeEl) {\n                this.previouslyActiveEl_ = activeEl;\n                this.focus();\n            }\n        }\n\n        /**\n         * conditionally blur the element and refocus the last focused element\n         *\n         * @private\n         */\n        conditionalBlur_() {\n            if (this.previouslyActiveEl_) {\n                this.previouslyActiveEl_.focus();\n                this.previouslyActiveEl_ = null;\n            }\n        }\n\n        /**\n         * Keydown handler. Attached when modal is focused.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            // Do not allow keydowns to reach out of the modal dialog.\n            event.stopPropagation();\n            if (keycode.isEventKey(event, 'Escape') && this.closeable()) {\n                event.preventDefault();\n                this.close();\n                return;\n            }\n\n            // exit early if it isn't a tab key\n            if (!keycode.isEventKey(event, 'Tab')) {\n                return;\n            }\n            const focusableEls = this.focusableEls_();\n            const activeEl = this.el_.querySelector(':focus');\n            let focusIndex;\n            for (let i = 0; i < focusableEls.length; i++) {\n                if (activeEl === focusableEls[i]) {\n                    focusIndex = i;\n                    break;\n                }\n            }\n            if (document.activeElement === this.el_) {\n                focusIndex = 0;\n            }\n            if (event.shiftKey && focusIndex === 0) {\n                focusableEls[focusableEls.length - 1].focus();\n                event.preventDefault();\n            } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {\n                focusableEls[0].focus();\n                event.preventDefault();\n            }\n        }\n\n        /**\n         * get all focusable elements\n         *\n         * @private\n         */\n        focusableEls_() {\n            const allChildren = this.el_.querySelectorAll('*');\n            return Array.prototype.filter.call(allChildren, child => {\n                return (child instanceof window.HTMLAnchorElement || child instanceof window.HTMLAreaElement) && child.hasAttribute('href') || (child instanceof window.HTMLInputElement || child instanceof window.HTMLSelectElement || child instanceof window.HTMLTextAreaElement || child instanceof window.HTMLButtonElement) && !child.hasAttribute('disabled') || child instanceof window.HTMLIFrameElement || child instanceof window.HTMLObjectElement || child instanceof window.HTMLEmbedElement || child.hasAttribute('tabindex') && child.getAttribute('tabindex') !== -1 || child.hasAttribute('contenteditable');\n            });\n        }\n    }\n\n    /**\n     * Default options for `ModalDialog` default options.\n     *\n     * @type {Object}\n     * @private\n     */\n    ModalDialog.prototype.options_ = {\n        pauseOnOpen: true,\n        temporary: true\n    };\n    Component$1.registerComponent('ModalDialog', ModalDialog);\n\n    /**\n     * @file track-list.js\n     */\n\n    /**\n     * Common functionaliy between {@link TextTrackList}, {@link AudioTrackList}, and\n     * {@link VideoTrackList}\n     *\n     * @extends EventTarget\n     */\n    class TrackList extends EventTarget$2 {\n        /**\n         * Create an instance of this class\n         *\n         * @param { import('./track').default[] } tracks\n         *        A list of tracks to initialize the list with.\n         *\n         * @abstract\n         */\n        constructor(tracks = []) {\n            super();\n            this.tracks_ = [];\n\n            /**\n             * @memberof TrackList\n             * @member {number} length\n             *         The current number of `Track`s in the this Trackist.\n             * @instance\n             */\n            Object.defineProperty(this, 'length', {\n                get() {\n                    return this.tracks_.length;\n                }\n            });\n            for (let i = 0; i < tracks.length; i++) {\n                this.addTrack(tracks[i]);\n            }\n        }\n\n        /**\n         * Add a {@link Track} to the `TrackList`\n         *\n         * @param { import('./track').default } track\n         *        The audio, video, or text track to add to the list.\n         *\n         * @fires TrackList#addtrack\n         */\n        addTrack(track) {\n            const index = this.tracks_.length;\n            if (!('' + index in this)) {\n                Object.defineProperty(this, index, {\n                    get() {\n                        return this.tracks_[index];\n                    }\n                });\n            }\n\n            // Do not add duplicate tracks\n            if (this.tracks_.indexOf(track) === -1) {\n                this.tracks_.push(track);\n                /**\n                 * Triggered when a track is added to a track list.\n                 *\n                 * @event TrackList#addtrack\n                 * @type {Event}\n                 * @property {Track} track\n                 *           A reference to track that was added.\n                 */\n                this.trigger({\n                    track,\n                    type: 'addtrack',\n                    target: this\n                });\n            }\n\n            /**\n             * Triggered when a track label is changed.\n             *\n             * @event TrackList#addtrack\n             * @type {Event}\n             * @property {Track} track\n             *           A reference to track that was added.\n             */\n            track.labelchange_ = () => {\n                this.trigger({\n                    track,\n                    type: 'labelchange',\n                    target: this\n                });\n            };\n            if (isEvented(track)) {\n                track.addEventListener('labelchange', track.labelchange_);\n            }\n        }\n\n        /**\n         * Remove a {@link Track} from the `TrackList`\n         *\n         * @param { import('./track').default } rtrack\n         *        The audio, video, or text track to remove from the list.\n         *\n         * @fires TrackList#removetrack\n         */\n        removeTrack(rtrack) {\n            let track;\n            for (let i = 0, l = this.length; i < l; i++) {\n                if (this[i] === rtrack) {\n                    track = this[i];\n                    if (track.off) {\n                        track.off();\n                    }\n                    this.tracks_.splice(i, 1);\n                    break;\n                }\n            }\n            if (!track) {\n                return;\n            }\n\n            /**\n             * Triggered when a track is removed from track list.\n             *\n             * @event TrackList#removetrack\n             * @type {Event}\n             * @property {Track} track\n             *           A reference to track that was removed.\n             */\n            this.trigger({\n                track,\n                type: 'removetrack',\n                target: this\n            });\n        }\n\n        /**\n         * Get a Track from the TrackList by a tracks id\n         *\n         * @param {string} id - the id of the track to get\n         * @method getTrackById\n         * @return { import('./track').default }\n         * @private\n         */\n        getTrackById(id) {\n            let result = null;\n            for (let i = 0, l = this.length; i < l; i++) {\n                const track = this[i];\n                if (track.id === id) {\n                    result = track;\n                    break;\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Triggered when a different track is selected/enabled.\n     *\n     * @event TrackList#change\n     * @type {Event}\n     */\n\n    /**\n     * Events that can be called with on + eventName. See {@link EventHandler}.\n     *\n     * @property {Object} TrackList#allowedEvents_\n     * @private\n     */\n    TrackList.prototype.allowedEvents_ = {\n        change: 'change',\n        addtrack: 'addtrack',\n        removetrack: 'removetrack',\n        labelchange: 'labelchange'\n    };\n\n    // emulate attribute EventHandler support to allow for feature detection\n    for (const event in TrackList.prototype.allowedEvents_) {\n        TrackList.prototype['on' + event] = null;\n    }\n\n    /**\n     * @file audio-track-list.js\n     */\n\n    /**\n     * Anywhere we call this function we diverge from the spec\n     * as we only support one enabled audiotrack at a time\n     *\n     * @param {AudioTrackList} list\n     *        list to work on\n     *\n     * @param { import('./audio-track').default } track\n     *        The track to skip\n     *\n     * @private\n     */\n    const disableOthers$1 = function (list, track) {\n        for (let i = 0; i < list.length; i++) {\n            if (!Object.keys(list[i]).length || track.id === list[i].id) {\n                continue;\n            }\n            // another audio track is enabled, disable it\n            list[i].enabled = false;\n        }\n    };\n\n    /**\n     * The current list of {@link AudioTrack} for a media file.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist}\n     * @extends TrackList\n     */\n    class AudioTrackList extends TrackList {\n        /**\n         * Create an instance of this class.\n         *\n         * @param {AudioTrack[]} [tracks=[]]\n         *        A list of `AudioTrack` to instantiate the list with.\n         */\n        constructor(tracks = []) {\n            // make sure only 1 track is enabled\n            // sorted from last index to first index\n            for (let i = tracks.length - 1; i >= 0; i--) {\n                if (tracks[i].enabled) {\n                    disableOthers$1(tracks, tracks[i]);\n                    break;\n                }\n            }\n            super(tracks);\n            this.changing_ = false;\n        }\n\n        /**\n         * Add an {@link AudioTrack} to the `AudioTrackList`.\n         *\n         * @param { import('./audio-track').default } track\n         *        The AudioTrack to add to the list\n         *\n         * @fires TrackList#addtrack\n         */\n        addTrack(track) {\n            if (track.enabled) {\n                disableOthers$1(this, track);\n            }\n            super.addTrack(track);\n            // native tracks don't have this\n            if (!track.addEventListener) {\n                return;\n            }\n            track.enabledChange_ = () => {\n                // when we are disabling other tracks (since we don't support\n                // more than one track at a time) we will set changing_\n                // to true so that we don't trigger additional change events\n                if (this.changing_) {\n                    return;\n                }\n                this.changing_ = true;\n                disableOthers$1(this, track);\n                this.changing_ = false;\n                this.trigger('change');\n            };\n\n            /**\n             * @listens AudioTrack#enabledchange\n             * @fires TrackList#change\n             */\n            track.addEventListener('enabledchange', track.enabledChange_);\n        }\n        removeTrack(rtrack) {\n            super.removeTrack(rtrack);\n            if (rtrack.removeEventListener && rtrack.enabledChange_) {\n                rtrack.removeEventListener('enabledchange', rtrack.enabledChange_);\n                rtrack.enabledChange_ = null;\n            }\n        }\n    }\n\n    /**\n     * @file video-track-list.js\n     */\n\n    /**\n     * Un-select all other {@link VideoTrack}s that are selected.\n     *\n     * @param {VideoTrackList} list\n     *        list to work on\n     *\n     * @param { import('./video-track').default } track\n     *        The track to skip\n     *\n     * @private\n     */\n    const disableOthers = function (list, track) {\n        for (let i = 0; i < list.length; i++) {\n            if (!Object.keys(list[i]).length || track.id === list[i].id) {\n                continue;\n            }\n            // another video track is enabled, disable it\n            list[i].selected = false;\n        }\n    };\n\n    /**\n     * The current list of {@link VideoTrack} for a video.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist}\n     * @extends TrackList\n     */\n    class VideoTrackList extends TrackList {\n        /**\n         * Create an instance of this class.\n         *\n         * @param {VideoTrack[]} [tracks=[]]\n         *        A list of `VideoTrack` to instantiate the list with.\n         */\n        constructor(tracks = []) {\n            // make sure only 1 track is enabled\n            // sorted from last index to first index\n            for (let i = tracks.length - 1; i >= 0; i--) {\n                if (tracks[i].selected) {\n                    disableOthers(tracks, tracks[i]);\n                    break;\n                }\n            }\n            super(tracks);\n            this.changing_ = false;\n\n            /**\n             * @member {number} VideoTrackList#selectedIndex\n             *         The current index of the selected {@link VideoTrack`}.\n             */\n            Object.defineProperty(this, 'selectedIndex', {\n                get() {\n                    for (let i = 0; i < this.length; i++) {\n                        if (this[i].selected) {\n                            return i;\n                        }\n                    }\n                    return -1;\n                },\n                set() {}\n            });\n        }\n\n        /**\n         * Add a {@link VideoTrack} to the `VideoTrackList`.\n         *\n         * @param { import('./video-track').default } track\n         *        The VideoTrack to add to the list\n         *\n         * @fires TrackList#addtrack\n         */\n        addTrack(track) {\n            if (track.selected) {\n                disableOthers(this, track);\n            }\n            super.addTrack(track);\n            // native tracks don't have this\n            if (!track.addEventListener) {\n                return;\n            }\n            track.selectedChange_ = () => {\n                if (this.changing_) {\n                    return;\n                }\n                this.changing_ = true;\n                disableOthers(this, track);\n                this.changing_ = false;\n                this.trigger('change');\n            };\n\n            /**\n             * @listens VideoTrack#selectedchange\n             * @fires TrackList#change\n             */\n            track.addEventListener('selectedchange', track.selectedChange_);\n        }\n        removeTrack(rtrack) {\n            super.removeTrack(rtrack);\n            if (rtrack.removeEventListener && rtrack.selectedChange_) {\n                rtrack.removeEventListener('selectedchange', rtrack.selectedChange_);\n                rtrack.selectedChange_ = null;\n            }\n        }\n    }\n\n    /**\n     * @file text-track-list.js\n     */\n\n    /**\n     * The current list of {@link TextTrack} for a media file.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist}\n     * @extends TrackList\n     */\n    class TextTrackList extends TrackList {\n        /**\n         * Add a {@link TextTrack} to the `TextTrackList`\n         *\n         * @param { import('./text-track').default } track\n         *        The text track to add to the list.\n         *\n         * @fires TrackList#addtrack\n         */\n        addTrack(track) {\n            super.addTrack(track);\n            if (!this.queueChange_) {\n                this.queueChange_ = () => this.queueTrigger('change');\n            }\n            if (!this.triggerSelectedlanguagechange) {\n                this.triggerSelectedlanguagechange_ = () => this.trigger('selectedlanguagechange');\n            }\n\n            /**\n             * @listens TextTrack#modechange\n             * @fires TrackList#change\n             */\n            track.addEventListener('modechange', this.queueChange_);\n            const nonLanguageTextTrackKind = ['metadata', 'chapters'];\n            if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {\n                track.addEventListener('modechange', this.triggerSelectedlanguagechange_);\n            }\n        }\n        removeTrack(rtrack) {\n            super.removeTrack(rtrack);\n\n            // manually remove the event handlers we added\n            if (rtrack.removeEventListener) {\n                if (this.queueChange_) {\n                    rtrack.removeEventListener('modechange', this.queueChange_);\n                }\n                if (this.selectedlanguagechange_) {\n                    rtrack.removeEventListener('modechange', this.triggerSelectedlanguagechange_);\n                }\n            }\n        }\n    }\n\n    /**\n     * @file html-track-element-list.js\n     */\n\n    /**\n     * The current list of {@link HtmlTrackElement}s.\n     */\n    class HtmlTrackElementList {\n        /**\n         * Create an instance of this class.\n         *\n         * @param {HtmlTrackElement[]} [tracks=[]]\n         *        A list of `HtmlTrackElement` to instantiate the list with.\n         */\n        constructor(trackElements = []) {\n            this.trackElements_ = [];\n\n            /**\n             * @memberof HtmlTrackElementList\n             * @member {number} length\n             *         The current number of `Track`s in the this Trackist.\n             * @instance\n             */\n            Object.defineProperty(this, 'length', {\n                get() {\n                    return this.trackElements_.length;\n                }\n            });\n            for (let i = 0, length = trackElements.length; i < length; i++) {\n                this.addTrackElement_(trackElements[i]);\n            }\n        }\n\n        /**\n         * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`\n         *\n         * @param {HtmlTrackElement} trackElement\n         *        The track element to add to the list.\n         *\n         * @private\n         */\n        addTrackElement_(trackElement) {\n            const index = this.trackElements_.length;\n            if (!('' + index in this)) {\n                Object.defineProperty(this, index, {\n                    get() {\n                        return this.trackElements_[index];\n                    }\n                });\n            }\n\n            // Do not add duplicate elements\n            if (this.trackElements_.indexOf(trackElement) === -1) {\n                this.trackElements_.push(trackElement);\n            }\n        }\n\n        /**\n         * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an\n         * {@link TextTrack}.\n         *\n         * @param {TextTrack} track\n         *        The track associated with a track element.\n         *\n         * @return {HtmlTrackElement|undefined}\n         *         The track element that was found or undefined.\n         *\n         * @private\n         */\n        getTrackElementByTrack_(track) {\n            let trackElement_;\n            for (let i = 0, length = this.trackElements_.length; i < length; i++) {\n                if (track === this.trackElements_[i].track) {\n                    trackElement_ = this.trackElements_[i];\n                    break;\n                }\n            }\n            return trackElement_;\n        }\n\n        /**\n         * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`\n         *\n         * @param {HtmlTrackElement} trackElement\n         *        The track element to remove from the list.\n         *\n         * @private\n         */\n        removeTrackElement_(trackElement) {\n            for (let i = 0, length = this.trackElements_.length; i < length; i++) {\n                if (trackElement === this.trackElements_[i]) {\n                    if (this.trackElements_[i].track && typeof this.trackElements_[i].track.off === 'function') {\n                        this.trackElements_[i].track.off();\n                    }\n                    if (typeof this.trackElements_[i].off === 'function') {\n                        this.trackElements_[i].off();\n                    }\n                    this.trackElements_.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * @file text-track-cue-list.js\n     */\n\n    /**\n     * @typedef {Object} TextTrackCueList~TextTrackCue\n     *\n     * @property {string} id\n     *           The unique id for this text track cue\n     *\n     * @property {number} startTime\n     *           The start time for this text track cue\n     *\n     * @property {number} endTime\n     *           The end time for this text track cue\n     *\n     * @property {boolean} pauseOnExit\n     *           Pause when the end time is reached if true.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcue}\n     */\n\n    /**\n     * A List of TextTrackCues.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist}\n     */\n    class TextTrackCueList {\n        /**\n         * Create an instance of this class..\n         *\n         * @param {Array} cues\n         *        A list of cues to be initialized with\n         */\n        constructor(cues) {\n            TextTrackCueList.prototype.setCues_.call(this, cues);\n\n            /**\n             * @memberof TextTrackCueList\n             * @member {number} length\n             *         The current number of `TextTrackCue`s in the TextTrackCueList.\n             * @instance\n             */\n            Object.defineProperty(this, 'length', {\n                get() {\n                    return this.length_;\n                }\n            });\n        }\n\n        /**\n         * A setter for cues in this list. Creates getters\n         * an an index for the cues.\n         *\n         * @param {Array} cues\n         *        An array of cues to set\n         *\n         * @private\n         */\n        setCues_(cues) {\n            const oldLength = this.length || 0;\n            let i = 0;\n            const l = cues.length;\n            this.cues_ = cues;\n            this.length_ = cues.length;\n            const defineProp = function (index) {\n                if (!('' + index in this)) {\n                    Object.defineProperty(this, '' + index, {\n                        get() {\n                            return this.cues_[index];\n                        }\n                    });\n                }\n            };\n            if (oldLength < l) {\n                i = oldLength;\n                for (; i < l; i++) {\n                    defineProp.call(this, i);\n                }\n            }\n        }\n\n        /**\n         * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.\n         *\n         * @param {string} id\n         *        The id of the cue that should be searched for.\n         *\n         * @return {TextTrackCueList~TextTrackCue|null}\n         *         A single cue or null if none was found.\n         */\n        getCueById(id) {\n            let result = null;\n            for (let i = 0, l = this.length; i < l; i++) {\n                const cue = this[i];\n                if (cue.id === id) {\n                    result = cue;\n                    break;\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @file track-kinds.js\n     */\n\n    /**\n     * All possible `VideoTrackKind`s\n     *\n     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind\n     * @typedef VideoTrack~Kind\n     * @enum\n     */\n    const VideoTrackKind = {\n        alternative: 'alternative',\n        captions: 'captions',\n        main: 'main',\n        sign: 'sign',\n        subtitles: 'subtitles',\n        commentary: 'commentary'\n    };\n\n    /**\n     * All possible `AudioTrackKind`s\n     *\n     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind\n     * @typedef AudioTrack~Kind\n     * @enum\n     */\n    const AudioTrackKind = {\n        'alternative': 'alternative',\n        'descriptions': 'descriptions',\n        'main': 'main',\n        'main-desc': 'main-desc',\n        'translation': 'translation',\n        'commentary': 'commentary'\n    };\n\n    /**\n     * All possible `TextTrackKind`s\n     *\n     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-texttrack-kind\n     * @typedef TextTrack~Kind\n     * @enum\n     */\n    const TextTrackKind = {\n        subtitles: 'subtitles',\n        captions: 'captions',\n        descriptions: 'descriptions',\n        chapters: 'chapters',\n        metadata: 'metadata'\n    };\n\n    /**\n     * All possible `TextTrackMode`s\n     *\n     * @see https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode\n     * @typedef TextTrack~Mode\n     * @enum\n     */\n    const TextTrackMode = {\n        disabled: 'disabled',\n        hidden: 'hidden',\n        showing: 'showing'\n    };\n\n    /**\n     * @file track.js\n     */\n\n    /**\n     * A Track class that contains all of the common functionality for {@link AudioTrack},\n     * {@link VideoTrack}, and {@link TextTrack}.\n     *\n     * > Note: This class should not be used directly\n     *\n     * @see {@link https://html.spec.whatwg.org/multipage/embedded-content.html}\n     * @extends EventTarget\n     * @abstract\n     */\n    class Track extends EventTarget$2 {\n        /**\n         * Create an instance of this class.\n         *\n         * @param {Object} [options={}]\n         *        Object of option names and values\n         *\n         * @param {string} [options.kind='']\n         *        A valid kind for the track type you are creating.\n         *\n         * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n         *        A unique id for this AudioTrack.\n         *\n         * @param {string} [options.label='']\n         *        The menu label for this track.\n         *\n         * @param {string} [options.language='']\n         *        A valid two character language code.\n         *\n         * @abstract\n         */\n        constructor(options = {}) {\n            super();\n            const trackProps = {\n                id: options.id || 'vjs_track_' + newGUID(),\n                kind: options.kind || '',\n                language: options.language || ''\n            };\n            let label = options.label || '';\n\n            /**\n             * @memberof Track\n             * @member {string} id\n             *         The id of this track. Cannot be changed after creation.\n             * @instance\n             *\n             * @readonly\n             */\n\n            /**\n             * @memberof Track\n             * @member {string} kind\n             *         The kind of track that this is. Cannot be changed after creation.\n             * @instance\n             *\n             * @readonly\n             */\n\n            /**\n             * @memberof Track\n             * @member {string} language\n             *         The two letter language code for this track. Cannot be changed after\n             *         creation.\n             * @instance\n             *\n             * @readonly\n             */\n\n            for (const key in trackProps) {\n                Object.defineProperty(this, key, {\n                    get() {\n                        return trackProps[key];\n                    },\n                    set() {}\n                });\n            }\n\n            /**\n             * @memberof Track\n             * @member {string} label\n             *         The label of this track. Cannot be changed after creation.\n             * @instance\n             *\n             * @fires Track#labelchange\n             */\n            Object.defineProperty(this, 'label', {\n                get() {\n                    return label;\n                },\n                set(newLabel) {\n                    if (newLabel !== label) {\n                        label = newLabel;\n\n                        /**\n                         * An event that fires when label changes on this track.\n                         *\n                         * > Note: This is not part of the spec!\n                         *\n                         * @event Track#labelchange\n                         * @type {Event}\n                         */\n                        this.trigger('labelchange');\n                    }\n                }\n            });\n        }\n    }\n\n    /**\n     * @file url.js\n     * @module url\n     */\n\n    /**\n     * @typedef {Object} url:URLObject\n     *\n     * @property {string} protocol\n     *           The protocol of the url that was parsed.\n     *\n     * @property {string} hostname\n     *           The hostname of the url that was parsed.\n     *\n     * @property {string} port\n     *           The port of the url that was parsed.\n     *\n     * @property {string} pathname\n     *           The pathname of the url that was parsed.\n     *\n     * @property {string} search\n     *           The search query of the url that was parsed.\n     *\n     * @property {string} hash\n     *           The hash of the url that was parsed.\n     *\n     * @property {string} host\n     *           The host of the url that was parsed.\n     */\n\n    /**\n     * Resolve and parse the elements of a URL.\n     *\n     * @function\n     * @param    {String} url\n     *           The url to parse\n     *\n     * @return   {url:URLObject}\n     *           An object of url details\n     */\n    const parseUrl = function (url) {\n        // This entire method can be replace with URL once we are able to drop IE11\n\n        const props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];\n\n        // add the url to an anchor and let the browser parse the URL\n        const a = document.createElement('a');\n        a.href = url;\n\n        // Copy the specific URL properties to a new object\n        // This is also needed for IE because the anchor loses its\n        // properties when it's removed from the dom\n        const details = {};\n        for (let i = 0; i < props.length; i++) {\n            details[props[i]] = a[props[i]];\n        }\n\n        // IE adds the port to the host property unlike everyone else. If\n        // a port identifier is added for standard ports, strip it.\n        if (details.protocol === 'http:') {\n            details.host = details.host.replace(/:80$/, '');\n        }\n        if (details.protocol === 'https:') {\n            details.host = details.host.replace(/:443$/, '');\n        }\n        if (!details.protocol) {\n            details.protocol = window.location.protocol;\n        }\n\n        /* istanbul ignore if */\n        if (!details.host) {\n            details.host = window.location.host;\n        }\n        return details;\n    };\n\n    /**\n     * Get absolute version of relative URL.\n     *\n     * @function\n     * @param    {string} url\n     *           URL to make absolute\n     *\n     * @return   {string}\n     *           Absolute URL\n     *\n     * @see      http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue\n     */\n    const getAbsoluteURL = function (url) {\n        // Check if absolute URL\n        if (!url.match(/^https?:\\/\\//)) {\n            // Add the url to an anchor and let the browser parse it to convert to an absolute url\n            const a = document.createElement('a');\n            a.href = url;\n            url = a.href;\n        }\n        return url;\n    };\n\n    /**\n     * Returns the extension of the passed file name. It will return an empty string\n     * if passed an invalid path.\n     *\n     * @function\n     * @param    {string} path\n     *           The fileName path like '/path/to/file.mp4'\n     *\n     * @return  {string}\n     *           The extension in lower case or an empty string if no\n     *           extension could be found.\n     */\n    const getFileExtension = function (path) {\n        if (typeof path === 'string') {\n            const splitPathRe = /^(\\/?)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?)(\\.([^\\.\\/\\?]+)))(?:[\\/]*|[\\?].*)$/;\n            const pathParts = splitPathRe.exec(path);\n            if (pathParts) {\n                return pathParts.pop().toLowerCase();\n            }\n        }\n        return '';\n    };\n\n    /**\n     * Returns whether the url passed is a cross domain request or not.\n     *\n     * @function\n     * @param    {string} url\n     *           The url to check.\n     *\n     * @param    {Object} [winLoc]\n     *           the domain to check the url against, defaults to window.location\n     *\n     * @param    {string} [winLoc.protocol]\n     *           The window location protocol defaults to window.location.protocol\n     *\n     * @param    {string} [winLoc.host]\n     *           The window location host defaults to window.location.host\n     *\n     * @return   {boolean}\n     *           Whether it is a cross domain request or not.\n     */\n    const isCrossOrigin = function (url, winLoc = window.location) {\n        const urlInfo = parseUrl(url);\n\n        // IE8 protocol relative urls will return ':' for protocol\n        const srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;\n\n        // Check if url is for another domain/origin\n        // IE8 doesn't know location.origin, so we won't rely on it here\n        const crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;\n        return crossOrigin;\n    };\n\n    var Url = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        parseUrl: parseUrl,\n        getAbsoluteURL: getAbsoluteURL,\n        getFileExtension: getFileExtension,\n        isCrossOrigin: isCrossOrigin\n    });\n\n    var win;\n    if (typeof window !== \"undefined\") {\n        win = window;\n    } else if (typeof commonjsGlobal !== \"undefined\") {\n        win = commonjsGlobal;\n    } else if (typeof self !== \"undefined\") {\n        win = self;\n    } else {\n        win = {};\n    }\n    var window_1 = win;\n\n    var _extends_1 = createCommonjsModule(function (module) {\n        function _extends() {\n            module.exports = _extends = Object.assign ? Object.assign.bind() : function (target) {\n                for (var i = 1; i < arguments.length; i++) {\n                    var source = arguments[i];\n                    for (var key in source) {\n                        if (Object.prototype.hasOwnProperty.call(source, key)) {\n                            target[key] = source[key];\n                        }\n                    }\n                }\n                return target;\n            }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n            return _extends.apply(this, arguments);\n        }\n        module.exports = _extends, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    });\n    var _extends$1 = unwrapExports(_extends_1);\n\n    var isFunction_1 = isFunction;\n    var toString = Object.prototype.toString;\n    function isFunction(fn) {\n        if (!fn) {\n            return false;\n        }\n        var string = toString.call(fn);\n        return string === '[object Function]' || typeof fn === 'function' && string !== '[object RegExp]' || typeof window !== 'undefined' && (\n            // IE8 and below\n            fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);\n    }\n\n    var httpResponseHandler = function httpResponseHandler(callback, decodeResponseBody) {\n        if (decodeResponseBody === void 0) {\n            decodeResponseBody = false;\n        }\n        return function (err, response, responseBody) {\n            // if the XHR failed, return that error\n            if (err) {\n                callback(err);\n                return;\n            } // if the HTTP status code is 4xx or 5xx, the request also failed\n\n            if (response.statusCode >= 400 && response.statusCode <= 599) {\n                var cause = responseBody;\n                if (decodeResponseBody) {\n                    if (window_1.TextDecoder) {\n                        var charset = getCharset(response.headers && response.headers['content-type']);\n                        try {\n                            cause = new TextDecoder(charset).decode(responseBody);\n                        } catch (e) {}\n                    } else {\n                        cause = String.fromCharCode.apply(null, new Uint8Array(responseBody));\n                    }\n                }\n                callback({\n                    cause: cause\n                });\n                return;\n            } // otherwise, request succeeded\n\n            callback(null, responseBody);\n        };\n    };\n    function getCharset(contentTypeHeader) {\n        if (contentTypeHeader === void 0) {\n            contentTypeHeader = '';\n        }\n        return contentTypeHeader.toLowerCase().split(';').reduce(function (charset, contentType) {\n            var _contentType$split = contentType.split('='),\n                type = _contentType$split[0],\n                value = _contentType$split[1];\n            if (type.trim() === 'charset') {\n                return value.trim();\n            }\n            return charset;\n        }, 'utf-8');\n    }\n    var httpHandler = httpResponseHandler;\n\n    createXHR.httpHandler = httpHandler;\n    /**\n     * @license\n     * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>\n     * Copyright (c) 2014 David Björklund\n     * Available under the MIT license\n     * <https://github.com/kesla/parse-headers/blob/master/LICENCE>\n     */\n\n    var parseHeaders = function parseHeaders(headers) {\n        var result = {};\n        if (!headers) {\n            return result;\n        }\n        headers.trim().split('\\n').forEach(function (row) {\n            var index = row.indexOf(':');\n            var key = row.slice(0, index).trim().toLowerCase();\n            var value = row.slice(index + 1).trim();\n            if (typeof result[key] === 'undefined') {\n                result[key] = value;\n            } else if (Array.isArray(result[key])) {\n                result[key].push(value);\n            } else {\n                result[key] = [result[key], value];\n            }\n        });\n        return result;\n    };\n    var lib = createXHR; // Allow use of default import syntax in TypeScript\n\n    var default_1 = createXHR;\n    createXHR.XMLHttpRequest = window_1.XMLHttpRequest || noop$1;\n    createXHR.XDomainRequest = \"withCredentials\" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window_1.XDomainRequest;\n    forEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function (method) {\n        createXHR[method === \"delete\" ? \"del\" : method] = function (uri, options, callback) {\n            options = initParams(uri, options, callback);\n            options.method = method.toUpperCase();\n            return _createXHR(options);\n        };\n    });\n    function forEachArray(array, iterator) {\n        for (var i = 0; i < array.length; i++) {\n            iterator(array[i]);\n        }\n    }\n    function isEmpty(obj) {\n        for (var i in obj) {\n            if (obj.hasOwnProperty(i)) return false;\n        }\n        return true;\n    }\n    function initParams(uri, options, callback) {\n        var params = uri;\n        if (isFunction_1(options)) {\n            callback = options;\n            if (typeof uri === \"string\") {\n                params = {\n                    uri: uri\n                };\n            }\n        } else {\n            params = _extends_1({}, options, {\n                uri: uri\n            });\n        }\n        params.callback = callback;\n        return params;\n    }\n    function createXHR(uri, options, callback) {\n        options = initParams(uri, options, callback);\n        return _createXHR(options);\n    }\n    function _createXHR(options) {\n        if (typeof options.callback === \"undefined\") {\n            throw new Error(\"callback argument missing\");\n        }\n        var called = false;\n        var callback = function cbOnce(err, response, body) {\n            if (!called) {\n                called = true;\n                options.callback(err, response, body);\n            }\n        };\n        function readystatechange() {\n            if (xhr.readyState === 4) {\n                setTimeout(loadFunc, 0);\n            }\n        }\n        function getBody() {\n            // Chrome with requestType=blob throws errors arround when even testing access to responseText\n            var body = undefined;\n            if (xhr.response) {\n                body = xhr.response;\n            } else {\n                body = xhr.responseText || getXml(xhr);\n            }\n            if (isJson) {\n                try {\n                    body = JSON.parse(body);\n                } catch (e) {}\n            }\n            return body;\n        }\n        function errorFunc(evt) {\n            clearTimeout(timeoutTimer);\n            if (!(evt instanceof Error)) {\n                evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\"));\n            }\n            evt.statusCode = 0;\n            return callback(evt, failureResponse);\n        } // will load the data & process the response in a special response object\n\n        function loadFunc() {\n            if (aborted) return;\n            var status;\n            clearTimeout(timeoutTimer);\n            if (options.useXDR && xhr.status === undefined) {\n                //IE8 CORS GET successful response doesn't have a status field, but body is fine\n                status = 200;\n            } else {\n                status = xhr.status === 1223 ? 204 : xhr.status;\n            }\n            var response = failureResponse;\n            var err = null;\n            if (status !== 0) {\n                response = {\n                    body: getBody(),\n                    statusCode: status,\n                    method: method,\n                    headers: {},\n                    url: uri,\n                    rawRequest: xhr\n                };\n                if (xhr.getAllResponseHeaders) {\n                    //remember xhr can in fact be XDR for CORS in IE\n                    response.headers = parseHeaders(xhr.getAllResponseHeaders());\n                }\n            } else {\n                err = new Error(\"Internal XMLHttpRequest Error\");\n            }\n            return callback(err, response, response.body);\n        }\n        var xhr = options.xhr || null;\n        if (!xhr) {\n            if (options.cors || options.useXDR) {\n                xhr = new createXHR.XDomainRequest();\n            } else {\n                xhr = new createXHR.XMLHttpRequest();\n            }\n        }\n        var key;\n        var aborted;\n        var uri = xhr.url = options.uri || options.url;\n        var method = xhr.method = options.method || \"GET\";\n        var body = options.body || options.data;\n        var headers = xhr.headers = options.headers || {};\n        var sync = !!options.sync;\n        var isJson = false;\n        var timeoutTimer;\n        var failureResponse = {\n            body: undefined,\n            headers: {},\n            statusCode: 0,\n            method: method,\n            url: uri,\n            rawRequest: xhr\n        };\n        if (\"json\" in options && options.json !== false) {\n            isJson = true;\n            headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\"); //Don't override existing accept header declared by user\n\n            if (method !== \"GET\" && method !== \"HEAD\") {\n                headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\"); //Don't override existing accept header declared by user\n\n                body = JSON.stringify(options.json === true ? body : options.json);\n            }\n        }\n        xhr.onreadystatechange = readystatechange;\n        xhr.onload = loadFunc;\n        xhr.onerror = errorFunc; // IE9 must have onprogress be set to a unique function.\n\n        xhr.onprogress = function () {// IE must die\n        };\n        xhr.onabort = function () {\n            aborted = true;\n        };\n        xhr.ontimeout = errorFunc;\n        xhr.open(method, uri, !sync, options.username, options.password); //has to be after open\n\n        if (!sync) {\n            xhr.withCredentials = !!options.withCredentials;\n        } // Cannot set timeout with sync request\n        // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n        // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n\n        if (!sync && options.timeout > 0) {\n            timeoutTimer = setTimeout(function () {\n                if (aborted) return;\n                aborted = true; //IE9 may still call readystatechange\n\n                xhr.abort(\"timeout\");\n                var e = new Error(\"XMLHttpRequest timeout\");\n                e.code = \"ETIMEDOUT\";\n                errorFunc(e);\n            }, options.timeout);\n        }\n        if (xhr.setRequestHeader) {\n            for (key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, headers[key]);\n                }\n            }\n        } else if (options.headers && !isEmpty(options.headers)) {\n            throw new Error(\"Headers cannot be set on an XDomainRequest object\");\n        }\n        if (\"responseType\" in options) {\n            xhr.responseType = options.responseType;\n        }\n        if (\"beforeSend\" in options && typeof options.beforeSend === \"function\") {\n            options.beforeSend(xhr);\n        } // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n        // XMLHttpRequest spec says to pass null as body to indicate no body\n        // See https://github.com/naugtur/xhr/issues/100.\n\n        xhr.send(body || null);\n        return xhr;\n    }\n    function getXml(xhr) {\n        // xhr.responseXML will throw Exception \"InvalidStateError\" or \"DOMException\"\n        // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.\n        try {\n            if (xhr.responseType === \"document\") {\n                return xhr.responseXML;\n            }\n            var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\";\n            if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n                return xhr.responseXML;\n            }\n        } catch (e) {}\n        return null;\n    }\n    function noop$1() {}\n    lib.default = default_1;\n\n    /**\n     * @file text-track.js\n     */\n\n    /**\n     * Takes a webvtt file contents and parses it into cues\n     *\n     * @param {string} srcContent\n     *        webVTT file contents\n     *\n     * @param {TextTrack} track\n     *        TextTrack to add cues to. Cues come from the srcContent.\n     *\n     * @private\n     */\n    const parseCues = function (srcContent, track) {\n        const parser = new window.WebVTT.Parser(window, window.vttjs, window.WebVTT.StringDecoder());\n        const errors = [];\n        parser.oncue = function (cue) {\n            track.addCue(cue);\n        };\n        parser.onparsingerror = function (error) {\n            errors.push(error);\n        };\n        parser.onflush = function () {\n            track.trigger({\n                type: 'loadeddata',\n                target: track\n            });\n        };\n        parser.parse(srcContent);\n        if (errors.length > 0) {\n            if (window.console && window.console.groupCollapsed) {\n                window.console.groupCollapsed(`Text Track parsing errors for ${track.src}`);\n            }\n            errors.forEach(error => log$1.error(error));\n            if (window.console && window.console.groupEnd) {\n                window.console.groupEnd();\n            }\n        }\n        parser.flush();\n    };\n\n    /**\n     * Load a `TextTrack` from a specified url.\n     *\n     * @param {string} src\n     *        Url to load track from.\n     *\n     * @param {TextTrack} track\n     *        Track to add cues to. Comes from the content at the end of `url`.\n     *\n     * @private\n     */\n    const loadTrack = function (src, track) {\n        const opts = {\n            uri: src\n        };\n        const crossOrigin = isCrossOrigin(src);\n        if (crossOrigin) {\n            opts.cors = crossOrigin;\n        }\n        const withCredentials = track.tech_.crossOrigin() === 'use-credentials';\n        if (withCredentials) {\n            opts.withCredentials = withCredentials;\n        }\n        lib(opts, bind_(this, function (err, response, responseBody) {\n            if (err) {\n                return log$1.error(err, response);\n            }\n            track.loaded_ = true;\n\n            // Make sure that vttjs has loaded, otherwise, wait till it finished loading\n            // NOTE: this is only used for the alt/video.novtt.js build\n            if (typeof window.WebVTT !== 'function') {\n                if (track.tech_) {\n                    // to prevent use before define eslint error, we define loadHandler\n                    // as a let here\n                    track.tech_.any(['vttjsloaded', 'vttjserror'], event => {\n                        if (event.type === 'vttjserror') {\n                            log$1.error(`vttjs failed to load, stopping trying to process ${track.src}`);\n                            return;\n                        }\n                        return parseCues(responseBody, track);\n                    });\n                }\n            } else {\n                parseCues(responseBody, track);\n            }\n        }));\n    };\n\n    /**\n     * A representation of a single `TextTrack`.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack}\n     * @extends Track\n     */\n    class TextTrack extends Track {\n        /**\n         * Create an instance of this class.\n         *\n         * @param {Object} options={}\n         *        Object of option names and values\n         *\n         * @param { import('../tech/tech').default } options.tech\n         *        A reference to the tech that owns this TextTrack.\n         *\n         * @param {TextTrack~Kind} [options.kind='subtitles']\n         *        A valid text track kind.\n         *\n         * @param {TextTrack~Mode} [options.mode='disabled']\n         *        A valid text track mode.\n         *\n         * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n         *        A unique id for this TextTrack.\n         *\n         * @param {string} [options.label='']\n         *        The menu label for this track.\n         *\n         * @param {string} [options.language='']\n         *        A valid two character language code.\n         *\n         * @param {string} [options.srclang='']\n         *        A valid two character language code. An alternative, but deprioritized\n         *        version of `options.language`\n         *\n         * @param {string} [options.src]\n         *        A url to TextTrack cues.\n         *\n         * @param {boolean} [options.default]\n         *        If this track should default to on or off.\n         */\n        constructor(options = {}) {\n            if (!options.tech) {\n                throw new Error('A tech was not provided.');\n            }\n            const settings = merge$2(options, {\n                kind: TextTrackKind[options.kind] || 'subtitles',\n                language: options.language || options.srclang || ''\n            });\n            let mode = TextTrackMode[settings.mode] || 'disabled';\n            const default_ = settings.default;\n            if (settings.kind === 'metadata' || settings.kind === 'chapters') {\n                mode = 'hidden';\n            }\n            super(settings);\n            this.tech_ = settings.tech;\n            this.cues_ = [];\n            this.activeCues_ = [];\n            this.preload_ = this.tech_.preloadTextTracks !== false;\n            const cues = new TextTrackCueList(this.cues_);\n            const activeCues = new TextTrackCueList(this.activeCues_);\n            let changed = false;\n            this.timeupdateHandler = bind_(this, function (event = {}) {\n                if (this.tech_.isDisposed()) {\n                    return;\n                }\n                if (!this.tech_.isReady_) {\n                    if (event.type !== 'timeupdate') {\n                        this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);\n                    }\n                    return;\n                }\n\n                // Accessing this.activeCues for the side-effects of updating itself\n                // due to its nature as a getter function. Do not remove or cues will\n                // stop updating!\n                // Use the setter to prevent deletion from uglify (pure_getters rule)\n                this.activeCues = this.activeCues;\n                if (changed) {\n                    this.trigger('cuechange');\n                    changed = false;\n                }\n                if (event.type !== 'timeupdate') {\n                    this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);\n                }\n            });\n            const disposeHandler = () => {\n                this.stopTracking();\n            };\n            this.tech_.one('dispose', disposeHandler);\n            if (mode !== 'disabled') {\n                this.startTracking();\n            }\n            Object.defineProperties(this, {\n                /**\n                 * @memberof TextTrack\n                 * @member {boolean} default\n                 *         If this track was set to be on or off by default. Cannot be changed after\n                 *         creation.\n                 * @instance\n                 *\n                 * @readonly\n                 */\n                default: {\n                    get() {\n                        return default_;\n                    },\n                    set() {}\n                },\n                /**\n                 * @memberof TextTrack\n                 * @member {string} mode\n                 *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will\n                 *         not be set if setting to an invalid mode.\n                 * @instance\n                 *\n                 * @fires TextTrack#modechange\n                 */\n                mode: {\n                    get() {\n                        return mode;\n                    },\n                    set(newMode) {\n                        if (!TextTrackMode[newMode]) {\n                            return;\n                        }\n                        if (mode === newMode) {\n                            return;\n                        }\n                        mode = newMode;\n                        if (!this.preload_ && mode !== 'disabled' && this.cues.length === 0) {\n                            // On-demand load.\n                            loadTrack(this.src, this);\n                        }\n                        this.stopTracking();\n                        if (mode !== 'disabled') {\n                            this.startTracking();\n                        }\n                        /**\n                         * An event that fires when mode changes on this track. This allows\n                         * the TextTrackList that holds this track to act accordingly.\n                         *\n                         * > Note: This is not part of the spec!\n                         *\n                         * @event TextTrack#modechange\n                         * @type {Event}\n                         */\n                        this.trigger('modechange');\n                    }\n                },\n                /**\n                 * @memberof TextTrack\n                 * @member {TextTrackCueList} cues\n                 *         The text track cue list for this TextTrack.\n                 * @instance\n                 */\n                cues: {\n                    get() {\n                        if (!this.loaded_) {\n                            return null;\n                        }\n                        return cues;\n                    },\n                    set() {}\n                },\n                /**\n                 * @memberof TextTrack\n                 * @member {TextTrackCueList} activeCues\n                 *         The list text track cues that are currently active for this TextTrack.\n                 * @instance\n                 */\n                activeCues: {\n                    get() {\n                        if (!this.loaded_) {\n                            return null;\n                        }\n\n                        // nothing to do\n                        if (this.cues.length === 0) {\n                            return activeCues;\n                        }\n                        const ct = this.tech_.currentTime();\n                        const active = [];\n                        for (let i = 0, l = this.cues.length; i < l; i++) {\n                            const cue = this.cues[i];\n                            if (cue.startTime <= ct && cue.endTime >= ct) {\n                                active.push(cue);\n                            }\n                        }\n                        changed = false;\n                        if (active.length !== this.activeCues_.length) {\n                            changed = true;\n                        } else {\n                            for (let i = 0; i < active.length; i++) {\n                                if (this.activeCues_.indexOf(active[i]) === -1) {\n                                    changed = true;\n                                }\n                            }\n                        }\n                        this.activeCues_ = active;\n                        activeCues.setCues_(this.activeCues_);\n                        return activeCues;\n                    },\n                    // /!\\ Keep this setter empty (see the timeupdate handler above)\n                    set() {}\n                }\n            });\n            if (settings.src) {\n                this.src = settings.src;\n                if (!this.preload_) {\n                    // Tracks will load on-demand.\n                    // Act like we're loaded for other purposes.\n                    this.loaded_ = true;\n                }\n                if (this.preload_ || settings.kind !== 'subtitles' && settings.kind !== 'captions') {\n                    loadTrack(this.src, this);\n                }\n            } else {\n                this.loaded_ = true;\n            }\n        }\n        startTracking() {\n            // More precise cues based on requestVideoFrameCallback with a requestAnimationFram fallback\n            this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);\n            // Also listen to timeupdate in case rVFC/rAF stops (window in background, audio in video el)\n            this.tech_.on('timeupdate', this.timeupdateHandler);\n        }\n        stopTracking() {\n            if (this.rvf_) {\n                this.tech_.cancelVideoFrameCallback(this.rvf_);\n                this.rvf_ = undefined;\n            }\n            this.tech_.off('timeupdate', this.timeupdateHandler);\n        }\n\n        /**\n         * Add a cue to the internal list of cues.\n         *\n         * @param {TextTrack~Cue} cue\n         *        The cue to add to our internal list\n         */\n        addCue(originalCue) {\n            let cue = originalCue;\n            if (window.vttjs && !(originalCue instanceof window.vttjs.VTTCue)) {\n                cue = new window.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);\n                for (const prop in originalCue) {\n                    if (!(prop in cue)) {\n                        cue[prop] = originalCue[prop];\n                    }\n                }\n\n                // make sure that `id` is copied over\n                cue.id = originalCue.id;\n                cue.originalCue_ = originalCue;\n            }\n            const tracks = this.tech_.textTracks();\n            for (let i = 0; i < tracks.length; i++) {\n                if (tracks[i] !== this) {\n                    tracks[i].removeCue(cue);\n                }\n            }\n            this.cues_.push(cue);\n            this.cues.setCues_(this.cues_);\n        }\n\n        /**\n         * Remove a cue from our internal list\n         *\n         * @param {TextTrack~Cue} removeCue\n         *        The cue to remove from our internal list\n         */\n        removeCue(removeCue) {\n            let i = this.cues_.length;\n            while (i--) {\n                const cue = this.cues_[i];\n                if (cue === removeCue || cue.originalCue_ && cue.originalCue_ === removeCue) {\n                    this.cues_.splice(i, 1);\n                    this.cues.setCues_(this.cues_);\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * cuechange - One or more cues in the track have become active or stopped being active.\n     */\n    TextTrack.prototype.allowedEvents_ = {\n        cuechange: 'cuechange'\n    };\n\n    /**\n     * A representation of a single `AudioTrack`. If it is part of an {@link AudioTrackList}\n     * only one `AudioTrack` in the list will be enabled at a time.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack}\n     * @extends Track\n     */\n    class AudioTrack extends Track {\n        /**\n         * Create an instance of this class.\n         *\n         * @param {Object} [options={}]\n         *        Object of option names and values\n         *\n         * @param {AudioTrack~Kind} [options.kind='']\n         *        A valid audio track kind\n         *\n         * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n         *        A unique id for this AudioTrack.\n         *\n         * @param {string} [options.label='']\n         *        The menu label for this track.\n         *\n         * @param {string} [options.language='']\n         *        A valid two character language code.\n         *\n         * @param {boolean} [options.enabled]\n         *        If this track is the one that is currently playing. If this track is part of\n         *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.\n         */\n        constructor(options = {}) {\n            const settings = merge$2(options, {\n                kind: AudioTrackKind[options.kind] || ''\n            });\n            super(settings);\n            let enabled = false;\n\n            /**\n             * @memberof AudioTrack\n             * @member {boolean} enabled\n             *         If this `AudioTrack` is enabled or not. When setting this will\n             *         fire {@link AudioTrack#enabledchange} if the state of enabled is changed.\n             * @instance\n             *\n             * @fires VideoTrack#selectedchange\n             */\n            Object.defineProperty(this, 'enabled', {\n                get() {\n                    return enabled;\n                },\n                set(newEnabled) {\n                    // an invalid or unchanged value\n                    if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {\n                        return;\n                    }\n                    enabled = newEnabled;\n\n                    /**\n                     * An event that fires when enabled changes on this track. This allows\n                     * the AudioTrackList that holds this track to act accordingly.\n                     *\n                     * > Note: This is not part of the spec! Native tracks will do\n                     *         this internally without an event.\n                     *\n                     * @event AudioTrack#enabledchange\n                     * @type {Event}\n                     */\n                    this.trigger('enabledchange');\n                }\n            });\n\n            // if the user sets this track to selected then\n            // set selected to that true value otherwise\n            // we keep it false\n            if (settings.enabled) {\n                this.enabled = settings.enabled;\n            }\n            this.loaded_ = true;\n        }\n    }\n\n    /**\n     * A representation of a single `VideoTrack`.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack}\n     * @extends Track\n     */\n    class VideoTrack extends Track {\n        /**\n         * Create an instance of this class.\n         *\n         * @param {Object} [options={}]\n         *        Object of option names and values\n         *\n         * @param {string} [options.kind='']\n         *        A valid {@link VideoTrack~Kind}\n         *\n         * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n         *        A unique id for this AudioTrack.\n         *\n         * @param {string} [options.label='']\n         *        The menu label for this track.\n         *\n         * @param {string} [options.language='']\n         *        A valid two character language code.\n         *\n         * @param {boolean} [options.selected]\n         *        If this track is the one that is currently playing.\n         */\n        constructor(options = {}) {\n            const settings = merge$2(options, {\n                kind: VideoTrackKind[options.kind] || ''\n            });\n            super(settings);\n            let selected = false;\n\n            /**\n             * @memberof VideoTrack\n             * @member {boolean} selected\n             *         If this `VideoTrack` is selected or not. When setting this will\n             *         fire {@link VideoTrack#selectedchange} if the state of selected changed.\n             * @instance\n             *\n             * @fires VideoTrack#selectedchange\n             */\n            Object.defineProperty(this, 'selected', {\n                get() {\n                    return selected;\n                },\n                set(newSelected) {\n                    // an invalid or unchanged value\n                    if (typeof newSelected !== 'boolean' || newSelected === selected) {\n                        return;\n                    }\n                    selected = newSelected;\n\n                    /**\n                     * An event that fires when selected changes on this track. This allows\n                     * the VideoTrackList that holds this track to act accordingly.\n                     *\n                     * > Note: This is not part of the spec! Native tracks will do\n                     *         this internally without an event.\n                     *\n                     * @event VideoTrack#selectedchange\n                     * @type {Event}\n                     */\n                    this.trigger('selectedchange');\n                }\n            });\n\n            // if the user sets this track to selected then\n            // set selected to that true value otherwise\n            // we keep it false\n            if (settings.selected) {\n                this.selected = settings.selected;\n            }\n        }\n    }\n\n    /**\n     * @file html-track-element.js\n     */\n\n    /**\n     * A single track represented in the DOM.\n     *\n     * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement}\n     * @extends EventTarget\n     */\n    class HTMLTrackElement extends EventTarget$2 {\n        /**\n         * Create an instance of this class.\n         *\n         * @param {Object} options={}\n         *        Object of option names and values\n         *\n         * @param { import('../tech/tech').default } options.tech\n         *        A reference to the tech that owns this HTMLTrackElement.\n         *\n         * @param {TextTrack~Kind} [options.kind='subtitles']\n         *        A valid text track kind.\n         *\n         * @param {TextTrack~Mode} [options.mode='disabled']\n         *        A valid text track mode.\n         *\n         * @param {string} [options.id='vjs_track_' + Guid.newGUID()]\n         *        A unique id for this TextTrack.\n         *\n         * @param {string} [options.label='']\n         *        The menu label for this track.\n         *\n         * @param {string} [options.language='']\n         *        A valid two character language code.\n         *\n         * @param {string} [options.srclang='']\n         *        A valid two character language code. An alternative, but deprioritized\n         *        version of `options.language`\n         *\n         * @param {string} [options.src]\n         *        A url to TextTrack cues.\n         *\n         * @param {boolean} [options.default]\n         *        If this track should default to on or off.\n         */\n        constructor(options = {}) {\n            super();\n            let readyState;\n            const track = new TextTrack(options);\n            this.kind = track.kind;\n            this.src = track.src;\n            this.srclang = track.language;\n            this.label = track.label;\n            this.default = track.default;\n            Object.defineProperties(this, {\n                /**\n                 * @memberof HTMLTrackElement\n                 * @member {HTMLTrackElement~ReadyState} readyState\n                 *         The current ready state of the track element.\n                 * @instance\n                 */\n                readyState: {\n                    get() {\n                        return readyState;\n                    }\n                },\n                /**\n                 * @memberof HTMLTrackElement\n                 * @member {TextTrack} track\n                 *         The underlying TextTrack object.\n                 * @instance\n                 *\n                 */\n                track: {\n                    get() {\n                        return track;\n                    }\n                }\n            });\n            readyState = HTMLTrackElement.NONE;\n\n            /**\n             * @listens TextTrack#loadeddata\n             * @fires HTMLTrackElement#load\n             */\n            track.addEventListener('loadeddata', () => {\n                readyState = HTMLTrackElement.LOADED;\n                this.trigger({\n                    type: 'load',\n                    target: this\n                });\n            });\n        }\n    }\n    HTMLTrackElement.prototype.allowedEvents_ = {\n        load: 'load'\n    };\n\n    /**\n     * The text track not loaded state.\n     *\n     * @type {number}\n     * @static\n     */\n    HTMLTrackElement.NONE = 0;\n\n    /**\n     * The text track loading state.\n     *\n     * @type {number}\n     * @static\n     */\n    HTMLTrackElement.LOADING = 1;\n\n    /**\n     * The text track loaded state.\n     *\n     * @type {number}\n     * @static\n     */\n    HTMLTrackElement.LOADED = 2;\n\n    /**\n     * The text track failed to load state.\n     *\n     * @type {number}\n     * @static\n     */\n    HTMLTrackElement.ERROR = 3;\n\n    /*\n   * This file contains all track properties that are used in\n   * player.js, tech.js, html5.js and possibly other techs in the future.\n   */\n\n    const NORMAL = {\n        audio: {\n            ListClass: AudioTrackList,\n            TrackClass: AudioTrack,\n            capitalName: 'Audio'\n        },\n        video: {\n            ListClass: VideoTrackList,\n            TrackClass: VideoTrack,\n            capitalName: 'Video'\n        },\n        text: {\n            ListClass: TextTrackList,\n            TrackClass: TextTrack,\n            capitalName: 'Text'\n        }\n    };\n    Object.keys(NORMAL).forEach(function (type) {\n        NORMAL[type].getterName = `${type}Tracks`;\n        NORMAL[type].privateName = `${type}Tracks_`;\n    });\n    const REMOTE = {\n        remoteText: {\n            ListClass: TextTrackList,\n            TrackClass: TextTrack,\n            capitalName: 'RemoteText',\n            getterName: 'remoteTextTracks',\n            privateName: 'remoteTextTracks_'\n        },\n        remoteTextEl: {\n            ListClass: HtmlTrackElementList,\n            TrackClass: HTMLTrackElement,\n            capitalName: 'RemoteTextTrackEls',\n            getterName: 'remoteTextTrackEls',\n            privateName: 'remoteTextTrackEls_'\n        }\n    };\n    const ALL = Object.assign({}, NORMAL, REMOTE);\n    REMOTE.names = Object.keys(REMOTE);\n    NORMAL.names = Object.keys(NORMAL);\n    ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);\n\n    var minDoc = {};\n\n    var topLevel = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : {};\n    var doccy;\n    if (typeof document !== 'undefined') {\n        doccy = document;\n    } else {\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n        if (!doccy) {\n            doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n        }\n    }\n    var document_1 = doccy;\n\n    /**\n     * Copyright 2013 vtt.js Contributors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *   http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n\n    /* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n    /* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n\n    var _objCreate = Object.create || function () {\n        function F() {}\n        return function (o) {\n            if (arguments.length !== 1) {\n                throw new Error('Object.create shim only accepts one parameter.');\n            }\n            F.prototype = o;\n            return new F();\n        };\n    }();\n\n    // Creates a new ParserError object from an errorData object. The errorData\n    // object should have default code and message properties. The default message\n    // property can be overriden by passing in a message parameter.\n    // See ParsingError.Errors below for acceptable errors.\n    function ParsingError(errorData, message) {\n        this.name = \"ParsingError\";\n        this.code = errorData.code;\n        this.message = message || errorData.message;\n    }\n    ParsingError.prototype = _objCreate(Error.prototype);\n    ParsingError.prototype.constructor = ParsingError;\n\n    // ParsingError metadata for acceptable ParsingErrors.\n    ParsingError.Errors = {\n        BadSignature: {\n            code: 0,\n            message: \"Malformed WebVTT signature.\"\n        },\n        BadTimeStamp: {\n            code: 1,\n            message: \"Malformed time stamp.\"\n        }\n    };\n\n    // Try to parse input as a time stamp.\n    function parseTimeStamp(input) {\n        function computeSeconds(h, m, s, f) {\n            return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;\n        }\n        var m = input.match(/^(\\d+):(\\d{1,2})(:\\d{1,2})?\\.(\\d{3})/);\n        if (!m) {\n            return null;\n        }\n        if (m[3]) {\n            // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]\n            return computeSeconds(m[1], m[2], m[3].replace(\":\", \"\"), m[4]);\n        } else if (m[1] > 59) {\n            // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n            // First position is hours as it's over 59.\n            return computeSeconds(m[1], m[2], 0, m[4]);\n        } else {\n            // Timestamp takes the form of [minutes]:[seconds].[milliseconds]\n            return computeSeconds(0, m[1], m[2], m[4]);\n        }\n    }\n\n    // A settings object holds key/value pairs and will ignore anything but the first\n    // assignment to a specific key.\n    function Settings() {\n        this.values = _objCreate(null);\n    }\n    Settings.prototype = {\n        // Only accept the first assignment to any key.\n        set: function (k, v) {\n            if (!this.get(k) && v !== \"\") {\n                this.values[k] = v;\n            }\n        },\n        // Return the value for a key, or a default value.\n        // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n        // a number of possible default values as properties where 'defaultKey' is\n        // the key of the property that will be chosen; otherwise it's assumed to be\n        // a single value.\n        get: function (k, dflt, defaultKey) {\n            if (defaultKey) {\n                return this.has(k) ? this.values[k] : dflt[defaultKey];\n            }\n            return this.has(k) ? this.values[k] : dflt;\n        },\n        // Check whether we have a value for a key.\n        has: function (k) {\n            return k in this.values;\n        },\n        // Accept a setting if its one of the given alternatives.\n        alt: function (k, v, a) {\n            for (var n = 0; n < a.length; ++n) {\n                if (v === a[n]) {\n                    this.set(k, v);\n                    break;\n                }\n            }\n        },\n        // Accept a setting if its a valid (signed) integer.\n        integer: function (k, v) {\n            if (/^-?\\d+$/.test(v)) {\n                // integer\n                this.set(k, parseInt(v, 10));\n            }\n        },\n        // Accept a setting if its a valid percentage.\n        percent: function (k, v) {\n            if (v.match(/^([\\d]{1,3})(\\.[\\d]*)?%$/)) {\n                v = parseFloat(v);\n                if (v >= 0 && v <= 100) {\n                    this.set(k, v);\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n\n    // Helper function to parse input into groups separated by 'groupDelim', and\n    // interprete each group as a key/value pair separated by 'keyValueDelim'.\n    function parseOptions(input, callback, keyValueDelim, groupDelim) {\n        var groups = groupDelim ? input.split(groupDelim) : [input];\n        for (var i in groups) {\n            if (typeof groups[i] !== \"string\") {\n                continue;\n            }\n            var kv = groups[i].split(keyValueDelim);\n            if (kv.length !== 2) {\n                continue;\n            }\n            var k = kv[0].trim();\n            var v = kv[1].trim();\n            callback(k, v);\n        }\n    }\n    function parseCue(input, cue, regionList) {\n        // Remember the original input if we need to throw an error.\n        var oInput = input;\n        // 4.1 WebVTT timestamp\n        function consumeTimeStamp() {\n            var ts = parseTimeStamp(input);\n            if (ts === null) {\n                throw new ParsingError(ParsingError.Errors.BadTimeStamp, \"Malformed timestamp: \" + oInput);\n            }\n            // Remove time stamp from input.\n            input = input.replace(/^[^\\sa-zA-Z-]+/, \"\");\n            return ts;\n        }\n\n        // 4.4.2 WebVTT cue settings\n        function consumeCueSettings(input, cue) {\n            var settings = new Settings();\n            parseOptions(input, function (k, v) {\n                switch (k) {\n                    case \"region\":\n                        // Find the last region we parsed with the same region id.\n                        for (var i = regionList.length - 1; i >= 0; i--) {\n                            if (regionList[i].id === v) {\n                                settings.set(k, regionList[i].region);\n                                break;\n                            }\n                        }\n                        break;\n                    case \"vertical\":\n                        settings.alt(k, v, [\"rl\", \"lr\"]);\n                        break;\n                    case \"line\":\n                        var vals = v.split(\",\"),\n                            vals0 = vals[0];\n                        settings.integer(k, vals0);\n                        settings.percent(k, vals0) ? settings.set(\"snapToLines\", false) : null;\n                        settings.alt(k, vals0, [\"auto\"]);\n                        if (vals.length === 2) {\n                            settings.alt(\"lineAlign\", vals[1], [\"start\", \"center\", \"end\"]);\n                        }\n                        break;\n                    case \"position\":\n                        vals = v.split(\",\");\n                        settings.percent(k, vals[0]);\n                        if (vals.length === 2) {\n                            settings.alt(\"positionAlign\", vals[1], [\"start\", \"center\", \"end\"]);\n                        }\n                        break;\n                    case \"size\":\n                        settings.percent(k, v);\n                        break;\n                    case \"align\":\n                        settings.alt(k, v, [\"start\", \"center\", \"end\", \"left\", \"right\"]);\n                        break;\n                }\n            }, /:/, /\\s/);\n\n            // Apply default values for any missing fields.\n            cue.region = settings.get(\"region\", null);\n            cue.vertical = settings.get(\"vertical\", \"\");\n            try {\n                cue.line = settings.get(\"line\", \"auto\");\n            } catch (e) {}\n            cue.lineAlign = settings.get(\"lineAlign\", \"start\");\n            cue.snapToLines = settings.get(\"snapToLines\", true);\n            cue.size = settings.get(\"size\", 100);\n            // Safari still uses the old middle value and won't accept center\n            try {\n                cue.align = settings.get(\"align\", \"center\");\n            } catch (e) {\n                cue.align = settings.get(\"align\", \"middle\");\n            }\n            try {\n                cue.position = settings.get(\"position\", \"auto\");\n            } catch (e) {\n                cue.position = settings.get(\"position\", {\n                    start: 0,\n                    left: 0,\n                    center: 50,\n                    middle: 50,\n                    end: 100,\n                    right: 100\n                }, cue.align);\n            }\n            cue.positionAlign = settings.get(\"positionAlign\", {\n                start: \"start\",\n                left: \"start\",\n                center: \"center\",\n                middle: \"center\",\n                end: \"end\",\n                right: \"end\"\n            }, cue.align);\n        }\n        function skipWhitespace() {\n            input = input.replace(/^\\s+/, \"\");\n        }\n\n        // 4.1 WebVTT cue timings.\n        skipWhitespace();\n        cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n        skipWhitespace();\n        if (input.substr(0, 3) !== \"-->\") {\n            // (3) next characters must match \"-->\"\n            throw new ParsingError(ParsingError.Errors.BadTimeStamp, \"Malformed time stamp (time stamps must be separated by '-->'): \" + oInput);\n        }\n        input = input.substr(3);\n        skipWhitespace();\n        cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n\n        // 4.1 WebVTT cue settings list.\n        skipWhitespace();\n        consumeCueSettings(input, cue);\n    }\n\n    // When evaluating this file as part of a Webpack bundle for server\n    // side rendering, `document` is an empty object.\n    var TEXTAREA_ELEMENT = document_1.createElement && document_1.createElement(\"textarea\");\n    var TAG_NAME = {\n        c: \"span\",\n        i: \"i\",\n        b: \"b\",\n        u: \"u\",\n        ruby: \"ruby\",\n        rt: \"rt\",\n        v: \"span\",\n        lang: \"span\"\n    };\n\n    // 5.1 default text color\n    // 5.2 default text background color is equivalent to text color with bg_ prefix\n    var DEFAULT_COLOR_CLASS = {\n        white: 'rgba(255,255,255,1)',\n        lime: 'rgba(0,255,0,1)',\n        cyan: 'rgba(0,255,255,1)',\n        red: 'rgba(255,0,0,1)',\n        yellow: 'rgba(255,255,0,1)',\n        magenta: 'rgba(255,0,255,1)',\n        blue: 'rgba(0,0,255,1)',\n        black: 'rgba(0,0,0,1)'\n    };\n    var TAG_ANNOTATION = {\n        v: \"title\",\n        lang: \"lang\"\n    };\n    var NEEDS_PARENT = {\n        rt: \"ruby\"\n    };\n\n    // Parse content into a document fragment.\n    function parseContent(window, input) {\n        function nextToken() {\n            // Check for end-of-string.\n            if (!input) {\n                return null;\n            }\n\n            // Consume 'n' characters from the input.\n            function consume(result) {\n                input = input.substr(result.length);\n                return result;\n            }\n            var m = input.match(/^([^<]*)(<[^>]*>?)?/);\n            // If there is some text before the next tag, return it, otherwise return\n            // the tag.\n            return consume(m[1] ? m[1] : m[2]);\n        }\n        function unescape(s) {\n            TEXTAREA_ELEMENT.innerHTML = s;\n            s = TEXTAREA_ELEMENT.textContent;\n            TEXTAREA_ELEMENT.textContent = \"\";\n            return s;\n        }\n        function shouldAdd(current, element) {\n            return !NEEDS_PARENT[element.localName] || NEEDS_PARENT[element.localName] === current.localName;\n        }\n\n        // Create an element for this tag.\n        function createElement(type, annotation) {\n            var tagName = TAG_NAME[type];\n            if (!tagName) {\n                return null;\n            }\n            var element = window.document.createElement(tagName);\n            var name = TAG_ANNOTATION[type];\n            if (name && annotation) {\n                element[name] = annotation.trim();\n            }\n            return element;\n        }\n        var rootDiv = window.document.createElement(\"div\"),\n            current = rootDiv,\n            t,\n            tagStack = [];\n        while ((t = nextToken()) !== null) {\n            if (t[0] === '<') {\n                if (t[1] === \"/\") {\n                    // If the closing tag matches, move back up to the parent node.\n                    if (tagStack.length && tagStack[tagStack.length - 1] === t.substr(2).replace(\">\", \"\")) {\n                        tagStack.pop();\n                        current = current.parentNode;\n                    }\n                    // Otherwise just ignore the end tag.\n                    continue;\n                }\n                var ts = parseTimeStamp(t.substr(1, t.length - 2));\n                var node;\n                if (ts) {\n                    // Timestamps are lead nodes as well.\n                    node = window.document.createProcessingInstruction(\"timestamp\", ts);\n                    current.appendChild(node);\n                    continue;\n                }\n                var m = t.match(/^<([^.\\s/0-9>]+)(\\.[^\\s\\\\>]+)?([^>\\\\]+)?(\\\\?)>?$/);\n                // If we can't parse the tag, skip to the next tag.\n                if (!m) {\n                    continue;\n                }\n                // Try to construct an element, and ignore the tag if we couldn't.\n                node = createElement(m[1], m[3]);\n                if (!node) {\n                    continue;\n                }\n                // Determine if the tag should be added based on the context of where it\n                // is placed in the cuetext.\n                if (!shouldAdd(current, node)) {\n                    continue;\n                }\n                // Set the class list (as a list of classes, separated by space).\n                if (m[2]) {\n                    var classes = m[2].split('.');\n                    classes.forEach(function (cl) {\n                        var bgColor = /^bg_/.test(cl);\n                        // slice out `bg_` if it's a background color\n                        var colorName = bgColor ? cl.slice(3) : cl;\n                        if (DEFAULT_COLOR_CLASS.hasOwnProperty(colorName)) {\n                            var propName = bgColor ? 'background-color' : 'color';\n                            var propValue = DEFAULT_COLOR_CLASS[colorName];\n                            node.style[propName] = propValue;\n                        }\n                    });\n                    node.className = classes.join(' ');\n                }\n                // Append the node to the current node, and enter the scope of the new\n                // node.\n                tagStack.push(m[1]);\n                current.appendChild(node);\n                current = node;\n                continue;\n            }\n\n            // Text nodes are leaf nodes.\n            current.appendChild(window.document.createTextNode(unescape(t)));\n        }\n        return rootDiv;\n    }\n\n    // This is a list of all the Unicode characters that have a strong\n    // right-to-left category. What this means is that these characters are\n    // written right-to-left for sure. It was generated by pulling all the strong\n    // right-to-left characters out of the Unicode data table. That table can\n    // found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt\n    var strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6], [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d], [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6], [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5], [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815], [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858], [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f], [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c], [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1], [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc], [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808], [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855], [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f], [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13], [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58], [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72], [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f], [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32], [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42], [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f], [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59], [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62], [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77], [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b], [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];\n    function isStrongRTLChar(charCode) {\n        for (var i = 0; i < strongRTLRanges.length; i++) {\n            var currentRange = strongRTLRanges[i];\n            if (charCode >= currentRange[0] && charCode <= currentRange[1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function determineBidi(cueDiv) {\n        var nodeStack = [],\n            text = \"\",\n            charCode;\n        if (!cueDiv || !cueDiv.childNodes) {\n            return \"ltr\";\n        }\n        function pushNodes(nodeStack, node) {\n            for (var i = node.childNodes.length - 1; i >= 0; i--) {\n                nodeStack.push(node.childNodes[i]);\n            }\n        }\n        function nextTextNode(nodeStack) {\n            if (!nodeStack || !nodeStack.length) {\n                return null;\n            }\n            var node = nodeStack.pop(),\n                text = node.textContent || node.innerText;\n            if (text) {\n                // TODO: This should match all unicode type B characters (paragraph\n                // separator characters). See issue #115.\n                var m = text.match(/^.*(\\n|\\r)/);\n                if (m) {\n                    nodeStack.length = 0;\n                    return m[0];\n                }\n                return text;\n            }\n            if (node.tagName === \"ruby\") {\n                return nextTextNode(nodeStack);\n            }\n            if (node.childNodes) {\n                pushNodes(nodeStack, node);\n                return nextTextNode(nodeStack);\n            }\n        }\n        pushNodes(nodeStack, cueDiv);\n        while (text = nextTextNode(nodeStack)) {\n            for (var i = 0; i < text.length; i++) {\n                charCode = text.charCodeAt(i);\n                if (isStrongRTLChar(charCode)) {\n                    return \"rtl\";\n                }\n            }\n        }\n        return \"ltr\";\n    }\n    function computeLinePos(cue) {\n        if (typeof cue.line === \"number\" && (cue.snapToLines || cue.line >= 0 && cue.line <= 100)) {\n            return cue.line;\n        }\n        if (!cue.track || !cue.track.textTrackList || !cue.track.textTrackList.mediaElement) {\n            return -1;\n        }\n        var track = cue.track,\n            trackList = track.textTrackList,\n            count = 0;\n        for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {\n            if (trackList[i].mode === \"showing\") {\n                count++;\n            }\n        }\n        return ++count * -1;\n    }\n    function StyleBox() {}\n\n    // Apply styles to a div. If there is no div passed then it defaults to the\n    // div on 'this'.\n    StyleBox.prototype.applyStyles = function (styles, div) {\n        div = div || this.div;\n        for (var prop in styles) {\n            if (styles.hasOwnProperty(prop)) {\n                div.style[prop] = styles[prop];\n            }\n        }\n    };\n    StyleBox.prototype.formatStyle = function (val, unit) {\n        return val === 0 ? 0 : val + unit;\n    };\n\n    // Constructs the computed display state of the cue (a div). Places the div\n    // into the overlay which should be a block level element (usually a div).\n    function CueStyleBox(window, cue, styleOptions) {\n        StyleBox.call(this);\n        this.cue = cue;\n\n        // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will\n        // have inline positioning and will function as the cue background box.\n        this.cueDiv = parseContent(window, cue.text);\n        var styles = {\n            color: \"rgba(255, 255, 255, 1)\",\n            backgroundColor: \"rgba(0, 0, 0, 0.8)\",\n            position: \"relative\",\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0,\n            display: \"inline\",\n            writingMode: cue.vertical === \"\" ? \"horizontal-tb\" : cue.vertical === \"lr\" ? \"vertical-lr\" : \"vertical-rl\",\n            unicodeBidi: \"plaintext\"\n        };\n        this.applyStyles(styles, this.cueDiv);\n\n        // Create an absolutely positioned div that will be used to position the cue\n        // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS\n        // mirrors of them except middle instead of center on Safari.\n        this.div = window.document.createElement(\"div\");\n        styles = {\n            direction: determineBidi(this.cueDiv),\n            writingMode: cue.vertical === \"\" ? \"horizontal-tb\" : cue.vertical === \"lr\" ? \"vertical-lr\" : \"vertical-rl\",\n            unicodeBidi: \"plaintext\",\n            textAlign: cue.align === \"middle\" ? \"center\" : cue.align,\n            font: styleOptions.font,\n            whiteSpace: \"pre-line\",\n            position: \"absolute\"\n        };\n        this.applyStyles(styles);\n        this.div.appendChild(this.cueDiv);\n\n        // Calculate the distance from the reference edge of the viewport to the text\n        // position of the cue box. The reference edge will be resolved later when\n        // the box orientation styles are applied.\n        var textPos = 0;\n        switch (cue.positionAlign) {\n            case \"start\":\n                textPos = cue.position;\n                break;\n            case \"center\":\n                textPos = cue.position - cue.size / 2;\n                break;\n            case \"end\":\n                textPos = cue.position - cue.size;\n                break;\n        }\n\n        // Horizontal box orientation; textPos is the distance from the left edge of the\n        // area to the left edge of the box and cue.size is the distance extending to\n        // the right from there.\n        if (cue.vertical === \"\") {\n            this.applyStyles({\n                left: this.formatStyle(textPos, \"%\"),\n                width: this.formatStyle(cue.size, \"%\")\n            });\n            // Vertical box orientation; textPos is the distance from the top edge of the\n            // area to the top edge of the box and cue.size is the height extending\n            // downwards from there.\n        } else {\n            this.applyStyles({\n                top: this.formatStyle(textPos, \"%\"),\n                height: this.formatStyle(cue.size, \"%\")\n            });\n        }\n        this.move = function (box) {\n            this.applyStyles({\n                top: this.formatStyle(box.top, \"px\"),\n                bottom: this.formatStyle(box.bottom, \"px\"),\n                left: this.formatStyle(box.left, \"px\"),\n                right: this.formatStyle(box.right, \"px\"),\n                height: this.formatStyle(box.height, \"px\"),\n                width: this.formatStyle(box.width, \"px\")\n            });\n        };\n    }\n    CueStyleBox.prototype = _objCreate(StyleBox.prototype);\n    CueStyleBox.prototype.constructor = CueStyleBox;\n\n    // Represents the co-ordinates of an Element in a way that we can easily\n    // compute things with such as if it overlaps or intersects with another Element.\n    // Can initialize it with either a StyleBox or another BoxPosition.\n    function BoxPosition(obj) {\n        // Either a BoxPosition was passed in and we need to copy it, or a StyleBox\n        // was passed in and we need to copy the results of 'getBoundingClientRect'\n        // as the object returned is readonly. All co-ordinate values are in reference\n        // to the viewport origin (top left).\n        var lh, height, width, top;\n        if (obj.div) {\n            height = obj.div.offsetHeight;\n            width = obj.div.offsetWidth;\n            top = obj.div.offsetTop;\n            var rects = (rects = obj.div.childNodes) && (rects = rects[0]) && rects.getClientRects && rects.getClientRects();\n            obj = obj.div.getBoundingClientRect();\n            // In certain cases the outter div will be slightly larger then the sum of\n            // the inner div's lines. This could be due to bold text, etc, on some platforms.\n            // In this case we should get the average line height and use that. This will\n            // result in the desired behaviour.\n            lh = rects ? Math.max(rects[0] && rects[0].height || 0, obj.height / rects.length) : 0;\n        }\n        this.left = obj.left;\n        this.right = obj.right;\n        this.top = obj.top || top;\n        this.height = obj.height || height;\n        this.bottom = obj.bottom || top + (obj.height || height);\n        this.width = obj.width || width;\n        this.lineHeight = lh !== undefined ? lh : obj.lineHeight;\n    }\n\n    // Move the box along a particular axis. Optionally pass in an amount to move\n    // the box. If no amount is passed then the default is the line height of the\n    // box.\n    BoxPosition.prototype.move = function (axis, toMove) {\n        toMove = toMove !== undefined ? toMove : this.lineHeight;\n        switch (axis) {\n            case \"+x\":\n                this.left += toMove;\n                this.right += toMove;\n                break;\n            case \"-x\":\n                this.left -= toMove;\n                this.right -= toMove;\n                break;\n            case \"+y\":\n                this.top += toMove;\n                this.bottom += toMove;\n                break;\n            case \"-y\":\n                this.top -= toMove;\n                this.bottom -= toMove;\n                break;\n        }\n    };\n\n    // Check if this box overlaps another box, b2.\n    BoxPosition.prototype.overlaps = function (b2) {\n        return this.left < b2.right && this.right > b2.left && this.top < b2.bottom && this.bottom > b2.top;\n    };\n\n    // Check if this box overlaps any other boxes in boxes.\n    BoxPosition.prototype.overlapsAny = function (boxes) {\n        for (var i = 0; i < boxes.length; i++) {\n            if (this.overlaps(boxes[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    // Check if this box is within another box.\n    BoxPosition.prototype.within = function (container) {\n        return this.top >= container.top && this.bottom <= container.bottom && this.left >= container.left && this.right <= container.right;\n    };\n\n    // Check if this box is entirely within the container or it is overlapping\n    // on the edge opposite of the axis direction passed. For example, if \"+x\" is\n    // passed and the box is overlapping on the left edge of the container, then\n    // return true.\n    BoxPosition.prototype.overlapsOppositeAxis = function (container, axis) {\n        switch (axis) {\n            case \"+x\":\n                return this.left < container.left;\n            case \"-x\":\n                return this.right > container.right;\n            case \"+y\":\n                return this.top < container.top;\n            case \"-y\":\n                return this.bottom > container.bottom;\n        }\n    };\n\n    // Find the percentage of the area that this box is overlapping with another\n    // box.\n    BoxPosition.prototype.intersectPercentage = function (b2) {\n        var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),\n            y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),\n            intersectArea = x * y;\n        return intersectArea / (this.height * this.width);\n    };\n\n    // Convert the positions from this box to CSS compatible positions using\n    // the reference container's positions. This has to be done because this\n    // box's positions are in reference to the viewport origin, whereas, CSS\n    // values are in referecne to their respective edges.\n    BoxPosition.prototype.toCSSCompatValues = function (reference) {\n        return {\n            top: this.top - reference.top,\n            bottom: reference.bottom - this.bottom,\n            left: this.left - reference.left,\n            right: reference.right - this.right,\n            height: this.height,\n            width: this.width\n        };\n    };\n\n    // Get an object that represents the box's position without anything extra.\n    // Can pass a StyleBox, HTMLElement, or another BoxPositon.\n    BoxPosition.getSimpleBoxPosition = function (obj) {\n        var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;\n        var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;\n        var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;\n        obj = obj.div ? obj.div.getBoundingClientRect() : obj.tagName ? obj.getBoundingClientRect() : obj;\n        var ret = {\n            left: obj.left,\n            right: obj.right,\n            top: obj.top || top,\n            height: obj.height || height,\n            bottom: obj.bottom || top + (obj.height || height),\n            width: obj.width || width\n        };\n        return ret;\n    };\n\n    // Move a StyleBox to its specified, or next best, position. The containerBox\n    // is the box that contains the StyleBox, such as a div. boxPositions are\n    // a list of other boxes that the styleBox can't overlap with.\n    function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {\n        // Find the best position for a cue box, b, on the video. The axis parameter\n        // is a list of axis, the order of which, it will move the box along. For example:\n        // Passing [\"+x\", \"-x\"] will move the box first along the x axis in the positive\n        // direction. If it doesn't find a good position for it there it will then move\n        // it along the x axis in the negative direction.\n        function findBestPosition(b, axis) {\n            var bestPosition,\n                specifiedPosition = new BoxPosition(b),\n                percentage = 1; // Highest possible so the first thing we get is better.\n\n            for (var i = 0; i < axis.length; i++) {\n                while (b.overlapsOppositeAxis(containerBox, axis[i]) || b.within(containerBox) && b.overlapsAny(boxPositions)) {\n                    b.move(axis[i]);\n                }\n                // We found a spot where we aren't overlapping anything. This is our\n                // best position.\n                if (b.within(containerBox)) {\n                    return b;\n                }\n                var p = b.intersectPercentage(containerBox);\n                // If we're outside the container box less then we were on our last try\n                // then remember this position as the best position.\n                if (percentage > p) {\n                    bestPosition = new BoxPosition(b);\n                    percentage = p;\n                }\n                // Reset the box position to the specified position.\n                b = new BoxPosition(specifiedPosition);\n            }\n            return bestPosition || specifiedPosition;\n        }\n        var boxPosition = new BoxPosition(styleBox),\n            cue = styleBox.cue,\n            linePos = computeLinePos(cue),\n            axis = [];\n\n        // If we have a line number to align the cue to.\n        if (cue.snapToLines) {\n            var size;\n            switch (cue.vertical) {\n                case \"\":\n                    axis = [\"+y\", \"-y\"];\n                    size = \"height\";\n                    break;\n                case \"rl\":\n                    axis = [\"+x\", \"-x\"];\n                    size = \"width\";\n                    break;\n                case \"lr\":\n                    axis = [\"-x\", \"+x\"];\n                    size = \"width\";\n                    break;\n            }\n            var step = boxPosition.lineHeight,\n                position = step * Math.round(linePos),\n                maxPosition = containerBox[size] + step,\n                initialAxis = axis[0];\n\n            // If the specified intial position is greater then the max position then\n            // clamp the box to the amount of steps it would take for the box to\n            // reach the max position.\n            if (Math.abs(position) > maxPosition) {\n                position = position < 0 ? -1 : 1;\n                position *= Math.ceil(maxPosition / step) * step;\n            }\n\n            // If computed line position returns negative then line numbers are\n            // relative to the bottom of the video instead of the top. Therefore, we\n            // need to increase our initial position by the length or width of the\n            // video, depending on the writing direction, and reverse our axis directions.\n            if (linePos < 0) {\n                position += cue.vertical === \"\" ? containerBox.height : containerBox.width;\n                axis = axis.reverse();\n            }\n\n            // Move the box to the specified position. This may not be its best\n            // position.\n            boxPosition.move(initialAxis, position);\n        } else {\n            // If we have a percentage line value for the cue.\n            var calculatedPercentage = boxPosition.lineHeight / containerBox.height * 100;\n            switch (cue.lineAlign) {\n                case \"center\":\n                    linePos -= calculatedPercentage / 2;\n                    break;\n                case \"end\":\n                    linePos -= calculatedPercentage;\n                    break;\n            }\n\n            // Apply initial line position to the cue box.\n            switch (cue.vertical) {\n                case \"\":\n                    styleBox.applyStyles({\n                        top: styleBox.formatStyle(linePos, \"%\")\n                    });\n                    break;\n                case \"rl\":\n                    styleBox.applyStyles({\n                        left: styleBox.formatStyle(linePos, \"%\")\n                    });\n                    break;\n                case \"lr\":\n                    styleBox.applyStyles({\n                        right: styleBox.formatStyle(linePos, \"%\")\n                    });\n                    break;\n            }\n            axis = [\"+y\", \"-x\", \"+x\", \"-y\"];\n\n            // Get the box position again after we've applied the specified positioning\n            // to it.\n            boxPosition = new BoxPosition(styleBox);\n        }\n        var bestPosition = findBestPosition(boxPosition, axis);\n        styleBox.move(bestPosition.toCSSCompatValues(containerBox));\n    }\n    function WebVTT$1() {\n        // Nothing\n    }\n\n    // Helper to allow strings to be decoded instead of the default binary utf8 data.\n    WebVTT$1.StringDecoder = function () {\n        return {\n            decode: function (data) {\n                if (!data) {\n                    return \"\";\n                }\n                if (typeof data !== \"string\") {\n                    throw new Error(\"Error - expected string data.\");\n                }\n                return decodeURIComponent(encodeURIComponent(data));\n            }\n        };\n    };\n    WebVTT$1.convertCueToDOMTree = function (window, cuetext) {\n        if (!window || !cuetext) {\n            return null;\n        }\n        return parseContent(window, cuetext);\n    };\n    var FONT_SIZE_PERCENT = 0.05;\n    var FONT_STYLE = \"sans-serif\";\n    var CUE_BACKGROUND_PADDING = \"1.5%\";\n\n    // Runs the processing model over the cues and regions passed to it.\n    // @param overlay A block level element (usually a div) that the computed cues\n    //                and regions will be placed into.\n    WebVTT$1.processCues = function (window, cues, overlay) {\n        if (!window || !cues || !overlay) {\n            return null;\n        }\n\n        // Remove all previous children.\n        while (overlay.firstChild) {\n            overlay.removeChild(overlay.firstChild);\n        }\n        var paddedOverlay = window.document.createElement(\"div\");\n        paddedOverlay.style.position = \"absolute\";\n        paddedOverlay.style.left = \"0\";\n        paddedOverlay.style.right = \"0\";\n        paddedOverlay.style.top = \"0\";\n        paddedOverlay.style.bottom = \"0\";\n        paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;\n        overlay.appendChild(paddedOverlay);\n\n        // Determine if we need to compute the display states of the cues. This could\n        // be the case if a cue's state has been changed since the last computation or\n        // if it has not been computed yet.\n        function shouldCompute(cues) {\n            for (var i = 0; i < cues.length; i++) {\n                if (cues[i].hasBeenReset || !cues[i].displayState) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        // We don't need to recompute the cues' display states. Just reuse them.\n        if (!shouldCompute(cues)) {\n            for (var i = 0; i < cues.length; i++) {\n                paddedOverlay.appendChild(cues[i].displayState);\n            }\n            return;\n        }\n        var boxPositions = [],\n            containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),\n            fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;\n        var styleOptions = {\n            font: fontSize + \"px \" + FONT_STYLE\n        };\n        (function () {\n            var styleBox, cue;\n            for (var i = 0; i < cues.length; i++) {\n                cue = cues[i];\n\n                // Compute the intial position and styles of the cue div.\n                styleBox = new CueStyleBox(window, cue, styleOptions);\n                paddedOverlay.appendChild(styleBox.div);\n\n                // Move the cue div to it's correct line position.\n                moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);\n\n                // Remember the computed div so that we don't have to recompute it later\n                // if we don't have too.\n                cue.displayState = styleBox.div;\n                boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));\n            }\n        })();\n    };\n    WebVTT$1.Parser = function (window, vttjs, decoder) {\n        if (!decoder) {\n            decoder = vttjs;\n            vttjs = {};\n        }\n        if (!vttjs) {\n            vttjs = {};\n        }\n        this.window = window;\n        this.vttjs = vttjs;\n        this.state = \"INITIAL\";\n        this.buffer = \"\";\n        this.decoder = decoder || new TextDecoder(\"utf8\");\n        this.regionList = [];\n    };\n    WebVTT$1.Parser.prototype = {\n        // If the error is a ParsingError then report it to the consumer if\n        // possible. If it's not a ParsingError then throw it like normal.\n        reportOrThrowError: function (e) {\n            if (e instanceof ParsingError) {\n                this.onparsingerror && this.onparsingerror(e);\n            } else {\n                throw e;\n            }\n        },\n        parse: function (data) {\n            var self = this;\n\n            // If there is no data then we won't decode it, but will just try to parse\n            // whatever is in buffer already. This may occur in circumstances, for\n            // example when flush() is called.\n            if (data) {\n                // Try to decode the data that we received.\n                self.buffer += self.decoder.decode(data, {\n                    stream: true\n                });\n            }\n            function collectNextLine() {\n                var buffer = self.buffer;\n                var pos = 0;\n                while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n                    ++pos;\n                }\n                var line = buffer.substr(0, pos);\n                // Advance the buffer early in case we fail below.\n                if (buffer[pos] === '\\r') {\n                    ++pos;\n                }\n                if (buffer[pos] === '\\n') {\n                    ++pos;\n                }\n                self.buffer = buffer.substr(pos);\n                return line;\n            }\n\n            // 3.4 WebVTT region and WebVTT region settings syntax\n            function parseRegion(input) {\n                var settings = new Settings();\n                parseOptions(input, function (k, v) {\n                    switch (k) {\n                        case \"id\":\n                            settings.set(k, v);\n                            break;\n                        case \"width\":\n                            settings.percent(k, v);\n                            break;\n                        case \"lines\":\n                            settings.integer(k, v);\n                            break;\n                        case \"regionanchor\":\n                        case \"viewportanchor\":\n                            var xy = v.split(',');\n                            if (xy.length !== 2) {\n                                break;\n                            }\n                            // We have to make sure both x and y parse, so use a temporary\n                            // settings object here.\n                            var anchor = new Settings();\n                            anchor.percent(\"x\", xy[0]);\n                            anchor.percent(\"y\", xy[1]);\n                            if (!anchor.has(\"x\") || !anchor.has(\"y\")) {\n                                break;\n                            }\n                            settings.set(k + \"X\", anchor.get(\"x\"));\n                            settings.set(k + \"Y\", anchor.get(\"y\"));\n                            break;\n                        case \"scroll\":\n                            settings.alt(k, v, [\"up\"]);\n                            break;\n                    }\n                }, /=/, /\\s/);\n\n                // Create the region, using default values for any values that were not\n                // specified.\n                if (settings.has(\"id\")) {\n                    var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();\n                    region.width = settings.get(\"width\", 100);\n                    region.lines = settings.get(\"lines\", 3);\n                    region.regionAnchorX = settings.get(\"regionanchorX\", 0);\n                    region.regionAnchorY = settings.get(\"regionanchorY\", 100);\n                    region.viewportAnchorX = settings.get(\"viewportanchorX\", 0);\n                    region.viewportAnchorY = settings.get(\"viewportanchorY\", 100);\n                    region.scroll = settings.get(\"scroll\", \"\");\n                    // Register the region.\n                    self.onregion && self.onregion(region);\n                    // Remember the VTTRegion for later in case we parse any VTTCues that\n                    // reference it.\n                    self.regionList.push({\n                        id: settings.get(\"id\"),\n                        region: region\n                    });\n                }\n            }\n\n            // draft-pantos-http-live-streaming-20\n            // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-3.5\n            // 3.5 WebVTT\n            function parseTimestampMap(input) {\n                var settings = new Settings();\n                parseOptions(input, function (k, v) {\n                    switch (k) {\n                        case \"MPEGT\":\n                            settings.integer(k + 'S', v);\n                            break;\n                        case \"LOCA\":\n                            settings.set(k + 'L', parseTimeStamp(v));\n                            break;\n                    }\n                }, /[^\\d]:/, /,/);\n                self.ontimestampmap && self.ontimestampmap({\n                    \"MPEGTS\": settings.get(\"MPEGTS\"),\n                    \"LOCAL\": settings.get(\"LOCAL\")\n                });\n            }\n\n            // 3.2 WebVTT metadata header syntax\n            function parseHeader(input) {\n                if (input.match(/X-TIMESTAMP-MAP/)) {\n                    // This line contains HLS X-TIMESTAMP-MAP metadata\n                    parseOptions(input, function (k, v) {\n                        switch (k) {\n                            case \"X-TIMESTAMP-MAP\":\n                                parseTimestampMap(v);\n                                break;\n                        }\n                    }, /=/);\n                } else {\n                    parseOptions(input, function (k, v) {\n                        switch (k) {\n                            case \"Region\":\n                                // 3.3 WebVTT region metadata header syntax\n                                parseRegion(v);\n                                break;\n                        }\n                    }, /:/);\n                }\n            }\n\n            // 5.1 WebVTT file parsing.\n            try {\n                var line;\n                if (self.state === \"INITIAL\") {\n                    // We can't start parsing until we have the first line.\n                    if (!/\\r\\n|\\n/.test(self.buffer)) {\n                        return this;\n                    }\n                    line = collectNextLine();\n                    var m = line.match(/^WEBVTT([ \\t].*)?$/);\n                    if (!m || !m[0]) {\n                        throw new ParsingError(ParsingError.Errors.BadSignature);\n                    }\n                    self.state = \"HEADER\";\n                }\n                var alreadyCollectedLine = false;\n                while (self.buffer) {\n                    // We can't parse a line until we have the full line.\n                    if (!/\\r\\n|\\n/.test(self.buffer)) {\n                        return this;\n                    }\n                    if (!alreadyCollectedLine) {\n                        line = collectNextLine();\n                    } else {\n                        alreadyCollectedLine = false;\n                    }\n                    switch (self.state) {\n                        case \"HEADER\":\n                            // 13-18 - Allow a header (metadata) under the WEBVTT line.\n                            if (/:/.test(line)) {\n                                parseHeader(line);\n                            } else if (!line) {\n                                // An empty line terminates the header and starts the body (cues).\n                                self.state = \"ID\";\n                            }\n                            continue;\n                        case \"NOTE\":\n                            // Ignore NOTE blocks.\n                            if (!line) {\n                                self.state = \"ID\";\n                            }\n                            continue;\n                        case \"ID\":\n                            // Check for the start of NOTE blocks.\n                            if (/^NOTE($|[ \\t])/.test(line)) {\n                                self.state = \"NOTE\";\n                                break;\n                            }\n                            // 19-29 - Allow any number of line terminators, then initialize new cue values.\n                            if (!line) {\n                                continue;\n                            }\n                            self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, \"\");\n                            // Safari still uses the old middle value and won't accept center\n                            try {\n                                self.cue.align = \"center\";\n                            } catch (e) {\n                                self.cue.align = \"middle\";\n                            }\n                            self.state = \"CUE\";\n                            // 30-39 - Check if self line contains an optional identifier or timing data.\n                            if (line.indexOf(\"-->\") === -1) {\n                                self.cue.id = line;\n                                continue;\n                            }\n                        // Process line as start of a cue.\n                        /*falls through*/\n                        case \"CUE\":\n                            // 40 - Collect cue timings and settings.\n                            try {\n                                parseCue(line, self.cue, self.regionList);\n                            } catch (e) {\n                                self.reportOrThrowError(e);\n                                // In case of an error ignore rest of the cue.\n                                self.cue = null;\n                                self.state = \"BADCUE\";\n                                continue;\n                            }\n                            self.state = \"CUETEXT\";\n                            continue;\n                        case \"CUETEXT\":\n                            var hasSubstring = line.indexOf(\"-->\") !== -1;\n                            // 34 - If we have an empty line then report the cue.\n                            // 35 - If we have the special substring '-->' then report the cue,\n                            // but do not collect the line as we need to process the current\n                            // one as a new cue.\n                            if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n                                // We are done parsing self cue.\n                                self.oncue && self.oncue(self.cue);\n                                self.cue = null;\n                                self.state = \"ID\";\n                                continue;\n                            }\n                            if (self.cue.text) {\n                                self.cue.text += \"\\n\";\n                            }\n                            self.cue.text += line.replace(/\\u2028/g, '\\n').replace(/u2029/g, '\\n');\n                            continue;\n                        case \"BADCUE\":\n                            // BADCUE\n                            // 54-62 - Collect and discard the remaining cue.\n                            if (!line) {\n                                self.state = \"ID\";\n                            }\n                            continue;\n                    }\n                }\n            } catch (e) {\n                self.reportOrThrowError(e);\n\n                // If we are currently parsing a cue, report what we have.\n                if (self.state === \"CUETEXT\" && self.cue && self.oncue) {\n                    self.oncue(self.cue);\n                }\n                self.cue = null;\n                // Enter BADWEBVTT state if header was not parsed correctly otherwise\n                // another exception occurred so enter BADCUE state.\n                self.state = self.state === \"INITIAL\" ? \"BADWEBVTT\" : \"BADCUE\";\n            }\n            return this;\n        },\n        flush: function () {\n            var self = this;\n            try {\n                // Finish decoding the stream.\n                self.buffer += self.decoder.decode();\n                // Synthesize the end of the current cue or region.\n                if (self.cue || self.state === \"HEADER\") {\n                    self.buffer += \"\\n\\n\";\n                    self.parse();\n                }\n                // If we've flushed, parsed, and we're still on the INITIAL state then\n                // that means we don't have enough of the stream to parse the first\n                // line.\n                if (self.state === \"INITIAL\") {\n                    throw new ParsingError(ParsingError.Errors.BadSignature);\n                }\n            } catch (e) {\n                self.reportOrThrowError(e);\n            }\n            self.onflush && self.onflush();\n            return this;\n        }\n    };\n    var vtt = WebVTT$1;\n\n    /**\n     * Copyright 2013 vtt.js Contributors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *   http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n\n    var autoKeyword = \"auto\";\n    var directionSetting = {\n        \"\": 1,\n        \"lr\": 1,\n        \"rl\": 1\n    };\n    var alignSetting = {\n        \"start\": 1,\n        \"center\": 1,\n        \"end\": 1,\n        \"left\": 1,\n        \"right\": 1,\n        \"auto\": 1,\n        \"line-left\": 1,\n        \"line-right\": 1\n    };\n    function findDirectionSetting(value) {\n        if (typeof value !== \"string\") {\n            return false;\n        }\n        var dir = directionSetting[value.toLowerCase()];\n        return dir ? value.toLowerCase() : false;\n    }\n    function findAlignSetting(value) {\n        if (typeof value !== \"string\") {\n            return false;\n        }\n        var align = alignSetting[value.toLowerCase()];\n        return align ? value.toLowerCase() : false;\n    }\n    function VTTCue(startTime, endTime, text) {\n        /**\n         * Shim implementation specific properties. These properties are not in\n         * the spec.\n         */\n\n        // Lets us know when the VTTCue's data has changed in such a way that we need\n        // to recompute its display state. This lets us compute its display state\n        // lazily.\n        this.hasBeenReset = false;\n\n        /**\n         * VTTCue and TextTrackCue properties\n         * http://dev.w3.org/html5/webvtt/#vttcue-interface\n         */\n\n        var _id = \"\";\n        var _pauseOnExit = false;\n        var _startTime = startTime;\n        var _endTime = endTime;\n        var _text = text;\n        var _region = null;\n        var _vertical = \"\";\n        var _snapToLines = true;\n        var _line = \"auto\";\n        var _lineAlign = \"start\";\n        var _position = \"auto\";\n        var _positionAlign = \"auto\";\n        var _size = 100;\n        var _align = \"center\";\n        Object.defineProperties(this, {\n            \"id\": {\n                enumerable: true,\n                get: function () {\n                    return _id;\n                },\n                set: function (value) {\n                    _id = \"\" + value;\n                }\n            },\n            \"pauseOnExit\": {\n                enumerable: true,\n                get: function () {\n                    return _pauseOnExit;\n                },\n                set: function (value) {\n                    _pauseOnExit = !!value;\n                }\n            },\n            \"startTime\": {\n                enumerable: true,\n                get: function () {\n                    return _startTime;\n                },\n                set: function (value) {\n                    if (typeof value !== \"number\") {\n                        throw new TypeError(\"Start time must be set to a number.\");\n                    }\n                    _startTime = value;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"endTime\": {\n                enumerable: true,\n                get: function () {\n                    return _endTime;\n                },\n                set: function (value) {\n                    if (typeof value !== \"number\") {\n                        throw new TypeError(\"End time must be set to a number.\");\n                    }\n                    _endTime = value;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"text\": {\n                enumerable: true,\n                get: function () {\n                    return _text;\n                },\n                set: function (value) {\n                    _text = \"\" + value;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"region\": {\n                enumerable: true,\n                get: function () {\n                    return _region;\n                },\n                set: function (value) {\n                    _region = value;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"vertical\": {\n                enumerable: true,\n                get: function () {\n                    return _vertical;\n                },\n                set: function (value) {\n                    var setting = findDirectionSetting(value);\n                    // Have to check for false because the setting an be an empty string.\n                    if (setting === false) {\n                        throw new SyntaxError(\"Vertical: an invalid or illegal direction string was specified.\");\n                    }\n                    _vertical = setting;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"snapToLines\": {\n                enumerable: true,\n                get: function () {\n                    return _snapToLines;\n                },\n                set: function (value) {\n                    _snapToLines = !!value;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"line\": {\n                enumerable: true,\n                get: function () {\n                    return _line;\n                },\n                set: function (value) {\n                    if (typeof value !== \"number\" && value !== autoKeyword) {\n                        throw new SyntaxError(\"Line: an invalid number or illegal string was specified.\");\n                    }\n                    _line = value;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"lineAlign\": {\n                enumerable: true,\n                get: function () {\n                    return _lineAlign;\n                },\n                set: function (value) {\n                    var setting = findAlignSetting(value);\n                    if (!setting) {\n                        console.warn(\"lineAlign: an invalid or illegal string was specified.\");\n                    } else {\n                        _lineAlign = setting;\n                        this.hasBeenReset = true;\n                    }\n                }\n            },\n            \"position\": {\n                enumerable: true,\n                get: function () {\n                    return _position;\n                },\n                set: function (value) {\n                    if (value < 0 || value > 100) {\n                        throw new Error(\"Position must be between 0 and 100.\");\n                    }\n                    _position = value;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"positionAlign\": {\n                enumerable: true,\n                get: function () {\n                    return _positionAlign;\n                },\n                set: function (value) {\n                    var setting = findAlignSetting(value);\n                    if (!setting) {\n                        console.warn(\"positionAlign: an invalid or illegal string was specified.\");\n                    } else {\n                        _positionAlign = setting;\n                        this.hasBeenReset = true;\n                    }\n                }\n            },\n            \"size\": {\n                enumerable: true,\n                get: function () {\n                    return _size;\n                },\n                set: function (value) {\n                    if (value < 0 || value > 100) {\n                        throw new Error(\"Size must be between 0 and 100.\");\n                    }\n                    _size = value;\n                    this.hasBeenReset = true;\n                }\n            },\n            \"align\": {\n                enumerable: true,\n                get: function () {\n                    return _align;\n                },\n                set: function (value) {\n                    var setting = findAlignSetting(value);\n                    if (!setting) {\n                        throw new SyntaxError(\"align: an invalid or illegal alignment string was specified.\");\n                    }\n                    _align = setting;\n                    this.hasBeenReset = true;\n                }\n            }\n        });\n\n        /**\n         * Other <track> spec defined properties\n         */\n\n        // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n        this.displayState = undefined;\n    }\n\n    /**\n     * VTTCue methods\n     */\n\n    VTTCue.prototype.getCueAsHTML = function () {\n        // Assume WebVTT.convertCueToDOMTree is on the global.\n        return WebVTT.convertCueToDOMTree(window, this.text);\n    };\n    var vttcue = VTTCue;\n\n    /**\n     * Copyright 2013 vtt.js Contributors\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *   http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     */\n\n    var scrollSetting = {\n        \"\": true,\n        \"up\": true\n    };\n    function findScrollSetting(value) {\n        if (typeof value !== \"string\") {\n            return false;\n        }\n        var scroll = scrollSetting[value.toLowerCase()];\n        return scroll ? value.toLowerCase() : false;\n    }\n    function isValidPercentValue(value) {\n        return typeof value === \"number\" && value >= 0 && value <= 100;\n    }\n\n    // VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface\n    function VTTRegion() {\n        var _width = 100;\n        var _lines = 3;\n        var _regionAnchorX = 0;\n        var _regionAnchorY = 100;\n        var _viewportAnchorX = 0;\n        var _viewportAnchorY = 100;\n        var _scroll = \"\";\n        Object.defineProperties(this, {\n            \"width\": {\n                enumerable: true,\n                get: function () {\n                    return _width;\n                },\n                set: function (value) {\n                    if (!isValidPercentValue(value)) {\n                        throw new Error(\"Width must be between 0 and 100.\");\n                    }\n                    _width = value;\n                }\n            },\n            \"lines\": {\n                enumerable: true,\n                get: function () {\n                    return _lines;\n                },\n                set: function (value) {\n                    if (typeof value !== \"number\") {\n                        throw new TypeError(\"Lines must be set to a number.\");\n                    }\n                    _lines = value;\n                }\n            },\n            \"regionAnchorY\": {\n                enumerable: true,\n                get: function () {\n                    return _regionAnchorY;\n                },\n                set: function (value) {\n                    if (!isValidPercentValue(value)) {\n                        throw new Error(\"RegionAnchorX must be between 0 and 100.\");\n                    }\n                    _regionAnchorY = value;\n                }\n            },\n            \"regionAnchorX\": {\n                enumerable: true,\n                get: function () {\n                    return _regionAnchorX;\n                },\n                set: function (value) {\n                    if (!isValidPercentValue(value)) {\n                        throw new Error(\"RegionAnchorY must be between 0 and 100.\");\n                    }\n                    _regionAnchorX = value;\n                }\n            },\n            \"viewportAnchorY\": {\n                enumerable: true,\n                get: function () {\n                    return _viewportAnchorY;\n                },\n                set: function (value) {\n                    if (!isValidPercentValue(value)) {\n                        throw new Error(\"ViewportAnchorY must be between 0 and 100.\");\n                    }\n                    _viewportAnchorY = value;\n                }\n            },\n            \"viewportAnchorX\": {\n                enumerable: true,\n                get: function () {\n                    return _viewportAnchorX;\n                },\n                set: function (value) {\n                    if (!isValidPercentValue(value)) {\n                        throw new Error(\"ViewportAnchorX must be between 0 and 100.\");\n                    }\n                    _viewportAnchorX = value;\n                }\n            },\n            \"scroll\": {\n                enumerable: true,\n                get: function () {\n                    return _scroll;\n                },\n                set: function (value) {\n                    var setting = findScrollSetting(value);\n                    // Have to check for false as an empty string is a legal value.\n                    if (setting === false) {\n                        console.warn(\"Scroll: an invalid or illegal string was specified.\");\n                    } else {\n                        _scroll = setting;\n                    }\n                }\n            }\n        });\n    }\n    var vttregion = VTTRegion;\n\n    var browserIndex = createCommonjsModule(function (module) {\n        /**\n         * Copyright 2013 vtt.js Contributors\n         *\n         * Licensed under the Apache License, Version 2.0 (the \"License\");\n         * you may not use this file except in compliance with the License.\n         * You may obtain a copy of the License at\n         *\n         *   http://www.apache.org/licenses/LICENSE-2.0\n         *\n         * Unless required by applicable law or agreed to in writing, software\n         * distributed under the License is distributed on an \"AS IS\" BASIS,\n         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n         * See the License for the specific language governing permissions and\n         * limitations under the License.\n         */\n\n            // Default exports for Node. Export the extended versions of VTTCue and\n            // VTTRegion in Node since we likely want the capability to convert back and\n            // forth between JSON. If we don't then it's not that big of a deal since we're\n            // off browser.\n\n        var vttjs = module.exports = {\n                WebVTT: vtt,\n                VTTCue: vttcue,\n                VTTRegion: vttregion\n            };\n        window_1.vttjs = vttjs;\n        window_1.WebVTT = vttjs.WebVTT;\n        var cueShim = vttjs.VTTCue;\n        var regionShim = vttjs.VTTRegion;\n        var nativeVTTCue = window_1.VTTCue;\n        var nativeVTTRegion = window_1.VTTRegion;\n        vttjs.shim = function () {\n            window_1.VTTCue = cueShim;\n            window_1.VTTRegion = regionShim;\n        };\n        vttjs.restore = function () {\n            window_1.VTTCue = nativeVTTCue;\n            window_1.VTTRegion = nativeVTTRegion;\n        };\n        if (!window_1.VTTCue) {\n            vttjs.shim();\n        }\n    });\n    browserIndex.WebVTT;\n    browserIndex.VTTCue;\n    browserIndex.VTTRegion;\n\n    /**\n     * @file tech.js\n     */\n\n    /**\n     * An Object containing a structure like: `{src: 'url', type: 'mimetype'}` or string\n     * that just contains the src url alone.\n     * * `var SourceObject = {src: 'http://ex.com/video.mp4', type: 'video/mp4'};`\n     * `var SourceString = 'http://example.com/some-video.mp4';`\n     *\n     * @typedef {Object|string} Tech~SourceObject\n     *\n     * @property {string} src\n     *           The url to the source\n     *\n     * @property {string} type\n     *           The mime type of the source\n     */\n\n    /**\n     * A function used by {@link Tech} to create a new {@link TextTrack}.\n     *\n     * @private\n     *\n     * @param {Tech} self\n     *        An instance of the Tech class.\n     *\n     * @param {string} kind\n     *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n     *\n     * @param {string} [label]\n     *        Label to identify the text track\n     *\n     * @param {string} [language]\n     *        Two letter language abbreviation\n     *\n     * @param {Object} [options={}]\n     *        An object with additional text track options\n     *\n     * @return {TextTrack}\n     *          The text track that was created.\n     */\n    function createTrackHelper(self, kind, label, language, options = {}) {\n        const tracks = self.textTracks();\n        options.kind = kind;\n        if (label) {\n            options.label = label;\n        }\n        if (language) {\n            options.language = language;\n        }\n        options.tech = self;\n        const track = new ALL.text.TrackClass(options);\n        tracks.addTrack(track);\n        return track;\n    }\n\n    /**\n     * This is the base class for media playback technology controllers, such as\n     * {@link HTML5}\n     *\n     * @extends Component\n     */\n    class Tech extends Component$1 {\n        /**\n         * Create an instance of this Tech.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        Callback function to call when the `HTML5` Tech is ready.\n         */\n        constructor(options = {}, ready = function () {}) {\n            // we don't want the tech to report user activity automatically.\n            // This is done manually in addControlsListeners\n            options.reportTouchActivity = false;\n            super(null, options, ready);\n            this.onDurationChange_ = e => this.onDurationChange(e);\n            this.trackProgress_ = e => this.trackProgress(e);\n            this.trackCurrentTime_ = e => this.trackCurrentTime(e);\n            this.stopTrackingCurrentTime_ = e => this.stopTrackingCurrentTime(e);\n            this.disposeSourceHandler_ = e => this.disposeSourceHandler(e);\n            this.queuedHanders_ = new Set();\n\n            // keep track of whether the current source has played at all to\n            // implement a very limited played()\n            this.hasStarted_ = false;\n            this.on('playing', function () {\n                this.hasStarted_ = true;\n            });\n            this.on('loadstart', function () {\n                this.hasStarted_ = false;\n            });\n            ALL.names.forEach(name => {\n                const props = ALL[name];\n                if (options && options[props.getterName]) {\n                    this[props.privateName] = options[props.getterName];\n                }\n            });\n\n            // Manually track progress in cases where the browser/tech doesn't report it.\n            if (!this.featuresProgressEvents) {\n                this.manualProgressOn();\n            }\n\n            // Manually track timeupdates in cases where the browser/tech doesn't report it.\n            if (!this.featuresTimeupdateEvents) {\n                this.manualTimeUpdatesOn();\n            }\n            ['Text', 'Audio', 'Video'].forEach(track => {\n                if (options[`native${track}Tracks`] === false) {\n                    this[`featuresNative${track}Tracks`] = false;\n                }\n            });\n            if (options.nativeCaptions === false || options.nativeTextTracks === false) {\n                this.featuresNativeTextTracks = false;\n            } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {\n                this.featuresNativeTextTracks = true;\n            }\n            if (!this.featuresNativeTextTracks) {\n                this.emulateTextTracks();\n            }\n            this.preloadTextTracks = options.preloadTextTracks !== false;\n            this.autoRemoteTextTracks_ = new ALL.text.ListClass();\n            this.initTrackListeners();\n\n            // Turn on component tap events only if not using native controls\n            if (!options.nativeControlsForTouch) {\n                this.emitTapEvents();\n            }\n            if (this.constructor) {\n                this.name_ = this.constructor.name || 'Unknown Tech';\n            }\n        }\n\n        /**\n         * A special function to trigger source set in a way that will allow player\n         * to re-trigger if the player or tech are not ready yet.\n         *\n         * @fires Tech#sourceset\n         * @param {string} src The source string at the time of the source changing.\n         */\n        triggerSourceset(src) {\n            if (!this.isReady_) {\n                // on initial ready we have to trigger source set\n                // 1ms after ready so that player can watch for it.\n                this.one('ready', () => this.setTimeout(() => this.triggerSourceset(src), 1));\n            }\n\n            /**\n             * Fired when the source is set on the tech causing the media element\n             * to reload.\n             *\n             * @see {@link Player#event:sourceset}\n             * @event Tech#sourceset\n             * @type {Event}\n             */\n            this.trigger({\n                src,\n                type: 'sourceset'\n            });\n        }\n\n        /* Fallbacks for unsupported event types\n    ================================================================================ */\n\n        /**\n         * Polyfill the `progress` event for browsers that don't support it natively.\n         *\n         * @see {@link Tech#trackProgress}\n         */\n        manualProgressOn() {\n            this.on('durationchange', this.onDurationChange_);\n            this.manualProgress = true;\n\n            // Trigger progress watching when a source begins loading\n            this.one('ready', this.trackProgress_);\n        }\n\n        /**\n         * Turn off the polyfill for `progress` events that was created in\n         * {@link Tech#manualProgressOn}\n         */\n        manualProgressOff() {\n            this.manualProgress = false;\n            this.stopTrackingProgress();\n            this.off('durationchange', this.onDurationChange_);\n        }\n\n        /**\n         * This is used to trigger a `progress` event when the buffered percent changes. It\n         * sets an interval function that will be called every 500 milliseconds to check if the\n         * buffer end percent has changed.\n         *\n         * > This function is called by {@link Tech#manualProgressOn}\n         *\n         * @param {Event} event\n         *        The `ready` event that caused this to run.\n         *\n         * @listens Tech#ready\n         * @fires Tech#progress\n         */\n        trackProgress(event) {\n            this.stopTrackingProgress();\n            this.progressInterval = this.setInterval(bind_(this, function () {\n                // Don't trigger unless buffered amount is greater than last time\n\n                const numBufferedPercent = this.bufferedPercent();\n                if (this.bufferedPercent_ !== numBufferedPercent) {\n                    /**\n                     * See {@link Player#progress}\n                     *\n                     * @event Tech#progress\n                     * @type {Event}\n                     */\n                    this.trigger('progress');\n                }\n                this.bufferedPercent_ = numBufferedPercent;\n                if (numBufferedPercent === 1) {\n                    this.stopTrackingProgress();\n                }\n            }), 500);\n        }\n\n        /**\n         * Update our internal duration on a `durationchange` event by calling\n         * {@link Tech#duration}.\n         *\n         * @param {Event} event\n         *        The `durationchange` event that caused this to run.\n         *\n         * @listens Tech#durationchange\n         */\n        onDurationChange(event) {\n            this.duration_ = this.duration();\n        }\n\n        /**\n         * Get and create a `TimeRange` object for buffering.\n         *\n         * @return { import('../utils/time').TimeRange }\n         *         The time range object that was created.\n         */\n        buffered() {\n            return createTimeRanges$1(0, 0);\n        }\n\n        /**\n         * Get the percentage of the current video that is currently buffered.\n         *\n         * @return {number}\n         *         A number from 0 to 1 that represents the decimal percentage of the\n         *         video that is buffered.\n         *\n         */\n        bufferedPercent() {\n            return bufferedPercent(this.buffered(), this.duration_);\n        }\n\n        /**\n         * Turn off the polyfill for `progress` events that was created in\n         * {@link Tech#manualProgressOn}\n         * Stop manually tracking progress events by clearing the interval that was set in\n         * {@link Tech#trackProgress}.\n         */\n        stopTrackingProgress() {\n            this.clearInterval(this.progressInterval);\n        }\n\n        /**\n         * Polyfill the `timeupdate` event for browsers that don't support it.\n         *\n         * @see {@link Tech#trackCurrentTime}\n         */\n        manualTimeUpdatesOn() {\n            this.manualTimeUpdates = true;\n            this.on('play', this.trackCurrentTime_);\n            this.on('pause', this.stopTrackingCurrentTime_);\n        }\n\n        /**\n         * Turn off the polyfill for `timeupdate` events that was created in\n         * {@link Tech#manualTimeUpdatesOn}\n         */\n        manualTimeUpdatesOff() {\n            this.manualTimeUpdates = false;\n            this.stopTrackingCurrentTime();\n            this.off('play', this.trackCurrentTime_);\n            this.off('pause', this.stopTrackingCurrentTime_);\n        }\n\n        /**\n         * Sets up an interval function to track current time and trigger `timeupdate` every\n         * 250 milliseconds.\n         *\n         * @listens Tech#play\n         * @triggers Tech#timeupdate\n         */\n        trackCurrentTime() {\n            if (this.currentTimeInterval) {\n                this.stopTrackingCurrentTime();\n            }\n            this.currentTimeInterval = this.setInterval(function () {\n                /**\n                 * Triggered at an interval of 250ms to indicated that time is passing in the video.\n                 *\n                 * @event Tech#timeupdate\n                 * @type {Event}\n                 */\n                this.trigger({\n                    type: 'timeupdate',\n                    target: this,\n                    manuallyTriggered: true\n                });\n\n                // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\n            }, 250);\n        }\n\n        /**\n         * Stop the interval function created in {@link Tech#trackCurrentTime} so that the\n         * `timeupdate` event is no longer triggered.\n         *\n         * @listens {Tech#pause}\n         */\n        stopTrackingCurrentTime() {\n            this.clearInterval(this.currentTimeInterval);\n\n            // #1002 - if the video ends right before the next timeupdate would happen,\n            // the progress bar won't make it all the way to the end\n            this.trigger({\n                type: 'timeupdate',\n                target: this,\n                manuallyTriggered: true\n            });\n        }\n\n        /**\n         * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},\n         * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.\n         *\n         * @fires Component#dispose\n         */\n        dispose() {\n            // clear out all tracks because we can't reuse them between techs\n            this.clearTracks(NORMAL.names);\n\n            // Turn off any manual progress or timeupdate tracking\n            if (this.manualProgress) {\n                this.manualProgressOff();\n            }\n            if (this.manualTimeUpdates) {\n                this.manualTimeUpdatesOff();\n            }\n            super.dispose();\n        }\n\n        /**\n         * Clear out a single `TrackList` or an array of `TrackLists` given their names.\n         *\n         * > Note: Techs without source handlers should call this between sources for `video`\n         *         & `audio` tracks. You don't want to use them between tracks!\n         *\n         * @param {string[]|string} types\n         *        TrackList names to clear, valid names are `video`, `audio`, and\n         *        `text`.\n         */\n        clearTracks(types) {\n            types = [].concat(types);\n            // clear out all tracks because we can't reuse them between techs\n            types.forEach(type => {\n                const list = this[`${type}Tracks`]() || [];\n                let i = list.length;\n                while (i--) {\n                    const track = list[i];\n                    if (type === 'text') {\n                        this.removeRemoteTextTrack(track);\n                    }\n                    list.removeTrack(track);\n                }\n            });\n        }\n\n        /**\n         * Remove any TextTracks added via addRemoteTextTrack that are\n         * flagged for automatic garbage collection\n         */\n        cleanupAutoTextTracks() {\n            const list = this.autoRemoteTextTracks_ || [];\n            let i = list.length;\n            while (i--) {\n                const track = list[i];\n                this.removeRemoteTextTrack(track);\n            }\n        }\n\n        /**\n         * Reset the tech, which will removes all sources and reset the internal readyState.\n         *\n         * @abstract\n         */\n        reset() {}\n\n        /**\n         * Get the value of `crossOrigin` from the tech.\n         *\n         * @abstract\n         *\n         * @see {Html5#crossOrigin}\n         */\n        crossOrigin() {}\n\n        /**\n         * Set the value of `crossOrigin` on the tech.\n         *\n         * @abstract\n         *\n         * @param {string} crossOrigin the crossOrigin value\n         * @see {Html5#setCrossOrigin}\n         */\n        setCrossOrigin() {}\n\n        /**\n         * Get or set an error on the Tech.\n         *\n         * @param {MediaError} [err]\n         *        Error to set on the Tech\n         *\n         * @return {MediaError|null}\n         *         The current error object on the tech, or null if there isn't one.\n         */\n        error(err) {\n            if (err !== undefined) {\n                this.error_ = new MediaError(err);\n                this.trigger('error');\n            }\n            return this.error_;\n        }\n\n        /**\n         * Returns the `TimeRange`s that have been played through for the current source.\n         *\n         * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.\n         *         It only checks whether the source has played at all or not.\n         *\n         * @return {TimeRange}\n         *         - A single time range if this video has played\n         *         - An empty set of ranges if not.\n         */\n        played() {\n            if (this.hasStarted_) {\n                return createTimeRanges$1(0, 0);\n            }\n            return createTimeRanges$1();\n        }\n\n        /**\n         * Start playback\n         *\n         * @abstract\n         *\n         * @see {Html5#play}\n         */\n        play() {}\n\n        /**\n         * Set whether we are scrubbing or not\n         *\n         * @abstract\n         * @param {boolean} _isScrubbing\n         *                  - true for we are currently scrubbing\n         *                  - false for we are no longer scrubbing\n         *\n         * @see {Html5#setScrubbing}\n         */\n        setScrubbing(_isScrubbing) {}\n\n        /**\n         * Get whether we are scrubbing or not\n         *\n         * @abstract\n         *\n         * @see {Html5#scrubbing}\n         */\n        scrubbing() {}\n\n        /**\n         * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was\n         * previously called.\n         *\n         * @param {number} _seconds\n         *        Set the current time of the media to this.\n         * @fires Tech#timeupdate\n         */\n        setCurrentTime(_seconds) {\n            // improve the accuracy of manual timeupdates\n            if (this.manualTimeUpdates) {\n                /**\n                 * A manual `timeupdate` event.\n                 *\n                 * @event Tech#timeupdate\n                 * @type {Event}\n                 */\n                this.trigger({\n                    type: 'timeupdate',\n                    target: this,\n                    manuallyTriggered: true\n                });\n            }\n        }\n\n        /**\n         * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and\n         * {@link TextTrackList} events.\n         *\n         * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.\n         *\n         * @fires Tech#audiotrackchange\n         * @fires Tech#videotrackchange\n         * @fires Tech#texttrackchange\n         */\n        initTrackListeners() {\n            /**\n             * Triggered when tracks are added or removed on the Tech {@link AudioTrackList}\n             *\n             * @event Tech#audiotrackchange\n             * @type {Event}\n             */\n\n            /**\n             * Triggered when tracks are added or removed on the Tech {@link VideoTrackList}\n             *\n             * @event Tech#videotrackchange\n             * @type {Event}\n             */\n\n            /**\n             * Triggered when tracks are added or removed on the Tech {@link TextTrackList}\n             *\n             * @event Tech#texttrackchange\n             * @type {Event}\n             */\n            NORMAL.names.forEach(name => {\n                const props = NORMAL[name];\n                const trackListChanges = () => {\n                    this.trigger(`${name}trackchange`);\n                };\n                const tracks = this[props.getterName]();\n                tracks.addEventListener('removetrack', trackListChanges);\n                tracks.addEventListener('addtrack', trackListChanges);\n                this.on('dispose', () => {\n                    tracks.removeEventListener('removetrack', trackListChanges);\n                    tracks.removeEventListener('addtrack', trackListChanges);\n                });\n            });\n        }\n\n        /**\n         * Emulate TextTracks using vtt.js if necessary\n         *\n         * @fires Tech#vttjsloaded\n         * @fires Tech#vttjserror\n         */\n        addWebVttScript_() {\n            if (window.WebVTT) {\n                return;\n            }\n\n            // Initially, Tech.el_ is a child of a dummy-div wait until the Component system\n            // signals that the Tech is ready at which point Tech.el_ is part of the DOM\n            // before inserting the WebVTT script\n            if (document.body.contains(this.el())) {\n                // load via require if available and vtt.js script location was not passed in\n                // as an option. novtt builds will turn the above require call into an empty object\n                // which will cause this if check to always fail.\n                if (!this.options_['vtt.js'] && isPlain(browserIndex) && Object.keys(browserIndex).length > 0) {\n                    this.trigger('vttjsloaded');\n                    return;\n                }\n\n                // load vtt.js via the script location option or the cdn of no location was\n                // passed in\n                const script = document.createElement('script');\n                script.src = this.options_['vtt.js'] || 'https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js';\n                script.onload = () => {\n                    /**\n                     * Fired when vtt.js is loaded.\n                     *\n                     * @event Tech#vttjsloaded\n                     * @type {Event}\n                     */\n                    this.trigger('vttjsloaded');\n                };\n                script.onerror = () => {\n                    /**\n                     * Fired when vtt.js was not loaded due to an error\n                     *\n                     * @event Tech#vttjsloaded\n                     * @type {Event}\n                     */\n                    this.trigger('vttjserror');\n                };\n                this.on('dispose', () => {\n                    script.onload = null;\n                    script.onerror = null;\n                });\n                // but have not loaded yet and we set it to true before the inject so that\n                // we don't overwrite the injected window.WebVTT if it loads right away\n                window.WebVTT = true;\n                this.el().parentNode.appendChild(script);\n            } else {\n                this.ready(this.addWebVttScript_);\n            }\n        }\n\n        /**\n         * Emulate texttracks\n         *\n         */\n        emulateTextTracks() {\n            const tracks = this.textTracks();\n            const remoteTracks = this.remoteTextTracks();\n            const handleAddTrack = e => tracks.addTrack(e.track);\n            const handleRemoveTrack = e => tracks.removeTrack(e.track);\n            remoteTracks.on('addtrack', handleAddTrack);\n            remoteTracks.on('removetrack', handleRemoveTrack);\n            this.addWebVttScript_();\n            const updateDisplay = () => this.trigger('texttrackchange');\n            const textTracksChanges = () => {\n                updateDisplay();\n                for (let i = 0; i < tracks.length; i++) {\n                    const track = tracks[i];\n                    track.removeEventListener('cuechange', updateDisplay);\n                    if (track.mode === 'showing') {\n                        track.addEventListener('cuechange', updateDisplay);\n                    }\n                }\n            };\n            textTracksChanges();\n            tracks.addEventListener('change', textTracksChanges);\n            tracks.addEventListener('addtrack', textTracksChanges);\n            tracks.addEventListener('removetrack', textTracksChanges);\n            this.on('dispose', function () {\n                remoteTracks.off('addtrack', handleAddTrack);\n                remoteTracks.off('removetrack', handleRemoveTrack);\n                tracks.removeEventListener('change', textTracksChanges);\n                tracks.removeEventListener('addtrack', textTracksChanges);\n                tracks.removeEventListener('removetrack', textTracksChanges);\n                for (let i = 0; i < tracks.length; i++) {\n                    const track = tracks[i];\n                    track.removeEventListener('cuechange', updateDisplay);\n                }\n            });\n        }\n\n        /**\n         * Create and returns a remote {@link TextTrack} object.\n         *\n         * @param {string} kind\n         *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n         *\n         * @param {string} [label]\n         *        Label to identify the text track\n         *\n         * @param {string} [language]\n         *        Two letter language abbreviation\n         *\n         * @return {TextTrack}\n         *         The TextTrack that gets created.\n         */\n        addTextTrack(kind, label, language) {\n            if (!kind) {\n                throw new Error('TextTrack kind is required but was not provided');\n            }\n            return createTrackHelper(this, kind, label, language);\n        }\n\n        /**\n         * Create an emulated TextTrack for use by addRemoteTextTrack\n         *\n         * This is intended to be overridden by classes that inherit from\n         * Tech in order to create native or custom TextTracks.\n         *\n         * @param {Object} options\n         *        The object should contain the options to initialize the TextTrack with.\n         *\n         * @param {string} [options.kind]\n         *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n         *\n         * @param {string} [options.label].\n         *        Label to identify the text track\n         *\n         * @param {string} [options.language]\n         *        Two letter language abbreviation.\n         *\n         * @return {HTMLTrackElement}\n         *         The track element that gets created.\n         */\n        createRemoteTextTrack(options) {\n            const track = merge$2(options, {\n                tech: this\n            });\n            return new REMOTE.remoteTextEl.TrackClass(track);\n        }\n\n        /**\n         * Creates a remote text track object and returns an html track element.\n         *\n         * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.\n         *\n         * @param {Object} options\n         *        See {@link Tech#createRemoteTextTrack} for more detailed properties.\n         *\n         * @param {boolean} [manualCleanup=false]\n         *        - When false: the TextTrack will be automatically removed from the video\n         *          element whenever the source changes\n         *        - When True: The TextTrack will have to be cleaned up manually\n         *\n         * @return {HTMLTrackElement}\n         *         An Html Track Element.\n         *\n         */\n        addRemoteTextTrack(options = {}, manualCleanup) {\n            const htmlTrackElement = this.createRemoteTextTrack(options);\n            if (typeof manualCleanup !== 'boolean') {\n                manualCleanup = false;\n            }\n\n            // store HTMLTrackElement and TextTrack to remote list\n            this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);\n            this.remoteTextTracks().addTrack(htmlTrackElement.track);\n            if (manualCleanup === false) {\n                // create the TextTrackList if it doesn't exist\n                this.ready(() => this.autoRemoteTextTracks_.addTrack(htmlTrackElement.track));\n            }\n            return htmlTrackElement;\n        }\n\n        /**\n         * Remove a remote text track from the remote `TextTrackList`.\n         *\n         * @param {TextTrack} track\n         *        `TextTrack` to remove from the `TextTrackList`\n         */\n        removeRemoteTextTrack(track) {\n            const trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);\n\n            // remove HTMLTrackElement and TextTrack from remote list\n            this.remoteTextTrackEls().removeTrackElement_(trackElement);\n            this.remoteTextTracks().removeTrack(track);\n            this.autoRemoteTextTracks_.removeTrack(track);\n        }\n\n        /**\n         * Gets available media playback quality metrics as specified by the W3C's Media\n         * Playback Quality API.\n         *\n         * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n         *\n         * @return {Object}\n         *         An object with supported media playback quality metrics\n         *\n         * @abstract\n         */\n        getVideoPlaybackQuality() {\n            return {};\n        }\n\n        /**\n         * Attempt to create a floating video window always on top of other windows\n         * so that users may continue consuming media while they interact with other\n         * content sites, or applications on their device.\n         *\n         * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\n         *\n         * @return {Promise|undefined}\n         *         A promise with a Picture-in-Picture window if the browser supports\n         *         Promises (or one was passed in as an option). It returns undefined\n         *         otherwise.\n         *\n         * @abstract\n         */\n        requestPictureInPicture() {\n            return Promise.reject();\n        }\n\n        /**\n         * A method to check for the value of the 'disablePictureInPicture' <video> property.\n         * Defaults to true, as it should be considered disabled if the tech does not support pip\n         *\n         * @abstract\n         */\n        disablePictureInPicture() {\n            return true;\n        }\n\n        /**\n         * A method to set or unset the 'disablePictureInPicture' <video> property.\n         *\n         * @abstract\n         */\n        setDisablePictureInPicture() {}\n\n        /**\n         * A fallback implementation of requestVideoFrameCallback using requestAnimationFrame\n         *\n         * @param {function} cb\n         * @return {number} request id\n         */\n        requestVideoFrameCallback(cb) {\n            const id = newGUID();\n            if (!this.isReady_ || this.paused()) {\n                this.queuedHanders_.add(id);\n                this.one('playing', () => {\n                    if (this.queuedHanders_.has(id)) {\n                        this.queuedHanders_.delete(id);\n                        cb();\n                    }\n                });\n            } else {\n                this.requestNamedAnimationFrame(id, cb);\n            }\n            return id;\n        }\n\n        /**\n         * A fallback implementation of cancelVideoFrameCallback\n         *\n         * @param {number} id id of callback to be cancelled\n         */\n        cancelVideoFrameCallback(id) {\n            if (this.queuedHanders_.has(id)) {\n                this.queuedHanders_.delete(id);\n            } else {\n                this.cancelNamedAnimationFrame(id);\n            }\n        }\n\n        /**\n         * A method to set a poster from a `Tech`.\n         *\n         * @abstract\n         */\n        setPoster() {}\n\n        /**\n         * A method to check for the presence of the 'playsinline' <video> attribute.\n         *\n         * @abstract\n         */\n        playsinline() {}\n\n        /**\n         * A method to set or unset the 'playsinline' <video> attribute.\n         *\n         * @abstract\n         */\n        setPlaysinline() {}\n\n        /**\n         * Attempt to force override of native audio tracks.\n         *\n         * @param {boolean} override - If set to true native audio will be overridden,\n         * otherwise native audio will potentially be used.\n         *\n         * @abstract\n         */\n        overrideNativeAudioTracks(override) {}\n\n        /**\n         * Attempt to force override of native video tracks.\n         *\n         * @param {boolean} override - If set to true native video will be overridden,\n         * otherwise native video will potentially be used.\n         *\n         * @abstract\n         */\n        overrideNativeVideoTracks(override) {}\n\n        /**\n         * Check if the tech can support the given mime-type.\n         *\n         * The base tech does not support any type, but source handlers might\n         * overwrite this.\n         *\n         * @param  {string} _type\n         *         The mimetype to check for support\n         *\n         * @return {string}\n         *         'probably', 'maybe', or empty string\n         *\n         * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}\n         *\n         * @abstract\n         */\n        canPlayType(_type) {\n            return '';\n        }\n\n        /**\n         * Check if the type is supported by this tech.\n         *\n         * The base tech does not support any type, but source handlers might\n         * overwrite this.\n         *\n         * @param {string} _type\n         *        The media type to check\n         * @return {string} Returns the native video element's response\n         */\n        static canPlayType(_type) {\n            return '';\n        }\n\n        /**\n         * Check if the tech can support the given source\n         *\n         * @param {Object} srcObj\n         *        The source object\n         * @param {Object} options\n         *        The options passed to the tech\n         * @return {string} 'probably', 'maybe', or '' (empty string)\n         */\n        static canPlaySource(srcObj, options) {\n            return Tech.canPlayType(srcObj.type);\n        }\n\n        /*\n     * Return whether the argument is a Tech or not.\n     * Can be passed either a Class like `Html5` or a instance like `player.tech_`\n     *\n     * @param {Object} component\n     *        The item to check\n     *\n     * @return {boolean}\n     *         Whether it is a tech or not\n     *         - True if it is a tech\n     *         - False if it is not\n     */\n        static isTech(component) {\n            return component.prototype instanceof Tech || component instanceof Tech || component === Tech;\n        }\n\n        /**\n         * Registers a `Tech` into a shared list for videojs.\n         *\n         * @param {string} name\n         *        Name of the `Tech` to register.\n         *\n         * @param {Object} tech\n         *        The `Tech` class to register.\n         */\n        static registerTech(name, tech) {\n            if (!Tech.techs_) {\n                Tech.techs_ = {};\n            }\n            if (!Tech.isTech(tech)) {\n                throw new Error(`Tech ${name} must be a Tech`);\n            }\n            if (!Tech.canPlayType) {\n                throw new Error('Techs must have a static canPlayType method on them');\n            }\n            if (!Tech.canPlaySource) {\n                throw new Error('Techs must have a static canPlaySource method on them');\n            }\n            name = toTitleCase$1(name);\n            Tech.techs_[name] = tech;\n            Tech.techs_[toLowerCase(name)] = tech;\n            if (name !== 'Tech') {\n                // camel case the techName for use in techOrder\n                Tech.defaultTechOrder_.push(name);\n            }\n            return tech;\n        }\n\n        /**\n         * Get a `Tech` from the shared list by name.\n         *\n         * @param {string} name\n         *        `camelCase` or `TitleCase` name of the Tech to get\n         *\n         * @return {Tech|undefined}\n         *         The `Tech` or undefined if there was no tech with the name requested.\n         */\n        static getTech(name) {\n            if (!name) {\n                return;\n            }\n            if (Tech.techs_ && Tech.techs_[name]) {\n                return Tech.techs_[name];\n            }\n            name = toTitleCase$1(name);\n            if (window && window.videojs && window.videojs[name]) {\n                log$1.warn(`The ${name} tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)`);\n                return window.videojs[name];\n            }\n        }\n    }\n\n    /**\n     * Get the {@link VideoTrackList}\n     *\n     * @returns {VideoTrackList}\n     * @method Tech.prototype.videoTracks\n     */\n\n    /**\n     * Get the {@link AudioTrackList}\n     *\n     * @returns {AudioTrackList}\n     * @method Tech.prototype.audioTracks\n     */\n\n    /**\n     * Get the {@link TextTrackList}\n     *\n     * @returns {TextTrackList}\n     * @method Tech.prototype.textTracks\n     */\n\n    /**\n     * Get the remote element {@link TextTrackList}\n     *\n     * @returns {TextTrackList}\n     * @method Tech.prototype.remoteTextTracks\n     */\n\n    /**\n     * Get the remote element {@link HtmlTrackElementList}\n     *\n     * @returns {HtmlTrackElementList}\n     * @method Tech.prototype.remoteTextTrackEls\n     */\n\n    ALL.names.forEach(function (name) {\n        const props = ALL[name];\n        Tech.prototype[props.getterName] = function () {\n            this[props.privateName] = this[props.privateName] || new props.ListClass();\n            return this[props.privateName];\n        };\n    });\n\n    /**\n     * List of associated text tracks\n     *\n     * @type {TextTrackList}\n     * @private\n     * @property Tech#textTracks_\n     */\n\n    /**\n     * List of associated audio tracks.\n     *\n     * @type {AudioTrackList}\n     * @private\n     * @property Tech#audioTracks_\n     */\n\n    /**\n     * List of associated video tracks.\n     *\n     * @type {VideoTrackList}\n     * @private\n     * @property Tech#videoTracks_\n     */\n\n    /**\n     * Boolean indicating whether the `Tech` supports volume control.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresVolumeControl = true;\n\n    /**\n     * Boolean indicating whether the `Tech` supports muting volume.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresMuteControl = true;\n\n    /**\n     * Boolean indicating whether the `Tech` supports fullscreen resize control.\n     * Resizing plugins using request fullscreen reloads the plugin\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresFullscreenResize = false;\n\n    /**\n     * Boolean indicating whether the `Tech` supports changing the speed at which the video\n     * plays. Examples:\n     *   - Set player to play 2x (twice) as fast\n     *   - Set player to play 0.5x (half) as fast\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresPlaybackRate = false;\n\n    /**\n     * Boolean indicating whether the `Tech` supports the `progress` event.\n     * This will be used to determine if {@link Tech#manualProgressOn} should be called.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresProgressEvents = false;\n\n    /**\n     * Boolean indicating whether the `Tech` supports the `sourceset` event.\n     *\n     * A tech should set this to `true` and then use {@link Tech#triggerSourceset}\n     * to trigger a {@link Tech#event:sourceset} at the earliest time after getting\n     * a new source.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresSourceset = false;\n\n    /**\n     * Boolean indicating whether the `Tech` supports the `timeupdate` event.\n     * This will be used to determine if {@link Tech#manualTimeUpdates} should be called.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresTimeupdateEvents = false;\n\n    /**\n     * Boolean indicating whether the `Tech` supports the native `TextTrack`s.\n     * This will help us integrate with native `TextTrack`s if the browser supports them.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresNativeTextTracks = false;\n\n    /**\n     * Boolean indicating whether the `Tech` supports `requestVideoFrameCallback`.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Tech.prototype.featuresVideoFrameCallback = false;\n\n    /**\n     * A functional mixin for techs that want to use the Source Handler pattern.\n     * Source handlers are scripts for handling specific formats.\n     * The source handler pattern is used for adaptive formats (HLS, DASH) that\n     * manually load video data and feed it into a Source Buffer (Media Source Extensions)\n     * Example: `Tech.withSourceHandlers.call(MyTech);`\n     *\n     * @param {Tech} _Tech\n     *        The tech to add source handler functions to.\n     *\n     * @mixes Tech~SourceHandlerAdditions\n     */\n    Tech.withSourceHandlers = function (_Tech) {\n        /**\n         * Register a source handler\n         *\n         * @param {Function} handler\n         *        The source handler class\n         *\n         * @param {number} [index]\n         *        Register it at the following index\n         */\n        _Tech.registerSourceHandler = function (handler, index) {\n            let handlers = _Tech.sourceHandlers;\n            if (!handlers) {\n                handlers = _Tech.sourceHandlers = [];\n            }\n            if (index === undefined) {\n                // add to the end of the list\n                index = handlers.length;\n            }\n            handlers.splice(index, 0, handler);\n        };\n\n        /**\n         * Check if the tech can support the given type. Also checks the\n         * Techs sourceHandlers.\n         *\n         * @param {string} type\n         *         The mimetype to check.\n         *\n         * @return {string}\n         *         'probably', 'maybe', or '' (empty string)\n         */\n        _Tech.canPlayType = function (type) {\n            const handlers = _Tech.sourceHandlers || [];\n            let can;\n            for (let i = 0; i < handlers.length; i++) {\n                can = handlers[i].canPlayType(type);\n                if (can) {\n                    return can;\n                }\n            }\n            return '';\n        };\n\n        /**\n         * Returns the first source handler that supports the source.\n         *\n         * TODO: Answer question: should 'probably' be prioritized over 'maybe'\n         *\n         * @param {Tech~SourceObject} source\n         *        The source object\n         *\n         * @param {Object} options\n         *        The options passed to the tech\n         *\n         * @return {SourceHandler|null}\n         *          The first source handler that supports the source or null if\n         *          no SourceHandler supports the source\n         */\n        _Tech.selectSourceHandler = function (source, options) {\n            const handlers = _Tech.sourceHandlers || [];\n            let can;\n            for (let i = 0; i < handlers.length; i++) {\n                can = handlers[i].canHandleSource(source, options);\n                if (can) {\n                    return handlers[i];\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Check if the tech can support the given source.\n         *\n         * @param {Tech~SourceObject} srcObj\n         *        The source object\n         *\n         * @param {Object} options\n         *        The options passed to the tech\n         *\n         * @return {string}\n         *         'probably', 'maybe', or '' (empty string)\n         */\n        _Tech.canPlaySource = function (srcObj, options) {\n            const sh = _Tech.selectSourceHandler(srcObj, options);\n            if (sh) {\n                return sh.canHandleSource(srcObj, options);\n            }\n            return '';\n        };\n\n        /**\n         * When using a source handler, prefer its implementation of\n         * any function normally provided by the tech.\n         */\n        const deferrable = ['seekable', 'seeking', 'duration'];\n\n        /**\n         * A wrapper around {@link Tech#seekable} that will call a `SourceHandler`s seekable\n         * function if it exists, with a fallback to the Techs seekable function.\n         *\n         * @method _Tech.seekable\n         */\n\n        /**\n         * A wrapper around {@link Tech#duration} that will call a `SourceHandler`s duration\n         * function if it exists, otherwise it will fallback to the techs duration function.\n         *\n         * @method _Tech.duration\n         */\n\n        deferrable.forEach(function (fnName) {\n            const originalFn = this[fnName];\n            if (typeof originalFn !== 'function') {\n                return;\n            }\n            this[fnName] = function () {\n                if (this.sourceHandler_ && this.sourceHandler_[fnName]) {\n                    return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);\n                }\n                return originalFn.apply(this, arguments);\n            };\n        }, _Tech.prototype);\n\n        /**\n         * Create a function for setting the source using a source object\n         * and source handlers.\n         * Should never be called unless a source handler was found.\n         *\n         * @param {Tech~SourceObject} source\n         *        A source object with src and type keys\n         */\n        _Tech.prototype.setSource = function (source) {\n            let sh = _Tech.selectSourceHandler(source, this.options_);\n            if (!sh) {\n                // Fall back to a native source handler when unsupported sources are\n                // deliberately set\n                if (_Tech.nativeSourceHandler) {\n                    sh = _Tech.nativeSourceHandler;\n                } else {\n                    log$1.error('No source handler found for the current source.');\n                }\n            }\n\n            // Dispose any existing source handler\n            this.disposeSourceHandler();\n            this.off('dispose', this.disposeSourceHandler_);\n            if (sh !== _Tech.nativeSourceHandler) {\n                this.currentSource_ = source;\n            }\n            this.sourceHandler_ = sh.handleSource(source, this, this.options_);\n            this.one('dispose', this.disposeSourceHandler_);\n        };\n\n        /**\n         * Clean up any existing SourceHandlers and listeners when the Tech is disposed.\n         *\n         * @listens Tech#dispose\n         */\n        _Tech.prototype.disposeSourceHandler = function () {\n            // if we have a source and get another one\n            // then we are loading something new\n            // than clear all of our current tracks\n            if (this.currentSource_) {\n                this.clearTracks(['audio', 'video']);\n                this.currentSource_ = null;\n            }\n\n            // always clean up auto-text tracks\n            this.cleanupAutoTextTracks();\n            if (this.sourceHandler_) {\n                if (this.sourceHandler_.dispose) {\n                    this.sourceHandler_.dispose();\n                }\n                this.sourceHandler_ = null;\n            }\n        };\n    };\n\n    // The base Tech class needs to be registered as a Component. It is the only\n    // Tech that can be registered as a Component.\n    Component$1.registerComponent('Tech', Tech);\n    Tech.registerTech('Tech', Tech);\n\n    /**\n     * A list of techs that should be added to techOrder on Players\n     *\n     * @private\n     */\n    Tech.defaultTechOrder_ = [];\n\n    /**\n     * @file middleware.js\n     * @module middleware\n     */\n    const middlewares = {};\n    const middlewareInstances = {};\n    const TERMINATOR = {};\n\n    /**\n     * A middleware object is a plain JavaScript object that has methods that\n     * match the {@link Tech} methods found in the lists of allowed\n     * {@link module:middleware.allowedGetters|getters},\n     * {@link module:middleware.allowedSetters|setters}, and\n     * {@link module:middleware.allowedMediators|mediators}.\n     *\n     * @typedef {Object} MiddlewareObject\n     */\n\n    /**\n     * A middleware factory function that should return a\n     * {@link module:middleware~MiddlewareObject|MiddlewareObject}.\n     *\n     * This factory will be called for each player when needed, with the player\n     * passed in as an argument.\n     *\n     * @callback MiddlewareFactory\n     * @param { import('../player').default } player\n     *        A Video.js player.\n     */\n\n    /**\n     * Define a middleware that the player should use by way of a factory function\n     * that returns a middleware object.\n     *\n     * @param  {string} type\n     *         The MIME type to match or `\"*\"` for all MIME types.\n     *\n     * @param  {MiddlewareFactory} middleware\n     *         A middleware factory function that will be executed for\n     *         matching types.\n     */\n    function use(type, middleware) {\n        middlewares[type] = middlewares[type] || [];\n        middlewares[type].push(middleware);\n    }\n\n    /**\n     * Asynchronously sets a source using middleware by recursing through any\n     * matching middlewares and calling `setSource` on each, passing along the\n     * previous returned value each time.\n     *\n     * @param  { import('../player').default } player\n     *         A {@link Player} instance.\n     *\n     * @param  {Tech~SourceObject} src\n     *         A source object.\n     *\n     * @param  {Function}\n     *         The next middleware to run.\n     */\n    function setSource(player, src, next) {\n        player.setTimeout(() => setSourceHelper(src, middlewares[src.type], next, player), 1);\n    }\n\n    /**\n     * When the tech is set, passes the tech to each middleware's `setTech` method.\n     *\n     * @param {Object[]} middleware\n     *        An array of middleware instances.\n     *\n     * @param { import('../tech/tech').default } tech\n     *        A Video.js tech.\n     */\n    function setTech(middleware, tech) {\n        middleware.forEach(mw => mw.setTech && mw.setTech(tech));\n    }\n\n    /**\n     * Calls a getter on the tech first, through each middleware\n     * from right to left to the player.\n     *\n     * @param  {Object[]} middleware\n     *         An array of middleware instances.\n     *\n     * @param  { import('../tech/tech').default } tech\n     *         The current tech.\n     *\n     * @param  {string} method\n     *         A method name.\n     *\n     * @return {*}\n     *         The final value from the tech after middleware has intercepted it.\n     */\n    function get(middleware, tech, method) {\n        return middleware.reduceRight(middlewareIterator(method), tech[method]());\n    }\n\n    /**\n     * Takes the argument given to the player and calls the setter method on each\n     * middleware from left to right to the tech.\n     *\n     * @param  {Object[]} middleware\n     *         An array of middleware instances.\n     *\n     * @param  { import('../tech/tech').default } tech\n     *         The current tech.\n     *\n     * @param  {string} method\n     *         A method name.\n     *\n     * @param  {*} arg\n     *         The value to set on the tech.\n     *\n     * @return {*}\n     *         The return value of the `method` of the `tech`.\n     */\n    function set(middleware, tech, method, arg) {\n        return tech[method](middleware.reduce(middlewareIterator(method), arg));\n    }\n\n    /**\n     * Takes the argument given to the player and calls the `call` version of the\n     * method on each middleware from left to right.\n     *\n     * Then, call the passed in method on the tech and return the result unchanged\n     * back to the player, through middleware, this time from right to left.\n     *\n     * @param  {Object[]} middleware\n     *         An array of middleware instances.\n     *\n     * @param  { import('../tech/tech').default } tech\n     *         The current tech.\n     *\n     * @param  {string} method\n     *         A method name.\n     *\n     * @param  {*} arg\n     *         The value to set on the tech.\n     *\n     * @return {*}\n     *         The return value of the `method` of the `tech`, regardless of the\n     *         return values of middlewares.\n     */\n    function mediate(middleware, tech, method, arg = null) {\n        const callMethod = 'call' + toTitleCase$1(method);\n        const middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);\n        const terminated = middlewareValue === TERMINATOR;\n        // deprecated. The `null` return value should instead return TERMINATOR to\n        // prevent confusion if a techs method actually returns null.\n        const returnValue = terminated ? null : tech[method](middlewareValue);\n        executeRight(middleware, method, returnValue, terminated);\n        return returnValue;\n    }\n\n    /**\n     * Enumeration of allowed getters where the keys are method names.\n     *\n     * @type {Object}\n     */\n    const allowedGetters = {\n        buffered: 1,\n        currentTime: 1,\n        duration: 1,\n        muted: 1,\n        played: 1,\n        paused: 1,\n        seekable: 1,\n        volume: 1,\n        ended: 1\n    };\n\n    /**\n     * Enumeration of allowed setters where the keys are method names.\n     *\n     * @type {Object}\n     */\n    const allowedSetters = {\n        setCurrentTime: 1,\n        setMuted: 1,\n        setVolume: 1\n    };\n\n    /**\n     * Enumeration of allowed mediators where the keys are method names.\n     *\n     * @type {Object}\n     */\n    const allowedMediators = {\n        play: 1,\n        pause: 1\n    };\n    function middlewareIterator(method) {\n        return (value, mw) => {\n            // if the previous middleware terminated, pass along the termination\n            if (value === TERMINATOR) {\n                return TERMINATOR;\n            }\n            if (mw[method]) {\n                return mw[method](value);\n            }\n            return value;\n        };\n    }\n    function executeRight(mws, method, value, terminated) {\n        for (let i = mws.length - 1; i >= 0; i--) {\n            const mw = mws[i];\n            if (mw[method]) {\n                mw[method](terminated, value);\n            }\n        }\n    }\n\n    /**\n     * Clear the middleware cache for a player.\n     *\n     * @param  { import('../player').default } player\n     *         A {@link Player} instance.\n     */\n    function clearCacheForPlayer(player) {\n        middlewareInstances[player.id()] = null;\n    }\n\n    /**\n     * {\n     *  [playerId]: [[mwFactory, mwInstance], ...]\n     * }\n     *\n     * @private\n     */\n    function getOrCreateFactory(player, mwFactory) {\n        const mws = middlewareInstances[player.id()];\n        let mw = null;\n        if (mws === undefined || mws === null) {\n            mw = mwFactory(player);\n            middlewareInstances[player.id()] = [[mwFactory, mw]];\n            return mw;\n        }\n        for (let i = 0; i < mws.length; i++) {\n            const [mwf, mwi] = mws[i];\n            if (mwf !== mwFactory) {\n                continue;\n            }\n            mw = mwi;\n        }\n        if (mw === null) {\n            mw = mwFactory(player);\n            mws.push([mwFactory, mw]);\n        }\n        return mw;\n    }\n    function setSourceHelper(src = {}, middleware = [], next, player, acc = [], lastRun = false) {\n        const [mwFactory, ...mwrest] = middleware;\n\n        // if mwFactory is a string, then we're at a fork in the road\n        if (typeof mwFactory === 'string') {\n            setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);\n\n            // if we have an mwFactory, call it with the player to get the mw,\n            // then call the mw's setSource method\n        } else if (mwFactory) {\n            const mw = getOrCreateFactory(player, mwFactory);\n\n            // if setSource isn't present, implicitly select this middleware\n            if (!mw.setSource) {\n                acc.push(mw);\n                return setSourceHelper(src, mwrest, next, player, acc, lastRun);\n            }\n            mw.setSource(Object.assign({}, src), function (err, _src) {\n                // something happened, try the next middleware on the current level\n                // make sure to use the old src\n                if (err) {\n                    return setSourceHelper(src, mwrest, next, player, acc, lastRun);\n                }\n\n                // we've succeeded, now we need to go deeper\n                acc.push(mw);\n\n                // if it's the same type, continue down the current chain\n                // otherwise, we want to go down the new chain\n                setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);\n            });\n        } else if (mwrest.length) {\n            setSourceHelper(src, mwrest, next, player, acc, lastRun);\n        } else if (lastRun) {\n            next(src, acc);\n        } else {\n            setSourceHelper(src, middlewares['*'], next, player, acc, true);\n        }\n    }\n\n    /**\n     * Mimetypes\n     *\n     * @see https://www.iana.org/assignments/media-types/media-types.xhtml\n     * @typedef Mimetypes~Kind\n     * @enum\n     */\n    const MimetypesKind = {\n        opus: 'video/ogg',\n        ogv: 'video/ogg',\n        mp4: 'video/mp4',\n        mov: 'video/mp4',\n        m4v: 'video/mp4',\n        mkv: 'video/x-matroska',\n        m4a: 'audio/mp4',\n        mp3: 'audio/mpeg',\n        aac: 'audio/aac',\n        caf: 'audio/x-caf',\n        flac: 'audio/flac',\n        oga: 'audio/ogg',\n        wav: 'audio/wav',\n        m3u8: 'application/x-mpegURL',\n        mpd: 'application/dash+xml',\n        jpg: 'image/jpeg',\n        jpeg: 'image/jpeg',\n        gif: 'image/gif',\n        png: 'image/png',\n        svg: 'image/svg+xml',\n        webp: 'image/webp'\n    };\n\n    /**\n     * Get the mimetype of a given src url if possible\n     *\n     * @param {string} src\n     *        The url to the src\n     *\n     * @return {string}\n     *         return the mimetype if it was known or empty string otherwise\n     */\n    const getMimetype = function (src = '') {\n        const ext = getFileExtension(src);\n        const mimetype = MimetypesKind[ext.toLowerCase()];\n        return mimetype || '';\n    };\n\n    /**\n     * Find the mime type of a given source string if possible. Uses the player\n     * source cache.\n     *\n     * @param { import('../player').default } player\n     *        The player object\n     *\n     * @param {string} src\n     *        The source string\n     *\n     * @return {string}\n     *         The type that was found\n     */\n    const findMimetype = (player, src) => {\n        if (!src) {\n            return '';\n        }\n\n        // 1. check for the type in the `source` cache\n        if (player.cache_.source.src === src && player.cache_.source.type) {\n            return player.cache_.source.type;\n        }\n\n        // 2. see if we have this source in our `currentSources` cache\n        const matchingSources = player.cache_.sources.filter(s => s.src === src);\n        if (matchingSources.length) {\n            return matchingSources[0].type;\n        }\n\n        // 3. look for the src url in source elements and use the type there\n        const sources = player.$$('source');\n        for (let i = 0; i < sources.length; i++) {\n            const s = sources[i];\n            if (s.type && s.src && s.src === src) {\n                return s.type;\n            }\n        }\n\n        // 4. finally fallback to our list of mime types based on src url extension\n        return getMimetype(src);\n    };\n\n    /**\n     * @module filter-source\n     */\n\n    /**\n     * Filter out single bad source objects or multiple source objects in an\n     * array. Also flattens nested source object arrays into a 1 dimensional\n     * array of source objects.\n     *\n     * @param {Tech~SourceObject|Tech~SourceObject[]} src\n     *        The src object to filter\n     *\n     * @return {Tech~SourceObject[]}\n     *         An array of sourceobjects containing only valid sources\n     *\n     * @private\n     */\n    const filterSource = function (src) {\n        // traverse array\n        if (Array.isArray(src)) {\n            let newsrc = [];\n            src.forEach(function (srcobj) {\n                srcobj = filterSource(srcobj);\n                if (Array.isArray(srcobj)) {\n                    newsrc = newsrc.concat(srcobj);\n                } else if (isObject$1(srcobj)) {\n                    newsrc.push(srcobj);\n                }\n            });\n            src = newsrc;\n        } else if (typeof src === 'string' && src.trim()) {\n            // convert string into object\n            src = [fixSource({\n                src\n            })];\n        } else if (isObject$1(src) && typeof src.src === 'string' && src.src && src.src.trim()) {\n            // src is already valid\n            src = [fixSource(src)];\n        } else {\n            // invalid source, turn it into an empty array\n            src = [];\n        }\n        return src;\n    };\n\n    /**\n     * Checks src mimetype, adding it when possible\n     *\n     * @param {Tech~SourceObject} src\n     *        The src object to check\n     * @return {Tech~SourceObject}\n     *        src Object with known type\n     */\n    function fixSource(src) {\n        if (!src.type) {\n            const mimetype = getMimetype(src.src);\n            if (mimetype) {\n                src.type = mimetype;\n            }\n        }\n        return src;\n    }\n\n    /**\n     * @file loader.js\n     */\n\n    /**\n     * The `MediaLoader` is the `Component` that decides which playback technology to load\n     * when a player is initialized.\n     *\n     * @extends Component\n     */\n    class MediaLoader extends Component$1 {\n        /**\n         * Create an instance of this class.\n         *\n         * @param { import('../player').default } player\n         *        The `Player` that this class should attach to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        The function that is run when this component is ready.\n         */\n        constructor(player, options, ready) {\n            // MediaLoader has no element\n            const options_ = merge$2({\n                createEl: false\n            }, options);\n            super(player, options_, ready);\n\n            // If there are no sources when the player is initialized,\n            // load the first supported playback technology.\n\n            if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {\n                for (let i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {\n                    const techName = toTitleCase$1(j[i]);\n                    let tech = Tech.getTech(techName);\n\n                    // Support old behavior of techs being registered as components.\n                    // Remove once that deprecated behavior is removed.\n                    if (!techName) {\n                        tech = Component$1.getComponent(techName);\n                    }\n\n                    // Check if the browser supports this technology\n                    if (tech && tech.isSupported()) {\n                        player.loadTech_(techName);\n                        break;\n                    }\n                }\n            } else {\n                // Loop through playback technologies (e.g. HTML5) and check for support.\n                // Then load the best source.\n                // A few assumptions here:\n                //   All playback technologies respect preload false.\n                player.src(options.playerOptions.sources);\n            }\n        }\n    }\n    Component$1.registerComponent('MediaLoader', MediaLoader);\n\n    /**\n     * @file clickable-component.js\n     */\n\n    /**\n     * Component which is clickable or keyboard actionable, but is not a\n     * native HTML button.\n     *\n     * @extends Component\n     */\n    class ClickableComponent extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param  { import('./player').default } player\n         *         The `Player` that this class should be attached to.\n         *\n         * @param  {Object} [options]\n         *         The key/value store of component options.\n         *\n         * @param  {function} [options.clickHandler]\n         *         The function to call when the button is clicked / activated\n         *\n         * @param  {string} [options.controlText]\n         *         The text to set on the button\n         *\n         * @param  {string} [options.className]\n         *         A class or space separated list of classes to add the component\n         *\n         */\n        constructor(player, options) {\n            super(player, options);\n            if (this.options_.controlText) {\n                this.controlText(this.options_.controlText);\n            }\n            this.handleMouseOver_ = e => this.handleMouseOver(e);\n            this.handleMouseOut_ = e => this.handleMouseOut(e);\n            this.handleClick_ = e => this.handleClick(e);\n            this.handleKeyDown_ = e => this.handleKeyDown(e);\n            this.emitTapEvents();\n            this.enable();\n        }\n\n        /**\n         * Create the `ClickableComponent`s DOM element.\n         *\n         * @param {string} [tag=div]\n         *        The element's node type.\n         *\n         * @param {Object} [props={}]\n         *        An object of properties that should be set on the element.\n         *\n         * @param {Object} [attributes={}]\n         *        An object of attributes that should be set on the element.\n         *\n         * @return {Element}\n         *         The element that gets created.\n         */\n        createEl(tag = 'div', props = {}, attributes = {}) {\n            props = Object.assign({\n                className: this.buildCSSClass(),\n                tabIndex: 0\n            }, props);\n            if (tag === 'button') {\n                log$1.error(`Creating a ClickableComponent with an HTML element of ${tag} is not supported; use a Button instead.`);\n            }\n\n            // Add ARIA attributes for clickable element which is not a native HTML button\n            attributes = Object.assign({\n                role: 'button'\n            }, attributes);\n            this.tabIndex_ = props.tabIndex;\n            const el = createEl(tag, props, attributes);\n            el.appendChild(createEl('span', {\n                className: 'vjs-icon-placeholder'\n            }, {\n                'aria-hidden': true\n            }));\n            this.createControlTextEl(el);\n            return el;\n        }\n        dispose() {\n            // remove controlTextEl_ on dispose\n            this.controlTextEl_ = null;\n            super.dispose();\n        }\n\n        /**\n         * Create a control text element on this `ClickableComponent`\n         *\n         * @param {Element} [el]\n         *        Parent element for the control text.\n         *\n         * @return {Element}\n         *         The control text element that gets created.\n         */\n        createControlTextEl(el) {\n            this.controlTextEl_ = createEl('span', {\n                className: 'vjs-control-text'\n            }, {\n                // let the screen reader user know that the text of the element may change\n                'aria-live': 'polite'\n            });\n            if (el) {\n                el.appendChild(this.controlTextEl_);\n            }\n            this.controlText(this.controlText_, el);\n            return this.controlTextEl_;\n        }\n\n        /**\n         * Get or set the localize text to use for the controls on the `ClickableComponent`.\n         *\n         * @param {string} [text]\n         *        Control text for element.\n         *\n         * @param {Element} [el=this.el()]\n         *        Element to set the title on.\n         *\n         * @return {string}\n         *         - The control text when getting\n         */\n        controlText(text, el = this.el()) {\n            if (text === undefined) {\n                return this.controlText_ || 'Need Text';\n            }\n            const localizedText = this.localize(text);\n\n            /** @protected */\n            this.controlText_ = text;\n            textContent(this.controlTextEl_, localizedText);\n            if (!this.nonIconControl && !this.player_.options_.noUITitleAttributes) {\n                // Set title attribute if only an icon is shown\n                el.setAttribute('title', localizedText);\n            }\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-control vjs-button ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Enable this `ClickableComponent`\n         */\n        enable() {\n            if (!this.enabled_) {\n                this.enabled_ = true;\n                this.removeClass('vjs-disabled');\n                this.el_.setAttribute('aria-disabled', 'false');\n                if (typeof this.tabIndex_ !== 'undefined') {\n                    this.el_.setAttribute('tabIndex', this.tabIndex_);\n                }\n                this.on(['tap', 'click'], this.handleClick_);\n                this.on('keydown', this.handleKeyDown_);\n            }\n        }\n\n        /**\n         * Disable this `ClickableComponent`\n         */\n        disable() {\n            this.enabled_ = false;\n            this.addClass('vjs-disabled');\n            this.el_.setAttribute('aria-disabled', 'true');\n            if (typeof this.tabIndex_ !== 'undefined') {\n                this.el_.removeAttribute('tabIndex');\n            }\n            this.off('mouseover', this.handleMouseOver_);\n            this.off('mouseout', this.handleMouseOut_);\n            this.off(['tap', 'click'], this.handleClick_);\n            this.off('keydown', this.handleKeyDown_);\n        }\n\n        /**\n         * Handles language change in ClickableComponent for the player in components\n         *\n         *\n         */\n        handleLanguagechange() {\n            this.controlText(this.controlText_);\n        }\n\n        /**\n         * Event handler that is called when a `ClickableComponent` receives a\n         * `click` or `tap` event.\n         *\n         * @param {Event} event\n         *        The `tap` or `click` event that caused this function to be called.\n         *\n         * @listens tap\n         * @listens click\n         * @abstract\n         */\n        handleClick(event) {\n            if (this.options_.clickHandler) {\n                this.options_.clickHandler.call(this, arguments);\n            }\n        }\n\n        /**\n         * Event handler that is called when a `ClickableComponent` receives a\n         * `keydown` event.\n         *\n         * By default, if the key is Space or Enter, it will trigger a `click` event.\n         *\n         * @param {Event} event\n         *        The `keydown` event that caused this function to be called.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            // Support Space or Enter key operation to fire a click event. Also,\n            // prevent the event from propagating through the DOM and triggering\n            // Player hotkeys.\n            if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.trigger('click');\n            } else {\n                // Pass keypress handling up for unsupported keys\n                super.handleKeyDown(event);\n            }\n        }\n    }\n    Component$1.registerComponent('ClickableComponent', ClickableComponent);\n\n    /**\n     * @file poster-image.js\n     */\n\n    /**\n     * A `ClickableComponent` that handles showing the poster image for the player.\n     *\n     * @extends ClickableComponent\n     */\n    class PosterImage extends ClickableComponent {\n        /**\n         * Create an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should attach to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.update();\n            this.update_ = e => this.update(e);\n            player.on('posterchange', this.update_);\n        }\n\n        /**\n         * Clean up and dispose of the `PosterImage`.\n         */\n        dispose() {\n            this.player().off('posterchange', this.update_);\n            super.dispose();\n        }\n\n        /**\n         * Create the `PosterImage`s DOM element.\n         *\n         * @return {Element}\n         *         The element that gets created.\n         */\n        createEl() {\n            // The el is an empty div to keep position in the DOM\n            // A picture and img el will be inserted when a source is set\n            return createEl('div', {\n                className: 'vjs-poster'\n            });\n        }\n\n        /**\n         * Get or set the `PosterImage`'s crossOrigin option.\n         *\n         * @param {string|null} [value]\n         *        The value to set the crossOrigin to. If an argument is\n         *        given, must be one of `'anonymous'` or `'use-credentials'`, or 'null'.\n         *\n         * @return {string|null}\n         *         - The current crossOrigin value of the `Player` when getting.\n         *         - undefined when setting\n         */\n        crossOrigin(value) {\n            // `null` can be set to unset a value\n            if (typeof value === 'undefined') {\n                if (this.$('img')) {\n                    // If the poster's element exists, give its value\n                    return this.$('img').crossOrigin;\n                } else if (this.player_.tech_ && this.player_.tech_.isReady_) {\n                    // If not but the tech is ready, query the tech\n                    return this.player_.crossOrigin();\n                }\n                // Otherwise check options as the  poster is usually set before the state of crossorigin\n                // can be retrieved by the getter\n                return this.player_.options_.crossOrigin || this.player_.options_.crossorigin || null;\n            }\n            if (value !== null && value !== 'anonymous' && value !== 'use-credentials') {\n                this.player_.log.warn(`crossOrigin must be null,  \"anonymous\" or \"use-credentials\", given \"${value}\"`);\n                return;\n            }\n            if (this.$('img')) {\n                this.$('img').crossOrigin = value;\n            }\n            return;\n        }\n\n        /**\n         * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.\n         *\n         * @listens Player#posterchange\n         *\n         * @param {Event} [event]\n         *        The `Player#posterchange` event that triggered this function.\n         */\n        update(event) {\n            const url = this.player().poster();\n            this.setSrc(url);\n\n            // If there's no poster source we should display:none on this component\n            // so it's not still clickable or right-clickable\n            if (url) {\n                this.show();\n            } else {\n                this.hide();\n            }\n        }\n\n        /**\n         * Set the source of the `PosterImage` depending on the display method. (Re)creates\n         * the inner picture and img elementss when needed.\n         *\n         * @param {string} [url]\n         *        The URL to the source for the `PosterImage`. If not specified or falsy,\n         *        any source and ant inner picture/img are removed.\n         */\n        setSrc(url) {\n            if (!url) {\n                this.el_.textContent = '';\n                return;\n            }\n            if (!this.$('img')) {\n                this.el_.appendChild(createEl('picture', {\n                    className: 'vjs-poster',\n                    // Don't want poster to be tabbable.\n                    tabIndex: -1\n                }, {}, createEl('img', {\n                    loading: 'lazy',\n                    crossOrigin: this.crossOrigin()\n                }, {\n                    alt: ''\n                })));\n            }\n            this.$('img').src = url;\n        }\n\n        /**\n         * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See\n         * {@link ClickableComponent#handleClick} for instances where this will be triggered.\n         *\n         * @listens tap\n         * @listens click\n         * @listens keydown\n         *\n         * @param {Event} event\n         +        The `click`, `tap` or `keydown` event that caused this function to be called.\n         */\n        handleClick(event) {\n            // We don't want a click to trigger playback when controls are disabled\n            if (!this.player_.controls()) {\n                return;\n            }\n            if (this.player_.tech(true)) {\n                this.player_.tech(true).focus();\n            }\n            if (this.player_.paused()) {\n                silencePromise(this.player_.play());\n            } else {\n                this.player_.pause();\n            }\n        }\n    }\n\n    /**\n     * Get or set the `PosterImage`'s crossorigin option. For the HTML5 player, this\n     * sets the `crossOrigin` property on the `<img>` tag to control the CORS\n     * behavior.\n     *\n     * @param {string|null} [value]\n     *        The value to set the `PosterImages`'s crossorigin to. If an argument is\n     *        given, must be one of `anonymous` or `use-credentials`.\n     *\n     * @return {string|null|undefined}\n     *         - The current crossorigin value of the `Player` when getting.\n     *         - undefined when setting\n     */\n    PosterImage.prototype.crossorigin = PosterImage.prototype.crossOrigin;\n    Component$1.registerComponent('PosterImage', PosterImage);\n\n    /**\n     * @file text-track-display.js\n     */\n    const darkGray = '#222';\n    const lightGray = '#ccc';\n    const fontMap = {\n        monospace: 'monospace',\n        sansSerif: 'sans-serif',\n        serif: 'serif',\n        monospaceSansSerif: '\"Andale Mono\", \"Lucida Console\", monospace',\n        monospaceSerif: '\"Courier New\", monospace',\n        proportionalSansSerif: 'sans-serif',\n        proportionalSerif: 'serif',\n        casual: '\"Comic Sans MS\", Impact, fantasy',\n        script: '\"Monotype Corsiva\", cursive',\n        smallcaps: '\"Andale Mono\", \"Lucida Console\", monospace, sans-serif'\n    };\n\n    /**\n     * Construct an rgba color from a given hex color code.\n     *\n     * @param {number} color\n     *        Hex number for color, like #f0e or #f604e2.\n     *\n     * @param {number} opacity\n     *        Value for opacity, 0.0 - 1.0.\n     *\n     * @return {string}\n     *         The rgba color that was created, like 'rgba(255, 0, 0, 0.3)'.\n     */\n    function constructColor(color, opacity) {\n        let hex;\n        if (color.length === 4) {\n            // color looks like \"#f0e\"\n            hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3];\n        } else if (color.length === 7) {\n            // color looks like \"#f604e2\"\n            hex = color.slice(1);\n        } else {\n            throw new Error('Invalid color code provided, ' + color + '; must be formatted as e.g. #f0e or #f604e2.');\n        }\n        return 'rgba(' + parseInt(hex.slice(0, 2), 16) + ',' + parseInt(hex.slice(2, 4), 16) + ',' + parseInt(hex.slice(4, 6), 16) + ',' + opacity + ')';\n    }\n\n    /**\n     * Try to update the style of a DOM element. Some style changes will throw an error,\n     * particularly in IE8. Those should be noops.\n     *\n     * @param {Element} el\n     *        The DOM element to be styled.\n     *\n     * @param {string} style\n     *        The CSS property on the element that should be styled.\n     *\n     * @param {string} rule\n     *        The style rule that should be applied to the property.\n     *\n     * @private\n     */\n    function tryUpdateStyle(el, style, rule) {\n        try {\n            el.style[style] = rule;\n        } catch (e) {\n            // Satisfies linter.\n            return;\n        }\n    }\n\n    /**\n     * The component for displaying text track cues.\n     *\n     * @extends Component\n     */\n    class TextTrackDisplay extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        The function to call when `TextTrackDisplay` is ready.\n         */\n        constructor(player, options, ready) {\n            super(player, options, ready);\n            const updateDisplayHandler = e => this.updateDisplay(e);\n            player.on('loadstart', e => this.toggleDisplay(e));\n            player.on('texttrackchange', updateDisplayHandler);\n            player.on('loadedmetadata', e => this.preselectTrack(e));\n\n            // This used to be called during player init, but was causing an error\n            // if a track should show by default and the display hadn't loaded yet.\n            // Should probably be moved to an external track loader when we support\n            // tracks that don't need a display.\n            player.ready(bind_(this, function () {\n                if (player.tech_ && player.tech_.featuresNativeTextTracks) {\n                    this.hide();\n                    return;\n                }\n                player.on('fullscreenchange', updateDisplayHandler);\n                player.on('playerresize', updateDisplayHandler);\n                const screenOrientation = window.screen.orientation || window;\n                const changeOrientationEvent = window.screen.orientation ? 'change' : 'orientationchange';\n                screenOrientation.addEventListener(changeOrientationEvent, updateDisplayHandler);\n                player.on('dispose', () => screenOrientation.removeEventListener(changeOrientationEvent, updateDisplayHandler));\n                const tracks = this.options_.playerOptions.tracks || [];\n                for (let i = 0; i < tracks.length; i++) {\n                    this.player_.addRemoteTextTrack(tracks[i], true);\n                }\n                this.preselectTrack();\n            }));\n        }\n\n        /**\n         * Preselect a track following this precedence:\n         * - matches the previously selected {@link TextTrack}'s language and kind\n         * - matches the previously selected {@link TextTrack}'s language only\n         * - is the first default captions track\n         * - is the first default descriptions track\n         *\n         * @listens Player#loadstart\n         */\n        preselectTrack() {\n            const modes = {\n                captions: 1,\n                subtitles: 1\n            };\n            const trackList = this.player_.textTracks();\n            const userPref = this.player_.cache_.selectedLanguage;\n            let firstDesc;\n            let firstCaptions;\n            let preferredTrack;\n            for (let i = 0; i < trackList.length; i++) {\n                const track = trackList[i];\n                if (userPref && userPref.enabled && userPref.language && userPref.language === track.language && track.kind in modes) {\n                    // Always choose the track that matches both language and kind\n                    if (track.kind === userPref.kind) {\n                        preferredTrack = track;\n                        // or choose the first track that matches language\n                    } else if (!preferredTrack) {\n                        preferredTrack = track;\n                    }\n\n                    // clear everything if offTextTrackMenuItem was clicked\n                } else if (userPref && !userPref.enabled) {\n                    preferredTrack = null;\n                    firstDesc = null;\n                    firstCaptions = null;\n                } else if (track.default) {\n                    if (track.kind === 'descriptions' && !firstDesc) {\n                        firstDesc = track;\n                    } else if (track.kind in modes && !firstCaptions) {\n                        firstCaptions = track;\n                    }\n                }\n            }\n\n            // The preferredTrack matches the user preference and takes\n            // precedence over all the other tracks.\n            // So, display the preferredTrack before the first default track\n            // and the subtitles/captions track before the descriptions track\n            if (preferredTrack) {\n                preferredTrack.mode = 'showing';\n            } else if (firstCaptions) {\n                firstCaptions.mode = 'showing';\n            } else if (firstDesc) {\n                firstDesc.mode = 'showing';\n            }\n        }\n\n        /**\n         * Turn display of {@link TextTrack}'s from the current state into the other state.\n         * There are only two states:\n         * - 'shown'\n         * - 'hidden'\n         *\n         * @listens Player#loadstart\n         */\n        toggleDisplay() {\n            if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {\n                this.hide();\n            } else {\n                this.show();\n            }\n        }\n\n        /**\n         * Create the {@link Component}'s DOM element.\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-text-track-display'\n            }, {\n                'translate': 'yes',\n                'aria-live': 'off',\n                'aria-atomic': 'true'\n            });\n        }\n\n        /**\n         * Clear all displayed {@link TextTrack}s.\n         */\n        clearDisplay() {\n            if (typeof window.WebVTT === 'function') {\n                window.WebVTT.processCues(window, [], this.el_);\n            }\n        }\n\n        /**\n         * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or\n         * a {@link Player#fullscreenchange} is fired.\n         *\n         * @listens Player#texttrackchange\n         * @listens Player#fullscreenchange\n         */\n        updateDisplay() {\n            const tracks = this.player_.textTracks();\n            const allowMultipleShowingTracks = this.options_.allowMultipleShowingTracks;\n            this.clearDisplay();\n            if (allowMultipleShowingTracks) {\n                const showingTracks = [];\n                for (let i = 0; i < tracks.length; ++i) {\n                    const track = tracks[i];\n                    if (track.mode !== 'showing') {\n                        continue;\n                    }\n                    showingTracks.push(track);\n                }\n                this.updateForTrack(showingTracks);\n                return;\n            }\n\n            //  Track display prioritization model: if multiple tracks are 'showing',\n            //  display the first 'subtitles' or 'captions' track which is 'showing',\n            //  otherwise display the first 'descriptions' track which is 'showing'\n\n            let descriptionsTrack = null;\n            let captionsSubtitlesTrack = null;\n            let i = tracks.length;\n            while (i--) {\n                const track = tracks[i];\n                if (track.mode === 'showing') {\n                    if (track.kind === 'descriptions') {\n                        descriptionsTrack = track;\n                    } else {\n                        captionsSubtitlesTrack = track;\n                    }\n                }\n            }\n            if (captionsSubtitlesTrack) {\n                if (this.getAttribute('aria-live') !== 'off') {\n                    this.setAttribute('aria-live', 'off');\n                }\n                this.updateForTrack(captionsSubtitlesTrack);\n            } else if (descriptionsTrack) {\n                if (this.getAttribute('aria-live') !== 'assertive') {\n                    this.setAttribute('aria-live', 'assertive');\n                }\n                this.updateForTrack(descriptionsTrack);\n            }\n        }\n\n        /**\n         * Style {@Link TextTrack} activeCues according to {@Link TextTrackSettings}.\n         *\n         * @param {TextTrack} track\n         *        Text track object containing active cues to style.\n         */\n        updateDisplayState(track) {\n            const overrides = this.player_.textTrackSettings.getValues();\n            const cues = track.activeCues;\n            let i = cues.length;\n            while (i--) {\n                const cue = cues[i];\n                if (!cue) {\n                    continue;\n                }\n                const cueDiv = cue.displayState;\n                if (overrides.color) {\n                    cueDiv.firstChild.style.color = overrides.color;\n                }\n                if (overrides.textOpacity) {\n                    tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));\n                }\n                if (overrides.backgroundColor) {\n                    cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;\n                }\n                if (overrides.backgroundOpacity) {\n                    tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));\n                }\n                if (overrides.windowColor) {\n                    if (overrides.windowOpacity) {\n                        tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));\n                    } else {\n                        cueDiv.style.backgroundColor = overrides.windowColor;\n                    }\n                }\n                if (overrides.edgeStyle) {\n                    if (overrides.edgeStyle === 'dropshadow') {\n                        cueDiv.firstChild.style.textShadow = `2px 2px 3px ${darkGray}, 2px 2px 4px ${darkGray}, 2px 2px 5px ${darkGray}`;\n                    } else if (overrides.edgeStyle === 'raised') {\n                        cueDiv.firstChild.style.textShadow = `1px 1px ${darkGray}, 2px 2px ${darkGray}, 3px 3px ${darkGray}`;\n                    } else if (overrides.edgeStyle === 'depressed') {\n                        cueDiv.firstChild.style.textShadow = `1px 1px ${lightGray}, 0 1px ${lightGray}, -1px -1px ${darkGray}, 0 -1px ${darkGray}`;\n                    } else if (overrides.edgeStyle === 'uniform') {\n                        cueDiv.firstChild.style.textShadow = `0 0 4px ${darkGray}, 0 0 4px ${darkGray}, 0 0 4px ${darkGray}, 0 0 4px ${darkGray}`;\n                    }\n                }\n                if (overrides.fontPercent && overrides.fontPercent !== 1) {\n                    const fontSize = window.parseFloat(cueDiv.style.fontSize);\n                    cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';\n                    cueDiv.style.height = 'auto';\n                    cueDiv.style.top = 'auto';\n                }\n                if (overrides.fontFamily && overrides.fontFamily !== 'default') {\n                    if (overrides.fontFamily === 'small-caps') {\n                        cueDiv.firstChild.style.fontVariant = 'small-caps';\n                    } else {\n                        cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];\n                    }\n                }\n            }\n        }\n\n        /**\n         * Add an {@link TextTrack} to to the {@link Tech}s {@link TextTrackList}.\n         *\n         * @param {TextTrack|TextTrack[]} tracks\n         *        Text track object or text track array to be added to the list.\n         */\n        updateForTrack(tracks) {\n            if (!Array.isArray(tracks)) {\n                tracks = [tracks];\n            }\n            if (typeof window.WebVTT !== 'function' || tracks.every(track => {\n                return !track.activeCues;\n            })) {\n                return;\n            }\n            const cues = [];\n\n            // push all active track cues\n            for (let i = 0; i < tracks.length; ++i) {\n                const track = tracks[i];\n                for (let j = 0; j < track.activeCues.length; ++j) {\n                    cues.push(track.activeCues[j]);\n                }\n            }\n\n            // removes all cues before it processes new ones\n            window.WebVTT.processCues(window, cues, this.el_);\n\n            // add unique class to each language text track & add settings styling if necessary\n            for (let i = 0; i < tracks.length; ++i) {\n                const track = tracks[i];\n                for (let j = 0; j < track.activeCues.length; ++j) {\n                    const cueEl = track.activeCues[j].displayState;\n                    addClass(cueEl, 'vjs-text-track-cue', 'vjs-text-track-cue-' + (track.language ? track.language : i));\n                    if (track.language) {\n                        setAttribute(cueEl, 'lang', track.language);\n                    }\n                }\n                if (this.player_.textTrackSettings) {\n                    this.updateDisplayState(track);\n                }\n            }\n        }\n    }\n    Component$1.registerComponent('TextTrackDisplay', TextTrackDisplay);\n\n    /**\n     * @file loading-spinner.js\n     */\n\n    /**\n     * A loading spinner for use during waiting/loading events.\n     *\n     * @extends Component\n     */\n    class LoadingSpinner extends Component$1 {\n        /**\n         * Create the `LoadingSpinner`s DOM element.\n         *\n         * @return {Element}\n         *         The dom element that gets created.\n         */\n        createEl() {\n            const isAudio = this.player_.isAudio();\n            const playerType = this.localize(isAudio ? 'Audio Player' : 'Video Player');\n            const controlText = createEl('span', {\n                className: 'vjs-control-text',\n                textContent: this.localize('{1} is loading.', [playerType])\n            });\n            const el = super.createEl('div', {\n                className: 'vjs-loading-spinner',\n                dir: 'ltr'\n            });\n            el.appendChild(controlText);\n            return el;\n        }\n\n        /**\n         * Update control text on languagechange\n         */\n        handleLanguagechange() {\n            this.$('.vjs-control-text').textContent = this.localize('{1} is loading.', [this.player_.isAudio() ? 'Audio Player' : 'Video Player']);\n        }\n    }\n    Component$1.registerComponent('LoadingSpinner', LoadingSpinner);\n\n    /**\n     * @file button.js\n     */\n\n    /**\n     * Base class for all buttons.\n     *\n     * @extends ClickableComponent\n     */\n    class Button extends ClickableComponent {\n        /**\n         * Create the `Button`s DOM element.\n         *\n         * @param {string} [tag=\"button\"]\n         *        The element's node type. This argument is IGNORED: no matter what\n         *        is passed, it will always create a `button` element.\n         *\n         * @param {Object} [props={}]\n         *        An object of properties that should be set on the element.\n         *\n         * @param {Object} [attributes={}]\n         *        An object of attributes that should be set on the element.\n         *\n         * @return {Element}\n         *         The element that gets created.\n         */\n        createEl(tag, props = {}, attributes = {}) {\n            tag = 'button';\n            props = Object.assign({\n                className: this.buildCSSClass()\n            }, props);\n\n            // Add attributes for button element\n            attributes = Object.assign({\n                // Necessary since the default button type is \"submit\"\n                type: 'button'\n            }, attributes);\n            const el = createEl(tag, props, attributes);\n            el.appendChild(createEl('span', {\n                className: 'vjs-icon-placeholder'\n            }, {\n                'aria-hidden': true\n            }));\n            this.createControlTextEl(el);\n            return el;\n        }\n\n        /**\n         * Add a child `Component` inside of this `Button`.\n         *\n         * @param {string|Component} child\n         *        The name or instance of a child to add.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of options that will get passed to children of\n         *        the child.\n         *\n         * @return {Component}\n         *         The `Component` that gets added as a child. When using a string the\n         *         `Component` will get created by this process.\n         *\n         * @deprecated since version 5\n         */\n        addChild(child, options = {}) {\n            const className = this.constructor.name;\n            log$1.warn(`Adding an actionable (user controllable) child to a Button (${className}) is not supported; use a ClickableComponent instead.`);\n\n            // Avoid the error message generated by ClickableComponent's addChild method\n            return Component$1.prototype.addChild.call(this, child, options);\n        }\n\n        /**\n         * Enable the `Button` element so that it can be activated or clicked. Use this with\n         * {@link Button#disable}.\n         */\n        enable() {\n            super.enable();\n            this.el_.removeAttribute('disabled');\n        }\n\n        /**\n         * Disable the `Button` element so that it cannot be activated or clicked. Use this with\n         * {@link Button#enable}.\n         */\n        disable() {\n            super.disable();\n            this.el_.setAttribute('disabled', 'disabled');\n        }\n\n        /**\n         * This gets called when a `Button` has focus and `keydown` is triggered via a key\n         * press.\n         *\n         * @param {Event} event\n         *        The event that caused this function to get called.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            // Ignore Space or Enter key operation, which is handled by the browser for\n            // a button - though not for its super class, ClickableComponent. Also,\n            // prevent the event from propagating through the DOM and triggering Player\n            // hotkeys. We do not preventDefault here because we _want_ the browser to\n            // handle it.\n            if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {\n                event.stopPropagation();\n                return;\n            }\n\n            // Pass keypress handling up for unsupported keys\n            super.handleKeyDown(event);\n        }\n    }\n    Component$1.registerComponent('Button', Button);\n\n    /**\n     * @file big-play-button.js\n     */\n\n    /**\n     * The initial play button that shows before the video has played. The hiding of the\n     * `BigPlayButton` get done via CSS and `Player` states.\n     *\n     * @extends Button\n     */\n    class BigPlayButton extends Button {\n        constructor(player, options) {\n            super(player, options);\n            this.mouseused_ = false;\n            this.on('mousedown', e => this.handleMouseDown(e));\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.\n         */\n        buildCSSClass() {\n            return 'vjs-big-play-button';\n        }\n\n        /**\n         * This gets called when a `BigPlayButton` \"clicked\". See {@link ClickableComponent}\n         * for more detailed information on what a click can be.\n         *\n         * @param {KeyboardEvent} event\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            const playPromise = this.player_.play();\n\n            // exit early if clicked via the mouse\n            if (this.mouseused_ && event.clientX && event.clientY) {\n                silencePromise(playPromise);\n                if (this.player_.tech(true)) {\n                    this.player_.tech(true).focus();\n                }\n                return;\n            }\n            const cb = this.player_.getChild('controlBar');\n            const playToggle = cb && cb.getChild('playToggle');\n            if (!playToggle) {\n                this.player_.tech(true).focus();\n                return;\n            }\n            const playFocus = () => playToggle.focus();\n            if (isPromise(playPromise)) {\n                playPromise.then(playFocus, () => {});\n            } else {\n                this.setTimeout(playFocus, 1);\n            }\n        }\n        handleKeyDown(event) {\n            this.mouseused_ = false;\n            super.handleKeyDown(event);\n        }\n        handleMouseDown(event) {\n            this.mouseused_ = true;\n        }\n    }\n\n    /**\n     * The text that should display over the `BigPlayButton`s controls. Added to for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    BigPlayButton.prototype.controlText_ = 'Play Video';\n    Component$1.registerComponent('BigPlayButton', BigPlayButton);\n\n    /**\n     * @file close-button.js\n     */\n\n    /**\n     * The `CloseButton` is a `{@link Button}` that fires a `close` event when\n     * it gets clicked.\n     *\n     * @extends Button\n     */\n    class CloseButton extends Button {\n        /**\n         * Creates an instance of the this class.\n         *\n         * @param  { import('./player').default } player\n         *         The `Player` that this class should be attached to.\n         *\n         * @param  {Object} [options]\n         *         The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.controlText(options && options.controlText || this.localize('Close'));\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-close-button ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * This gets called when a `CloseButton` gets clicked. See\n         * {@link ClickableComponent#handleClick} for more information on when\n         * this will be triggered\n         *\n         * @param {Event} event\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         * @fires CloseButton#close\n         */\n        handleClick(event) {\n            /**\n             * Triggered when the a `CloseButton` is clicked.\n             *\n             * @event CloseButton#close\n             * @type {Event}\n             *\n             * @property {boolean} [bubbles=false]\n             *           set to false so that the close event does not\n             *           bubble up to parents if there is no listener\n             */\n            this.trigger({\n                type: 'close',\n                bubbles: false\n            });\n        }\n        /**\n         * Event handler that is called when a `CloseButton` receives a\n         * `keydown` event.\n         *\n         * By default, if the key is Esc, it will trigger a `click` event.\n         *\n         * @param {Event} event\n         *        The `keydown` event that caused this function to be called.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            // Esc button will trigger `click` event\n            if (keycode.isEventKey(event, 'Esc')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.trigger('click');\n            } else {\n                // Pass keypress handling up for unsupported keys\n                super.handleKeyDown(event);\n            }\n        }\n    }\n    Component$1.registerComponent('CloseButton', CloseButton);\n\n    /**\n     * @file play-toggle.js\n     */\n\n    /**\n     * Button to toggle between play and pause.\n     *\n     * @extends Button\n     */\n    class PlayToggle extends Button {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of player options.\n         */\n        constructor(player, options = {}) {\n            super(player, options);\n\n            // show or hide replay icon\n            options.replay = options.replay === undefined || options.replay;\n            this.on(player, 'play', e => this.handlePlay(e));\n            this.on(player, 'pause', e => this.handlePause(e));\n            if (options.replay) {\n                this.on(player, 'ended', e => this.handleEnded(e));\n            }\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-play-control ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * This gets called when an `PlayToggle` is \"clicked\". See\n         * {@link ClickableComponent} for more detailed information on what a click can be.\n         *\n         * @param {Event} [event]\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            if (this.player_.paused()) {\n                silencePromise(this.player_.play());\n            } else {\n                this.player_.pause();\n            }\n        }\n\n        /**\n         * This gets called once after the video has ended and the user seeks so that\n         * we can change the replay button back to a play button.\n         *\n         * @param {Event} [event]\n         *        The event that caused this function to run.\n         *\n         * @listens Player#seeked\n         */\n        handleSeeked(event) {\n            this.removeClass('vjs-ended');\n            if (this.player_.paused()) {\n                this.handlePause(event);\n            } else {\n                this.handlePlay(event);\n            }\n        }\n\n        /**\n         * Add the vjs-playing class to the element so it can change appearance.\n         *\n         * @param {Event} [event]\n         *        The event that caused this function to run.\n         *\n         * @listens Player#play\n         */\n        handlePlay(event) {\n            this.removeClass('vjs-ended', 'vjs-paused');\n            this.addClass('vjs-playing');\n            // change the button text to \"Pause\"\n            this.controlText('Pause');\n        }\n\n        /**\n         * Add the vjs-paused class to the element so it can change appearance.\n         *\n         * @param {Event} [event]\n         *        The event that caused this function to run.\n         *\n         * @listens Player#pause\n         */\n        handlePause(event) {\n            this.removeClass('vjs-playing');\n            this.addClass('vjs-paused');\n            // change the button text to \"Play\"\n            this.controlText('Play');\n        }\n\n        /**\n         * Add the vjs-ended class to the element so it can change appearance\n         *\n         * @param {Event} [event]\n         *        The event that caused this function to run.\n         *\n         * @listens Player#ended\n         */\n        handleEnded(event) {\n            this.removeClass('vjs-playing');\n            this.addClass('vjs-ended');\n            // change the button text to \"Replay\"\n            this.controlText('Replay');\n\n            // on the next seek remove the replay button\n            this.one(this.player_, 'seeked', e => this.handleSeeked(e));\n        }\n    }\n\n    /**\n     * The text that should display over the `PlayToggle`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    PlayToggle.prototype.controlText_ = 'Play';\n    Component$1.registerComponent('PlayToggle', PlayToggle);\n\n    /**\n     * @file time-display.js\n     */\n\n    /**\n     * Displays time information about the video\n     *\n     * @extends Component\n     */\n    class TimeDisplay extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.on(player, ['timeupdate', 'ended'], e => this.updateContent(e));\n            this.updateTextNode_();\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            const className = this.buildCSSClass();\n            const el = super.createEl('div', {\n                className: `${className} vjs-time-control vjs-control`\n            });\n            const span = createEl('span', {\n                className: 'vjs-control-text',\n                textContent: `${this.localize(this.labelText_)}\\u00a0`\n            }, {\n                role: 'presentation'\n            });\n            el.appendChild(span);\n            this.contentEl_ = createEl('span', {\n                className: `${className}-display`\n            }, {\n                // span elements have no implicit role, but some screen readers (notably VoiceOver)\n                // treat them as a break between items in the DOM when using arrow keys\n                // (or left-to-right swipes on iOS) to read contents of a page. Using\n                // role='presentation' causes VoiceOver to NOT treat this span as a break.\n                role: 'presentation'\n            });\n            el.appendChild(this.contentEl_);\n            return el;\n        }\n        dispose() {\n            this.contentEl_ = null;\n            this.textNode_ = null;\n            super.dispose();\n        }\n\n        /**\n         * Updates the time display text node with a new time\n         *\n         * @param {number} [time=0] the time to update to\n         *\n         * @private\n         */\n        updateTextNode_(time = 0) {\n            time = formatTime(time);\n            if (this.formattedTime_ === time) {\n                return;\n            }\n            this.formattedTime_ = time;\n            this.requestNamedAnimationFrame('TimeDisplay#updateTextNode_', () => {\n                if (!this.contentEl_) {\n                    return;\n                }\n                let oldNode = this.textNode_;\n                if (oldNode && this.contentEl_.firstChild !== oldNode) {\n                    oldNode = null;\n                    log$1.warn('TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.');\n                }\n                this.textNode_ = document.createTextNode(this.formattedTime_);\n                if (!this.textNode_) {\n                    return;\n                }\n                if (oldNode) {\n                    this.contentEl_.replaceChild(this.textNode_, oldNode);\n                } else {\n                    this.contentEl_.appendChild(this.textNode_);\n                }\n            });\n        }\n\n        /**\n         * To be filled out in the child class, should update the displayed time\n         * in accordance with the fact that the current time has changed.\n         *\n         * @param {Event} [event]\n         *        The `timeupdate`  event that caused this to run.\n         *\n         * @listens Player#timeupdate\n         */\n        updateContent(event) {}\n    }\n\n    /**\n     * The text that is added to the `TimeDisplay` for screen reader users.\n     *\n     * @type {string}\n     * @private\n     */\n    TimeDisplay.prototype.labelText_ = 'Time';\n\n    /**\n     * The text that should display over the `TimeDisplay`s controls. Added to for localization.\n     *\n     * @type {string}\n     * @protected\n     *\n     * @deprecated in v7; controlText_ is not used in non-active display Components\n     */\n    TimeDisplay.prototype.controlText_ = 'Time';\n    Component$1.registerComponent('TimeDisplay', TimeDisplay);\n\n    /**\n     * @file current-time-display.js\n     */\n\n    /**\n     * Displays the current time\n     *\n     * @extends Component\n     */\n    class CurrentTimeDisplay extends TimeDisplay {\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return 'vjs-current-time';\n        }\n\n        /**\n         * Update current time display\n         *\n         * @param {Event} [event]\n         *        The `timeupdate` event that caused this function to run.\n         *\n         * @listens Player#timeupdate\n         */\n        updateContent(event) {\n            // Allows for smooth scrubbing, when player can't keep up.\n            let time;\n            if (this.player_.ended()) {\n                time = this.player_.duration();\n            } else {\n                time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n            }\n            this.updateTextNode_(time);\n        }\n    }\n\n    /**\n     * The text that is added to the `CurrentTimeDisplay` for screen reader users.\n     *\n     * @type {string}\n     * @private\n     */\n    CurrentTimeDisplay.prototype.labelText_ = 'Current Time';\n\n    /**\n     * The text that should display over the `CurrentTimeDisplay`s controls. Added to for localization.\n     *\n     * @type {string}\n     * @protected\n     *\n     * @deprecated in v7; controlText_ is not used in non-active display Components\n     */\n    CurrentTimeDisplay.prototype.controlText_ = 'Current Time';\n    Component$1.registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);\n\n    /**\n     * @file duration-display.js\n     */\n\n    /**\n     * Displays the duration\n     *\n     * @extends Component\n     */\n    class DurationDisplay extends TimeDisplay {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            const updateContent = e => this.updateContent(e);\n\n            // we do not want to/need to throttle duration changes,\n            // as they should always display the changed duration as\n            // it has changed\n            this.on(player, 'durationchange', updateContent);\n\n            // Listen to loadstart because the player duration is reset when a new media element is loaded,\n            // but the durationchange on the user agent will not fire.\n            // @see [Spec]{@link https://www.w3.org/TR/2011/WD-html5-20110113/video.html#media-element-load-algorithm}\n            this.on(player, 'loadstart', updateContent);\n\n            // Also listen for timeupdate (in the parent) and loadedmetadata because removing those\n            // listeners could have broken dependent applications/libraries. These\n            // can likely be removed for 7.0.\n            this.on(player, 'loadedmetadata', updateContent);\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return 'vjs-duration';\n        }\n\n        /**\n         * Update duration time display.\n         *\n         * @param {Event} [event]\n         *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused\n         *        this function to be called.\n         *\n         * @listens Player#durationchange\n         * @listens Player#timeupdate\n         * @listens Player#loadedmetadata\n         */\n        updateContent(event) {\n            const duration = this.player_.duration();\n            this.updateTextNode_(duration);\n        }\n    }\n\n    /**\n     * The text that is added to the `DurationDisplay` for screen reader users.\n     *\n     * @type {string}\n     * @private\n     */\n    DurationDisplay.prototype.labelText_ = 'Duration';\n\n    /**\n     * The text that should display over the `DurationDisplay`s controls. Added to for localization.\n     *\n     * @type {string}\n     * @protected\n     *\n     * @deprecated in v7; controlText_ is not used in non-active display Components\n     */\n    DurationDisplay.prototype.controlText_ = 'Duration';\n    Component$1.registerComponent('DurationDisplay', DurationDisplay);\n\n    /**\n     * @file time-divider.js\n     */\n\n    /**\n     * The separator between the current time and duration.\n     * Can be hidden if it's not needed in the design.\n     *\n     * @extends Component\n     */\n    class TimeDivider extends Component$1 {\n        /**\n         * Create the component's DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            const el = super.createEl('div', {\n                className: 'vjs-time-control vjs-time-divider'\n            }, {\n                // this element and its contents can be hidden from assistive techs since\n                // it is made extraneous by the announcement of the control text\n                // for the current time and duration displays\n                'aria-hidden': true\n            });\n            const div = super.createEl('div');\n            const span = super.createEl('span', {\n                textContent: '/'\n            });\n            div.appendChild(span);\n            el.appendChild(div);\n            return el;\n        }\n    }\n    Component$1.registerComponent('TimeDivider', TimeDivider);\n\n    /**\n     * @file remaining-time-display.js\n     */\n\n    /**\n     * Displays the time left in the video\n     *\n     * @extends Component\n     */\n    class RemainingTimeDisplay extends TimeDisplay {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.on(player, 'durationchange', e => this.updateContent(e));\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return 'vjs-remaining-time';\n        }\n\n        /**\n         * Create the `Component`'s DOM element with the \"minus\" character prepend to the time\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            const el = super.createEl();\n            if (this.options_.displayNegative !== false) {\n                el.insertBefore(createEl('span', {}, {\n                    'aria-hidden': true\n                }, '-'), this.contentEl_);\n            }\n            return el;\n        }\n\n        /**\n         * Update remaining time display.\n         *\n         * @param {Event} [event]\n         *        The `timeupdate` or `durationchange` event that caused this to run.\n         *\n         * @listens Player#timeupdate\n         * @listens Player#durationchange\n         */\n        updateContent(event) {\n            if (typeof this.player_.duration() !== 'number') {\n                return;\n            }\n            let time;\n\n            // @deprecated We should only use remainingTimeDisplay\n            // as of video.js 7\n            if (this.player_.ended()) {\n                time = 0;\n            } else if (this.player_.remainingTimeDisplay) {\n                time = this.player_.remainingTimeDisplay();\n            } else {\n                time = this.player_.remainingTime();\n            }\n            this.updateTextNode_(time);\n        }\n    }\n\n    /**\n     * The text that is added to the `RemainingTimeDisplay` for screen reader users.\n     *\n     * @type {string}\n     * @private\n     */\n    RemainingTimeDisplay.prototype.labelText_ = 'Remaining Time';\n\n    /**\n     * The text that should display over the `RemainingTimeDisplay`s controls. Added to for localization.\n     *\n     * @type {string}\n     * @protected\n     *\n     * @deprecated in v7; controlText_ is not used in non-active display Components\n     */\n    RemainingTimeDisplay.prototype.controlText_ = 'Remaining Time';\n    Component$1.registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);\n\n    /**\n     * @file live-display.js\n     */\n\n    // TODO - Future make it click to snap to live\n\n    /**\n     * Displays the live indicator when duration is Infinity.\n     *\n     * @extends Component\n     */\n    class LiveDisplay extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.updateShowing();\n            this.on(this.player(), 'durationchange', e => this.updateShowing(e));\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            const el = super.createEl('div', {\n                className: 'vjs-live-control vjs-control'\n            });\n            this.contentEl_ = createEl('div', {\n                className: 'vjs-live-display'\n            }, {\n                'aria-live': 'off'\n            });\n            this.contentEl_.appendChild(createEl('span', {\n                className: 'vjs-control-text',\n                textContent: `${this.localize('Stream Type')}\\u00a0`\n            }));\n            this.contentEl_.appendChild(document.createTextNode(this.localize('LIVE')));\n            el.appendChild(this.contentEl_);\n            return el;\n        }\n        dispose() {\n            this.contentEl_ = null;\n            super.dispose();\n        }\n\n        /**\n         * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide\n         * it accordingly\n         *\n         * @param {Event} [event]\n         *        The {@link Player#durationchange} event that caused this function to run.\n         *\n         * @listens Player#durationchange\n         */\n        updateShowing(event) {\n            if (this.player().duration() === Infinity) {\n                this.show();\n            } else {\n                this.hide();\n            }\n        }\n    }\n    Component$1.registerComponent('LiveDisplay', LiveDisplay);\n\n    /**\n     * @file seek-to-live.js\n     */\n\n    /**\n     * Displays the live indicator when duration is Infinity.\n     *\n     * @extends Component\n     */\n    class SeekToLive extends Button {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.updateLiveEdgeStatus();\n            if (this.player_.liveTracker) {\n                this.updateLiveEdgeStatusHandler_ = e => this.updateLiveEdgeStatus(e);\n                this.on(this.player_.liveTracker, 'liveedgechange', this.updateLiveEdgeStatusHandler_);\n            }\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            const el = super.createEl('button', {\n                className: 'vjs-seek-to-live-control vjs-control'\n            });\n            this.textEl_ = createEl('span', {\n                className: 'vjs-seek-to-live-text',\n                textContent: this.localize('LIVE')\n            }, {\n                'aria-hidden': 'true'\n            });\n            el.appendChild(this.textEl_);\n            return el;\n        }\n\n        /**\n         * Update the state of this button if we are at the live edge\n         * or not\n         */\n        updateLiveEdgeStatus() {\n            // default to live edge\n            if (!this.player_.liveTracker || this.player_.liveTracker.atLiveEdge()) {\n                this.setAttribute('aria-disabled', true);\n                this.addClass('vjs-at-live-edge');\n                this.controlText('Seek to live, currently playing live');\n            } else {\n                this.setAttribute('aria-disabled', false);\n                this.removeClass('vjs-at-live-edge');\n                this.controlText('Seek to live, currently behind live');\n            }\n        }\n\n        /**\n         * On click bring us as near to the live point as possible.\n         * This requires that we wait for the next `live-seekable-change`\n         * event which will happen every segment length seconds.\n         */\n        handleClick() {\n            this.player_.liveTracker.seekToLiveEdge();\n        }\n\n        /**\n         * Dispose of the element and stop tracking\n         */\n        dispose() {\n            if (this.player_.liveTracker) {\n                this.off(this.player_.liveTracker, 'liveedgechange', this.updateLiveEdgeStatusHandler_);\n            }\n            this.textEl_ = null;\n            super.dispose();\n        }\n    }\n    /**\n     * The text that should display over the `SeekToLive`s control. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    SeekToLive.prototype.controlText_ = 'Seek to live, currently playing live';\n    Component$1.registerComponent('SeekToLive', SeekToLive);\n\n    /**\n     * @file num.js\n     * @module num\n     */\n\n    /**\n     * Keep a number between a min and a max value\n     *\n     * @param {number} number\n     *        The number to clamp\n     *\n     * @param {number} min\n     *        The minimum value\n     * @param {number} max\n     *        The maximum value\n     *\n     * @return {number}\n     *         the clamped number\n     */\n    function clamp(number, min, max) {\n        number = Number(number);\n        return Math.min(max, Math.max(min, isNaN(number) ? min : number));\n    }\n\n    var Num = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        clamp: clamp\n    });\n\n    /**\n     * @file slider.js\n     */\n\n    /**\n     * The base functionality for a slider. Can be vertical or horizontal.\n     * For instance the volume bar or the seek bar on a video is a slider.\n     *\n     * @extends Component\n     */\n    class Slider extends Component$1 {\n        /**\n         * Create an instance of this class\n         *\n         * @param { import('../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.handleMouseDown_ = e => this.handleMouseDown(e);\n            this.handleMouseUp_ = e => this.handleMouseUp(e);\n            this.handleKeyDown_ = e => this.handleKeyDown(e);\n            this.handleClick_ = e => this.handleClick(e);\n            this.handleMouseMove_ = e => this.handleMouseMove(e);\n            this.update_ = e => this.update(e);\n\n            // Set property names to bar to match with the child Slider class is looking for\n            this.bar = this.getChild(this.options_.barName);\n\n            // Set a horizontal or vertical class on the slider depending on the slider type\n            this.vertical(!!this.options_.vertical);\n            this.enable();\n        }\n\n        /**\n         * Are controls are currently enabled for this slider or not.\n         *\n         * @return {boolean}\n         *         true if controls are enabled, false otherwise\n         */\n        enabled() {\n            return this.enabled_;\n        }\n\n        /**\n         * Enable controls for this slider if they are disabled\n         */\n        enable() {\n            if (this.enabled()) {\n                return;\n            }\n            this.on('mousedown', this.handleMouseDown_);\n            this.on('touchstart', this.handleMouseDown_);\n            this.on('keydown', this.handleKeyDown_);\n            this.on('click', this.handleClick_);\n\n            // TODO: deprecated, controlsvisible does not seem to be fired\n            this.on(this.player_, 'controlsvisible', this.update);\n            if (this.playerEvent) {\n                this.on(this.player_, this.playerEvent, this.update);\n            }\n            this.removeClass('disabled');\n            this.setAttribute('tabindex', 0);\n            this.enabled_ = true;\n        }\n\n        /**\n         * Disable controls for this slider if they are enabled\n         */\n        disable() {\n            if (!this.enabled()) {\n                return;\n            }\n            const doc = this.bar.el_.ownerDocument;\n            this.off('mousedown', this.handleMouseDown_);\n            this.off('touchstart', this.handleMouseDown_);\n            this.off('keydown', this.handleKeyDown_);\n            this.off('click', this.handleClick_);\n            this.off(this.player_, 'controlsvisible', this.update_);\n            this.off(doc, 'mousemove', this.handleMouseMove_);\n            this.off(doc, 'mouseup', this.handleMouseUp_);\n            this.off(doc, 'touchmove', this.handleMouseMove_);\n            this.off(doc, 'touchend', this.handleMouseUp_);\n            this.removeAttribute('tabindex');\n            this.addClass('disabled');\n            if (this.playerEvent) {\n                this.off(this.player_, this.playerEvent, this.update);\n            }\n            this.enabled_ = false;\n        }\n\n        /**\n         * Create the `Slider`s DOM element.\n         *\n         * @param {string} type\n         *        Type of element to create.\n         *\n         * @param {Object} [props={}]\n         *        List of properties in Object form.\n         *\n         * @param {Object} [attributes={}]\n         *        list of attributes in Object form.\n         *\n         * @return {Element}\n         *         The element that gets created.\n         */\n        createEl(type, props = {}, attributes = {}) {\n            // Add the slider element class to all sub classes\n            props.className = props.className + ' vjs-slider';\n            props = Object.assign({\n                tabIndex: 0\n            }, props);\n            attributes = Object.assign({\n                'role': 'slider',\n                'aria-valuenow': 0,\n                'aria-valuemin': 0,\n                'aria-valuemax': 100\n            }, attributes);\n            return super.createEl(type, props, attributes);\n        }\n\n        /**\n         * Handle `mousedown` or `touchstart` events on the `Slider`.\n         *\n         * @param {MouseEvent} event\n         *        `mousedown` or `touchstart` event that triggered this function\n         *\n         * @listens mousedown\n         * @listens touchstart\n         * @fires Slider#slideractive\n         */\n        handleMouseDown(event) {\n            const doc = this.bar.el_.ownerDocument;\n            if (event.type === 'mousedown') {\n                event.preventDefault();\n            }\n            // Do not call preventDefault() on touchstart in Chrome\n            // to avoid console warnings. Use a 'touch-action: none' style\n            // instead to prevent unintended scrolling.\n            // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n            if (event.type === 'touchstart' && !IS_CHROME) {\n                event.preventDefault();\n            }\n            blockTextSelection();\n            this.addClass('vjs-sliding');\n            /**\n             * Triggered when the slider is in an active state\n             *\n             * @event Slider#slideractive\n             * @type {MouseEvent}\n             */\n            this.trigger('slideractive');\n            this.on(doc, 'mousemove', this.handleMouseMove_);\n            this.on(doc, 'mouseup', this.handleMouseUp_);\n            this.on(doc, 'touchmove', this.handleMouseMove_);\n            this.on(doc, 'touchend', this.handleMouseUp_);\n            this.handleMouseMove(event, true);\n        }\n\n        /**\n         * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.\n         * The `mousemove` and `touchmove` events will only only trigger this function during\n         * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and\n         * {@link Slider#handleMouseUp}.\n         *\n         * @param {MouseEvent} event\n         *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered\n         *        this function\n         * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false.\n         *\n         * @listens mousemove\n         * @listens touchmove\n         */\n        handleMouseMove(event) {}\n\n        /**\n         * Handle `mouseup` or `touchend` events on the `Slider`.\n         *\n         * @param {MouseEvent} event\n         *        `mouseup` or `touchend` event that triggered this function.\n         *\n         * @listens touchend\n         * @listens mouseup\n         * @fires Slider#sliderinactive\n         */\n        handleMouseUp(event) {\n            const doc = this.bar.el_.ownerDocument;\n            unblockTextSelection();\n            this.removeClass('vjs-sliding');\n            /**\n             * Triggered when the slider is no longer in an active state.\n             *\n             * @event Slider#sliderinactive\n             * @type {Event}\n             */\n            this.trigger('sliderinactive');\n            this.off(doc, 'mousemove', this.handleMouseMove_);\n            this.off(doc, 'mouseup', this.handleMouseUp_);\n            this.off(doc, 'touchmove', this.handleMouseMove_);\n            this.off(doc, 'touchend', this.handleMouseUp_);\n            this.update();\n        }\n\n        /**\n         * Update the progress bar of the `Slider`.\n         *\n         * @return {number}\n         *          The percentage of progress the progress bar represents as a\n         *          number from 0 to 1.\n         */\n        update() {\n            // In VolumeBar init we have a setTimeout for update that pops and update\n            // to the end of the execution stack. The player is destroyed before then\n            // update will cause an error\n            // If there's no bar...\n            if (!this.el_ || !this.bar) {\n                return;\n            }\n\n            // clamp progress between 0 and 1\n            // and only round to four decimal places, as we round to two below\n            const progress = this.getProgress();\n            if (progress === this.progress_) {\n                return progress;\n            }\n            this.progress_ = progress;\n            this.requestNamedAnimationFrame('Slider#update', () => {\n                // Set the new bar width or height\n                const sizeKey = this.vertical() ? 'height' : 'width';\n\n                // Convert to a percentage for css value\n                this.bar.el().style[sizeKey] = (progress * 100).toFixed(2) + '%';\n            });\n            return progress;\n        }\n\n        /**\n         * Get the percentage of the bar that should be filled\n         * but clamped and rounded.\n         *\n         * @return {number}\n         *         percentage filled that the slider is\n         */\n        getProgress() {\n            return Number(clamp(this.getPercent(), 0, 1).toFixed(4));\n        }\n\n        /**\n         * Calculate distance for slider\n         *\n         * @param {Event} event\n         *        The event that caused this function to run.\n         *\n         * @return {number}\n         *         The current position of the Slider.\n         *         - position.x for vertical `Slider`s\n         *         - position.y for horizontal `Slider`s\n         */\n        calculateDistance(event) {\n            const position = getPointerPosition(this.el_, event);\n            if (this.vertical()) {\n                return position.y;\n            }\n            return position.x;\n        }\n\n        /**\n         * Handle a `keydown` event on the `Slider`. Watches for left, right, up, and down\n         * arrow keys. This function will only be called when the slider has focus. See\n         * {@link Slider#handleFocus} and {@link Slider#handleBlur}.\n         *\n         * @param {KeyboardEvent} event\n         *        the `keydown` event that caused this function to run.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            // Left and Down Arrows\n            if (keycode.isEventKey(event, 'Left') || keycode.isEventKey(event, 'Down')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.stepBack();\n\n                // Up and Right Arrows\n            } else if (keycode.isEventKey(event, 'Right') || keycode.isEventKey(event, 'Up')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.stepForward();\n            } else {\n                // Pass keydown handling up for unsupported keys\n                super.handleKeyDown(event);\n            }\n        }\n\n        /**\n         * Listener for click events on slider, used to prevent clicks\n         *   from bubbling up to parent elements like button menus.\n         *\n         * @param {Object} event\n         *        Event that caused this object to run\n         */\n        handleClick(event) {\n            event.stopPropagation();\n            event.preventDefault();\n        }\n\n        /**\n         * Get/set if slider is horizontal for vertical\n         *\n         * @param {boolean} [bool]\n         *        - true if slider is vertical,\n         *        - false is horizontal\n         *\n         * @return {boolean}\n         *         - true if slider is vertical, and getting\n         *         - false if the slider is horizontal, and getting\n         */\n        vertical(bool) {\n            if (bool === undefined) {\n                return this.vertical_ || false;\n            }\n            this.vertical_ = !!bool;\n            if (this.vertical_) {\n                this.addClass('vjs-slider-vertical');\n            } else {\n                this.addClass('vjs-slider-horizontal');\n            }\n        }\n    }\n    Component$1.registerComponent('Slider', Slider);\n\n    /**\n     * @file load-progress-bar.js\n     */\n\n        // get the percent width of a time compared to the total end\n    const percentify = (time, end) => clamp(time / end * 100, 0, 100).toFixed(2) + '%';\n\n    /**\n     * Shows loading progress\n     *\n     * @extends Component\n     */\n    class LoadProgressBar extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.partEls_ = [];\n            this.on(player, 'progress', e => this.update(e));\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            const el = super.createEl('div', {\n                className: 'vjs-load-progress'\n            });\n            const wrapper = createEl('span', {\n                className: 'vjs-control-text'\n            });\n            const loadedText = createEl('span', {\n                textContent: this.localize('Loaded')\n            });\n            const separator = document.createTextNode(': ');\n            this.percentageEl_ = createEl('span', {\n                className: 'vjs-control-text-loaded-percentage',\n                textContent: '0%'\n            });\n            el.appendChild(wrapper);\n            wrapper.appendChild(loadedText);\n            wrapper.appendChild(separator);\n            wrapper.appendChild(this.percentageEl_);\n            return el;\n        }\n        dispose() {\n            this.partEls_ = null;\n            this.percentageEl_ = null;\n            super.dispose();\n        }\n\n        /**\n         * Update progress bar\n         *\n         * @param {Event} [event]\n         *        The `progress` event that caused this function to run.\n         *\n         * @listens Player#progress\n         */\n        update(event) {\n            this.requestNamedAnimationFrame('LoadProgressBar#update', () => {\n                const liveTracker = this.player_.liveTracker;\n                const buffered = this.player_.buffered();\n                const duration = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : this.player_.duration();\n                const bufferedEnd = this.player_.bufferedEnd();\n                const children = this.partEls_;\n                const percent = percentify(bufferedEnd, duration);\n                if (this.percent_ !== percent) {\n                    // update the width of the progress bar\n                    this.el_.style.width = percent;\n                    // update the control-text\n                    textContent(this.percentageEl_, percent);\n                    this.percent_ = percent;\n                }\n\n                // add child elements to represent the individual buffered time ranges\n                for (let i = 0; i < buffered.length; i++) {\n                    const start = buffered.start(i);\n                    const end = buffered.end(i);\n                    let part = children[i];\n                    if (!part) {\n                        part = this.el_.appendChild(createEl());\n                        children[i] = part;\n                    }\n\n                    //  only update if changed\n                    if (part.dataset.start === start && part.dataset.end === end) {\n                        continue;\n                    }\n                    part.dataset.start = start;\n                    part.dataset.end = end;\n\n                    // set the percent based on the width of the progress bar (bufferedEnd)\n                    part.style.left = percentify(start, bufferedEnd);\n                    part.style.width = percentify(end - start, bufferedEnd);\n                }\n\n                // remove unused buffered range elements\n                for (let i = children.length; i > buffered.length; i--) {\n                    this.el_.removeChild(children[i - 1]);\n                }\n                children.length = buffered.length;\n            });\n        }\n    }\n    Component$1.registerComponent('LoadProgressBar', LoadProgressBar);\n\n    /**\n     * @file time-tooltip.js\n     */\n\n    /**\n     * Time tooltips display a time above the progress bar.\n     *\n     * @extends Component\n     */\n    class TimeTooltip extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The {@link Player} that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);\n        }\n\n        /**\n         * Create the time tooltip DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-time-tooltip'\n            }, {\n                'aria-hidden': 'true'\n            });\n        }\n\n        /**\n         * Updates the position of the time tooltip relative to the `SeekBar`.\n         *\n         * @param {Object} seekBarRect\n         *        The `ClientRect` for the {@link SeekBar} element.\n         *\n         * @param {number} seekBarPoint\n         *        A number from 0 to 1, representing a horizontal reference point\n         *        from the left edge of the {@link SeekBar}\n         */\n        update(seekBarRect, seekBarPoint, content) {\n            const tooltipRect = findPosition(this.el_);\n            const playerRect = getBoundingClientRect(this.player_.el());\n            const seekBarPointPx = seekBarRect.width * seekBarPoint;\n\n            // do nothing if either rect isn't available\n            // for example, if the player isn't in the DOM for testing\n            if (!playerRect || !tooltipRect) {\n                return;\n            }\n\n            // This is the space left of the `seekBarPoint` available within the bounds\n            // of the player. We calculate any gap between the left edge of the player\n            // and the left edge of the `SeekBar` and add the number of pixels in the\n            // `SeekBar` before hitting the `seekBarPoint`\n            const spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;\n\n            // This is the space right of the `seekBarPoint` available within the bounds\n            // of the player. We calculate the number of pixels from the `seekBarPoint`\n            // to the right edge of the `SeekBar` and add to that any gap between the\n            // right edge of the `SeekBar` and the player.\n            const spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);\n\n            // This is the number of pixels by which the tooltip will need to be pulled\n            // further to the right to center it over the `seekBarPoint`.\n            let pullTooltipBy = tooltipRect.width / 2;\n\n            // Adjust the `pullTooltipBy` distance to the left or right depending on\n            // the results of the space calculations above.\n            if (spaceLeftOfPoint < pullTooltipBy) {\n                pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;\n            } else if (spaceRightOfPoint < pullTooltipBy) {\n                pullTooltipBy = spaceRightOfPoint;\n            }\n\n            // Due to the imprecision of decimal/ratio based calculations and varying\n            // rounding behaviors, there are cases where the spacing adjustment is off\n            // by a pixel or two. This adds insurance to these calculations.\n            if (pullTooltipBy < 0) {\n                pullTooltipBy = 0;\n            } else if (pullTooltipBy > tooltipRect.width) {\n                pullTooltipBy = tooltipRect.width;\n            }\n\n            // prevent small width fluctuations within 0.4px from\n            // changing the value below.\n            // This really helps for live to prevent the play\n            // progress time tooltip from jittering\n            pullTooltipBy = Math.round(pullTooltipBy);\n            this.el_.style.right = `-${pullTooltipBy}px`;\n            this.write(content);\n        }\n\n        /**\n         * Write the time to the tooltip DOM element.\n         *\n         * @param {string} content\n         *        The formatted time for the tooltip.\n         */\n        write(content) {\n            textContent(this.el_, content);\n        }\n\n        /**\n         * Updates the position of the time tooltip relative to the `SeekBar`.\n         *\n         * @param {Object} seekBarRect\n         *        The `ClientRect` for the {@link SeekBar} element.\n         *\n         * @param {number} seekBarPoint\n         *        A number from 0 to 1, representing a horizontal reference point\n         *        from the left edge of the {@link SeekBar}\n         *\n         * @param {number} time\n         *        The time to update the tooltip to, not used during live playback\n         *\n         * @param {Function} cb\n         *        A function that will be called during the request animation frame\n         *        for tooltips that need to do additional animations from the default\n         */\n        updateTime(seekBarRect, seekBarPoint, time, cb) {\n            this.requestNamedAnimationFrame('TimeTooltip#updateTime', () => {\n                let content;\n                const duration = this.player_.duration();\n                if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {\n                    const liveWindow = this.player_.liveTracker.liveWindow();\n                    const secondsBehind = liveWindow - seekBarPoint * liveWindow;\n                    content = (secondsBehind < 1 ? '' : '-') + formatTime(secondsBehind, liveWindow);\n                } else {\n                    content = formatTime(time, duration);\n                }\n                this.update(seekBarRect, seekBarPoint, content);\n                if (cb) {\n                    cb();\n                }\n            });\n        }\n    }\n    Component$1.registerComponent('TimeTooltip', TimeTooltip);\n\n    /**\n     * @file play-progress-bar.js\n     */\n\n    /**\n     * Used by {@link SeekBar} to display media playback progress as part of the\n     * {@link ProgressControl}.\n     *\n     * @extends Component\n     */\n    class PlayProgressBar extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The {@link Player} that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);\n        }\n\n        /**\n         * Create the the DOM element for this class.\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-play-progress vjs-slider-bar'\n            }, {\n                'aria-hidden': 'true'\n            });\n        }\n\n        /**\n         * Enqueues updates to its own DOM as well as the DOM of its\n         * {@link TimeTooltip} child.\n         *\n         * @param {Object} seekBarRect\n         *        The `ClientRect` for the {@link SeekBar} element.\n         *\n         * @param {number} seekBarPoint\n         *        A number from 0 to 1, representing a horizontal reference point\n         *        from the left edge of the {@link SeekBar}\n         */\n        update(seekBarRect, seekBarPoint) {\n            const timeTooltip = this.getChild('timeTooltip');\n            if (!timeTooltip) {\n                return;\n            }\n            const time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n            timeTooltip.updateTime(seekBarRect, seekBarPoint, time);\n        }\n    }\n\n    /**\n     * Default options for {@link PlayProgressBar}.\n     *\n     * @type {Object}\n     * @private\n     */\n    PlayProgressBar.prototype.options_ = {\n        children: []\n    };\n\n    // Time tooltips should not be added to a player on mobile devices\n    if (!IS_IOS && !IS_ANDROID) {\n        PlayProgressBar.prototype.options_.children.push('timeTooltip');\n    }\n    Component$1.registerComponent('PlayProgressBar', PlayProgressBar);\n\n    /**\n     * @file mouse-time-display.js\n     */\n\n    /**\n     * The {@link MouseTimeDisplay} component tracks mouse movement over the\n     * {@link ProgressControl}. It displays an indicator and a {@link TimeTooltip}\n     * indicating the time which is represented by a given point in the\n     * {@link ProgressControl}.\n     *\n     * @extends Component\n     */\n    class MouseTimeDisplay extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The {@link Player} that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);\n        }\n\n        /**\n         * Create the DOM element for this class.\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-mouse-display'\n            });\n        }\n\n        /**\n         * Enqueues updates to its own DOM as well as the DOM of its\n         * {@link TimeTooltip} child.\n         *\n         * @param {Object} seekBarRect\n         *        The `ClientRect` for the {@link SeekBar} element.\n         *\n         * @param {number} seekBarPoint\n         *        A number from 0 to 1, representing a horizontal reference point\n         *        from the left edge of the {@link SeekBar}\n         */\n        update(seekBarRect, seekBarPoint) {\n            const time = seekBarPoint * this.player_.duration();\n            this.getChild('timeTooltip').updateTime(seekBarRect, seekBarPoint, time, () => {\n                this.el_.style.left = `${seekBarRect.width * seekBarPoint}px`;\n            });\n        }\n    }\n\n    /**\n     * Default options for `MouseTimeDisplay`\n     *\n     * @type {Object}\n     * @private\n     */\n    MouseTimeDisplay.prototype.options_ = {\n        children: ['timeTooltip']\n    };\n    Component$1.registerComponent('MouseTimeDisplay', MouseTimeDisplay);\n\n    /**\n     * @file seek-bar.js\n     */\n\n        // The number of seconds the `step*` functions move the timeline.\n    const STEP_SECONDS = 5;\n\n    // The multiplier of STEP_SECONDS that PgUp/PgDown move the timeline.\n    const PAGE_KEY_MULTIPLIER = 12;\n\n    /**\n     * Seek bar and container for the progress bars. Uses {@link PlayProgressBar}\n     * as its `bar`.\n     *\n     * @extends Slider\n     */\n    class SeekBar extends Slider {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.setEventHandlers_();\n        }\n\n        /**\n         * Sets the event handlers\n         *\n         * @private\n         */\n        setEventHandlers_() {\n            this.update_ = bind_(this, this.update);\n            this.update = throttle(this.update_, UPDATE_REFRESH_INTERVAL);\n            this.on(this.player_, ['ended', 'durationchange', 'timeupdate'], this.update);\n            if (this.player_.liveTracker) {\n                this.on(this.player_.liveTracker, 'liveedgechange', this.update);\n            }\n\n            // when playing, let's ensure we smoothly update the play progress bar\n            // via an interval\n            this.updateInterval = null;\n            this.enableIntervalHandler_ = e => this.enableInterval_(e);\n            this.disableIntervalHandler_ = e => this.disableInterval_(e);\n            this.on(this.player_, ['playing'], this.enableIntervalHandler_);\n            this.on(this.player_, ['ended', 'pause', 'waiting'], this.disableIntervalHandler_);\n\n            // we don't need to update the play progress if the document is hidden,\n            // also, this causes the CPU to spike and eventually crash the page on IE11.\n            if ('hidden' in document && 'visibilityState' in document) {\n                this.on(document, 'visibilitychange', this.toggleVisibility_);\n            }\n        }\n        toggleVisibility_(e) {\n            if (document.visibilityState === 'hidden') {\n                this.cancelNamedAnimationFrame('SeekBar#update');\n                this.cancelNamedAnimationFrame('Slider#update');\n                this.disableInterval_(e);\n            } else {\n                if (!this.player_.ended() && !this.player_.paused()) {\n                    this.enableInterval_();\n                }\n\n                // we just switched back to the page and someone may be looking, so, update ASAP\n                this.update();\n            }\n        }\n        enableInterval_() {\n            if (this.updateInterval) {\n                return;\n            }\n            this.updateInterval = this.setInterval(this.update, UPDATE_REFRESH_INTERVAL);\n        }\n        disableInterval_(e) {\n            if (this.player_.liveTracker && this.player_.liveTracker.isLive() && e && e.type !== 'ended') {\n                return;\n            }\n            if (!this.updateInterval) {\n                return;\n            }\n            this.clearInterval(this.updateInterval);\n            this.updateInterval = null;\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-progress-holder'\n            }, {\n                'aria-label': this.localize('Progress Bar')\n            });\n        }\n\n        /**\n         * This function updates the play progress bar and accessibility\n         * attributes to whatever is passed in.\n         *\n         * @param {Event} [event]\n         *        The `timeupdate` or `ended` event that caused this to run.\n         *\n         * @listens Player#timeupdate\n         *\n         * @return {number}\n         *          The current percent at a number from 0-1\n         */\n        update(event) {\n            // ignore updates while the tab is hidden\n            if (document.visibilityState === 'hidden') {\n                return;\n            }\n            const percent = super.update();\n            this.requestNamedAnimationFrame('SeekBar#update', () => {\n                const currentTime = this.player_.ended() ? this.player_.duration() : this.getCurrentTime_();\n                const liveTracker = this.player_.liveTracker;\n                let duration = this.player_.duration();\n                if (liveTracker && liveTracker.isLive()) {\n                    duration = this.player_.liveTracker.liveCurrentTime();\n                }\n                if (this.percent_ !== percent) {\n                    // machine readable value of progress bar (percentage complete)\n                    this.el_.setAttribute('aria-valuenow', (percent * 100).toFixed(2));\n                    this.percent_ = percent;\n                }\n                if (this.currentTime_ !== currentTime || this.duration_ !== duration) {\n                    // human readable value of progress bar (time complete)\n                    this.el_.setAttribute('aria-valuetext', this.localize('progress bar timing: currentTime={1} duration={2}', [formatTime(currentTime, duration), formatTime(duration, duration)], '{1} of {2}'));\n                    this.currentTime_ = currentTime;\n                    this.duration_ = duration;\n                }\n\n                // update the progress bar time tooltip with the current time\n                if (this.bar) {\n                    this.bar.update(getBoundingClientRect(this.el()), this.getProgress());\n                }\n            });\n            return percent;\n        }\n\n        /**\n         * Prevent liveThreshold from causing seeks to seem like they\n         * are not happening from a user perspective.\n         *\n         * @param {number} ct\n         *        current time to seek to\n         */\n        userSeek_(ct) {\n            if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {\n                this.player_.liveTracker.nextSeekedFromUser();\n            }\n            this.player_.currentTime(ct);\n        }\n\n        /**\n         * Get the value of current time but allows for smooth scrubbing,\n         * when player can't keep up.\n         *\n         * @return {number}\n         *         The current time value to display\n         *\n         * @private\n         */\n        getCurrentTime_() {\n            return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();\n        }\n\n        /**\n         * Get the percentage of media played so far.\n         *\n         * @return {number}\n         *         The percentage of media played so far (0 to 1).\n         */\n        getPercent() {\n            const currentTime = this.getCurrentTime_();\n            let percent;\n            const liveTracker = this.player_.liveTracker;\n            if (liveTracker && liveTracker.isLive()) {\n                percent = (currentTime - liveTracker.seekableStart()) / liveTracker.liveWindow();\n\n                // prevent the percent from changing at the live edge\n                if (liveTracker.atLiveEdge()) {\n                    percent = 1;\n                }\n            } else {\n                percent = currentTime / this.player_.duration();\n            }\n            return percent;\n        }\n\n        /**\n         * Handle mouse down on seek bar\n         *\n         * @param {MouseEvent} event\n         *        The `mousedown` event that caused this to run.\n         *\n         * @listens mousedown\n         */\n        handleMouseDown(event) {\n            if (!isSingleLeftClick(event)) {\n                return;\n            }\n\n            // Stop event propagation to prevent double fire in progress-control.js\n            event.stopPropagation();\n            this.videoWasPlaying = !this.player_.paused();\n            this.player_.pause();\n            super.handleMouseDown(event);\n        }\n\n        /**\n         * Handle mouse move on seek bar\n         *\n         * @param {MouseEvent} event\n         *        The `mousemove` event that caused this to run.\n         * @param {boolean} mouseDown this is a flag that should be set to true if `handleMouseMove` is called directly. It allows us to skip things that should not happen if coming from mouse down but should happen on regular mouse move handler. Defaults to false\n         *\n         * @listens mousemove\n         */\n        handleMouseMove(event, mouseDown = false) {\n            if (!isSingleLeftClick(event)) {\n                return;\n            }\n            if (!mouseDown && !this.player_.scrubbing()) {\n                this.player_.scrubbing(true);\n            }\n            let newTime;\n            const distance = this.calculateDistance(event);\n            const liveTracker = this.player_.liveTracker;\n            if (!liveTracker || !liveTracker.isLive()) {\n                newTime = distance * this.player_.duration();\n\n                // Don't let video end while scrubbing.\n                if (newTime === this.player_.duration()) {\n                    newTime = newTime - 0.1;\n                }\n            } else {\n                if (distance >= 0.99) {\n                    liveTracker.seekToLiveEdge();\n                    return;\n                }\n                const seekableStart = liveTracker.seekableStart();\n                const seekableEnd = liveTracker.liveCurrentTime();\n                newTime = seekableStart + distance * liveTracker.liveWindow();\n\n                // Don't let video end while scrubbing.\n                if (newTime >= seekableEnd) {\n                    newTime = seekableEnd;\n                }\n\n                // Compensate for precision differences so that currentTime is not less\n                // than seekable start\n                if (newTime <= seekableStart) {\n                    newTime = seekableStart + 0.1;\n                }\n\n                // On android seekableEnd can be Infinity sometimes,\n                // this will cause newTime to be Infinity, which is\n                // not a valid currentTime.\n                if (newTime === Infinity) {\n                    return;\n                }\n            }\n\n            // Set new time (tell player to seek to new time)\n            this.userSeek_(newTime);\n        }\n        enable() {\n            super.enable();\n            const mouseTimeDisplay = this.getChild('mouseTimeDisplay');\n            if (!mouseTimeDisplay) {\n                return;\n            }\n            mouseTimeDisplay.show();\n        }\n        disable() {\n            super.disable();\n            const mouseTimeDisplay = this.getChild('mouseTimeDisplay');\n            if (!mouseTimeDisplay) {\n                return;\n            }\n            mouseTimeDisplay.hide();\n        }\n\n        /**\n         * Handle mouse up on seek bar\n         *\n         * @param {MouseEvent} event\n         *        The `mouseup` event that caused this to run.\n         *\n         * @listens mouseup\n         */\n        handleMouseUp(event) {\n            super.handleMouseUp(event);\n\n            // Stop event propagation to prevent double fire in progress-control.js\n            if (event) {\n                event.stopPropagation();\n            }\n            this.player_.scrubbing(false);\n\n            /**\n             * Trigger timeupdate because we're done seeking and the time has changed.\n             * This is particularly useful for if the player is paused to time the time displays.\n             *\n             * @event Tech#timeupdate\n             * @type {Event}\n             */\n            this.player_.trigger({\n                type: 'timeupdate',\n                target: this,\n                manuallyTriggered: true\n            });\n            if (this.videoWasPlaying) {\n                silencePromise(this.player_.play());\n            } else {\n                // We're done seeking and the time has changed.\n                // If the player is paused, make sure we display the correct time on the seek bar.\n                this.update_();\n            }\n        }\n\n        /**\n         * Move more quickly fast forward for keyboard-only users\n         */\n        stepForward() {\n            this.userSeek_(this.player_.currentTime() + STEP_SECONDS);\n        }\n\n        /**\n         * Move more quickly rewind for keyboard-only users\n         */\n        stepBack() {\n            this.userSeek_(this.player_.currentTime() - STEP_SECONDS);\n        }\n\n        /**\n         * Toggles the playback state of the player\n         * This gets called when enter or space is used on the seekbar\n         *\n         * @param {KeyboardEvent} event\n         *        The `keydown` event that caused this function to be called\n         *\n         */\n        handleAction(event) {\n            if (this.player_.paused()) {\n                this.player_.play();\n            } else {\n                this.player_.pause();\n            }\n        }\n\n        /**\n         * Called when this SeekBar has focus and a key gets pressed down.\n         * Supports the following keys:\n         *\n         *   Space or Enter key fire a click event\n         *   Home key moves to start of the timeline\n         *   End key moves to end of the timeline\n         *   Digit \"0\" through \"9\" keys move to 0%, 10% ... 80%, 90% of the timeline\n         *   PageDown key moves back a larger step than ArrowDown\n         *   PageUp key moves forward a large step\n         *\n         * @param {KeyboardEvent} event\n         *        The `keydown` event that caused this function to be called.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            const liveTracker = this.player_.liveTracker;\n            if (keycode.isEventKey(event, 'Space') || keycode.isEventKey(event, 'Enter')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.handleAction(event);\n            } else if (keycode.isEventKey(event, 'Home')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.userSeek_(0);\n            } else if (keycode.isEventKey(event, 'End')) {\n                event.preventDefault();\n                event.stopPropagation();\n                if (liveTracker && liveTracker.isLive()) {\n                    this.userSeek_(liveTracker.liveCurrentTime());\n                } else {\n                    this.userSeek_(this.player_.duration());\n                }\n            } else if (/^[0-9]$/.test(keycode(event))) {\n                event.preventDefault();\n                event.stopPropagation();\n                const gotoFraction = (keycode.codes[keycode(event)] - keycode.codes['0']) * 10.0 / 100.0;\n                if (liveTracker && liveTracker.isLive()) {\n                    this.userSeek_(liveTracker.seekableStart() + liveTracker.liveWindow() * gotoFraction);\n                } else {\n                    this.userSeek_(this.player_.duration() * gotoFraction);\n                }\n            } else if (keycode.isEventKey(event, 'PgDn')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.userSeek_(this.player_.currentTime() - STEP_SECONDS * PAGE_KEY_MULTIPLIER);\n            } else if (keycode.isEventKey(event, 'PgUp')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.userSeek_(this.player_.currentTime() + STEP_SECONDS * PAGE_KEY_MULTIPLIER);\n            } else {\n                // Pass keydown handling up for unsupported keys\n                super.handleKeyDown(event);\n            }\n        }\n        dispose() {\n            this.disableInterval_();\n            this.off(this.player_, ['ended', 'durationchange', 'timeupdate'], this.update);\n            if (this.player_.liveTracker) {\n                this.off(this.player_.liveTracker, 'liveedgechange', this.update);\n            }\n            this.off(this.player_, ['playing'], this.enableIntervalHandler_);\n            this.off(this.player_, ['ended', 'pause', 'waiting'], this.disableIntervalHandler_);\n\n            // we don't need to update the play progress if the document is hidden,\n            // also, this causes the CPU to spike and eventually crash the page on IE11.\n            if ('hidden' in document && 'visibilityState' in document) {\n                this.off(document, 'visibilitychange', this.toggleVisibility_);\n            }\n            super.dispose();\n        }\n    }\n\n    /**\n     * Default options for the `SeekBar`\n     *\n     * @type {Object}\n     * @private\n     */\n    SeekBar.prototype.options_ = {\n        children: ['loadProgressBar', 'playProgressBar'],\n        barName: 'playProgressBar'\n    };\n\n    // MouseTimeDisplay tooltips should not be added to a player on mobile devices\n    if (!IS_IOS && !IS_ANDROID) {\n        SeekBar.prototype.options_.children.splice(1, 0, 'mouseTimeDisplay');\n    }\n    Component$1.registerComponent('SeekBar', SeekBar);\n\n    /**\n     * @file progress-control.js\n     */\n\n    /**\n     * The Progress Control component contains the seek bar, load progress,\n     * and play progress.\n     *\n     * @extends Component\n     */\n    class ProgressControl extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.handleMouseMove = throttle(bind_(this, this.handleMouseMove), UPDATE_REFRESH_INTERVAL);\n            this.throttledHandleMouseSeek = throttle(bind_(this, this.handleMouseSeek), UPDATE_REFRESH_INTERVAL);\n            this.handleMouseUpHandler_ = e => this.handleMouseUp(e);\n            this.handleMouseDownHandler_ = e => this.handleMouseDown(e);\n            this.enable();\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-progress-control vjs-control'\n            });\n        }\n\n        /**\n         * When the mouse moves over the `ProgressControl`, the pointer position\n         * gets passed down to the `MouseTimeDisplay` component.\n         *\n         * @param {Event} event\n         *        The `mousemove` event that caused this function to run.\n         *\n         * @listen mousemove\n         */\n        handleMouseMove(event) {\n            const seekBar = this.getChild('seekBar');\n            if (!seekBar) {\n                return;\n            }\n            const playProgressBar = seekBar.getChild('playProgressBar');\n            const mouseTimeDisplay = seekBar.getChild('mouseTimeDisplay');\n            if (!playProgressBar && !mouseTimeDisplay) {\n                return;\n            }\n            const seekBarEl = seekBar.el();\n            const seekBarRect = findPosition(seekBarEl);\n            let seekBarPoint = getPointerPosition(seekBarEl, event).x;\n\n            // The default skin has a gap on either side of the `SeekBar`. This means\n            // that it's possible to trigger this behavior outside the boundaries of\n            // the `SeekBar`. This ensures we stay within it at all times.\n            seekBarPoint = clamp(seekBarPoint, 0, 1);\n            if (mouseTimeDisplay) {\n                mouseTimeDisplay.update(seekBarRect, seekBarPoint);\n            }\n            if (playProgressBar) {\n                playProgressBar.update(seekBarRect, seekBar.getProgress());\n            }\n        }\n\n        /**\n         * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.\n         *\n         * @method ProgressControl#throttledHandleMouseSeek\n         * @param {Event} event\n         *        The `mousemove` event that caused this function to run.\n         *\n         * @listen mousemove\n         * @listen touchmove\n         */\n\n        /**\n         * Handle `mousemove` or `touchmove` events on the `ProgressControl`.\n         *\n         * @param {Event} event\n         *        `mousedown` or `touchstart` event that triggered this function\n         *\n         * @listens mousemove\n         * @listens touchmove\n         */\n        handleMouseSeek(event) {\n            const seekBar = this.getChild('seekBar');\n            if (seekBar) {\n                seekBar.handleMouseMove(event);\n            }\n        }\n\n        /**\n         * Are controls are currently enabled for this progress control.\n         *\n         * @return {boolean}\n         *         true if controls are enabled, false otherwise\n         */\n        enabled() {\n            return this.enabled_;\n        }\n\n        /**\n         * Disable all controls on the progress control and its children\n         */\n        disable() {\n            this.children().forEach(child => child.disable && child.disable());\n            if (!this.enabled()) {\n                return;\n            }\n            this.off(['mousedown', 'touchstart'], this.handleMouseDownHandler_);\n            this.off(this.el_, 'mousemove', this.handleMouseMove);\n            this.removeListenersAddedOnMousedownAndTouchstart();\n            this.addClass('disabled');\n            this.enabled_ = false;\n\n            // Restore normal playback state if controls are disabled while scrubbing\n            if (this.player_.scrubbing()) {\n                const seekBar = this.getChild('seekBar');\n                this.player_.scrubbing(false);\n                if (seekBar.videoWasPlaying) {\n                    silencePromise(this.player_.play());\n                }\n            }\n        }\n\n        /**\n         * Enable all controls on the progress control and its children\n         */\n        enable() {\n            this.children().forEach(child => child.enable && child.enable());\n            if (this.enabled()) {\n                return;\n            }\n            this.on(['mousedown', 'touchstart'], this.handleMouseDownHandler_);\n            this.on(this.el_, 'mousemove', this.handleMouseMove);\n            this.removeClass('disabled');\n            this.enabled_ = true;\n        }\n\n        /**\n         * Cleanup listeners after the user finishes interacting with the progress controls\n         */\n        removeListenersAddedOnMousedownAndTouchstart() {\n            const doc = this.el_.ownerDocument;\n            this.off(doc, 'mousemove', this.throttledHandleMouseSeek);\n            this.off(doc, 'touchmove', this.throttledHandleMouseSeek);\n            this.off(doc, 'mouseup', this.handleMouseUpHandler_);\n            this.off(doc, 'touchend', this.handleMouseUpHandler_);\n        }\n\n        /**\n         * Handle `mousedown` or `touchstart` events on the `ProgressControl`.\n         *\n         * @param {Event} event\n         *        `mousedown` or `touchstart` event that triggered this function\n         *\n         * @listens mousedown\n         * @listens touchstart\n         */\n        handleMouseDown(event) {\n            const doc = this.el_.ownerDocument;\n            const seekBar = this.getChild('seekBar');\n            if (seekBar) {\n                seekBar.handleMouseDown(event);\n            }\n            this.on(doc, 'mousemove', this.throttledHandleMouseSeek);\n            this.on(doc, 'touchmove', this.throttledHandleMouseSeek);\n            this.on(doc, 'mouseup', this.handleMouseUpHandler_);\n            this.on(doc, 'touchend', this.handleMouseUpHandler_);\n        }\n\n        /**\n         * Handle `mouseup` or `touchend` events on the `ProgressControl`.\n         *\n         * @param {Event} event\n         *        `mouseup` or `touchend` event that triggered this function.\n         *\n         * @listens touchend\n         * @listens mouseup\n         */\n        handleMouseUp(event) {\n            const seekBar = this.getChild('seekBar');\n            if (seekBar) {\n                seekBar.handleMouseUp(event);\n            }\n            this.removeListenersAddedOnMousedownAndTouchstart();\n        }\n    }\n\n    /**\n     * Default options for `ProgressControl`\n     *\n     * @type {Object}\n     * @private\n     */\n    ProgressControl.prototype.options_ = {\n        children: ['seekBar']\n    };\n    Component$1.registerComponent('ProgressControl', ProgressControl);\n\n    /**\n     * @file picture-in-picture-toggle.js\n     */\n\n    /**\n     * Toggle Picture-in-Picture mode\n     *\n     * @extends Button\n     */\n    class PictureInPictureToggle extends Button {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @listens Player#enterpictureinpicture\n         * @listens Player#leavepictureinpicture\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.on(player, ['enterpictureinpicture', 'leavepictureinpicture'], e => this.handlePictureInPictureChange(e));\n            this.on(player, ['disablepictureinpicturechanged', 'loadedmetadata'], e => this.handlePictureInPictureEnabledChange(e));\n            this.on(player, ['loadedmetadata', 'audioonlymodechange', 'audiopostermodechange'], () => {\n                // This audio detection will not detect HLS or DASH audio-only streams because there was no reliable way to detect them at the time\n                const isSourceAudio = player.currentType().substring(0, 5) === 'audio';\n                if (isSourceAudio || player.audioPosterMode() || player.audioOnlyMode()) {\n                    if (player.isInPictureInPicture()) {\n                        player.exitPictureInPicture();\n                    }\n                    this.hide();\n                } else {\n                    this.show();\n                }\n            });\n\n            // TODO: Deactivate button on player emptied event.\n            this.disable();\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-picture-in-picture-control ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Enables or disables button based on availability of a Picture-In-Picture mode.\n         *\n         * Enabled if\n         * - `player.options().enableDocumentPictureInPicture` is true and\n         *   window.documentPictureInPicture is available; or\n         * - `player.disablePictureInPicture()` is false and\n         *   element.requestPictureInPicture is available\n         */\n        handlePictureInPictureEnabledChange() {\n            if (document.pictureInPictureEnabled && this.player_.disablePictureInPicture() === false || this.player_.options_.enableDocumentPictureInPicture && 'documentPictureInPicture' in window) {\n                this.enable();\n            } else {\n                this.disable();\n            }\n        }\n\n        /**\n         * Handles enterpictureinpicture and leavepictureinpicture on the player and change control text accordingly.\n         *\n         * @param {Event} [event]\n         *        The {@link Player#enterpictureinpicture} or {@link Player#leavepictureinpicture} event that caused this function to be\n         *        called.\n         *\n         * @listens Player#enterpictureinpicture\n         * @listens Player#leavepictureinpicture\n         */\n        handlePictureInPictureChange(event) {\n            if (this.player_.isInPictureInPicture()) {\n                this.controlText('Exit Picture-in-Picture');\n            } else {\n                this.controlText('Picture-in-Picture');\n            }\n            this.handlePictureInPictureEnabledChange();\n        }\n\n        /**\n         * This gets called when an `PictureInPictureToggle` is \"clicked\". See\n         * {@link ClickableComponent} for more detailed information on what a click can be.\n         *\n         * @param {Event} [event]\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            if (!this.player_.isInPictureInPicture()) {\n                this.player_.requestPictureInPicture();\n            } else {\n                this.player_.exitPictureInPicture();\n            }\n        }\n    }\n\n    /**\n     * The text that should display over the `PictureInPictureToggle`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    PictureInPictureToggle.prototype.controlText_ = 'Picture-in-Picture';\n    Component$1.registerComponent('PictureInPictureToggle', PictureInPictureToggle);\n\n    /**\n     * @file fullscreen-toggle.js\n     */\n\n    /**\n     * Toggle fullscreen video\n     *\n     * @extends Button\n     */\n    class FullscreenToggle extends Button {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.on(player, 'fullscreenchange', e => this.handleFullscreenChange(e));\n            if (document[player.fsApi_.fullscreenEnabled] === false) {\n                this.disable();\n            }\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-fullscreen-control ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Handles fullscreenchange on the player and change control text accordingly.\n         *\n         * @param {Event} [event]\n         *        The {@link Player#fullscreenchange} event that caused this function to be\n         *        called.\n         *\n         * @listens Player#fullscreenchange\n         */\n        handleFullscreenChange(event) {\n            if (this.player_.isFullscreen()) {\n                this.controlText('Exit Fullscreen');\n            } else {\n                this.controlText('Fullscreen');\n            }\n        }\n\n        /**\n         * This gets called when an `FullscreenToggle` is \"clicked\". See\n         * {@link ClickableComponent} for more detailed information on what a click can be.\n         *\n         * @param {Event} [event]\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            if (!this.player_.isFullscreen()) {\n                this.player_.requestFullscreen();\n            } else {\n                this.player_.exitFullscreen();\n            }\n        }\n    }\n\n    /**\n     * The text that should display over the `FullscreenToggle`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    FullscreenToggle.prototype.controlText_ = 'Fullscreen';\n    Component$1.registerComponent('FullscreenToggle', FullscreenToggle);\n\n    /**\n     * Check if volume control is supported and if it isn't hide the\n     * `Component` that was passed  using the `vjs-hidden` class.\n     *\n     * @param { import('../../component').default } self\n     *        The component that should be hidden if volume is unsupported\n     *\n     * @param { import('../../player').default } player\n     *        A reference to the player\n     *\n     * @private\n     */\n    const checkVolumeSupport = function (self, player) {\n        // hide volume controls when they're not supported by the current tech\n        if (player.tech_ && !player.tech_.featuresVolumeControl) {\n            self.addClass('vjs-hidden');\n        }\n        self.on(player, 'loadstart', function () {\n            if (!player.tech_.featuresVolumeControl) {\n                self.addClass('vjs-hidden');\n            } else {\n                self.removeClass('vjs-hidden');\n            }\n        });\n    };\n\n    /**\n     * @file volume-level.js\n     */\n\n    /**\n     * Shows volume level\n     *\n     * @extends Component\n     */\n    class VolumeLevel extends Component$1 {\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            const el = super.createEl('div', {\n                className: 'vjs-volume-level'\n            });\n            el.appendChild(super.createEl('span', {\n                className: 'vjs-control-text'\n            }));\n            return el;\n        }\n    }\n    Component$1.registerComponent('VolumeLevel', VolumeLevel);\n\n    /**\n     * @file volume-level-tooltip.js\n     */\n\n    /**\n     * Volume level tooltips display a volume above or side by side the volume bar.\n     *\n     * @extends Component\n     */\n    class VolumeLevelTooltip extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The {@link Player} that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);\n        }\n\n        /**\n         * Create the volume tooltip DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-volume-tooltip'\n            }, {\n                'aria-hidden': 'true'\n            });\n        }\n\n        /**\n         * Updates the position of the tooltip relative to the `VolumeBar` and\n         * its content text.\n         *\n         * @param {Object} rangeBarRect\n         *        The `ClientRect` for the {@link VolumeBar} element.\n         *\n         * @param {number} rangeBarPoint\n         *        A number from 0 to 1, representing a horizontal/vertical reference point\n         *        from the left edge of the {@link VolumeBar}\n         *\n         * @param {boolean} vertical\n         *        Referees to the Volume control position\n         *        in the control bar{@link VolumeControl}\n         *\n         */\n        update(rangeBarRect, rangeBarPoint, vertical, content) {\n            if (!vertical) {\n                const tooltipRect = getBoundingClientRect(this.el_);\n                const playerRect = getBoundingClientRect(this.player_.el());\n                const volumeBarPointPx = rangeBarRect.width * rangeBarPoint;\n                if (!playerRect || !tooltipRect) {\n                    return;\n                }\n                const spaceLeftOfPoint = rangeBarRect.left - playerRect.left + volumeBarPointPx;\n                const spaceRightOfPoint = rangeBarRect.width - volumeBarPointPx + (playerRect.right - rangeBarRect.right);\n                let pullTooltipBy = tooltipRect.width / 2;\n                if (spaceLeftOfPoint < pullTooltipBy) {\n                    pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;\n                } else if (spaceRightOfPoint < pullTooltipBy) {\n                    pullTooltipBy = spaceRightOfPoint;\n                }\n                if (pullTooltipBy < 0) {\n                    pullTooltipBy = 0;\n                } else if (pullTooltipBy > tooltipRect.width) {\n                    pullTooltipBy = tooltipRect.width;\n                }\n                this.el_.style.right = `-${pullTooltipBy}px`;\n            }\n            this.write(`${content}%`);\n        }\n\n        /**\n         * Write the volume to the tooltip DOM element.\n         *\n         * @param {string} content\n         *        The formatted volume for the tooltip.\n         */\n        write(content) {\n            textContent(this.el_, content);\n        }\n\n        /**\n         * Updates the position of the volume tooltip relative to the `VolumeBar`.\n         *\n         * @param {Object} rangeBarRect\n         *        The `ClientRect` for the {@link VolumeBar} element.\n         *\n         * @param {number} rangeBarPoint\n         *        A number from 0 to 1, representing a horizontal/vertical reference point\n         *        from the left edge of the {@link VolumeBar}\n         *\n         * @param {boolean} vertical\n         *        Referees to the Volume control position\n         *        in the control bar{@link VolumeControl}\n         *\n         * @param {number} volume\n         *        The volume level to update the tooltip to\n         *\n         * @param {Function} cb\n         *        A function that will be called during the request animation frame\n         *        for tooltips that need to do additional animations from the default\n         */\n        updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, cb) {\n            this.requestNamedAnimationFrame('VolumeLevelTooltip#updateVolume', () => {\n                this.update(rangeBarRect, rangeBarPoint, vertical, volume.toFixed(0));\n                if (cb) {\n                    cb();\n                }\n            });\n        }\n    }\n    Component$1.registerComponent('VolumeLevelTooltip', VolumeLevelTooltip);\n\n    /**\n     * @file mouse-volume-level-display.js\n     */\n\n    /**\n     * The {@link MouseVolumeLevelDisplay} component tracks mouse movement over the\n     * {@link VolumeControl}. It displays an indicator and a {@link VolumeLevelTooltip}\n     * indicating the volume level which is represented by a given point in the\n     * {@link VolumeBar}.\n     *\n     * @extends Component\n     */\n    class MouseVolumeLevelDisplay extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The {@link Player} that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);\n        }\n\n        /**\n         * Create the DOM element for this class.\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-mouse-display'\n            });\n        }\n\n        /**\n         * Enquires updates to its own DOM as well as the DOM of its\n         * {@link VolumeLevelTooltip} child.\n         *\n         * @param {Object} rangeBarRect\n         *        The `ClientRect` for the {@link VolumeBar} element.\n         *\n         * @param {number} rangeBarPoint\n         *        A number from 0 to 1, representing a horizontal/vertical reference point\n         *        from the left edge of the {@link VolumeBar}\n         *\n         * @param {boolean} vertical\n         *        Referees to the Volume control position\n         *        in the control bar{@link VolumeControl}\n         *\n         */\n        update(rangeBarRect, rangeBarPoint, vertical) {\n            const volume = 100 * rangeBarPoint;\n            this.getChild('volumeLevelTooltip').updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, () => {\n                if (vertical) {\n                    this.el_.style.bottom = `${rangeBarRect.height * rangeBarPoint}px`;\n                } else {\n                    this.el_.style.left = `${rangeBarRect.width * rangeBarPoint}px`;\n                }\n            });\n        }\n    }\n\n    /**\n     * Default options for `MouseVolumeLevelDisplay`\n     *\n     * @type {Object}\n     * @private\n     */\n    MouseVolumeLevelDisplay.prototype.options_ = {\n        children: ['volumeLevelTooltip']\n    };\n    Component$1.registerComponent('MouseVolumeLevelDisplay', MouseVolumeLevelDisplay);\n\n    /**\n     * @file volume-bar.js\n     */\n\n    /**\n     * The bar that contains the volume level and can be clicked on to adjust the level\n     *\n     * @extends Slider\n     */\n    class VolumeBar extends Slider {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.on('slideractive', e => this.updateLastVolume_(e));\n            this.on(player, 'volumechange', e => this.updateARIAAttributes(e));\n            player.ready(() => this.updateARIAAttributes());\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-volume-bar vjs-slider-bar'\n            }, {\n                'aria-label': this.localize('Volume Level'),\n                'aria-live': 'polite'\n            });\n        }\n\n        /**\n         * Handle mouse down on volume bar\n         *\n         * @param {Event} event\n         *        The `mousedown` event that caused this to run.\n         *\n         * @listens mousedown\n         */\n        handleMouseDown(event) {\n            if (!isSingleLeftClick(event)) {\n                return;\n            }\n            super.handleMouseDown(event);\n        }\n\n        /**\n         * Handle movement events on the {@link VolumeMenuButton}.\n         *\n         * @param {Event} event\n         *        The event that caused this function to run.\n         *\n         * @listens mousemove\n         */\n        handleMouseMove(event) {\n            const mouseVolumeLevelDisplay = this.getChild('mouseVolumeLevelDisplay');\n            if (mouseVolumeLevelDisplay) {\n                const volumeBarEl = this.el();\n                const volumeBarRect = getBoundingClientRect(volumeBarEl);\n                const vertical = this.vertical();\n                let volumeBarPoint = getPointerPosition(volumeBarEl, event);\n                volumeBarPoint = vertical ? volumeBarPoint.y : volumeBarPoint.x;\n                // The default skin has a gap on either side of the `VolumeBar`. This means\n                // that it's possible to trigger this behavior outside the boundaries of\n                // the `VolumeBar`. This ensures we stay within it at all times.\n                volumeBarPoint = clamp(volumeBarPoint, 0, 1);\n                mouseVolumeLevelDisplay.update(volumeBarRect, volumeBarPoint, vertical);\n            }\n            if (!isSingleLeftClick(event)) {\n                return;\n            }\n            this.checkMuted();\n            this.player_.volume(this.calculateDistance(event));\n        }\n\n        /**\n         * If the player is muted unmute it.\n         */\n        checkMuted() {\n            if (this.player_.muted()) {\n                this.player_.muted(false);\n            }\n        }\n\n        /**\n         * Get percent of volume level\n         *\n         * @return {number}\n         *         Volume level percent as a decimal number.\n         */\n        getPercent() {\n            if (this.player_.muted()) {\n                return 0;\n            }\n            return this.player_.volume();\n        }\n\n        /**\n         * Increase volume level for keyboard users\n         */\n        stepForward() {\n            this.checkMuted();\n            this.player_.volume(this.player_.volume() + 0.1);\n        }\n\n        /**\n         * Decrease volume level for keyboard users\n         */\n        stepBack() {\n            this.checkMuted();\n            this.player_.volume(this.player_.volume() - 0.1);\n        }\n\n        /**\n         * Update ARIA accessibility attributes\n         *\n         * @param {Event} [event]\n         *        The `volumechange` event that caused this function to run.\n         *\n         * @listens Player#volumechange\n         */\n        updateARIAAttributes(event) {\n            const ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();\n            this.el_.setAttribute('aria-valuenow', ariaValue);\n            this.el_.setAttribute('aria-valuetext', ariaValue + '%');\n        }\n\n        /**\n         * Returns the current value of the player volume as a percentage\n         *\n         * @private\n         */\n        volumeAsPercentage_() {\n            return Math.round(this.player_.volume() * 100);\n        }\n\n        /**\n         * When user starts dragging the VolumeBar, store the volume and listen for\n         * the end of the drag. When the drag ends, if the volume was set to zero,\n         * set lastVolume to the stored volume.\n         *\n         * @listens slideractive\n         * @private\n         */\n        updateLastVolume_() {\n            const volumeBeforeDrag = this.player_.volume();\n            this.one('sliderinactive', () => {\n                if (this.player_.volume() === 0) {\n                    this.player_.lastVolume_(volumeBeforeDrag);\n                }\n            });\n        }\n    }\n\n    /**\n     * Default options for the `VolumeBar`\n     *\n     * @type {Object}\n     * @private\n     */\n    VolumeBar.prototype.options_ = {\n        children: ['volumeLevel'],\n        barName: 'volumeLevel'\n    };\n\n    // MouseVolumeLevelDisplay tooltip should not be added to a player on mobile devices\n    if (!IS_IOS && !IS_ANDROID) {\n        VolumeBar.prototype.options_.children.splice(0, 0, 'mouseVolumeLevelDisplay');\n    }\n\n    /**\n     * Call the update event for this Slider when this event happens on the player.\n     *\n     * @type {string}\n     */\n    VolumeBar.prototype.playerEvent = 'volumechange';\n    Component$1.registerComponent('VolumeBar', VolumeBar);\n\n    /**\n     * @file volume-control.js\n     */\n\n    /**\n     * The component for controlling the volume level\n     *\n     * @extends Component\n     */\n    class VolumeControl extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of player options.\n         */\n        constructor(player, options = {}) {\n            options.vertical = options.vertical || false;\n\n            // Pass the vertical option down to the VolumeBar if\n            // the VolumeBar is turned on.\n            if (typeof options.volumeBar === 'undefined' || isPlain(options.volumeBar)) {\n                options.volumeBar = options.volumeBar || {};\n                options.volumeBar.vertical = options.vertical;\n            }\n            super(player, options);\n\n            // hide this control if volume support is missing\n            checkVolumeSupport(this, player);\n            this.throttledHandleMouseMove = throttle(bind_(this, this.handleMouseMove), UPDATE_REFRESH_INTERVAL);\n            this.handleMouseUpHandler_ = e => this.handleMouseUp(e);\n            this.on('mousedown', e => this.handleMouseDown(e));\n            this.on('touchstart', e => this.handleMouseDown(e));\n            this.on('mousemove', e => this.handleMouseMove(e));\n\n            // while the slider is active (the mouse has been pressed down and\n            // is dragging) or in focus we do not want to hide the VolumeBar\n            this.on(this.volumeBar, ['focus', 'slideractive'], () => {\n                this.volumeBar.addClass('vjs-slider-active');\n                this.addClass('vjs-slider-active');\n                this.trigger('slideractive');\n            });\n            this.on(this.volumeBar, ['blur', 'sliderinactive'], () => {\n                this.volumeBar.removeClass('vjs-slider-active');\n                this.removeClass('vjs-slider-active');\n                this.trigger('sliderinactive');\n            });\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            let orientationClass = 'vjs-volume-horizontal';\n            if (this.options_.vertical) {\n                orientationClass = 'vjs-volume-vertical';\n            }\n            return super.createEl('div', {\n                className: `vjs-volume-control vjs-control ${orientationClass}`\n            });\n        }\n\n        /**\n         * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n         *\n         * @param {Event} event\n         *        `mousedown` or `touchstart` event that triggered this function\n         *\n         * @listens mousedown\n         * @listens touchstart\n         */\n        handleMouseDown(event) {\n            const doc = this.el_.ownerDocument;\n            this.on(doc, 'mousemove', this.throttledHandleMouseMove);\n            this.on(doc, 'touchmove', this.throttledHandleMouseMove);\n            this.on(doc, 'mouseup', this.handleMouseUpHandler_);\n            this.on(doc, 'touchend', this.handleMouseUpHandler_);\n        }\n\n        /**\n         * Handle `mouseup` or `touchend` events on the `VolumeControl`.\n         *\n         * @param {Event} event\n         *        `mouseup` or `touchend` event that triggered this function.\n         *\n         * @listens touchend\n         * @listens mouseup\n         */\n        handleMouseUp(event) {\n            const doc = this.el_.ownerDocument;\n            this.off(doc, 'mousemove', this.throttledHandleMouseMove);\n            this.off(doc, 'touchmove', this.throttledHandleMouseMove);\n            this.off(doc, 'mouseup', this.handleMouseUpHandler_);\n            this.off(doc, 'touchend', this.handleMouseUpHandler_);\n        }\n\n        /**\n         * Handle `mousedown` or `touchstart` events on the `VolumeControl`.\n         *\n         * @param {Event} event\n         *        `mousedown` or `touchstart` event that triggered this function\n         *\n         * @listens mousedown\n         * @listens touchstart\n         */\n        handleMouseMove(event) {\n            this.volumeBar.handleMouseMove(event);\n        }\n    }\n\n    /**\n     * Default options for the `VolumeControl`\n     *\n     * @type {Object}\n     * @private\n     */\n    VolumeControl.prototype.options_ = {\n        children: ['volumeBar']\n    };\n    Component$1.registerComponent('VolumeControl', VolumeControl);\n\n    /**\n     * Check if muting volume is supported and if it isn't hide the mute toggle\n     * button.\n     *\n     * @param { import('../../component').default } self\n     *        A reference to the mute toggle button\n     *\n     * @param { import('../../player').default } player\n     *        A reference to the player\n     *\n     * @private\n     */\n    const checkMuteSupport = function (self, player) {\n        // hide mute toggle button if it's not supported by the current tech\n        if (player.tech_ && !player.tech_.featuresMuteControl) {\n            self.addClass('vjs-hidden');\n        }\n        self.on(player, 'loadstart', function () {\n            if (!player.tech_.featuresMuteControl) {\n                self.addClass('vjs-hidden');\n            } else {\n                self.removeClass('vjs-hidden');\n            }\n        });\n    };\n\n    /**\n     * @file mute-toggle.js\n     */\n\n    /**\n     * A button component for muting the audio.\n     *\n     * @extends Button\n     */\n    class MuteToggle extends Button {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n\n            // hide this control if volume support is missing\n            checkMuteSupport(this, player);\n            this.on(player, ['loadstart', 'volumechange'], e => this.update(e));\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-mute-control ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * This gets called when an `MuteToggle` is \"clicked\". See\n         * {@link ClickableComponent} for more detailed information on what a click can be.\n         *\n         * @param {Event} [event]\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            const vol = this.player_.volume();\n            const lastVolume = this.player_.lastVolume_();\n            if (vol === 0) {\n                const volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;\n                this.player_.volume(volumeToSet);\n                this.player_.muted(false);\n            } else {\n                this.player_.muted(this.player_.muted() ? false : true);\n            }\n        }\n\n        /**\n         * Update the `MuteToggle` button based on the state of `volume` and `muted`\n         * on the player.\n         *\n         * @param {Event} [event]\n         *        The {@link Player#loadstart} event if this function was called\n         *        through an event.\n         *\n         * @listens Player#loadstart\n         * @listens Player#volumechange\n         */\n        update(event) {\n            this.updateIcon_();\n            this.updateControlText_();\n        }\n\n        /**\n         * Update the appearance of the `MuteToggle` icon.\n         *\n         * Possible states (given `level` variable below):\n         * - 0: crossed out\n         * - 1: zero bars of volume\n         * - 2: one bar of volume\n         * - 3: two bars of volume\n         *\n         * @private\n         */\n        updateIcon_() {\n            const vol = this.player_.volume();\n            let level = 3;\n\n            // in iOS when a player is loaded with muted attribute\n            // and volume is changed with a native mute button\n            // we want to make sure muted state is updated\n            if (IS_IOS && this.player_.tech_ && this.player_.tech_.el_) {\n                this.player_.muted(this.player_.tech_.el_.muted);\n            }\n            if (vol === 0 || this.player_.muted()) {\n                level = 0;\n            } else if (vol < 0.33) {\n                level = 1;\n            } else if (vol < 0.67) {\n                level = 2;\n            }\n            removeClass(this.el_, [0, 1, 2, 3].reduce((str, i) => str + `${i ? ' ' : ''}vjs-vol-${i}`, ''));\n            addClass(this.el_, `vjs-vol-${level}`);\n        }\n\n        /**\n         * If `muted` has changed on the player, update the control text\n         * (`title` attribute on `vjs-mute-control` element and content of\n         * `vjs-control-text` element).\n         *\n         * @private\n         */\n        updateControlText_() {\n            const soundOff = this.player_.muted() || this.player_.volume() === 0;\n            const text = soundOff ? 'Unmute' : 'Mute';\n            if (this.controlText() !== text) {\n                this.controlText(text);\n            }\n        }\n    }\n\n    /**\n     * The text that should display over the `MuteToggle`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    MuteToggle.prototype.controlText_ = 'Mute';\n    Component$1.registerComponent('MuteToggle', MuteToggle);\n\n    /**\n     * @file volume-control.js\n     */\n\n    /**\n     * A Component to contain the MuteToggle and VolumeControl so that\n     * they can work together.\n     *\n     * @extends Component\n     */\n    class VolumePanel extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of player options.\n         */\n        constructor(player, options = {}) {\n            if (typeof options.inline !== 'undefined') {\n                options.inline = options.inline;\n            } else {\n                options.inline = true;\n            }\n\n            // pass the inline option down to the VolumeControl as vertical if\n            // the VolumeControl is on.\n            if (typeof options.volumeControl === 'undefined' || isPlain(options.volumeControl)) {\n                options.volumeControl = options.volumeControl || {};\n                options.volumeControl.vertical = !options.inline;\n            }\n            super(player, options);\n\n            // this handler is used by mouse handler methods below\n            this.handleKeyPressHandler_ = e => this.handleKeyPress(e);\n            this.on(player, ['loadstart'], e => this.volumePanelState_(e));\n            this.on(this.muteToggle, 'keyup', e => this.handleKeyPress(e));\n            this.on(this.volumeControl, 'keyup', e => this.handleVolumeControlKeyUp(e));\n            this.on('keydown', e => this.handleKeyPress(e));\n            this.on('mouseover', e => this.handleMouseOver(e));\n            this.on('mouseout', e => this.handleMouseOut(e));\n\n            // while the slider is active (the mouse has been pressed down and\n            // is dragging) we do not want to hide the VolumeBar\n            this.on(this.volumeControl, ['slideractive'], this.sliderActive_);\n            this.on(this.volumeControl, ['sliderinactive'], this.sliderInactive_);\n        }\n\n        /**\n         * Add vjs-slider-active class to the VolumePanel\n         *\n         * @listens VolumeControl#slideractive\n         * @private\n         */\n        sliderActive_() {\n            this.addClass('vjs-slider-active');\n        }\n\n        /**\n         * Removes vjs-slider-active class to the VolumePanel\n         *\n         * @listens VolumeControl#sliderinactive\n         * @private\n         */\n        sliderInactive_() {\n            this.removeClass('vjs-slider-active');\n        }\n\n        /**\n         * Adds vjs-hidden or vjs-mute-toggle-only to the VolumePanel\n         * depending on MuteToggle and VolumeControl state\n         *\n         * @listens Player#loadstart\n         * @private\n         */\n        volumePanelState_() {\n            // hide volume panel if neither volume control or mute toggle\n            // are displayed\n            if (this.volumeControl.hasClass('vjs-hidden') && this.muteToggle.hasClass('vjs-hidden')) {\n                this.addClass('vjs-hidden');\n            }\n\n            // if only mute toggle is visible we don't want\n            // volume panel expanding when hovered or active\n            if (this.volumeControl.hasClass('vjs-hidden') && !this.muteToggle.hasClass('vjs-hidden')) {\n                this.addClass('vjs-mute-toggle-only');\n            }\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            let orientationClass = 'vjs-volume-panel-horizontal';\n            if (!this.options_.inline) {\n                orientationClass = 'vjs-volume-panel-vertical';\n            }\n            return super.createEl('div', {\n                className: `vjs-volume-panel vjs-control ${orientationClass}`\n            });\n        }\n\n        /**\n         * Dispose of the `volume-panel` and all child components.\n         */\n        dispose() {\n            this.handleMouseOut();\n            super.dispose();\n        }\n\n        /**\n         * Handles `keyup` events on the `VolumeControl`, looking for ESC, which closes\n         * the volume panel and sets focus on `MuteToggle`.\n         *\n         * @param {Event} event\n         *        The `keyup` event that caused this function to be called.\n         *\n         * @listens keyup\n         */\n        handleVolumeControlKeyUp(event) {\n            if (keycode.isEventKey(event, 'Esc')) {\n                this.muteToggle.focus();\n            }\n        }\n\n        /**\n         * This gets called when a `VolumePanel` gains hover via a `mouseover` event.\n         * Turns on listening for `mouseover` event. When they happen it\n         * calls `this.handleMouseOver`.\n         *\n         * @param {Event} event\n         *        The `mouseover` event that caused this function to be called.\n         *\n         * @listens mouseover\n         */\n        handleMouseOver(event) {\n            this.addClass('vjs-hover');\n            on(document, 'keyup', this.handleKeyPressHandler_);\n        }\n\n        /**\n         * This gets called when a `VolumePanel` gains hover via a `mouseout` event.\n         * Turns on listening for `mouseout` event. When they happen it\n         * calls `this.handleMouseOut`.\n         *\n         * @param {Event} event\n         *        The `mouseout` event that caused this function to be called.\n         *\n         * @listens mouseout\n         */\n        handleMouseOut(event) {\n            this.removeClass('vjs-hover');\n            off(document, 'keyup', this.handleKeyPressHandler_);\n        }\n\n        /**\n         * Handles `keyup` event on the document or `keydown` event on the `VolumePanel`,\n         * looking for ESC, which hides the `VolumeControl`.\n         *\n         * @param {Event} event\n         *        The keypress that triggered this event.\n         *\n         * @listens keydown | keyup\n         */\n        handleKeyPress(event) {\n            if (keycode.isEventKey(event, 'Esc')) {\n                this.handleMouseOut();\n            }\n        }\n    }\n\n    /**\n     * Default options for the `VolumeControl`\n     *\n     * @type {Object}\n     * @private\n     */\n    VolumePanel.prototype.options_ = {\n        children: ['muteToggle', 'volumeControl']\n    };\n    Component$1.registerComponent('VolumePanel', VolumePanel);\n\n    /**\n     * Button to skip forward a configurable amount of time\n     * through a video. Renders in the control bar.\n     *\n     * e.g. options: {controlBar: {skipButtons: forward: 5}}\n     *\n     * @extends Button\n     */\n    class SkipForward extends Button {\n        constructor(player, options) {\n            super(player, options);\n            this.validOptions = [5, 10, 30];\n            this.skipTime = this.getSkipForwardTime();\n            if (this.skipTime && this.validOptions.includes(this.skipTime)) {\n                this.controlText(this.localize('Skip forward {1} seconds', [this.skipTime]));\n                this.show();\n            } else {\n                this.hide();\n            }\n        }\n        getSkipForwardTime() {\n            const playerOptions = this.options_.playerOptions;\n            return playerOptions.controlBar && playerOptions.controlBar.skipButtons && playerOptions.controlBar.skipButtons.forward;\n        }\n        buildCSSClass() {\n            return `vjs-skip-forward-${this.getSkipForwardTime()} ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * On click, skips forward in the duration/seekable range by a configurable amount of seconds.\n         * If the time left in the duration/seekable range is less than the configured 'skip forward' time,\n         * skips to end of duration/seekable range.\n         *\n         * Handle a click on a `SkipForward` button\n         *\n         * @param {EventTarget~Event} event\n         *        The `click` event that caused this function\n         *        to be called\n         */\n        handleClick(event) {\n            const currentVideoTime = this.player_.currentTime();\n            const liveTracker = this.player_.liveTracker;\n            const duration = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : this.player_.duration();\n            let newTime;\n            if (currentVideoTime + this.skipTime <= duration) {\n                newTime = currentVideoTime + this.skipTime;\n            } else {\n                newTime = duration;\n            }\n            this.player_.currentTime(newTime);\n        }\n\n        /**\n         * Update control text on languagechange\n         */\n        handleLanguagechange() {\n            this.controlText(this.localize('Skip forward {1} seconds', [this.skipTime]));\n        }\n    }\n    Component$1.registerComponent('SkipForward', SkipForward);\n\n    /**\n     * Button to skip backward a configurable amount of time\n     * through a video. Renders in the control bar.\n     *\n     *  * e.g. options: {controlBar: {skipButtons: backward: 5}}\n     *\n     * @extends Button\n     */\n    class SkipBackward extends Button {\n        constructor(player, options) {\n            super(player, options);\n            this.validOptions = [5, 10, 30];\n            this.skipTime = this.getSkipBackwardTime();\n            if (this.skipTime && this.validOptions.includes(this.skipTime)) {\n                this.controlText(this.localize('Skip backward {1} seconds', [this.skipTime]));\n                this.show();\n            } else {\n                this.hide();\n            }\n        }\n        getSkipBackwardTime() {\n            const playerOptions = this.options_.playerOptions;\n            return playerOptions.controlBar && playerOptions.controlBar.skipButtons && playerOptions.controlBar.skipButtons.backward;\n        }\n        buildCSSClass() {\n            return `vjs-skip-backward-${this.getSkipBackwardTime()} ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * On click, skips backward in the video by a configurable amount of seconds.\n         * If the current time in the video is less than the configured 'skip backward' time,\n         * skips to beginning of video or seekable range.\n         *\n         * Handle a click on a `SkipBackward` button\n         *\n         * @param {EventTarget~Event} event\n         *        The `click` event that caused this function\n         *        to be called\n         */\n        handleClick(event) {\n            const currentVideoTime = this.player_.currentTime();\n            const liveTracker = this.player_.liveTracker;\n            const seekableStart = liveTracker && liveTracker.isLive() && liveTracker.seekableStart();\n            let newTime;\n            if (seekableStart && currentVideoTime - this.skipTime <= seekableStart) {\n                newTime = seekableStart;\n            } else if (currentVideoTime >= this.skipTime) {\n                newTime = currentVideoTime - this.skipTime;\n            } else {\n                newTime = 0;\n            }\n            this.player_.currentTime(newTime);\n        }\n\n        /**\n         * Update control text on languagechange\n         */\n        handleLanguagechange() {\n            this.controlText(this.localize('Skip backward {1} seconds', [this.skipTime]));\n        }\n    }\n    SkipBackward.prototype.controlText_ = 'Skip Backward';\n    Component$1.registerComponent('SkipBackward', SkipBackward);\n\n    /**\n     * @file menu.js\n     */\n\n    /**\n     * The Menu component is used to build popup menus, including subtitle and\n     * captions selection menus.\n     *\n     * @extends Component\n     */\n    class Menu extends Component$1 {\n        /**\n         * Create an instance of this class.\n         *\n         * @param { import('../player').default } player\n         *        the player that this component should attach to\n         *\n         * @param {Object} [options]\n         *        Object of option names and values\n         *\n         */\n        constructor(player, options) {\n            super(player, options);\n            if (options) {\n                this.menuButton_ = options.menuButton;\n            }\n            this.focusedChild_ = -1;\n            this.on('keydown', e => this.handleKeyDown(e));\n\n            // All the menu item instances share the same blur handler provided by the menu container.\n            this.boundHandleBlur_ = e => this.handleBlur(e);\n            this.boundHandleTapClick_ = e => this.handleTapClick(e);\n        }\n\n        /**\n         * Add event listeners to the {@link MenuItem}.\n         *\n         * @param {Object} component\n         *        The instance of the `MenuItem` to add listeners to.\n         *\n         */\n        addEventListenerForItem(component) {\n            if (!(component instanceof Component$1)) {\n                return;\n            }\n            this.on(component, 'blur', this.boundHandleBlur_);\n            this.on(component, ['tap', 'click'], this.boundHandleTapClick_);\n        }\n\n        /**\n         * Remove event listeners from the {@link MenuItem}.\n         *\n         * @param {Object} component\n         *        The instance of the `MenuItem` to remove listeners.\n         *\n         */\n        removeEventListenerForItem(component) {\n            if (!(component instanceof Component$1)) {\n                return;\n            }\n            this.off(component, 'blur', this.boundHandleBlur_);\n            this.off(component, ['tap', 'click'], this.boundHandleTapClick_);\n        }\n\n        /**\n         * This method will be called indirectly when the component has been added\n         * before the component adds to the new menu instance by `addItem`.\n         * In this case, the original menu instance will remove the component\n         * by calling `removeChild`.\n         *\n         * @param {Object} component\n         *        The instance of the `MenuItem`\n         */\n        removeChild(component) {\n            if (typeof component === 'string') {\n                component = this.getChild(component);\n            }\n            this.removeEventListenerForItem(component);\n            super.removeChild(component);\n        }\n\n        /**\n         * Add a {@link MenuItem} to the menu.\n         *\n         * @param {Object|string} component\n         *        The name or instance of the `MenuItem` to add.\n         *\n         */\n        addItem(component) {\n            const childComponent = this.addChild(component);\n            if (childComponent) {\n                this.addEventListenerForItem(childComponent);\n            }\n        }\n\n        /**\n         * Create the `Menu`s DOM element.\n         *\n         * @return {Element}\n         *         the element that was created\n         */\n        createEl() {\n            const contentElType = this.options_.contentElType || 'ul';\n            this.contentEl_ = createEl(contentElType, {\n                className: 'vjs-menu-content'\n            });\n            this.contentEl_.setAttribute('role', 'menu');\n            const el = super.createEl('div', {\n                append: this.contentEl_,\n                className: 'vjs-menu'\n            });\n            el.appendChild(this.contentEl_);\n\n            // Prevent clicks from bubbling up. Needed for Menu Buttons,\n            // where a click on the parent is significant\n            on(el, 'click', function (event) {\n                event.preventDefault();\n                event.stopImmediatePropagation();\n            });\n            return el;\n        }\n        dispose() {\n            this.contentEl_ = null;\n            this.boundHandleBlur_ = null;\n            this.boundHandleTapClick_ = null;\n            super.dispose();\n        }\n\n        /**\n         * Called when a `MenuItem` loses focus.\n         *\n         * @param {Event} event\n         *        The `blur` event that caused this function to be called.\n         *\n         * @listens blur\n         */\n        handleBlur(event) {\n            const relatedTarget = event.relatedTarget || document.activeElement;\n\n            // Close menu popup when a user clicks outside the menu\n            if (!this.children().some(element => {\n                return element.el() === relatedTarget;\n            })) {\n                const btn = this.menuButton_;\n                if (btn && btn.buttonPressed_ && relatedTarget !== btn.el().firstChild) {\n                    btn.unpressButton();\n                }\n            }\n        }\n\n        /**\n         * Called when a `MenuItem` gets clicked or tapped.\n         *\n         * @param {Event} event\n         *        The `click` or `tap` event that caused this function to be called.\n         *\n         * @listens click,tap\n         */\n        handleTapClick(event) {\n            // Unpress the associated MenuButton, and move focus back to it\n            if (this.menuButton_) {\n                this.menuButton_.unpressButton();\n                const childComponents = this.children();\n                if (!Array.isArray(childComponents)) {\n                    return;\n                }\n                const foundComponent = childComponents.filter(component => component.el() === event.target)[0];\n                if (!foundComponent) {\n                    return;\n                }\n\n                // don't focus menu button if item is a caption settings item\n                // because focus will move elsewhere\n                if (foundComponent.name() !== 'CaptionSettingsMenuItem') {\n                    this.menuButton_.focus();\n                }\n            }\n        }\n\n        /**\n         * Handle a `keydown` event on this menu. This listener is added in the constructor.\n         *\n         * @param {Event} event\n         *        A `keydown` event that happened on the menu.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            // Left and Down Arrows\n            if (keycode.isEventKey(event, 'Left') || keycode.isEventKey(event, 'Down')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.stepForward();\n\n                // Up and Right Arrows\n            } else if (keycode.isEventKey(event, 'Right') || keycode.isEventKey(event, 'Up')) {\n                event.preventDefault();\n                event.stopPropagation();\n                this.stepBack();\n            }\n        }\n\n        /**\n         * Move to next (lower) menu item for keyboard users.\n         */\n        stepForward() {\n            let stepChild = 0;\n            if (this.focusedChild_ !== undefined) {\n                stepChild = this.focusedChild_ + 1;\n            }\n            this.focus(stepChild);\n        }\n\n        /**\n         * Move to previous (higher) menu item for keyboard users.\n         */\n        stepBack() {\n            let stepChild = 0;\n            if (this.focusedChild_ !== undefined) {\n                stepChild = this.focusedChild_ - 1;\n            }\n            this.focus(stepChild);\n        }\n\n        /**\n         * Set focus on a {@link MenuItem} in the `Menu`.\n         *\n         * @param {Object|string} [item=0]\n         *        Index of child item set focus on.\n         */\n        focus(item = 0) {\n            const children = this.children().slice();\n            const haveTitle = children.length && children[0].hasClass('vjs-menu-title');\n            if (haveTitle) {\n                children.shift();\n            }\n            if (children.length > 0) {\n                if (item < 0) {\n                    item = 0;\n                } else if (item >= children.length) {\n                    item = children.length - 1;\n                }\n                this.focusedChild_ = item;\n                children[item].el_.focus();\n            }\n        }\n    }\n    Component$1.registerComponent('Menu', Menu);\n\n    /**\n     * @file menu-button.js\n     */\n\n    /**\n     * A `MenuButton` class for any popup {@link Menu}.\n     *\n     * @extends Component\n     */\n    class MenuButton extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of player options.\n         */\n        constructor(player, options = {}) {\n            super(player, options);\n            this.menuButton_ = new Button(player, options);\n            this.menuButton_.controlText(this.controlText_);\n            this.menuButton_.el_.setAttribute('aria-haspopup', 'true');\n\n            // Add buildCSSClass values to the button, not the wrapper\n            const buttonClass = Button.prototype.buildCSSClass();\n            this.menuButton_.el_.className = this.buildCSSClass() + ' ' + buttonClass;\n            this.menuButton_.removeClass('vjs-control');\n            this.addChild(this.menuButton_);\n            this.update();\n            this.enabled_ = true;\n            const handleClick = e => this.handleClick(e);\n            this.handleMenuKeyUp_ = e => this.handleMenuKeyUp(e);\n            this.on(this.menuButton_, 'tap', handleClick);\n            this.on(this.menuButton_, 'click', handleClick);\n            this.on(this.menuButton_, 'keydown', e => this.handleKeyDown(e));\n            this.on(this.menuButton_, 'mouseenter', () => {\n                this.addClass('vjs-hover');\n                this.menu.show();\n                on(document, 'keyup', this.handleMenuKeyUp_);\n            });\n            this.on('mouseleave', e => this.handleMouseLeave(e));\n            this.on('keydown', e => this.handleSubmenuKeyDown(e));\n        }\n\n        /**\n         * Update the menu based on the current state of its items.\n         */\n        update() {\n            const menu = this.createMenu();\n            if (this.menu) {\n                this.menu.dispose();\n                this.removeChild(this.menu);\n            }\n            this.menu = menu;\n            this.addChild(menu);\n\n            /**\n             * Track the state of the menu button\n             *\n             * @type {Boolean}\n             * @private\n             */\n            this.buttonPressed_ = false;\n            this.menuButton_.el_.setAttribute('aria-expanded', 'false');\n            if (this.items && this.items.length <= this.hideThreshold_) {\n                this.hide();\n                this.menu.contentEl_.removeAttribute('role');\n            } else {\n                this.show();\n                this.menu.contentEl_.setAttribute('role', 'menu');\n            }\n        }\n\n        /**\n         * Create the menu and add all items to it.\n         *\n         * @return {Menu}\n         *         The constructed menu\n         */\n        createMenu() {\n            const menu = new Menu(this.player_, {\n                menuButton: this\n            });\n\n            /**\n             * Hide the menu if the number of items is less than or equal to this threshold. This defaults\n             * to 0 and whenever we add items which can be hidden to the menu we'll increment it. We list\n             * it here because every time we run `createMenu` we need to reset the value.\n             *\n             * @protected\n             * @type {Number}\n             */\n            this.hideThreshold_ = 0;\n\n            // Add a title list item to the top\n            if (this.options_.title) {\n                const titleEl = createEl('li', {\n                    className: 'vjs-menu-title',\n                    textContent: toTitleCase$1(this.options_.title),\n                    tabIndex: -1\n                });\n                const titleComponent = new Component$1(this.player_, {\n                    el: titleEl\n                });\n                menu.addItem(titleComponent);\n            }\n            this.items = this.createItems();\n            if (this.items) {\n                // Add menu items to the menu\n                for (let i = 0; i < this.items.length; i++) {\n                    menu.addItem(this.items[i]);\n                }\n            }\n            return menu;\n        }\n\n        /**\n         * Create the list of menu items. Specific to each subclass.\n         *\n         * @abstract\n         */\n        createItems() {}\n\n        /**\n         * Create the `MenuButtons`s DOM element.\n         *\n         * @return {Element}\n         *         The element that gets created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: this.buildWrapperCSSClass()\n            }, {});\n        }\n\n        /**\n         * Allow sub components to stack CSS class names for the wrapper element\n         *\n         * @return {string}\n         *         The constructed wrapper DOM `className`\n         */\n        buildWrapperCSSClass() {\n            let menuButtonClass = 'vjs-menu-button';\n\n            // If the inline option is passed, we want to use different styles altogether.\n            if (this.options_.inline === true) {\n                menuButtonClass += '-inline';\n            } else {\n                menuButtonClass += '-popup';\n            }\n\n            // TODO: Fix the CSS so that this isn't necessary\n            const buttonClass = Button.prototype.buildCSSClass();\n            return `vjs-menu-button ${menuButtonClass} ${buttonClass} ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            let menuButtonClass = 'vjs-menu-button';\n\n            // If the inline option is passed, we want to use different styles altogether.\n            if (this.options_.inline === true) {\n                menuButtonClass += '-inline';\n            } else {\n                menuButtonClass += '-popup';\n            }\n            return `vjs-menu-button ${menuButtonClass} ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Get or set the localized control text that will be used for accessibility.\n         *\n         * > NOTE: This will come from the internal `menuButton_` element.\n         *\n         * @param {string} [text]\n         *        Control text for element.\n         *\n         * @param {Element} [el=this.menuButton_.el()]\n         *        Element to set the title on.\n         *\n         * @return {string}\n         *         - The control text when getting\n         */\n        controlText(text, el = this.menuButton_.el()) {\n            return this.menuButton_.controlText(text, el);\n        }\n\n        /**\n         * Dispose of the `menu-button` and all child components.\n         */\n        dispose() {\n            this.handleMouseLeave();\n            super.dispose();\n        }\n\n        /**\n         * Handle a click on a `MenuButton`.\n         * See {@link ClickableComponent#handleClick} for instances where this is called.\n         *\n         * @param {Event} event\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            if (this.buttonPressed_) {\n                this.unpressButton();\n            } else {\n                this.pressButton();\n            }\n        }\n\n        /**\n         * Handle `mouseleave` for `MenuButton`.\n         *\n         * @param {Event} event\n         *        The `mouseleave` event that caused this function to be called.\n         *\n         * @listens mouseleave\n         */\n        handleMouseLeave(event) {\n            this.removeClass('vjs-hover');\n            off(document, 'keyup', this.handleMenuKeyUp_);\n        }\n\n        /**\n         * Set the focus to the actual button, not to this element\n         */\n        focus() {\n            this.menuButton_.focus();\n        }\n\n        /**\n         * Remove the focus from the actual button, not this element\n         */\n        blur() {\n            this.menuButton_.blur();\n        }\n\n        /**\n         * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See\n         * {@link ClickableComponent#handleKeyDown} for instances where this is called.\n         *\n         * @param {Event} event\n         *        The `keydown` event that caused this function to be called.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            // Escape or Tab unpress the 'button'\n            if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {\n                if (this.buttonPressed_) {\n                    this.unpressButton();\n                }\n\n                // Don't preventDefault for Tab key - we still want to lose focus\n                if (!keycode.isEventKey(event, 'Tab')) {\n                    event.preventDefault();\n                    // Set focus back to the menu button's button\n                    this.menuButton_.focus();\n                }\n                // Up Arrow or Down Arrow also 'press' the button to open the menu\n            } else if (keycode.isEventKey(event, 'Up') || keycode.isEventKey(event, 'Down')) {\n                if (!this.buttonPressed_) {\n                    event.preventDefault();\n                    this.pressButton();\n                }\n            }\n        }\n\n        /**\n         * Handle a `keyup` event on a `MenuButton`. The listener for this is added in\n         * the constructor.\n         *\n         * @param {Event} event\n         *        Key press event\n         *\n         * @listens keyup\n         */\n        handleMenuKeyUp(event) {\n            // Escape hides popup menu\n            if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {\n                this.removeClass('vjs-hover');\n            }\n        }\n\n        /**\n         * This method name now delegates to `handleSubmenuKeyDown`. This means\n         * anyone calling `handleSubmenuKeyPress` will not see their method calls\n         * stop working.\n         *\n         * @param {Event} event\n         *        The event that caused this function to be called.\n         */\n        handleSubmenuKeyPress(event) {\n            this.handleSubmenuKeyDown(event);\n        }\n\n        /**\n         * Handle a `keydown` event on a sub-menu. The listener for this is added in\n         * the constructor.\n         *\n         * @param {Event} event\n         *        Key press event\n         *\n         * @listens keydown\n         */\n        handleSubmenuKeyDown(event) {\n            // Escape or Tab unpress the 'button'\n            if (keycode.isEventKey(event, 'Esc') || keycode.isEventKey(event, 'Tab')) {\n                if (this.buttonPressed_) {\n                    this.unpressButton();\n                }\n                // Don't preventDefault for Tab key - we still want to lose focus\n                if (!keycode.isEventKey(event, 'Tab')) {\n                    event.preventDefault();\n                    // Set focus back to the menu button's button\n                    this.menuButton_.focus();\n                }\n            }\n        }\n\n        /**\n         * Put the current `MenuButton` into a pressed state.\n         */\n        pressButton() {\n            if (this.enabled_) {\n                this.buttonPressed_ = true;\n                this.menu.show();\n                this.menu.lockShowing();\n                this.menuButton_.el_.setAttribute('aria-expanded', 'true');\n\n                // set the focus into the submenu, except on iOS where it is resulting in\n                // undesired scrolling behavior when the player is in an iframe\n                if (IS_IOS && isInFrame()) {\n                    // Return early so that the menu isn't focused\n                    return;\n                }\n                this.menu.focus();\n            }\n        }\n\n        /**\n         * Take the current `MenuButton` out of a pressed state.\n         */\n        unpressButton() {\n            if (this.enabled_) {\n                this.buttonPressed_ = false;\n                this.menu.unlockShowing();\n                this.menu.hide();\n                this.menuButton_.el_.setAttribute('aria-expanded', 'false');\n            }\n        }\n\n        /**\n         * Disable the `MenuButton`. Don't allow it to be clicked.\n         */\n        disable() {\n            this.unpressButton();\n            this.enabled_ = false;\n            this.addClass('vjs-disabled');\n            this.menuButton_.disable();\n        }\n\n        /**\n         * Enable the `MenuButton`. Allow it to be clicked.\n         */\n        enable() {\n            this.enabled_ = true;\n            this.removeClass('vjs-disabled');\n            this.menuButton_.enable();\n        }\n    }\n    Component$1.registerComponent('MenuButton', MenuButton);\n\n    /**\n     * @file track-button.js\n     */\n\n    /**\n     * The base class for buttons that toggle specific  track types (e.g. subtitles).\n     *\n     * @extends MenuButton\n     */\n    class TrackButton extends MenuButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            const tracks = options.tracks;\n            super(player, options);\n            if (this.items.length <= 1) {\n                this.hide();\n            }\n            if (!tracks) {\n                return;\n            }\n            const updateHandler = bind_(this, this.update);\n            tracks.addEventListener('removetrack', updateHandler);\n            tracks.addEventListener('addtrack', updateHandler);\n            tracks.addEventListener('labelchange', updateHandler);\n            this.player_.on('ready', updateHandler);\n            this.player_.on('dispose', function () {\n                tracks.removeEventListener('removetrack', updateHandler);\n                tracks.removeEventListener('addtrack', updateHandler);\n                tracks.removeEventListener('labelchange', updateHandler);\n            });\n        }\n    }\n    Component$1.registerComponent('TrackButton', TrackButton);\n\n    /**\n     * @file menu-keys.js\n     */\n\n    /**\n     * All keys used for operation of a menu (`MenuButton`, `Menu`, and `MenuItem`)\n     * Note that 'Enter' and 'Space' are not included here (otherwise they would\n     * prevent the `MenuButton` and `MenuItem` from being keyboard-clickable)\n     *\n     * @typedef MenuKeys\n     * @array\n     */\n    const MenuKeys = ['Tab', 'Esc', 'Up', 'Down', 'Right', 'Left'];\n\n    /**\n     * @file menu-item.js\n     */\n\n    /**\n     * The component for a menu item. `<li>`\n     *\n     * @extends ClickableComponent\n     */\n    class MenuItem extends ClickableComponent {\n        /**\n         * Creates an instance of the this class.\n         *\n         * @param { import('../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of player options.\n         *\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.selectable = options.selectable;\n            this.isSelected_ = options.selected || false;\n            this.multiSelectable = options.multiSelectable;\n            this.selected(this.isSelected_);\n            if (this.selectable) {\n                if (this.multiSelectable) {\n                    this.el_.setAttribute('role', 'menuitemcheckbox');\n                } else {\n                    this.el_.setAttribute('role', 'menuitemradio');\n                }\n            } else {\n                this.el_.setAttribute('role', 'menuitem');\n            }\n        }\n\n        /**\n         * Create the `MenuItem's DOM element\n         *\n         * @param {string} [type=li]\n         *        Element's node type, not actually used, always set to `li`.\n         *\n         * @param {Object} [props={}]\n         *        An object of properties that should be set on the element\n         *\n         * @param {Object} [attrs={}]\n         *        An object of attributes that should be set on the element\n         *\n         * @return {Element}\n         *         The element that gets created.\n         */\n        createEl(type, props, attrs) {\n            // The control is textual, not just an icon\n            this.nonIconControl = true;\n            const el = super.createEl('li', Object.assign({\n                className: 'vjs-menu-item',\n                tabIndex: -1\n            }, props), attrs);\n\n            // swap icon with menu item text.\n            el.replaceChild(createEl('span', {\n                className: 'vjs-menu-item-text',\n                textContent: this.localize(this.options_.label)\n            }), el.querySelector('.vjs-icon-placeholder'));\n            return el;\n        }\n\n        /**\n         * Ignore keys which are used by the menu, but pass any other ones up. See\n         * {@link ClickableComponent#handleKeyDown} for instances where this is called.\n         *\n         * @param {Event} event\n         *        The `keydown` event that caused this function to be called.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            if (!MenuKeys.some(key => keycode.isEventKey(event, key))) {\n                // Pass keydown handling up for unused keys\n                super.handleKeyDown(event);\n            }\n        }\n\n        /**\n         * Any click on a `MenuItem` puts it into the selected state.\n         * See {@link ClickableComponent#handleClick} for instances where this is called.\n         *\n         * @param {Event} event\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            this.selected(true);\n        }\n\n        /**\n         * Set the state for this menu item as selected or not.\n         *\n         * @param {boolean} selected\n         *        if the menu item is selected or not\n         */\n        selected(selected) {\n            if (this.selectable) {\n                if (selected) {\n                    this.addClass('vjs-selected');\n                    this.el_.setAttribute('aria-checked', 'true');\n                    // aria-checked isn't fully supported by browsers/screen readers,\n                    // so indicate selected state to screen reader in the control text.\n                    this.controlText(', selected');\n                    this.isSelected_ = true;\n                } else {\n                    this.removeClass('vjs-selected');\n                    this.el_.setAttribute('aria-checked', 'false');\n                    // Indicate un-selected state to screen reader\n                    this.controlText('');\n                    this.isSelected_ = false;\n                }\n            }\n        }\n    }\n    Component$1.registerComponent('MenuItem', MenuItem);\n\n    /**\n     * @file text-track-menu-item.js\n     */\n\n    /**\n     * The specific menu item type for selecting a language within a text track kind\n     *\n     * @extends MenuItem\n     */\n    class TextTrackMenuItem extends MenuItem {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            const track = options.track;\n            const tracks = player.textTracks();\n\n            // Modify options for parent MenuItem class's init.\n            options.label = track.label || track.language || 'Unknown';\n            options.selected = track.mode === 'showing';\n            super(player, options);\n            this.track = track;\n            // Determine the relevant kind(s) of tracks for this component and filter\n            // out empty kinds.\n            this.kinds = (options.kinds || [options.kind || this.track.kind]).filter(Boolean);\n            const changeHandler = (...args) => {\n                this.handleTracksChange.apply(this, args);\n            };\n            const selectedLanguageChangeHandler = (...args) => {\n                this.handleSelectedLanguageChange.apply(this, args);\n            };\n            player.on(['loadstart', 'texttrackchange'], changeHandler);\n            tracks.addEventListener('change', changeHandler);\n            tracks.addEventListener('selectedlanguagechange', selectedLanguageChangeHandler);\n            this.on('dispose', function () {\n                player.off(['loadstart', 'texttrackchange'], changeHandler);\n                tracks.removeEventListener('change', changeHandler);\n                tracks.removeEventListener('selectedlanguagechange', selectedLanguageChangeHandler);\n            });\n\n            // iOS7 doesn't dispatch change events to TextTrackLists when an\n            // associated track's mode changes. Without something like\n            // Object.observe() (also not present on iOS7), it's not\n            // possible to detect changes to the mode attribute and polyfill\n            // the change event. As a poor substitute, we manually dispatch\n            // change events whenever the controls modify the mode.\n            if (tracks.onchange === undefined) {\n                let event;\n                this.on(['tap', 'click'], function () {\n                    if (typeof window.Event !== 'object') {\n                        // Android 2.3 throws an Illegal Constructor error for window.Event\n                        try {\n                            event = new window.Event('change');\n                        } catch (err) {\n                            // continue regardless of error\n                        }\n                    }\n                    if (!event) {\n                        event = document.createEvent('Event');\n                        event.initEvent('change', true, true);\n                    }\n                    tracks.dispatchEvent(event);\n                });\n            }\n\n            // set the default state based on current tracks\n            this.handleTracksChange();\n        }\n\n        /**\n         * This gets called when an `TextTrackMenuItem` is \"clicked\". See\n         * {@link ClickableComponent} for more detailed information on what a click can be.\n         *\n         * @param {Event} event\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            const referenceTrack = this.track;\n            const tracks = this.player_.textTracks();\n            super.handleClick(event);\n            if (!tracks) {\n                return;\n            }\n            for (let i = 0; i < tracks.length; i++) {\n                const track = tracks[i];\n\n                // If the track from the text tracks list is not of the right kind,\n                // skip it. We do not want to affect tracks of incompatible kind(s).\n                if (this.kinds.indexOf(track.kind) === -1) {\n                    continue;\n                }\n\n                // If this text track is the component's track and it is not showing,\n                // set it to showing.\n                if (track === referenceTrack) {\n                    if (track.mode !== 'showing') {\n                        track.mode = 'showing';\n                    }\n\n                    // If this text track is not the component's track and it is not\n                    // disabled, set it to disabled.\n                } else if (track.mode !== 'disabled') {\n                    track.mode = 'disabled';\n                }\n            }\n        }\n\n        /**\n         * Handle text track list change\n         *\n         * @param {Event} event\n         *        The `change` event that caused this function to be called.\n         *\n         * @listens TextTrackList#change\n         */\n        handleTracksChange(event) {\n            const shouldBeSelected = this.track.mode === 'showing';\n\n            // Prevent redundant selected() calls because they may cause\n            // screen readers to read the appended control text unnecessarily\n            if (shouldBeSelected !== this.isSelected_) {\n                this.selected(shouldBeSelected);\n            }\n        }\n        handleSelectedLanguageChange(event) {\n            if (this.track.mode === 'showing') {\n                const selectedLanguage = this.player_.cache_.selectedLanguage;\n\n                // Don't replace the kind of track across the same language\n                if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {\n                    return;\n                }\n                this.player_.cache_.selectedLanguage = {\n                    enabled: true,\n                    language: this.track.language,\n                    kind: this.track.kind\n                };\n            }\n        }\n        dispose() {\n            // remove reference to track object on dispose\n            this.track = null;\n            super.dispose();\n        }\n    }\n    Component$1.registerComponent('TextTrackMenuItem', TextTrackMenuItem);\n\n    /**\n     * @file off-text-track-menu-item.js\n     */\n\n    /**\n     * A special menu item for turning of a specific type of text track\n     *\n     * @extends TextTrackMenuItem\n     */\n    class OffTextTrackMenuItem extends TextTrackMenuItem {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            // Create pseudo track info\n            // Requires options['kind']\n            options.track = {\n                player,\n                // it is no longer necessary to store `kind` or `kinds` on the track itself\n                // since they are now stored in the `kinds` property of all instances of\n                // TextTrackMenuItem, but this will remain for backwards compatibility\n                kind: options.kind,\n                kinds: options.kinds,\n                default: false,\n                mode: 'disabled'\n            };\n            if (!options.kinds) {\n                options.kinds = [options.kind];\n            }\n            if (options.label) {\n                options.track.label = options.label;\n            } else {\n                options.track.label = options.kinds.join(' and ') + ' off';\n            }\n\n            // MenuItem is selectable\n            options.selectable = true;\n            // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n            options.multiSelectable = false;\n            super(player, options);\n        }\n\n        /**\n         * Handle text track change\n         *\n         * @param {Event} event\n         *        The event that caused this function to run\n         */\n        handleTracksChange(event) {\n            const tracks = this.player().textTracks();\n            let shouldBeSelected = true;\n            for (let i = 0, l = tracks.length; i < l; i++) {\n                const track = tracks[i];\n                if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === 'showing') {\n                    shouldBeSelected = false;\n                    break;\n                }\n            }\n\n            // Prevent redundant selected() calls because they may cause\n            // screen readers to read the appended control text unnecessarily\n            if (shouldBeSelected !== this.isSelected_) {\n                this.selected(shouldBeSelected);\n            }\n        }\n        handleSelectedLanguageChange(event) {\n            const tracks = this.player().textTracks();\n            let allHidden = true;\n            for (let i = 0, l = tracks.length; i < l; i++) {\n                const track = tracks[i];\n                if (['captions', 'descriptions', 'subtitles'].indexOf(track.kind) > -1 && track.mode === 'showing') {\n                    allHidden = false;\n                    break;\n                }\n            }\n            if (allHidden) {\n                this.player_.cache_.selectedLanguage = {\n                    enabled: false\n                };\n            }\n        }\n\n        /**\n         * Update control text and label on languagechange\n         */\n        handleLanguagechange() {\n            this.$('.vjs-menu-item-text').textContent = this.player_.localize(this.options_.label);\n            super.handleLanguagechange();\n        }\n    }\n    Component$1.registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);\n\n    /**\n     * @file text-track-button.js\n     */\n\n    /**\n     * The base class for buttons that toggle specific text track types (e.g. subtitles)\n     *\n     * @extends MenuButton\n     */\n    class TextTrackButton extends TrackButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of player options.\n         */\n        constructor(player, options = {}) {\n            options.tracks = player.textTracks();\n            super(player, options);\n        }\n\n        /**\n         * Create a menu item for each text track\n         *\n         * @param {TextTrackMenuItem[]} [items=[]]\n         *        Existing array of items to use during creation\n         *\n         * @return {TextTrackMenuItem[]}\n         *         Array of menu items that were created\n         */\n        createItems(items = [], TrackMenuItem = TextTrackMenuItem) {\n            // Label is an override for the [track] off label\n            // USed to localise captions/subtitles\n            let label;\n            if (this.label_) {\n                label = `${this.label_} off`;\n            }\n            // Add an OFF menu item to turn all tracks off\n            items.push(new OffTextTrackMenuItem(this.player_, {\n                kinds: this.kinds_,\n                kind: this.kind_,\n                label\n            }));\n            this.hideThreshold_ += 1;\n            const tracks = this.player_.textTracks();\n            if (!Array.isArray(this.kinds_)) {\n                this.kinds_ = [this.kind_];\n            }\n            for (let i = 0; i < tracks.length; i++) {\n                const track = tracks[i];\n\n                // only add tracks that are of an appropriate kind and have a label\n                if (this.kinds_.indexOf(track.kind) > -1) {\n                    const item = new TrackMenuItem(this.player_, {\n                        track,\n                        kinds: this.kinds_,\n                        kind: this.kind_,\n                        // MenuItem is selectable\n                        selectable: true,\n                        // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n                        multiSelectable: false\n                    });\n                    item.addClass(`vjs-${track.kind}-menu-item`);\n                    items.push(item);\n                }\n            }\n            return items;\n        }\n    }\n    Component$1.registerComponent('TextTrackButton', TextTrackButton);\n\n    /**\n     * @file chapters-track-menu-item.js\n     */\n\n    /**\n     * The chapter track menu item\n     *\n     * @extends MenuItem\n     */\n    class ChaptersTrackMenuItem extends MenuItem {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            const track = options.track;\n            const cue = options.cue;\n            const currentTime = player.currentTime();\n\n            // Modify options for parent MenuItem class's init.\n            options.selectable = true;\n            options.multiSelectable = false;\n            options.label = cue.text;\n            options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;\n            super(player, options);\n            this.track = track;\n            this.cue = cue;\n        }\n\n        /**\n         * This gets called when an `ChaptersTrackMenuItem` is \"clicked\". See\n         * {@link ClickableComponent} for more detailed information on what a click can be.\n         *\n         * @param {Event} [event]\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            super.handleClick();\n            this.player_.currentTime(this.cue.startTime);\n        }\n    }\n    Component$1.registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);\n\n    /**\n     * @file chapters-button.js\n     */\n\n    /**\n     * The button component for toggling and selecting chapters\n     * Chapters act much differently than other text tracks\n     * Cues are navigation vs. other tracks of alternative languages\n     *\n     * @extends TextTrackButton\n     */\n    class ChaptersButton extends TextTrackButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        The function to call when this function is ready.\n         */\n        constructor(player, options, ready) {\n            super(player, options, ready);\n            this.selectCurrentItem_ = () => {\n                this.items.forEach(item => {\n                    item.selected(this.track_.activeCues[0] === item.cue);\n                });\n            };\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-chapters-button ${super.buildCSSClass()}`;\n        }\n        buildWrapperCSSClass() {\n            return `vjs-chapters-button ${super.buildWrapperCSSClass()}`;\n        }\n\n        /**\n         * Update the menu based on the current state of its items.\n         *\n         * @param {Event} [event]\n         *        An event that triggered this function to run.\n         *\n         * @listens TextTrackList#addtrack\n         * @listens TextTrackList#removetrack\n         * @listens TextTrackList#change\n         */\n        update(event) {\n            if (event && event.track && event.track.kind !== 'chapters') {\n                return;\n            }\n            const track = this.findChaptersTrack();\n            if (track !== this.track_) {\n                this.setTrack(track);\n                super.update();\n            } else if (!this.items || track && track.cues && track.cues.length !== this.items.length) {\n                // Update the menu initially or if the number of cues has changed since set\n                super.update();\n            }\n        }\n\n        /**\n         * Set the currently selected track for the chapters button.\n         *\n         * @param {TextTrack} track\n         *        The new track to select. Nothing will change if this is the currently selected\n         *        track.\n         */\n        setTrack(track) {\n            if (this.track_ === track) {\n                return;\n            }\n            if (!this.updateHandler_) {\n                this.updateHandler_ = this.update.bind(this);\n            }\n\n            // here this.track_ refers to the old track instance\n            if (this.track_) {\n                const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);\n                if (remoteTextTrackEl) {\n                    remoteTextTrackEl.removeEventListener('load', this.updateHandler_);\n                }\n                this.track_.removeEventListener('cuechange', this.selectCurrentItem_);\n                this.track_ = null;\n            }\n            this.track_ = track;\n\n            // here this.track_ refers to the new track instance\n            if (this.track_) {\n                this.track_.mode = 'hidden';\n                const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);\n                if (remoteTextTrackEl) {\n                    remoteTextTrackEl.addEventListener('load', this.updateHandler_);\n                }\n                this.track_.addEventListener('cuechange', this.selectCurrentItem_);\n            }\n        }\n\n        /**\n         * Find the track object that is currently in use by this ChaptersButton\n         *\n         * @return {TextTrack|undefined}\n         *         The current track or undefined if none was found.\n         */\n        findChaptersTrack() {\n            const tracks = this.player_.textTracks() || [];\n            for (let i = tracks.length - 1; i >= 0; i--) {\n                // We will always choose the last track as our chaptersTrack\n                const track = tracks[i];\n                if (track.kind === this.kind_) {\n                    return track;\n                }\n            }\n        }\n\n        /**\n         * Get the caption for the ChaptersButton based on the track label. This will also\n         * use the current tracks localized kind as a fallback if a label does not exist.\n         *\n         * @return {string}\n         *         The tracks current label or the localized track kind.\n         */\n        getMenuCaption() {\n            if (this.track_ && this.track_.label) {\n                return this.track_.label;\n            }\n            return this.localize(toTitleCase$1(this.kind_));\n        }\n\n        /**\n         * Create menu from chapter track\n         *\n         * @return { import('../../menu/menu').default }\n         *         New menu for the chapter buttons\n         */\n        createMenu() {\n            this.options_.title = this.getMenuCaption();\n            return super.createMenu();\n        }\n\n        /**\n         * Create a menu item for each text track\n         *\n         * @return  { import('./text-track-menu-item').default[] }\n         *         Array of menu items\n         */\n        createItems() {\n            const items = [];\n            if (!this.track_) {\n                return items;\n            }\n            const cues = this.track_.cues;\n            if (!cues) {\n                return items;\n            }\n            for (let i = 0, l = cues.length; i < l; i++) {\n                const cue = cues[i];\n                const mi = new ChaptersTrackMenuItem(this.player_, {\n                    track: this.track_,\n                    cue\n                });\n                items.push(mi);\n            }\n            return items;\n        }\n    }\n\n    /**\n     * `kind` of TextTrack to look for to associate it with this menu.\n     *\n     * @type {string}\n     * @private\n     */\n    ChaptersButton.prototype.kind_ = 'chapters';\n\n    /**\n     * The text that should display over the `ChaptersButton`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    ChaptersButton.prototype.controlText_ = 'Chapters';\n    Component$1.registerComponent('ChaptersButton', ChaptersButton);\n\n    /**\n     * @file descriptions-button.js\n     */\n\n    /**\n     * The button component for toggling and selecting descriptions\n     *\n     * @extends TextTrackButton\n     */\n    class DescriptionsButton extends TextTrackButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        The function to call when this component is ready.\n         */\n        constructor(player, options, ready) {\n            super(player, options, ready);\n            const tracks = player.textTracks();\n            const changeHandler = bind_(this, this.handleTracksChange);\n            tracks.addEventListener('change', changeHandler);\n            this.on('dispose', function () {\n                tracks.removeEventListener('change', changeHandler);\n            });\n        }\n\n        /**\n         * Handle text track change\n         *\n         * @param {Event} event\n         *        The event that caused this function to run\n         *\n         * @listens TextTrackList#change\n         */\n        handleTracksChange(event) {\n            const tracks = this.player().textTracks();\n            let disabled = false;\n\n            // Check whether a track of a different kind is showing\n            for (let i = 0, l = tracks.length; i < l; i++) {\n                const track = tracks[i];\n                if (track.kind !== this.kind_ && track.mode === 'showing') {\n                    disabled = true;\n                    break;\n                }\n            }\n\n            // If another track is showing, disable this menu button\n            if (disabled) {\n                this.disable();\n            } else {\n                this.enable();\n            }\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-descriptions-button ${super.buildCSSClass()}`;\n        }\n        buildWrapperCSSClass() {\n            return `vjs-descriptions-button ${super.buildWrapperCSSClass()}`;\n        }\n    }\n\n    /**\n     * `kind` of TextTrack to look for to associate it with this menu.\n     *\n     * @type {string}\n     * @private\n     */\n    DescriptionsButton.prototype.kind_ = 'descriptions';\n\n    /**\n     * The text that should display over the `DescriptionsButton`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    DescriptionsButton.prototype.controlText_ = 'Descriptions';\n    Component$1.registerComponent('DescriptionsButton', DescriptionsButton);\n\n    /**\n     * @file subtitles-button.js\n     */\n\n    /**\n     * The button component for toggling and selecting subtitles\n     *\n     * @extends TextTrackButton\n     */\n    class SubtitlesButton extends TextTrackButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        The function to call when this component is ready.\n         */\n        constructor(player, options, ready) {\n            super(player, options, ready);\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-subtitles-button ${super.buildCSSClass()}`;\n        }\n        buildWrapperCSSClass() {\n            return `vjs-subtitles-button ${super.buildWrapperCSSClass()}`;\n        }\n    }\n\n    /**\n     * `kind` of TextTrack to look for to associate it with this menu.\n     *\n     * @type {string}\n     * @private\n     */\n    SubtitlesButton.prototype.kind_ = 'subtitles';\n\n    /**\n     * The text that should display over the `SubtitlesButton`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    SubtitlesButton.prototype.controlText_ = 'Subtitles';\n    Component$1.registerComponent('SubtitlesButton', SubtitlesButton);\n\n    /**\n     * @file caption-settings-menu-item.js\n     */\n\n    /**\n     * The menu item for caption track settings menu\n     *\n     * @extends TextTrackMenuItem\n     */\n    class CaptionSettingsMenuItem extends TextTrackMenuItem {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            options.track = {\n                player,\n                kind: options.kind,\n                label: options.kind + ' settings',\n                selectable: false,\n                default: false,\n                mode: 'disabled'\n            };\n\n            // CaptionSettingsMenuItem has no concept of 'selected'\n            options.selectable = false;\n            options.name = 'CaptionSettingsMenuItem';\n            super(player, options);\n            this.addClass('vjs-texttrack-settings');\n            this.controlText(', opens ' + options.kind + ' settings dialog');\n        }\n\n        /**\n         * This gets called when an `CaptionSettingsMenuItem` is \"clicked\". See\n         * {@link ClickableComponent} for more detailed information on what a click can be.\n         *\n         * @param {Event} [event]\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            this.player().getChild('textTrackSettings').open();\n        }\n\n        /**\n         * Update control text and label on languagechange\n         */\n        handleLanguagechange() {\n            this.$('.vjs-menu-item-text').textContent = this.player_.localize(this.options_.kind + ' settings');\n            super.handleLanguagechange();\n        }\n    }\n    Component$1.registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);\n\n    /**\n     * @file captions-button.js\n     */\n\n    /**\n     * The button component for toggling and selecting captions\n     *\n     * @extends TextTrackButton\n     */\n    class CaptionsButton extends TextTrackButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        The function to call when this component is ready.\n         */\n        constructor(player, options, ready) {\n            super(player, options, ready);\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-captions-button ${super.buildCSSClass()}`;\n        }\n        buildWrapperCSSClass() {\n            return `vjs-captions-button ${super.buildWrapperCSSClass()}`;\n        }\n\n        /**\n         * Create caption menu items\n         *\n         * @return {CaptionSettingsMenuItem[]}\n         *         The array of current menu items.\n         */\n        createItems() {\n            const items = [];\n            if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {\n                items.push(new CaptionSettingsMenuItem(this.player_, {\n                    kind: this.kind_\n                }));\n                this.hideThreshold_ += 1;\n            }\n            return super.createItems(items);\n        }\n    }\n\n    /**\n     * `kind` of TextTrack to look for to associate it with this menu.\n     *\n     * @type {string}\n     * @private\n     */\n    CaptionsButton.prototype.kind_ = 'captions';\n\n    /**\n     * The text that should display over the `CaptionsButton`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    CaptionsButton.prototype.controlText_ = 'Captions';\n    Component$1.registerComponent('CaptionsButton', CaptionsButton);\n\n    /**\n     * @file subs-caps-menu-item.js\n     */\n\n    /**\n     * SubsCapsMenuItem has an [cc] icon to distinguish captions from subtitles\n     * in the SubsCapsMenu.\n     *\n     * @extends TextTrackMenuItem\n     */\n    class SubsCapsMenuItem extends TextTrackMenuItem {\n        createEl(type, props, attrs) {\n            const el = super.createEl(type, props, attrs);\n            const parentSpan = el.querySelector('.vjs-menu-item-text');\n            if (this.options_.track.kind === 'captions') {\n                parentSpan.appendChild(createEl('span', {\n                    className: 'vjs-icon-placeholder'\n                }, {\n                    'aria-hidden': true\n                }));\n                parentSpan.appendChild(createEl('span', {\n                    className: 'vjs-control-text',\n                    // space added as the text will visually flow with the\n                    // label\n                    textContent: ` ${this.localize('Captions')}`\n                }));\n            }\n            return el;\n        }\n    }\n    Component$1.registerComponent('SubsCapsMenuItem', SubsCapsMenuItem);\n\n    /**\n     * @file sub-caps-button.js\n     */\n\n    /**\n     * The button component for toggling and selecting captions and/or subtitles\n     *\n     * @extends TextTrackButton\n     */\n    class SubsCapsButton extends TextTrackButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        The function to call when this component is ready.\n         */\n        constructor(player, options = {}) {\n            super(player, options);\n\n            // Although North America uses \"captions\" in most cases for\n            // \"captions and subtitles\" other locales use \"subtitles\"\n            this.label_ = 'subtitles';\n            if (['en', 'en-us', 'en-ca', 'fr-ca'].indexOf(this.player_.language_) > -1) {\n                this.label_ = 'captions';\n            }\n            this.menuButton_.controlText(toTitleCase$1(this.label_));\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-subs-caps-button ${super.buildCSSClass()}`;\n        }\n        buildWrapperCSSClass() {\n            return `vjs-subs-caps-button ${super.buildWrapperCSSClass()}`;\n        }\n\n        /**\n         * Create caption/subtitles menu items\n         *\n         * @return {CaptionSettingsMenuItem[]}\n         *         The array of current menu items.\n         */\n        createItems() {\n            let items = [];\n            if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild('textTrackSettings')) {\n                items.push(new CaptionSettingsMenuItem(this.player_, {\n                    kind: this.label_\n                }));\n                this.hideThreshold_ += 1;\n            }\n            items = super.createItems(items, SubsCapsMenuItem);\n            return items;\n        }\n    }\n\n    /**\n     * `kind`s of TextTrack to look for to associate it with this menu.\n     *\n     * @type {array}\n     * @private\n     */\n    SubsCapsButton.prototype.kinds_ = ['captions', 'subtitles'];\n\n    /**\n     * The text that should display over the `SubsCapsButton`s controls.\n     *\n     *\n     * @type {string}\n     * @protected\n     */\n    SubsCapsButton.prototype.controlText_ = 'Subtitles';\n    Component$1.registerComponent('SubsCapsButton', SubsCapsButton);\n\n    /**\n     * @file audio-track-menu-item.js\n     */\n\n    /**\n     * An {@link AudioTrack} {@link MenuItem}\n     *\n     * @extends MenuItem\n     */\n    class AudioTrackMenuItem extends MenuItem {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            const track = options.track;\n            const tracks = player.audioTracks();\n\n            // Modify options for parent MenuItem class's init.\n            options.label = track.label || track.language || 'Unknown';\n            options.selected = track.enabled;\n            super(player, options);\n            this.track = track;\n            this.addClass(`vjs-${track.kind}-menu-item`);\n            const changeHandler = (...args) => {\n                this.handleTracksChange.apply(this, args);\n            };\n            tracks.addEventListener('change', changeHandler);\n            this.on('dispose', () => {\n                tracks.removeEventListener('change', changeHandler);\n            });\n        }\n        createEl(type, props, attrs) {\n            const el = super.createEl(type, props, attrs);\n            const parentSpan = el.querySelector('.vjs-menu-item-text');\n            if (this.options_.track.kind === 'main-desc') {\n                parentSpan.appendChild(createEl('span', {\n                    className: 'vjs-icon-placeholder'\n                }, {\n                    'aria-hidden': true\n                }));\n                parentSpan.appendChild(createEl('span', {\n                    className: 'vjs-control-text',\n                    textContent: ' ' + this.localize('Descriptions')\n                }));\n            }\n            return el;\n        }\n\n        /**\n         * This gets called when an `AudioTrackMenuItem is \"clicked\". See {@link ClickableComponent}\n         * for more detailed information on what a click can be.\n         *\n         * @param {Event} [event]\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            super.handleClick(event);\n\n            // the audio track list will automatically toggle other tracks\n            // off for us.\n            this.track.enabled = true;\n\n            // when native audio tracks are used, we want to make sure that other tracks are turned off\n            if (this.player_.tech_.featuresNativeAudioTracks) {\n                const tracks = this.player_.audioTracks();\n                for (let i = 0; i < tracks.length; i++) {\n                    const track = tracks[i];\n\n                    // skip the current track since we enabled it above\n                    if (track === this.track) {\n                        continue;\n                    }\n                    track.enabled = track === this.track;\n                }\n            }\n        }\n\n        /**\n         * Handle any {@link AudioTrack} change.\n         *\n         * @param {Event} [event]\n         *        The {@link AudioTrackList#change} event that caused this to run.\n         *\n         * @listens AudioTrackList#change\n         */\n        handleTracksChange(event) {\n            this.selected(this.track.enabled);\n        }\n    }\n    Component$1.registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);\n\n    /**\n     * @file audio-track-button.js\n     */\n\n    /**\n     * The base class for buttons that toggle specific {@link AudioTrack} types.\n     *\n     * @extends TrackButton\n     */\n    class AudioTrackButton extends TrackButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param {Player} player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options={}]\n         *        The key/value store of player options.\n         */\n        constructor(player, options = {}) {\n            options.tracks = player.audioTracks();\n            super(player, options);\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-audio-button ${super.buildCSSClass()}`;\n        }\n        buildWrapperCSSClass() {\n            return `vjs-audio-button ${super.buildWrapperCSSClass()}`;\n        }\n\n        /**\n         * Create a menu item for each audio track\n         *\n         * @param {AudioTrackMenuItem[]} [items=[]]\n         *        An array of existing menu items to use.\n         *\n         * @return {AudioTrackMenuItem[]}\n         *         An array of menu items\n         */\n        createItems(items = []) {\n            // if there's only one audio track, there no point in showing it\n            this.hideThreshold_ = 1;\n            const tracks = this.player_.audioTracks();\n            for (let i = 0; i < tracks.length; i++) {\n                const track = tracks[i];\n                items.push(new AudioTrackMenuItem(this.player_, {\n                    track,\n                    // MenuItem is selectable\n                    selectable: true,\n                    // MenuItem is NOT multiSelectable (i.e. only one can be marked \"selected\" at a time)\n                    multiSelectable: false\n                }));\n            }\n            return items;\n        }\n    }\n\n    /**\n     * The text that should display over the `AudioTrackButton`s controls. Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    AudioTrackButton.prototype.controlText_ = 'Audio Track';\n    Component$1.registerComponent('AudioTrackButton', AudioTrackButton);\n\n    /**\n     * @file playback-rate-menu-item.js\n     */\n\n    /**\n     * The specific menu item type for selecting a playback rate.\n     *\n     * @extends MenuItem\n     */\n    class PlaybackRateMenuItem extends MenuItem {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            const label = options.rate;\n            const rate = parseFloat(label, 10);\n\n            // Modify options for parent MenuItem class's init.\n            options.label = label;\n            options.selected = rate === player.playbackRate();\n            options.selectable = true;\n            options.multiSelectable = false;\n            super(player, options);\n            this.label = label;\n            this.rate = rate;\n            this.on(player, 'ratechange', e => this.update(e));\n        }\n\n        /**\n         * This gets called when an `PlaybackRateMenuItem` is \"clicked\". See\n         * {@link ClickableComponent} for more detailed information on what a click can be.\n         *\n         * @param {Event} [event]\n         *        The `keydown`, `tap`, or `click` event that caused this function to be\n         *        called.\n         *\n         * @listens tap\n         * @listens click\n         */\n        handleClick(event) {\n            super.handleClick();\n            this.player().playbackRate(this.rate);\n        }\n\n        /**\n         * Update the PlaybackRateMenuItem when the playbackrate changes.\n         *\n         * @param {Event} [event]\n         *        The `ratechange` event that caused this function to run.\n         *\n         * @listens Player#ratechange\n         */\n        update(event) {\n            this.selected(this.player().playbackRate() === this.rate);\n        }\n    }\n\n    /**\n     * The text that should display over the `PlaybackRateMenuItem`s controls. Added for localization.\n     *\n     * @type {string}\n     * @private\n     */\n    PlaybackRateMenuItem.prototype.contentElType = 'button';\n    Component$1.registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);\n\n    /**\n     * @file playback-rate-menu-button.js\n     */\n\n    /**\n     * The component for controlling the playback rate.\n     *\n     * @extends MenuButton\n     */\n    class PlaybackRateMenuButton extends MenuButton {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../../player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.menuButton_.el_.setAttribute('aria-describedby', this.labelElId_);\n            this.updateVisibility();\n            this.updateLabel();\n            this.on(player, 'loadstart', e => this.updateVisibility(e));\n            this.on(player, 'ratechange', e => this.updateLabel(e));\n            this.on(player, 'playbackrateschange', e => this.handlePlaybackRateschange(e));\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            const el = super.createEl();\n            this.labelElId_ = 'vjs-playback-rate-value-label-' + this.id_;\n            this.labelEl_ = createEl('div', {\n                className: 'vjs-playback-rate-value',\n                id: this.labelElId_,\n                textContent: '1x'\n            });\n            el.appendChild(this.labelEl_);\n            return el;\n        }\n        dispose() {\n            this.labelEl_ = null;\n            super.dispose();\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-playback-rate ${super.buildCSSClass()}`;\n        }\n        buildWrapperCSSClass() {\n            return `vjs-playback-rate ${super.buildWrapperCSSClass()}`;\n        }\n\n        /**\n         * Create the list of menu items. Specific to each subclass.\n         *\n         */\n        createItems() {\n            const rates = this.playbackRates();\n            const items = [];\n            for (let i = rates.length - 1; i >= 0; i--) {\n                items.push(new PlaybackRateMenuItem(this.player(), {\n                    rate: rates[i] + 'x'\n                }));\n            }\n            return items;\n        }\n\n        /**\n         * On playbackrateschange, update the menu to account for the new items.\n         *\n         * @listens Player#playbackrateschange\n         */\n        handlePlaybackRateschange(event) {\n            this.update();\n        }\n\n        /**\n         * Get possible playback rates\n         *\n         * @return {Array}\n         *         All possible playback rates\n         */\n        playbackRates() {\n            const player = this.player();\n            return player.playbackRates && player.playbackRates() || [];\n        }\n\n        /**\n         * Get whether playback rates is supported by the tech\n         * and an array of playback rates exists\n         *\n         * @return {boolean}\n         *         Whether changing playback rate is supported\n         */\n        playbackRateSupported() {\n            return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;\n        }\n\n        /**\n         * Hide playback rate controls when they're no playback rate options to select\n         *\n         * @param {Event} [event]\n         *        The event that caused this function to run.\n         *\n         * @listens Player#loadstart\n         */\n        updateVisibility(event) {\n            if (this.playbackRateSupported()) {\n                this.removeClass('vjs-hidden');\n            } else {\n                this.addClass('vjs-hidden');\n            }\n        }\n\n        /**\n         * Update button label when rate changed\n         *\n         * @param {Event} [event]\n         *        The event that caused this function to run.\n         *\n         * @listens Player#ratechange\n         */\n        updateLabel(event) {\n            if (this.playbackRateSupported()) {\n                this.labelEl_.textContent = this.player().playbackRate() + 'x';\n            }\n        }\n    }\n\n    /**\n     * The text that should display over the `PlaybackRateMenuButton`s controls.\n     *\n     * Added for localization.\n     *\n     * @type {string}\n     * @protected\n     */\n    PlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';\n    Component$1.registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);\n\n    /**\n     * @file spacer.js\n     */\n\n    /**\n     * Just an empty spacer element that can be used as an append point for plugins, etc.\n     * Also can be used to create space between elements when necessary.\n     *\n     * @extends Component\n     */\n    class Spacer extends Component$1 {\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-spacer ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl(tag = 'div', props = {}, attributes = {}) {\n            if (!props.className) {\n                props.className = this.buildCSSClass();\n            }\n            return super.createEl(tag, props, attributes);\n        }\n    }\n    Component$1.registerComponent('Spacer', Spacer);\n\n    /**\n     * @file custom-control-spacer.js\n     */\n\n    /**\n     * Spacer specifically meant to be used as an insertion point for new plugins, etc.\n     *\n     * @extends Spacer\n     */\n    class CustomControlSpacer extends Spacer {\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         */\n        buildCSSClass() {\n            return `vjs-custom-control-spacer ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: this.buildCSSClass(),\n                // No-flex/table-cell mode requires there be some content\n                // in the cell to fill the remaining space of the table.\n                textContent: '\\u00a0'\n            });\n        }\n    }\n    Component$1.registerComponent('CustomControlSpacer', CustomControlSpacer);\n\n    /**\n     * @file control-bar.js\n     */\n\n    /**\n     * Container of main controls.\n     *\n     * @extends Component\n     */\n    class ControlBar extends Component$1 {\n        /**\n         * Create the `Component`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            return super.createEl('div', {\n                className: 'vjs-control-bar',\n                dir: 'ltr'\n            });\n        }\n    }\n\n    /**\n     * Default options for `ControlBar`\n     *\n     * @type {Object}\n     * @private\n     */\n    ControlBar.prototype.options_ = {\n        children: ['playToggle', 'skipBackward', 'skipForward', 'volumePanel', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'seekToLive', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subsCapsButton', 'audioTrackButton', 'fullscreenToggle']\n    };\n    if ('exitPictureInPicture' in document) {\n        ControlBar.prototype.options_.children.splice(ControlBar.prototype.options_.children.length - 1, 0, 'pictureInPictureToggle');\n    }\n    Component$1.registerComponent('ControlBar', ControlBar);\n\n    /**\n     * @file error-display.js\n     */\n\n    /**\n     * A display that indicates an error has occurred. This means that the video\n     * is unplayable.\n     *\n     * @extends ModalDialog\n     */\n    class ErrorDisplay extends ModalDialog {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param  { import('./player').default } player\n         *         The `Player` that this class should be attached to.\n         *\n         * @param  {Object} [options]\n         *         The key/value store of player options.\n         */\n        constructor(player, options) {\n            super(player, options);\n            this.on(player, 'error', e => this.open(e));\n        }\n\n        /**\n         * Builds the default DOM `className`.\n         *\n         * @return {string}\n         *         The DOM `className` for this object.\n         *\n         * @deprecated Since version 5.\n         */\n        buildCSSClass() {\n            return `vjs-error-display ${super.buildCSSClass()}`;\n        }\n\n        /**\n         * Gets the localized error message based on the `Player`s error.\n         *\n         * @return {string}\n         *         The `Player`s error message localized or an empty string.\n         */\n        content() {\n            const error = this.player().error();\n            return error ? this.localize(error.message) : '';\n        }\n    }\n\n    /**\n     * The default options for an `ErrorDisplay`.\n     *\n     * @private\n     */\n    ErrorDisplay.prototype.options_ = Object.assign({}, ModalDialog.prototype.options_, {\n        pauseOnOpen: false,\n        fillAlways: true,\n        temporary: false,\n        uncloseable: true\n    });\n    Component$1.registerComponent('ErrorDisplay', ErrorDisplay);\n\n    /**\n     * @file text-track-settings.js\n     */\n    const LOCAL_STORAGE_KEY$1 = 'vjs-text-track-settings';\n    const COLOR_BLACK = ['#000', 'Black'];\n    const COLOR_BLUE = ['#00F', 'Blue'];\n    const COLOR_CYAN = ['#0FF', 'Cyan'];\n    const COLOR_GREEN = ['#0F0', 'Green'];\n    const COLOR_MAGENTA = ['#F0F', 'Magenta'];\n    const COLOR_RED = ['#F00', 'Red'];\n    const COLOR_WHITE = ['#FFF', 'White'];\n    const COLOR_YELLOW = ['#FF0', 'Yellow'];\n    const OPACITY_OPAQUE = ['1', 'Opaque'];\n    const OPACITY_SEMI = ['0.5', 'Semi-Transparent'];\n    const OPACITY_TRANS = ['0', 'Transparent'];\n\n    // Configuration for the various <select> elements in the DOM of this component.\n    //\n    // Possible keys include:\n    //\n    // `default`:\n    //   The default option index. Only needs to be provided if not zero.\n    // `parser`:\n    //   A function which is used to parse the value from the selected option in\n    //   a customized way.\n    // `selector`:\n    //   The selector used to find the associated <select> element.\n    const selectConfigs = {\n        backgroundColor: {\n            selector: '.vjs-bg-color > select',\n            id: 'captions-background-color-%s',\n            label: 'Color',\n            options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]\n        },\n        backgroundOpacity: {\n            selector: '.vjs-bg-opacity > select',\n            id: 'captions-background-opacity-%s',\n            label: 'Opacity',\n            options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]\n        },\n        color: {\n            selector: '.vjs-text-color > select',\n            id: 'captions-foreground-color-%s',\n            label: 'Color',\n            options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]\n        },\n        edgeStyle: {\n            selector: '.vjs-edge-style > select',\n            id: '%s',\n            label: 'Text Edge Style',\n            options: [['none', 'None'], ['raised', 'Raised'], ['depressed', 'Depressed'], ['uniform', 'Uniform'], ['dropshadow', 'Dropshadow']]\n        },\n        fontFamily: {\n            selector: '.vjs-font-family > select',\n            id: 'captions-font-family-%s',\n            label: 'Font Family',\n            options: [['proportionalSansSerif', 'Proportional Sans-Serif'], ['monospaceSansSerif', 'Monospace Sans-Serif'], ['proportionalSerif', 'Proportional Serif'], ['monospaceSerif', 'Monospace Serif'], ['casual', 'Casual'], ['script', 'Script'], ['small-caps', 'Small Caps']]\n        },\n        fontPercent: {\n            selector: '.vjs-font-percent > select',\n            id: 'captions-font-size-%s',\n            label: 'Font Size',\n            options: [['0.50', '50%'], ['0.75', '75%'], ['1.00', '100%'], ['1.25', '125%'], ['1.50', '150%'], ['1.75', '175%'], ['2.00', '200%'], ['3.00', '300%'], ['4.00', '400%']],\n            default: 2,\n            parser: v => v === '1.00' ? null : Number(v)\n        },\n        textOpacity: {\n            selector: '.vjs-text-opacity > select',\n            id: 'captions-foreground-opacity-%s',\n            label: 'Opacity',\n            options: [OPACITY_OPAQUE, OPACITY_SEMI]\n        },\n        // Options for this object are defined below.\n        windowColor: {\n            selector: '.vjs-window-color > select',\n            id: 'captions-window-color-%s',\n            label: 'Color'\n        },\n        // Options for this object are defined below.\n        windowOpacity: {\n            selector: '.vjs-window-opacity > select',\n            id: 'captions-window-opacity-%s',\n            label: 'Opacity',\n            options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]\n        }\n    };\n    selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;\n\n    /**\n     * Get the actual value of an option.\n     *\n     * @param  {string} value\n     *         The value to get\n     *\n     * @param  {Function} [parser]\n     *         Optional function to adjust the value.\n     *\n     * @return {*}\n     *         - Will be `undefined` if no value exists\n     *         - Will be `undefined` if the given value is \"none\".\n     *         - Will be the actual value otherwise.\n     *\n     * @private\n     */\n    function parseOptionValue(value, parser) {\n        if (parser) {\n            value = parser(value);\n        }\n        if (value && value !== 'none') {\n            return value;\n        }\n    }\n\n    /**\n     * Gets the value of the selected <option> element within a <select> element.\n     *\n     * @param  {Element} el\n     *         the element to look in\n     *\n     * @param  {Function} [parser]\n     *         Optional function to adjust the value.\n     *\n     * @return {*}\n     *         - Will be `undefined` if no value exists\n     *         - Will be `undefined` if the given value is \"none\".\n     *         - Will be the actual value otherwise.\n     *\n     * @private\n     */\n    function getSelectedOptionValue(el, parser) {\n        const value = el.options[el.options.selectedIndex].value;\n        return parseOptionValue(value, parser);\n    }\n\n    /**\n     * Sets the selected <option> element within a <select> element based on a\n     * given value.\n     *\n     * @param {Element} el\n     *        The element to look in.\n     *\n     * @param {string} value\n     *        the property to look on.\n     *\n     * @param {Function} [parser]\n     *        Optional function to adjust the value before comparing.\n     *\n     * @private\n     */\n    function setSelectedOption(el, value, parser) {\n        if (!value) {\n            return;\n        }\n        for (let i = 0; i < el.options.length; i++) {\n            if (parseOptionValue(el.options[i].value, parser) === value) {\n                el.selectedIndex = i;\n                break;\n            }\n        }\n    }\n\n    /**\n     * Manipulate Text Tracks settings.\n     *\n     * @extends ModalDialog\n     */\n    class TextTrackSettings extends ModalDialog {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('../player').default } player\n         *         The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *         The key/value store of player options.\n         */\n        constructor(player, options) {\n            options.temporary = false;\n            super(player, options);\n            this.updateDisplay = this.updateDisplay.bind(this);\n\n            // fill the modal and pretend we have opened it\n            this.fill();\n            this.hasBeenOpened_ = this.hasBeenFilled_ = true;\n            this.endDialog = createEl('p', {\n                className: 'vjs-control-text',\n                textContent: this.localize('End of dialog window.')\n            });\n            this.el().appendChild(this.endDialog);\n            this.setDefaults();\n\n            // Grab `persistTextTrackSettings` from the player options if not passed in child options\n            if (options.persistTextTrackSettings === undefined) {\n                this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings;\n            }\n            this.on(this.$('.vjs-done-button'), 'click', () => {\n                this.saveSettings();\n                this.close();\n            });\n            this.on(this.$('.vjs-default-button'), 'click', () => {\n                this.setDefaults();\n                this.updateDisplay();\n            });\n            each(selectConfigs, config => {\n                this.on(this.$(config.selector), 'change', this.updateDisplay);\n            });\n            if (this.options_.persistTextTrackSettings) {\n                this.restoreSettings();\n            }\n        }\n        dispose() {\n            this.endDialog = null;\n            super.dispose();\n        }\n\n        /**\n         * Create a <select> element with configured options.\n         *\n         * @param {string} key\n         *        Configuration key to use during creation.\n         *\n         * @return {string}\n         *         An HTML string.\n         *\n         * @private\n         */\n        createElSelect_(key, legendId = '', type = 'label') {\n            const config = selectConfigs[key];\n            const id = config.id.replace('%s', this.id_);\n            const selectLabelledbyIds = [legendId, id].join(' ').trim();\n            return [`<${type} id=\"${id}\" class=\"${type === 'label' ? 'vjs-label' : ''}\">`, this.localize(config.label), `</${type}>`, `<select aria-labelledby=\"${selectLabelledbyIds}\">`].concat(config.options.map(o => {\n                const optionId = id + '-' + o[1].replace(/\\W+/g, '');\n                return [`<option id=\"${optionId}\" value=\"${o[0]}\" `, `aria-labelledby=\"${selectLabelledbyIds} ${optionId}\">`, this.localize(o[1]), '</option>'].join('');\n            })).concat('</select>').join('');\n        }\n\n        /**\n         * Create foreground color element for the component\n         *\n         * @return {string}\n         *         An HTML string.\n         *\n         * @private\n         */\n        createElFgColor_() {\n            const legendId = `captions-text-legend-${this.id_}`;\n            return ['<fieldset class=\"vjs-fg vjs-track-setting\">', `<legend id=\"${legendId}\">`, this.localize('Text'), '</legend>', '<span class=\"vjs-text-color\">', this.createElSelect_('color', legendId), '</span>', '<span class=\"vjs-text-opacity vjs-opacity\">', this.createElSelect_('textOpacity', legendId), '</span>', '</fieldset>'].join('');\n        }\n\n        /**\n         * Create background color element for the component\n         *\n         * @return {string}\n         *         An HTML string.\n         *\n         * @private\n         */\n        createElBgColor_() {\n            const legendId = `captions-background-${this.id_}`;\n            return ['<fieldset class=\"vjs-bg vjs-track-setting\">', `<legend id=\"${legendId}\">`, this.localize('Text Background'), '</legend>', '<span class=\"vjs-bg-color\">', this.createElSelect_('backgroundColor', legendId), '</span>', '<span class=\"vjs-bg-opacity vjs-opacity\">', this.createElSelect_('backgroundOpacity', legendId), '</span>', '</fieldset>'].join('');\n        }\n\n        /**\n         * Create window color element for the component\n         *\n         * @return {string}\n         *         An HTML string.\n         *\n         * @private\n         */\n        createElWinColor_() {\n            const legendId = `captions-window-${this.id_}`;\n            return ['<fieldset class=\"vjs-window vjs-track-setting\">', `<legend id=\"${legendId}\">`, this.localize('Caption Area Background'), '</legend>', '<span class=\"vjs-window-color\">', this.createElSelect_('windowColor', legendId), '</span>', '<span class=\"vjs-window-opacity vjs-opacity\">', this.createElSelect_('windowOpacity', legendId), '</span>', '</fieldset>'].join('');\n        }\n\n        /**\n         * Create color elements for the component\n         *\n         * @return {Element}\n         *         The element that was created\n         *\n         * @private\n         */\n        createElColors_() {\n            return createEl('div', {\n                className: 'vjs-track-settings-colors',\n                innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join('')\n            });\n        }\n\n        /**\n         * Create font elements for the component\n         *\n         * @return {Element}\n         *         The element that was created.\n         *\n         * @private\n         */\n        createElFont_() {\n            return createEl('div', {\n                className: 'vjs-track-settings-font',\n                innerHTML: ['<fieldset class=\"vjs-font-percent vjs-track-setting\">', this.createElSelect_('fontPercent', '', 'legend'), '</fieldset>', '<fieldset class=\"vjs-edge-style vjs-track-setting\">', this.createElSelect_('edgeStyle', '', 'legend'), '</fieldset>', '<fieldset class=\"vjs-font-family vjs-track-setting\">', this.createElSelect_('fontFamily', '', 'legend'), '</fieldset>'].join('')\n            });\n        }\n\n        /**\n         * Create controls for the component\n         *\n         * @return {Element}\n         *         The element that was created.\n         *\n         * @private\n         */\n        createElControls_() {\n            const defaultsDescription = this.localize('restore all settings to the default values');\n            return createEl('div', {\n                className: 'vjs-track-settings-controls',\n                innerHTML: [`<button type=\"button\" class=\"vjs-default-button\" title=\"${defaultsDescription}\">`, this.localize('Reset'), `<span class=\"vjs-control-text\"> ${defaultsDescription}</span>`, '</button>', `<button type=\"button\" class=\"vjs-done-button\">${this.localize('Done')}</button>`].join('')\n            });\n        }\n        content() {\n            return [this.createElColors_(), this.createElFont_(), this.createElControls_()];\n        }\n        label() {\n            return this.localize('Caption Settings Dialog');\n        }\n        description() {\n            return this.localize('Beginning of dialog window. Escape will cancel and close the window.');\n        }\n        buildCSSClass() {\n            return super.buildCSSClass() + ' vjs-text-track-settings';\n        }\n\n        /**\n         * Gets an object of text track settings (or null).\n         *\n         * @return {Object}\n         *         An object with config values parsed from the DOM or localStorage.\n         */\n        getValues() {\n            return reduce(selectConfigs, (accum, config, key) => {\n                const value = getSelectedOptionValue(this.$(config.selector), config.parser);\n                if (value !== undefined) {\n                    accum[key] = value;\n                }\n                return accum;\n            }, {});\n        }\n\n        /**\n         * Sets text track settings from an object of values.\n         *\n         * @param {Object} values\n         *        An object with config values parsed from the DOM or localStorage.\n         */\n        setValues(values) {\n            each(selectConfigs, (config, key) => {\n                setSelectedOption(this.$(config.selector), values[key], config.parser);\n            });\n        }\n\n        /**\n         * Sets all `<select>` elements to their default values.\n         */\n        setDefaults() {\n            each(selectConfigs, config => {\n                const index = config.hasOwnProperty('default') ? config.default : 0;\n                this.$(config.selector).selectedIndex = index;\n            });\n        }\n\n        /**\n         * Restore texttrack settings from localStorage\n         */\n        restoreSettings() {\n            let values;\n            try {\n                values = JSON.parse(window.localStorage.getItem(LOCAL_STORAGE_KEY$1));\n            } catch (err) {\n                log$1.warn(err);\n            }\n            if (values) {\n                this.setValues(values);\n            }\n        }\n\n        /**\n         * Save text track settings to localStorage\n         */\n        saveSettings() {\n            if (!this.options_.persistTextTrackSettings) {\n                return;\n            }\n            const values = this.getValues();\n            try {\n                if (Object.keys(values).length) {\n                    window.localStorage.setItem(LOCAL_STORAGE_KEY$1, JSON.stringify(values));\n                } else {\n                    window.localStorage.removeItem(LOCAL_STORAGE_KEY$1);\n                }\n            } catch (err) {\n                log$1.warn(err);\n            }\n        }\n\n        /**\n         * Update display of text track settings\n         */\n        updateDisplay() {\n            const ttDisplay = this.player_.getChild('textTrackDisplay');\n            if (ttDisplay) {\n                ttDisplay.updateDisplay();\n            }\n        }\n\n        /**\n         * conditionally blur the element and refocus the captions button\n         *\n         * @private\n         */\n        conditionalBlur_() {\n            this.previouslyActiveEl_ = null;\n            const cb = this.player_.controlBar;\n            const subsCapsBtn = cb && cb.subsCapsButton;\n            const ccBtn = cb && cb.captionsButton;\n            if (subsCapsBtn) {\n                subsCapsBtn.focus();\n            } else if (ccBtn) {\n                ccBtn.focus();\n            }\n        }\n\n        /**\n         * Repopulate dialog with new localizations on languagechange\n         */\n        handleLanguagechange() {\n            this.fill();\n        }\n    }\n    Component$1.registerComponent('TextTrackSettings', TextTrackSettings);\n\n    /**\n     * @file resize-manager.js\n     */\n\n    /**\n     * A Resize Manager. It is in charge of triggering `playerresize` on the player in the right conditions.\n     *\n     * It'll either create an iframe and use a debounced resize handler on it or use the new {@link https://wicg.github.io/ResizeObserver/|ResizeObserver}.\n     *\n     * If the ResizeObserver is available natively, it will be used. A polyfill can be passed in as an option.\n     * If a `playerresize` event is not needed, the ResizeManager component can be removed from the player, see the example below.\n     *\n     * @example <caption>How to disable the resize manager</caption>\n     * const player = videojs('#vid', {\n     *   resizeManager: false\n     * });\n     *\n     * @see {@link https://wicg.github.io/ResizeObserver/|ResizeObserver specification}\n     *\n     * @extends Component\n     */\n    class ResizeManager extends Component$1 {\n        /**\n         * Create the ResizeManager.\n         *\n         * @param {Object} player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of ResizeManager options.\n         *\n         * @param {Object} [options.ResizeObserver]\n         *        A polyfill for ResizeObserver can be passed in here.\n         *        If this is set to null it will ignore the native ResizeObserver and fall back to the iframe fallback.\n         */\n        constructor(player, options) {\n            let RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || window.ResizeObserver;\n\n            // if `null` was passed, we want to disable the ResizeObserver\n            if (options.ResizeObserver === null) {\n                RESIZE_OBSERVER_AVAILABLE = false;\n            }\n\n            // Only create an element when ResizeObserver isn't available\n            const options_ = merge$2({\n                createEl: !RESIZE_OBSERVER_AVAILABLE,\n                reportTouchActivity: false\n            }, options);\n            super(player, options_);\n            this.ResizeObserver = options.ResizeObserver || window.ResizeObserver;\n            this.loadListener_ = null;\n            this.resizeObserver_ = null;\n            this.debouncedHandler_ = debounce(() => {\n                this.resizeHandler();\n            }, 100, false, this);\n            if (RESIZE_OBSERVER_AVAILABLE) {\n                this.resizeObserver_ = new this.ResizeObserver(this.debouncedHandler_);\n                this.resizeObserver_.observe(player.el());\n            } else {\n                this.loadListener_ = () => {\n                    if (!this.el_ || !this.el_.contentWindow) {\n                        return;\n                    }\n                    const debouncedHandler_ = this.debouncedHandler_;\n                    let unloadListener_ = this.unloadListener_ = function () {\n                        off(this, 'resize', debouncedHandler_);\n                        off(this, 'unload', unloadListener_);\n                        unloadListener_ = null;\n                    };\n\n                    // safari and edge can unload the iframe before resizemanager dispose\n                    // we have to dispose of event handlers correctly before that happens\n                    on(this.el_.contentWindow, 'unload', unloadListener_);\n                    on(this.el_.contentWindow, 'resize', debouncedHandler_);\n                };\n                this.one('load', this.loadListener_);\n            }\n        }\n        createEl() {\n            return super.createEl('iframe', {\n                className: 'vjs-resize-manager',\n                tabIndex: -1,\n                title: this.localize('No content')\n            }, {\n                'aria-hidden': 'true'\n            });\n        }\n\n        /**\n         * Called when a resize is triggered on the iframe or a resize is observed via the ResizeObserver\n         *\n         * @fires Player#playerresize\n         */\n        resizeHandler() {\n            /**\n             * Called when the player size has changed\n             *\n             * @event Player#playerresize\n             * @type {Event}\n             */\n            // make sure player is still around to trigger\n            // prevents this from causing an error after dispose\n            if (!this.player_ || !this.player_.trigger) {\n                return;\n            }\n            this.player_.trigger('playerresize');\n        }\n        dispose() {\n            if (this.debouncedHandler_) {\n                this.debouncedHandler_.cancel();\n            }\n            if (this.resizeObserver_) {\n                if (this.player_.el()) {\n                    this.resizeObserver_.unobserve(this.player_.el());\n                }\n                this.resizeObserver_.disconnect();\n            }\n            if (this.loadListener_) {\n                this.off('load', this.loadListener_);\n            }\n            if (this.el_ && this.el_.contentWindow && this.unloadListener_) {\n                this.unloadListener_.call(this.el_.contentWindow);\n            }\n            this.ResizeObserver = null;\n            this.resizeObserver = null;\n            this.debouncedHandler_ = null;\n            this.loadListener_ = null;\n            super.dispose();\n        }\n    }\n    Component$1.registerComponent('ResizeManager', ResizeManager);\n\n    const defaults = {\n        trackingThreshold: 20,\n        liveTolerance: 15\n    };\n\n    /*\n    track when we are at the live edge, and other helpers for live playback */\n\n    /**\n     * A class for checking live current time and determining when the player\n     * is at or behind the live edge.\n     */\n    class LiveTracker extends Component$1 {\n        /**\n         * Creates an instance of this class.\n         *\n         * @param { import('./player').default } player\n         *        The `Player` that this class should be attached to.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {number} [options.trackingThreshold=20]\n         *        Number of seconds of live window (seekableEnd - seekableStart) that\n         *        media needs to have before the liveui will be shown.\n         *\n         * @param {number} [options.liveTolerance=15]\n         *        Number of seconds behind live that we have to be\n         *        before we will be considered non-live. Note that this will only\n         *        be used when playing at the live edge. This allows large seekable end\n         *        changes to not effect whether we are live or not.\n         */\n        constructor(player, options) {\n            // LiveTracker does not need an element\n            const options_ = merge$2(defaults, options, {\n                createEl: false\n            });\n            super(player, options_);\n            this.trackLiveHandler_ = () => this.trackLive_();\n            this.handlePlay_ = e => this.handlePlay(e);\n            this.handleFirstTimeupdate_ = e => this.handleFirstTimeupdate(e);\n            this.handleSeeked_ = e => this.handleSeeked(e);\n            this.seekToLiveEdge_ = e => this.seekToLiveEdge(e);\n            this.reset_();\n            this.on(this.player_, 'durationchange', e => this.handleDurationchange(e));\n            // we should try to toggle tracking on canplay as native playback engines, like Safari\n            // may not have the proper values for things like seekableEnd until then\n            this.on(this.player_, 'canplay', () => this.toggleTracking());\n        }\n\n        /**\n         * all the functionality for tracking when seek end changes\n         * and for tracking how far past seek end we should be\n         */\n        trackLive_() {\n            const seekable = this.player_.seekable();\n\n            // skip undefined seekable\n            if (!seekable || !seekable.length) {\n                return;\n            }\n            const newTime = Number(window.performance.now().toFixed(4));\n            const deltaTime = this.lastTime_ === -1 ? 0 : (newTime - this.lastTime_) / 1000;\n            this.lastTime_ = newTime;\n            this.pastSeekEnd_ = this.pastSeekEnd() + deltaTime;\n            const liveCurrentTime = this.liveCurrentTime();\n            const currentTime = this.player_.currentTime();\n\n            // we are behind live if any are true\n            // 1. the player is paused\n            // 2. the user seeked to a location 2 seconds away from live\n            // 3. the difference between live and current time is greater\n            //    liveTolerance which defaults to 15s\n            let isBehind = this.player_.paused() || this.seekedBehindLive_ || Math.abs(liveCurrentTime - currentTime) > this.options_.liveTolerance;\n\n            // we cannot be behind if\n            // 1. until we have not seen a timeupdate yet\n            // 2. liveCurrentTime is Infinity, which happens on Android and Native Safari\n            if (!this.timeupdateSeen_ || liveCurrentTime === Infinity) {\n                isBehind = false;\n            }\n            if (isBehind !== this.behindLiveEdge_) {\n                this.behindLiveEdge_ = isBehind;\n                this.trigger('liveedgechange');\n            }\n        }\n\n        /**\n         * handle a durationchange event on the player\n         * and start/stop tracking accordingly.\n         */\n        handleDurationchange() {\n            this.toggleTracking();\n        }\n\n        /**\n         * start/stop tracking\n         */\n        toggleTracking() {\n            if (this.player_.duration() === Infinity && this.liveWindow() >= this.options_.trackingThreshold) {\n                if (this.player_.options_.liveui) {\n                    this.player_.addClass('vjs-liveui');\n                }\n                this.startTracking();\n            } else {\n                this.player_.removeClass('vjs-liveui');\n                this.stopTracking();\n            }\n        }\n\n        /**\n         * start tracking live playback\n         */\n        startTracking() {\n            if (this.isTracking()) {\n                return;\n            }\n\n            // If we haven't seen a timeupdate, we need to check whether playback\n            // began before this component started tracking. This can happen commonly\n            // when using autoplay.\n            if (!this.timeupdateSeen_) {\n                this.timeupdateSeen_ = this.player_.hasStarted();\n            }\n            this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, UPDATE_REFRESH_INTERVAL);\n            this.trackLive_();\n            this.on(this.player_, ['play', 'pause'], this.trackLiveHandler_);\n            if (!this.timeupdateSeen_) {\n                this.one(this.player_, 'play', this.handlePlay_);\n                this.one(this.player_, 'timeupdate', this.handleFirstTimeupdate_);\n            } else {\n                this.on(this.player_, 'seeked', this.handleSeeked_);\n            }\n        }\n\n        /**\n         * handle the first timeupdate on the player if it wasn't already playing\n         * when live tracker started tracking.\n         */\n        handleFirstTimeupdate() {\n            this.timeupdateSeen_ = true;\n            this.on(this.player_, 'seeked', this.handleSeeked_);\n        }\n\n        /**\n         * Keep track of what time a seek starts, and listen for seeked\n         * to find where a seek ends.\n         */\n        handleSeeked() {\n            const timeDiff = Math.abs(this.liveCurrentTime() - this.player_.currentTime());\n            this.seekedBehindLive_ = this.nextSeekedFromUser_ && timeDiff > 2;\n            this.nextSeekedFromUser_ = false;\n            this.trackLive_();\n        }\n\n        /**\n         * handle the first play on the player, and make sure that we seek\n         * right to the live edge.\n         */\n        handlePlay() {\n            this.one(this.player_, 'timeupdate', this.seekToLiveEdge_);\n        }\n\n        /**\n         * Stop tracking, and set all internal variables to\n         * their initial value.\n         */\n        reset_() {\n            this.lastTime_ = -1;\n            this.pastSeekEnd_ = 0;\n            this.lastSeekEnd_ = -1;\n            this.behindLiveEdge_ = true;\n            this.timeupdateSeen_ = false;\n            this.seekedBehindLive_ = false;\n            this.nextSeekedFromUser_ = false;\n            this.clearInterval(this.trackingInterval_);\n            this.trackingInterval_ = null;\n            this.off(this.player_, ['play', 'pause'], this.trackLiveHandler_);\n            this.off(this.player_, 'seeked', this.handleSeeked_);\n            this.off(this.player_, 'play', this.handlePlay_);\n            this.off(this.player_, 'timeupdate', this.handleFirstTimeupdate_);\n            this.off(this.player_, 'timeupdate', this.seekToLiveEdge_);\n        }\n\n        /**\n         * The next seeked event is from the user. Meaning that any seek\n         * > 2s behind live will be considered behind live for real and\n         * liveTolerance will be ignored.\n         */\n        nextSeekedFromUser() {\n            this.nextSeekedFromUser_ = true;\n        }\n\n        /**\n         * stop tracking live playback\n         */\n        stopTracking() {\n            if (!this.isTracking()) {\n                return;\n            }\n            this.reset_();\n            this.trigger('liveedgechange');\n        }\n\n        /**\n         * A helper to get the player seekable end\n         * so that we don't have to null check everywhere\n         *\n         * @return {number}\n         *         The furthest seekable end or Infinity.\n         */\n        seekableEnd() {\n            const seekable = this.player_.seekable();\n            const seekableEnds = [];\n            let i = seekable ? seekable.length : 0;\n            while (i--) {\n                seekableEnds.push(seekable.end(i));\n            }\n\n            // grab the furthest seekable end after sorting, or if there are none\n            // default to Infinity\n            return seekableEnds.length ? seekableEnds.sort()[seekableEnds.length - 1] : Infinity;\n        }\n\n        /**\n         * A helper to get the player seekable start\n         * so that we don't have to null check everywhere\n         *\n         * @return {number}\n         *         The earliest seekable start or 0.\n         */\n        seekableStart() {\n            const seekable = this.player_.seekable();\n            const seekableStarts = [];\n            let i = seekable ? seekable.length : 0;\n            while (i--) {\n                seekableStarts.push(seekable.start(i));\n            }\n\n            // grab the first seekable start after sorting, or if there are none\n            // default to 0\n            return seekableStarts.length ? seekableStarts.sort()[0] : 0;\n        }\n\n        /**\n         * Get the live time window aka\n         * the amount of time between seekable start and\n         * live current time.\n         *\n         * @return {number}\n         *         The amount of seconds that are seekable in\n         *         the live video.\n         */\n        liveWindow() {\n            const liveCurrentTime = this.liveCurrentTime();\n\n            // if liveCurrenTime is Infinity then we don't have a liveWindow at all\n            if (liveCurrentTime === Infinity) {\n                return 0;\n            }\n            return liveCurrentTime - this.seekableStart();\n        }\n\n        /**\n         * Determines if the player is live, only checks if this component\n         * is tracking live playback or not\n         *\n         * @return {boolean}\n         *         Whether liveTracker is tracking\n         */\n        isLive() {\n            return this.isTracking();\n        }\n\n        /**\n         * Determines if currentTime is at the live edge and won't fall behind\n         * on each seekableendchange\n         *\n         * @return {boolean}\n         *         Whether playback is at the live edge\n         */\n        atLiveEdge() {\n            return !this.behindLiveEdge();\n        }\n\n        /**\n         * get what we expect the live current time to be\n         *\n         * @return {number}\n         *         The expected live current time\n         */\n        liveCurrentTime() {\n            return this.pastSeekEnd() + this.seekableEnd();\n        }\n\n        /**\n         * The number of seconds that have occurred after seekable end\n         * changed. This will be reset to 0 once seekable end changes.\n         *\n         * @return {number}\n         *         Seconds past the current seekable end\n         */\n        pastSeekEnd() {\n            const seekableEnd = this.seekableEnd();\n            if (this.lastSeekEnd_ !== -1 && seekableEnd !== this.lastSeekEnd_) {\n                this.pastSeekEnd_ = 0;\n            }\n            this.lastSeekEnd_ = seekableEnd;\n            return this.pastSeekEnd_;\n        }\n\n        /**\n         * If we are currently behind the live edge, aka currentTime will be\n         * behind on a seekableendchange\n         *\n         * @return {boolean}\n         *         If we are behind the live edge\n         */\n        behindLiveEdge() {\n            return this.behindLiveEdge_;\n        }\n\n        /**\n         * Whether live tracker is currently tracking or not.\n         */\n        isTracking() {\n            return typeof this.trackingInterval_ === 'number';\n        }\n\n        /**\n         * Seek to the live edge if we are behind the live edge\n         */\n        seekToLiveEdge() {\n            this.seekedBehindLive_ = false;\n            if (this.atLiveEdge()) {\n                return;\n            }\n            this.nextSeekedFromUser_ = false;\n            this.player_.currentTime(this.liveCurrentTime());\n        }\n\n        /**\n         * Dispose of liveTracker\n         */\n        dispose() {\n            this.stopTracking();\n            super.dispose();\n        }\n    }\n    Component$1.registerComponent('LiveTracker', LiveTracker);\n\n    /**\n     * Displays an element over the player which contains an optional title and\n     * description for the current content.\n     *\n     * Much of the code for this component originated in the now obsolete\n     * videojs-dock plugin: https://github.com/brightcove/videojs-dock/\n     *\n     * @extends Component\n     */\n    class TitleBar extends Component$1 {\n        constructor(player, options) {\n            super(player, options);\n            this.on('statechanged', e => this.updateDom_());\n            this.updateDom_();\n        }\n\n        /**\n         * Create the `TitleBar`'s DOM element\n         *\n         * @return {Element}\n         *         The element that was created.\n         */\n        createEl() {\n            this.els = {\n                title: createEl('div', {\n                    className: 'vjs-title-bar-title',\n                    id: `vjs-title-bar-title-${newGUID()}`\n                }),\n                description: createEl('div', {\n                    className: 'vjs-title-bar-description',\n                    id: `vjs-title-bar-description-${newGUID()}`\n                })\n            };\n            return createEl('div', {\n                className: 'vjs-title-bar'\n            }, {}, Object.values(this.els));\n        }\n\n        /**\n         * Updates the DOM based on the component's state object.\n         */\n        updateDom_() {\n            const tech = this.player_.tech_;\n            const techEl = tech && tech.el_;\n            const techAriaAttrs = {\n                title: 'aria-labelledby',\n                description: 'aria-describedby'\n            };\n            ['title', 'description'].forEach(k => {\n                const value = this.state[k];\n                const el = this.els[k];\n                const techAriaAttr = techAriaAttrs[k];\n                emptyEl(el);\n                if (value) {\n                    textContent(el, value);\n                }\n\n                // If there is a tech element available, update its ARIA attributes\n                // according to whether a title and/or description have been provided.\n                if (techEl) {\n                    techEl.removeAttribute(techAriaAttr);\n                    if (value) {\n                        techEl.setAttribute(techAriaAttr, el.id);\n                    }\n                }\n            });\n            if (this.state.title || this.state.description) {\n                this.show();\n            } else {\n                this.hide();\n            }\n        }\n\n        /**\n         * Update the contents of the title bar component with new title and\n         * description text.\n         *\n         * If both title and description are missing, the title bar will be hidden.\n         *\n         * If either title or description are present, the title bar will be visible.\n         *\n         * NOTE: Any previously set value will be preserved. To unset a previously\n         * set value, you must pass an empty string or null.\n         *\n         * For example:\n         *\n         * ```\n         * update({title: 'foo', description: 'bar'}) // title: 'foo', description: 'bar'\n         * update({description: 'bar2'}) // title: 'foo', description: 'bar2'\n         * update({title: ''}) // title: '', description: 'bar2'\n         * update({title: 'foo', description: null}) // title: 'foo', description: null\n         * ```\n         *\n         * @param  {Object} [options={}]\n         *         An options object. When empty, the title bar will be hidden.\n         *\n         * @param  {string} [options.title]\n         *         A title to display in the title bar.\n         *\n         * @param  {string} [options.description]\n         *         A description to display in the title bar.\n         */\n        update(options) {\n            this.setState(options);\n        }\n\n        /**\n         * Dispose the component.\n         */\n        dispose() {\n            const tech = this.player_.tech_;\n            const techEl = tech && tech.el_;\n            if (techEl) {\n                techEl.removeAttribute('aria-labelledby');\n                techEl.removeAttribute('aria-describedby');\n            }\n            super.dispose();\n            this.els = null;\n        }\n    }\n    Component$1.registerComponent('TitleBar', TitleBar);\n\n    /**\n     * This function is used to fire a sourceset when there is something\n     * similar to `mediaEl.load()` being called. It will try to find the source via\n     * the `src` attribute and then the `<source>` elements. It will then fire `sourceset`\n     * with the source that was found or empty string if we cannot know. If it cannot\n     * find a source then `sourceset` will not be fired.\n     *\n     * @param { import('./html5').default } tech\n     *        The tech object that sourceset was setup on\n     *\n     * @return {boolean}\n     *         returns false if the sourceset was not fired and true otherwise.\n     */\n    const sourcesetLoad = tech => {\n        const el = tech.el();\n\n        // if `el.src` is set, that source will be loaded.\n        if (el.hasAttribute('src')) {\n            tech.triggerSourceset(el.src);\n            return true;\n        }\n\n        /**\n         * Since there isn't a src property on the media element, source elements will be used for\n         * implementing the source selection algorithm. This happens asynchronously and\n         * for most cases were there is more than one source we cannot tell what source will\n         * be loaded, without re-implementing the source selection algorithm. At this time we are not\n         * going to do that. There are three special cases that we do handle here though:\n         *\n         * 1. If there are no sources, do not fire `sourceset`.\n         * 2. If there is only one `<source>` with a `src` property/attribute that is our `src`\n         * 3. If there is more than one `<source>` but all of them have the same `src` url.\n         *    That will be our src.\n         */\n        const sources = tech.$$('source');\n        const srcUrls = [];\n        let src = '';\n\n        // if there are no sources, do not fire sourceset\n        if (!sources.length) {\n            return false;\n        }\n\n        // only count valid/non-duplicate source elements\n        for (let i = 0; i < sources.length; i++) {\n            const url = sources[i].src;\n            if (url && srcUrls.indexOf(url) === -1) {\n                srcUrls.push(url);\n            }\n        }\n\n        // there were no valid sources\n        if (!srcUrls.length) {\n            return false;\n        }\n\n        // there is only one valid source element url\n        // use that\n        if (srcUrls.length === 1) {\n            src = srcUrls[0];\n        }\n        tech.triggerSourceset(src);\n        return true;\n    };\n\n    /**\n     * our implementation of an `innerHTML` descriptor for browsers\n     * that do not have one.\n     */\n    const innerHTMLDescriptorPolyfill = Object.defineProperty({}, 'innerHTML', {\n        get() {\n            return this.cloneNode(true).innerHTML;\n        },\n        set(v) {\n            // make a dummy node to use innerHTML on\n            const dummy = document.createElement(this.nodeName.toLowerCase());\n\n            // set innerHTML to the value provided\n            dummy.innerHTML = v;\n\n            // make a document fragment to hold the nodes from dummy\n            const docFrag = document.createDocumentFragment();\n\n            // copy all of the nodes created by the innerHTML on dummy\n            // to the document fragment\n            while (dummy.childNodes.length) {\n                docFrag.appendChild(dummy.childNodes[0]);\n            }\n\n            // remove content\n            this.innerText = '';\n\n            // now we add all of that html in one by appending the\n            // document fragment. This is how innerHTML does it.\n            window.Element.prototype.appendChild.call(this, docFrag);\n\n            // then return the result that innerHTML's setter would\n            return this.innerHTML;\n        }\n    });\n\n    /**\n     * Get a property descriptor given a list of priorities and the\n     * property to get.\n     */\n    const getDescriptor = (priority, prop) => {\n        let descriptor = {};\n        for (let i = 0; i < priority.length; i++) {\n            descriptor = Object.getOwnPropertyDescriptor(priority[i], prop);\n            if (descriptor && descriptor.set && descriptor.get) {\n                break;\n            }\n        }\n        descriptor.enumerable = true;\n        descriptor.configurable = true;\n        return descriptor;\n    };\n    const getInnerHTMLDescriptor = tech => getDescriptor([tech.el(), window.HTMLMediaElement.prototype, window.Element.prototype, innerHTMLDescriptorPolyfill], 'innerHTML');\n\n    /**\n     * Patches browser internal functions so that we can tell synchronously\n     * if a `<source>` was appended to the media element. For some reason this\n     * causes a `sourceset` if the the media element is ready and has no source.\n     * This happens when:\n     * - The page has just loaded and the media element does not have a source.\n     * - The media element was emptied of all sources, then `load()` was called.\n     *\n     * It does this by patching the following functions/properties when they are supported:\n     *\n     * - `append()` - can be used to add a `<source>` element to the media element\n     * - `appendChild()` - can be used to add a `<source>` element to the media element\n     * - `insertAdjacentHTML()` -  can be used to add a `<source>` element to the media element\n     * - `innerHTML` -  can be used to add a `<source>` element to the media element\n     *\n     * @param {Html5} tech\n     *        The tech object that sourceset is being setup on.\n     */\n    const firstSourceWatch = function (tech) {\n        const el = tech.el();\n\n        // make sure firstSourceWatch isn't setup twice.\n        if (el.resetSourceWatch_) {\n            return;\n        }\n        const old = {};\n        const innerDescriptor = getInnerHTMLDescriptor(tech);\n        const appendWrapper = appendFn => (...args) => {\n            const retval = appendFn.apply(el, args);\n            sourcesetLoad(tech);\n            return retval;\n        };\n        ['append', 'appendChild', 'insertAdjacentHTML'].forEach(k => {\n            if (!el[k]) {\n                return;\n            }\n\n            // store the old function\n            old[k] = el[k];\n\n            // call the old function with a sourceset if a source\n            // was loaded\n            el[k] = appendWrapper(old[k]);\n        });\n        Object.defineProperty(el, 'innerHTML', merge$2(innerDescriptor, {\n            set: appendWrapper(innerDescriptor.set)\n        }));\n        el.resetSourceWatch_ = () => {\n            el.resetSourceWatch_ = null;\n            Object.keys(old).forEach(k => {\n                el[k] = old[k];\n            });\n            Object.defineProperty(el, 'innerHTML', innerDescriptor);\n        };\n\n        // on the first sourceset, we need to revert our changes\n        tech.one('sourceset', el.resetSourceWatch_);\n    };\n\n    /**\n     * our implementation of a `src` descriptor for browsers\n     * that do not have one\n     */\n    const srcDescriptorPolyfill = Object.defineProperty({}, 'src', {\n        get() {\n            if (this.hasAttribute('src')) {\n                return getAbsoluteURL(window.Element.prototype.getAttribute.call(this, 'src'));\n            }\n            return '';\n        },\n        set(v) {\n            window.Element.prototype.setAttribute.call(this, 'src', v);\n            return v;\n        }\n    });\n    const getSrcDescriptor = tech => getDescriptor([tech.el(), window.HTMLMediaElement.prototype, srcDescriptorPolyfill], 'src');\n\n    /**\n     * setup `sourceset` handling on the `Html5` tech. This function\n     * patches the following element properties/functions:\n     *\n     * - `src` - to determine when `src` is set\n     * - `setAttribute()` - to determine when `src` is set\n     * - `load()` - this re-triggers the source selection algorithm, and can\n     *              cause a sourceset.\n     *\n     * If there is no source when we are adding `sourceset` support or during a `load()`\n     * we also patch the functions listed in `firstSourceWatch`.\n     *\n     * @param {Html5} tech\n     *        The tech to patch\n     */\n    const setupSourceset = function (tech) {\n        if (!tech.featuresSourceset) {\n            return;\n        }\n        const el = tech.el();\n\n        // make sure sourceset isn't setup twice.\n        if (el.resetSourceset_) {\n            return;\n        }\n        const srcDescriptor = getSrcDescriptor(tech);\n        const oldSetAttribute = el.setAttribute;\n        const oldLoad = el.load;\n        Object.defineProperty(el, 'src', merge$2(srcDescriptor, {\n            set: v => {\n                const retval = srcDescriptor.set.call(el, v);\n\n                // we use the getter here to get the actual value set on src\n                tech.triggerSourceset(el.src);\n                return retval;\n            }\n        }));\n        el.setAttribute = (n, v) => {\n            const retval = oldSetAttribute.call(el, n, v);\n            if (/src/i.test(n)) {\n                tech.triggerSourceset(el.src);\n            }\n            return retval;\n        };\n        el.load = () => {\n            const retval = oldLoad.call(el);\n\n            // if load was called, but there was no source to fire\n            // sourceset on. We have to watch for a source append\n            // as that can trigger a `sourceset` when the media element\n            // has no source\n            if (!sourcesetLoad(tech)) {\n                tech.triggerSourceset('');\n                firstSourceWatch(tech);\n            }\n            return retval;\n        };\n        if (el.currentSrc) {\n            tech.triggerSourceset(el.currentSrc);\n        } else if (!sourcesetLoad(tech)) {\n            firstSourceWatch(tech);\n        }\n        el.resetSourceset_ = () => {\n            el.resetSourceset_ = null;\n            el.load = oldLoad;\n            el.setAttribute = oldSetAttribute;\n            Object.defineProperty(el, 'src', srcDescriptor);\n            if (el.resetSourceWatch_) {\n                el.resetSourceWatch_();\n            }\n        };\n    };\n\n    /**\n     * @file html5.js\n     */\n\n    /**\n     * HTML5 Media Controller - Wrapper for HTML5 Media API\n     *\n     * @mixes Tech~SourceHandlerAdditions\n     * @extends Tech\n     */\n    class Html5 extends Tech {\n        /**\n         * Create an instance of this Tech.\n         *\n         * @param {Object} [options]\n         *        The key/value store of player options.\n         *\n         * @param {Function} [ready]\n         *        Callback function to call when the `HTML5` Tech is ready.\n         */\n        constructor(options, ready) {\n            super(options, ready);\n            const source = options.source;\n            let crossoriginTracks = false;\n            this.featuresVideoFrameCallback = this.featuresVideoFrameCallback && this.el_.tagName === 'VIDEO';\n\n            // Set the source if one is provided\n            // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)\n            // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source\n            // anyway so the error gets fired.\n            if (source && (this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {\n                this.setSource(source);\n            } else {\n                this.handleLateInit_(this.el_);\n            }\n\n            // setup sourceset after late sourceset/init\n            if (options.enableSourceset) {\n                this.setupSourcesetHandling_();\n            }\n            this.isScrubbing_ = false;\n            if (this.el_.hasChildNodes()) {\n                const nodes = this.el_.childNodes;\n                let nodesLength = nodes.length;\n                const removeNodes = [];\n                while (nodesLength--) {\n                    const node = nodes[nodesLength];\n                    const nodeName = node.nodeName.toLowerCase();\n                    if (nodeName === 'track') {\n                        if (!this.featuresNativeTextTracks) {\n                            // Empty video tag tracks so the built-in player doesn't use them also.\n                            // This may not be fast enough to stop HTML5 browsers from reading the tags\n                            // so we'll need to turn off any default tracks if we're manually doing\n                            // captions and subtitles. videoElement.textTracks\n                            removeNodes.push(node);\n                        } else {\n                            // store HTMLTrackElement and TextTrack to remote list\n                            this.remoteTextTrackEls().addTrackElement_(node);\n                            this.remoteTextTracks().addTrack(node.track);\n                            this.textTracks().addTrack(node.track);\n                            if (!crossoriginTracks && !this.el_.hasAttribute('crossorigin') && isCrossOrigin(node.src)) {\n                                crossoriginTracks = true;\n                            }\n                        }\n                    }\n                }\n                for (let i = 0; i < removeNodes.length; i++) {\n                    this.el_.removeChild(removeNodes[i]);\n                }\n            }\n            this.proxyNativeTracks_();\n            if (this.featuresNativeTextTracks && crossoriginTracks) {\n                log$1.warn('Text Tracks are being loaded from another origin but the crossorigin attribute isn\\'t used.\\n' + 'This may prevent text tracks from loading.');\n            }\n\n            // prevent iOS Safari from disabling metadata text tracks during native playback\n            this.restoreMetadataTracksInIOSNativePlayer_();\n\n            // Determine if native controls should be used\n            // Our goal should be to get the custom controls on mobile solid everywhere\n            // so we can remove this all together. Right now this will block custom\n            // controls on touch enabled laptops like the Chrome Pixel\n            if ((TOUCH_ENABLED || IS_IPHONE) && options.nativeControlsForTouch === true) {\n                this.setControls(true);\n            }\n\n            // on iOS, we want to proxy `webkitbeginfullscreen` and `webkitendfullscreen`\n            // into a `fullscreenchange` event\n            this.proxyWebkitFullscreen_();\n            this.triggerReady();\n        }\n\n        /**\n         * Dispose of `HTML5` media element and remove all tracks.\n         */\n        dispose() {\n            if (this.el_ && this.el_.resetSourceset_) {\n                this.el_.resetSourceset_();\n            }\n            Html5.disposeMediaElement(this.el_);\n            this.options_ = null;\n\n            // tech will handle clearing of the emulated track list\n            super.dispose();\n        }\n\n        /**\n         * Modify the media element so that we can detect when\n         * the source is changed. Fires `sourceset` just after the source has changed\n         */\n        setupSourcesetHandling_() {\n            setupSourceset(this);\n        }\n\n        /**\n         * When a captions track is enabled in the iOS Safari native player, all other\n         * tracks are disabled (including metadata tracks), which nulls all of their\n         * associated cue points. This will restore metadata tracks to their pre-fullscreen\n         * state in those cases so that cue points are not needlessly lost.\n         *\n         * @private\n         */\n        restoreMetadataTracksInIOSNativePlayer_() {\n            const textTracks = this.textTracks();\n            let metadataTracksPreFullscreenState;\n\n            // captures a snapshot of every metadata track's current state\n            const takeMetadataTrackSnapshot = () => {\n                metadataTracksPreFullscreenState = [];\n                for (let i = 0; i < textTracks.length; i++) {\n                    const track = textTracks[i];\n                    if (track.kind === 'metadata') {\n                        metadataTracksPreFullscreenState.push({\n                            track,\n                            storedMode: track.mode\n                        });\n                    }\n                }\n            };\n\n            // snapshot each metadata track's initial state, and update the snapshot\n            // each time there is a track 'change' event\n            takeMetadataTrackSnapshot();\n            textTracks.addEventListener('change', takeMetadataTrackSnapshot);\n            this.on('dispose', () => textTracks.removeEventListener('change', takeMetadataTrackSnapshot));\n            const restoreTrackMode = () => {\n                for (let i = 0; i < metadataTracksPreFullscreenState.length; i++) {\n                    const storedTrack = metadataTracksPreFullscreenState[i];\n                    if (storedTrack.track.mode === 'disabled' && storedTrack.track.mode !== storedTrack.storedMode) {\n                        storedTrack.track.mode = storedTrack.storedMode;\n                    }\n                }\n                // we only want this handler to be executed on the first 'change' event\n                textTracks.removeEventListener('change', restoreTrackMode);\n            };\n\n            // when we enter fullscreen playback, stop updating the snapshot and\n            // restore all track modes to their pre-fullscreen state\n            this.on('webkitbeginfullscreen', () => {\n                textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\n\n                // remove the listener before adding it just in case it wasn't previously removed\n                textTracks.removeEventListener('change', restoreTrackMode);\n                textTracks.addEventListener('change', restoreTrackMode);\n            });\n\n            // start updating the snapshot again after leaving fullscreen\n            this.on('webkitendfullscreen', () => {\n                // remove the listener before adding it just in case it wasn't previously removed\n                textTracks.removeEventListener('change', takeMetadataTrackSnapshot);\n                textTracks.addEventListener('change', takeMetadataTrackSnapshot);\n\n                // remove the restoreTrackMode handler in case it wasn't triggered during fullscreen playback\n                textTracks.removeEventListener('change', restoreTrackMode);\n            });\n        }\n\n        /**\n         * Attempt to force override of tracks for the given type\n         *\n         * @param {string} type - Track type to override, possible values include 'Audio',\n         * 'Video', and 'Text'.\n         * @param {boolean} override - If set to true native audio/video will be overridden,\n         * otherwise native audio/video will potentially be used.\n         * @private\n         */\n        overrideNative_(type, override) {\n            // If there is no behavioral change don't add/remove listeners\n            if (override !== this[`featuresNative${type}Tracks`]) {\n                return;\n            }\n            const lowerCaseType = type.toLowerCase();\n            if (this[`${lowerCaseType}TracksListeners_`]) {\n                Object.keys(this[`${lowerCaseType}TracksListeners_`]).forEach(eventName => {\n                    const elTracks = this.el()[`${lowerCaseType}Tracks`];\n                    elTracks.removeEventListener(eventName, this[`${lowerCaseType}TracksListeners_`][eventName]);\n                });\n            }\n            this[`featuresNative${type}Tracks`] = !override;\n            this[`${lowerCaseType}TracksListeners_`] = null;\n            this.proxyNativeTracksForType_(lowerCaseType);\n        }\n\n        /**\n         * Attempt to force override of native audio tracks.\n         *\n         * @param {boolean} override - If set to true native audio will be overridden,\n         * otherwise native audio will potentially be used.\n         */\n        overrideNativeAudioTracks(override) {\n            this.overrideNative_('Audio', override);\n        }\n\n        /**\n         * Attempt to force override of native video tracks.\n         *\n         * @param {boolean} override - If set to true native video will be overridden,\n         * otherwise native video will potentially be used.\n         */\n        overrideNativeVideoTracks(override) {\n            this.overrideNative_('Video', override);\n        }\n\n        /**\n         * Proxy native track list events for the given type to our track\n         * lists if the browser we are playing in supports that type of track list.\n         *\n         * @param {string} name - Track type; values include 'audio', 'video', and 'text'\n         * @private\n         */\n        proxyNativeTracksForType_(name) {\n            const props = NORMAL[name];\n            const elTracks = this.el()[props.getterName];\n            const techTracks = this[props.getterName]();\n            if (!this[`featuresNative${props.capitalName}Tracks`] || !elTracks || !elTracks.addEventListener) {\n                return;\n            }\n            const listeners = {\n                change: e => {\n                    const event = {\n                        type: 'change',\n                        target: techTracks,\n                        currentTarget: techTracks,\n                        srcElement: techTracks\n                    };\n                    techTracks.trigger(event);\n\n                    // if we are a text track change event, we should also notify the\n                    // remote text track list. This can potentially cause a false positive\n                    // if we were to get a change event on a non-remote track and\n                    // we triggered the event on the remote text track list which doesn't\n                    // contain that track. However, best practices mean looping through the\n                    // list of tracks and searching for the appropriate mode value, so,\n                    // this shouldn't pose an issue\n                    if (name === 'text') {\n                        this[REMOTE.remoteText.getterName]().trigger(event);\n                    }\n                },\n                addtrack(e) {\n                    techTracks.addTrack(e.track);\n                },\n                removetrack(e) {\n                    techTracks.removeTrack(e.track);\n                }\n            };\n            const removeOldTracks = function () {\n                const removeTracks = [];\n                for (let i = 0; i < techTracks.length; i++) {\n                    let found = false;\n                    for (let j = 0; j < elTracks.length; j++) {\n                        if (elTracks[j] === techTracks[i]) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        removeTracks.push(techTracks[i]);\n                    }\n                }\n                while (removeTracks.length) {\n                    techTracks.removeTrack(removeTracks.shift());\n                }\n            };\n            this[props.getterName + 'Listeners_'] = listeners;\n            Object.keys(listeners).forEach(eventName => {\n                const listener = listeners[eventName];\n                elTracks.addEventListener(eventName, listener);\n                this.on('dispose', e => elTracks.removeEventListener(eventName, listener));\n            });\n\n            // Remove (native) tracks that are not used anymore\n            this.on('loadstart', removeOldTracks);\n            this.on('dispose', e => this.off('loadstart', removeOldTracks));\n        }\n\n        /**\n         * Proxy all native track list events to our track lists if the browser we are playing\n         * in supports that type of track list.\n         *\n         * @private\n         */\n        proxyNativeTracks_() {\n            NORMAL.names.forEach(name => {\n                this.proxyNativeTracksForType_(name);\n            });\n        }\n\n        /**\n         * Create the `Html5` Tech's DOM element.\n         *\n         * @return {Element}\n         *         The element that gets created.\n         */\n        createEl() {\n            let el = this.options_.tag;\n\n            // Check if this browser supports moving the element into the box.\n            // On the iPhone video will break if you move the element,\n            // So we have to create a brand new element.\n            // If we ingested the player div, we do not need to move the media element.\n            if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {\n                // If the original tag is still there, clone and remove it.\n                if (el) {\n                    const clone = el.cloneNode(true);\n                    if (el.parentNode) {\n                        el.parentNode.insertBefore(clone, el);\n                    }\n                    Html5.disposeMediaElement(el);\n                    el = clone;\n                } else {\n                    el = document.createElement('video');\n\n                    // determine if native controls should be used\n                    const tagAttributes = this.options_.tag && getAttributes(this.options_.tag);\n                    const attributes = merge$2({}, tagAttributes);\n                    if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {\n                        delete attributes.controls;\n                    }\n                    setAttributes(el, Object.assign(attributes, {\n                        id: this.options_.techId,\n                        class: 'vjs-tech'\n                    }));\n                }\n                el.playerId = this.options_.playerId;\n            }\n            if (typeof this.options_.preload !== 'undefined') {\n                setAttribute(el, 'preload', this.options_.preload);\n            }\n            if (this.options_.disablePictureInPicture !== undefined) {\n                el.disablePictureInPicture = this.options_.disablePictureInPicture;\n            }\n\n            // Update specific tag settings, in case they were overridden\n            // `autoplay` has to be *last* so that `muted` and `playsinline` are present\n            // when iOS/Safari or other browsers attempt to autoplay.\n            const settingsAttrs = ['loop', 'muted', 'playsinline', 'autoplay'];\n            for (let i = 0; i < settingsAttrs.length; i++) {\n                const attr = settingsAttrs[i];\n                const value = this.options_[attr];\n                if (typeof value !== 'undefined') {\n                    if (value) {\n                        setAttribute(el, attr, attr);\n                    } else {\n                        removeAttribute(el, attr);\n                    }\n                    el[attr] = value;\n                }\n            }\n            return el;\n        }\n\n        /**\n         * This will be triggered if the loadstart event has already fired, before videojs was\n         * ready. Two known examples of when this can happen are:\n         * 1. If we're loading the playback object after it has started loading\n         * 2. The media is already playing the (often with autoplay on) then\n         *\n         * This function will fire another loadstart so that videojs can catchup.\n         *\n         * @fires Tech#loadstart\n         *\n         * @return {undefined}\n         *         returns nothing.\n         */\n        handleLateInit_(el) {\n            if (el.networkState === 0 || el.networkState === 3) {\n                // The video element hasn't started loading the source yet\n                // or didn't find a source\n                return;\n            }\n            if (el.readyState === 0) {\n                // NetworkState is set synchronously BUT loadstart is fired at the\n                // end of the current stack, usually before setInterval(fn, 0).\n                // So at this point we know loadstart may have already fired or is\n                // about to fire, and either way the player hasn't seen it yet.\n                // We don't want to fire loadstart prematurely here and cause a\n                // double loadstart so we'll wait and see if it happens between now\n                // and the next loop, and fire it if not.\n                // HOWEVER, we also want to make sure it fires before loadedmetadata\n                // which could also happen between now and the next loop, so we'll\n                // watch for that also.\n                let loadstartFired = false;\n                const setLoadstartFired = function () {\n                    loadstartFired = true;\n                };\n                this.on('loadstart', setLoadstartFired);\n                const triggerLoadstart = function () {\n                    // We did miss the original loadstart. Make sure the player\n                    // sees loadstart before loadedmetadata\n                    if (!loadstartFired) {\n                        this.trigger('loadstart');\n                    }\n                };\n                this.on('loadedmetadata', triggerLoadstart);\n                this.ready(function () {\n                    this.off('loadstart', setLoadstartFired);\n                    this.off('loadedmetadata', triggerLoadstart);\n                    if (!loadstartFired) {\n                        // We did miss the original native loadstart. Fire it now.\n                        this.trigger('loadstart');\n                    }\n                });\n                return;\n            }\n\n            // From here on we know that loadstart already fired and we missed it.\n            // The other readyState events aren't as much of a problem if we double\n            // them, so not going to go to as much trouble as loadstart to prevent\n            // that unless we find reason to.\n            const eventsToTrigger = ['loadstart'];\n\n            // loadedmetadata: newly equal to HAVE_METADATA (1) or greater\n            eventsToTrigger.push('loadedmetadata');\n\n            // loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater\n            if (el.readyState >= 2) {\n                eventsToTrigger.push('loadeddata');\n            }\n\n            // canplay: newly increased to HAVE_FUTURE_DATA (3) or greater\n            if (el.readyState >= 3) {\n                eventsToTrigger.push('canplay');\n            }\n\n            // canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)\n            if (el.readyState >= 4) {\n                eventsToTrigger.push('canplaythrough');\n            }\n\n            // We still need to give the player time to add event listeners\n            this.ready(function () {\n                eventsToTrigger.forEach(function (type) {\n                    this.trigger(type);\n                }, this);\n            });\n        }\n\n        /**\n         * Set whether we are scrubbing or not.\n         * This is used to decide whether we should use `fastSeek` or not.\n         * `fastSeek` is used to provide trick play on Safari browsers.\n         *\n         * @param {boolean} isScrubbing\n         *                  - true for we are currently scrubbing\n         *                  - false for we are no longer scrubbing\n         */\n        setScrubbing(isScrubbing) {\n            this.isScrubbing_ = isScrubbing;\n        }\n\n        /**\n         * Get whether we are scrubbing or not.\n         *\n         * @return {boolean} isScrubbing\n         *                  - true for we are currently scrubbing\n         *                  - false for we are no longer scrubbing\n         */\n        scrubbing() {\n            return this.isScrubbing_;\n        }\n\n        /**\n         * Set current time for the `HTML5` tech.\n         *\n         * @param {number} seconds\n         *        Set the current time of the media to this.\n         */\n        setCurrentTime(seconds) {\n            try {\n                if (this.isScrubbing_ && this.el_.fastSeek && IS_ANY_SAFARI) {\n                    this.el_.fastSeek(seconds);\n                } else {\n                    this.el_.currentTime = seconds;\n                }\n            } catch (e) {\n                log$1(e, 'Video is not ready. (Video.js)');\n                // this.warning(VideoJS.warnings.videoNotReady);\n            }\n        }\n\n        /**\n         * Get the current duration of the HTML5 media element.\n         *\n         * @return {number}\n         *         The duration of the media or 0 if there is no duration.\n         */\n        duration() {\n            // Android Chrome will report duration as Infinity for VOD HLS until after\n            // playback has started, which triggers the live display erroneously.\n            // Return NaN if playback has not started and trigger a durationupdate once\n            // the duration can be reliably known.\n            if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {\n                // Wait for the first `timeupdate` with currentTime > 0 - there may be\n                // several with 0\n                const checkProgress = () => {\n                    if (this.el_.currentTime > 0) {\n                        // Trigger durationchange for genuinely live video\n                        if (this.el_.duration === Infinity) {\n                            this.trigger('durationchange');\n                        }\n                        this.off('timeupdate', checkProgress);\n                    }\n                };\n                this.on('timeupdate', checkProgress);\n                return NaN;\n            }\n            return this.el_.duration || NaN;\n        }\n\n        /**\n         * Get the current width of the HTML5 media element.\n         *\n         * @return {number}\n         *         The width of the HTML5 media element.\n         */\n        width() {\n            return this.el_.offsetWidth;\n        }\n\n        /**\n         * Get the current height of the HTML5 media element.\n         *\n         * @return {number}\n         *         The height of the HTML5 media element.\n         */\n        height() {\n            return this.el_.offsetHeight;\n        }\n\n        /**\n         * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into\n         * `fullscreenchange` event.\n         *\n         * @private\n         * @fires fullscreenchange\n         * @listens webkitendfullscreen\n         * @listens webkitbeginfullscreen\n         * @listens webkitbeginfullscreen\n         */\n        proxyWebkitFullscreen_() {\n            if (!('webkitDisplayingFullscreen' in this.el_)) {\n                return;\n            }\n            const endFn = function () {\n                this.trigger('fullscreenchange', {\n                    isFullscreen: false\n                });\n                // Safari will sometimes set controls on the videoelement when existing fullscreen.\n                if (this.el_.controls && !this.options_.nativeControlsForTouch && this.controls()) {\n                    this.el_.controls = false;\n                }\n            };\n            const beginFn = function () {\n                if ('webkitPresentationMode' in this.el_ && this.el_.webkitPresentationMode !== 'picture-in-picture') {\n                    this.one('webkitendfullscreen', endFn);\n                    this.trigger('fullscreenchange', {\n                        isFullscreen: true,\n                        // set a flag in case another tech triggers fullscreenchange\n                        nativeIOSFullscreen: true\n                    });\n                }\n            };\n            this.on('webkitbeginfullscreen', beginFn);\n            this.on('dispose', () => {\n                this.off('webkitbeginfullscreen', beginFn);\n                this.off('webkitendfullscreen', endFn);\n            });\n        }\n\n        /**\n         * Check if fullscreen is supported on the video el.\n         *\n         * @return {boolean}\n         *         - True if fullscreen is supported.\n         *         - False if fullscreen is not supported.\n         */\n        supportsFullScreen() {\n            return typeof this.el_.webkitEnterFullScreen === 'function';\n        }\n\n        /**\n         * Request that the `HTML5` Tech enter fullscreen.\n         */\n        enterFullScreen() {\n            const video = this.el_;\n            if (video.paused && video.networkState <= video.HAVE_METADATA) {\n                // attempt to prime the video element for programmatic access\n                // this isn't necessary on the desktop but shouldn't hurt\n                silencePromise(this.el_.play());\n\n                // playing and pausing synchronously during the transition to fullscreen\n                // can get iOS ~6.1 devices into a play/pause loop\n                this.setTimeout(function () {\n                    video.pause();\n                    try {\n                        video.webkitEnterFullScreen();\n                    } catch (e) {\n                        this.trigger('fullscreenerror', e);\n                    }\n                }, 0);\n            } else {\n                try {\n                    video.webkitEnterFullScreen();\n                } catch (e) {\n                    this.trigger('fullscreenerror', e);\n                }\n            }\n        }\n\n        /**\n         * Request that the `HTML5` Tech exit fullscreen.\n         */\n        exitFullScreen() {\n            if (!this.el_.webkitDisplayingFullscreen) {\n                this.trigger('fullscreenerror', new Error('The video is not fullscreen'));\n                return;\n            }\n            this.el_.webkitExitFullScreen();\n        }\n\n        /**\n         * Create a floating video window always on top of other windows so that users may\n         * continue consuming media while they interact with other content sites, or\n         * applications on their device.\n         *\n         * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\n         *\n         * @return {Promise}\n         *         A promise with a Picture-in-Picture window.\n         */\n        requestPictureInPicture() {\n            return this.el_.requestPictureInPicture();\n        }\n\n        /**\n         * Native requestVideoFrameCallback if supported by browser/tech, or fallback\n         * Don't use rVCF on Safari when DRM is playing, as it doesn't fire\n         * Needs to be checked later than the constructor\n         * This will be a false positive for clear sources loaded after a Fairplay source\n         *\n         * @param {function} cb function to call\n         * @return {number} id of request\n         */\n        requestVideoFrameCallback(cb) {\n            if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {\n                return this.el_.requestVideoFrameCallback(cb);\n            }\n            return super.requestVideoFrameCallback(cb);\n        }\n\n        /**\n         * Native or fallback requestVideoFrameCallback\n         *\n         * @param {number} id request id to cancel\n         */\n        cancelVideoFrameCallback(id) {\n            if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {\n                this.el_.cancelVideoFrameCallback(id);\n            } else {\n                super.cancelVideoFrameCallback(id);\n            }\n        }\n\n        /**\n         * A getter/setter for the `Html5` Tech's source object.\n         * > Note: Please use {@link Html5#setSource}\n         *\n         * @param {Tech~SourceObject} [src]\n         *        The source object you want to set on the `HTML5` techs element.\n         *\n         * @return {Tech~SourceObject|undefined}\n         *         - The current source object when a source is not passed in.\n         *         - undefined when setting\n         *\n         * @deprecated Since version 5.\n         */\n        src(src) {\n            if (src === undefined) {\n                return this.el_.src;\n            }\n\n            // Setting src through `src` instead of `setSrc` will be deprecated\n            this.setSrc(src);\n        }\n\n        /**\n         * Reset the tech by removing all sources and then calling\n         * {@link Html5.resetMediaElement}.\n         */\n        reset() {\n            Html5.resetMediaElement(this.el_);\n        }\n\n        /**\n         * Get the current source on the `HTML5` Tech. Falls back to returning the source from\n         * the HTML5 media element.\n         *\n         * @return {Tech~SourceObject}\n         *         The current source object from the HTML5 tech. With a fallback to the\n         *         elements source.\n         */\n        currentSrc() {\n            if (this.currentSource_) {\n                return this.currentSource_.src;\n            }\n            return this.el_.currentSrc;\n        }\n\n        /**\n         * Set controls attribute for the HTML5 media Element.\n         *\n         * @param {string} val\n         *        Value to set the controls attribute to\n         */\n        setControls(val) {\n            this.el_.controls = !!val;\n        }\n\n        /**\n         * Create and returns a remote {@link TextTrack} object.\n         *\n         * @param {string} kind\n         *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)\n         *\n         * @param {string} [label]\n         *        Label to identify the text track\n         *\n         * @param {string} [language]\n         *        Two letter language abbreviation\n         *\n         * @return {TextTrack}\n         *         The TextTrack that gets created.\n         */\n        addTextTrack(kind, label, language) {\n            if (!this.featuresNativeTextTracks) {\n                return super.addTextTrack(kind, label, language);\n            }\n            return this.el_.addTextTrack(kind, label, language);\n        }\n\n        /**\n         * Creates either native TextTrack or an emulated TextTrack depending\n         * on the value of `featuresNativeTextTracks`\n         *\n         * @param {Object} options\n         *        The object should contain the options to initialize the TextTrack with.\n         *\n         * @param {string} [options.kind]\n         *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).\n         *\n         * @param {string} [options.label]\n         *        Label to identify the text track\n         *\n         * @param {string} [options.language]\n         *        Two letter language abbreviation.\n         *\n         * @param {boolean} [options.default]\n         *        Default this track to on.\n         *\n         * @param {string} [options.id]\n         *        The internal id to assign this track.\n         *\n         * @param {string} [options.src]\n         *        A source url for the track.\n         *\n         * @return {HTMLTrackElement}\n         *         The track element that gets created.\n         */\n        createRemoteTextTrack(options) {\n            if (!this.featuresNativeTextTracks) {\n                return super.createRemoteTextTrack(options);\n            }\n            const htmlTrackElement = document.createElement('track');\n            if (options.kind) {\n                htmlTrackElement.kind = options.kind;\n            }\n            if (options.label) {\n                htmlTrackElement.label = options.label;\n            }\n            if (options.language || options.srclang) {\n                htmlTrackElement.srclang = options.language || options.srclang;\n            }\n            if (options.default) {\n                htmlTrackElement.default = options.default;\n            }\n            if (options.id) {\n                htmlTrackElement.id = options.id;\n            }\n            if (options.src) {\n                htmlTrackElement.src = options.src;\n            }\n            return htmlTrackElement;\n        }\n\n        /**\n         * Creates a remote text track object and returns an html track element.\n         *\n         * @param {Object} options The object should contain values for\n         * kind, language, label, and src (location of the WebVTT file)\n         * @param {boolean} [manualCleanup=false] if set to true, the TextTrack\n         * will not be removed from the TextTrackList and HtmlTrackElementList\n         * after a source change\n         * @return {HTMLTrackElement} An Html Track Element.\n         * This can be an emulated {@link HTMLTrackElement} or a native one.\n         *\n         */\n        addRemoteTextTrack(options, manualCleanup) {\n            const htmlTrackElement = super.addRemoteTextTrack(options, manualCleanup);\n            if (this.featuresNativeTextTracks) {\n                this.el().appendChild(htmlTrackElement);\n            }\n            return htmlTrackElement;\n        }\n\n        /**\n         * Remove remote `TextTrack` from `TextTrackList` object\n         *\n         * @param {TextTrack} track\n         *        `TextTrack` object to remove\n         */\n        removeRemoteTextTrack(track) {\n            super.removeRemoteTextTrack(track);\n            if (this.featuresNativeTextTracks) {\n                const tracks = this.$$('track');\n                let i = tracks.length;\n                while (i--) {\n                    if (track === tracks[i] || track === tracks[i].track) {\n                        this.el().removeChild(tracks[i]);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Gets available media playback quality metrics as specified by the W3C's Media\n         * Playback Quality API.\n         *\n         * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n         *\n         * @return {Object}\n         *         An object with supported media playback quality metrics\n         */\n        getVideoPlaybackQuality() {\n            if (typeof this.el().getVideoPlaybackQuality === 'function') {\n                return this.el().getVideoPlaybackQuality();\n            }\n            const videoPlaybackQuality = {};\n            if (typeof this.el().webkitDroppedFrameCount !== 'undefined' && typeof this.el().webkitDecodedFrameCount !== 'undefined') {\n                videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;\n                videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;\n            }\n            if (window.performance) {\n                videoPlaybackQuality.creationTime = window.performance.now();\n            }\n            return videoPlaybackQuality;\n        }\n    }\n\n    /* HTML5 Support Testing ---------------------------------------------------- */\n\n    /**\n     * Element for testing browser HTML5 media capabilities\n     *\n     * @type {Element}\n     * @constant\n     * @private\n     */\n    defineLazyProperty(Html5, 'TEST_VID', function () {\n        if (!isReal()) {\n            return;\n        }\n        const video = document.createElement('video');\n        const track = document.createElement('track');\n        track.kind = 'captions';\n        track.srclang = 'en';\n        track.label = 'English';\n        video.appendChild(track);\n        return video;\n    });\n\n    /**\n     * Check if HTML5 media is supported by this browser/device.\n     *\n     * @return {boolean}\n     *         - True if HTML5 media is supported.\n     *         - False if HTML5 media is not supported.\n     */\n    Html5.isSupported = function () {\n        // IE with no Media Player is a LIAR! (#984)\n        try {\n            Html5.TEST_VID.volume = 0.5;\n        } catch (e) {\n            return false;\n        }\n        return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);\n    };\n\n    /**\n     * Check if the tech can support the given type\n     *\n     * @param {string} type\n     *        The mimetype to check\n     * @return {string} 'probably', 'maybe', or '' (empty string)\n     */\n    Html5.canPlayType = function (type) {\n        return Html5.TEST_VID.canPlayType(type);\n    };\n\n    /**\n     * Check if the tech can support the given source\n     *\n     * @param {Object} srcObj\n     *        The source object\n     * @param {Object} options\n     *        The options passed to the tech\n     * @return {string} 'probably', 'maybe', or '' (empty string)\n     */\n    Html5.canPlaySource = function (srcObj, options) {\n        return Html5.canPlayType(srcObj.type);\n    };\n\n    /**\n     * Check if the volume can be changed in this browser/device.\n     * Volume cannot be changed in a lot of mobile devices.\n     * Specifically, it can't be changed from 1 on iOS.\n     *\n     * @return {boolean}\n     *         - True if volume can be controlled\n     *         - False otherwise\n     */\n    Html5.canControlVolume = function () {\n        // IE will error if Windows Media Player not installed #3315\n        try {\n            const volume = Html5.TEST_VID.volume;\n            Html5.TEST_VID.volume = volume / 2 + 0.1;\n            const canControl = volume !== Html5.TEST_VID.volume;\n\n            // With the introduction of iOS 15, there are cases where the volume is read as\n            // changed but reverts back to its original state at the start of the next tick.\n            // To determine whether volume can be controlled on iOS,\n            // a timeout is set and the volume is checked asynchronously.\n            // Since `features` doesn't currently work asynchronously, the value is manually set.\n            if (canControl && IS_IOS) {\n                window.setTimeout(() => {\n                    if (Html5 && Html5.prototype) {\n                        Html5.prototype.featuresVolumeControl = volume !== Html5.TEST_VID.volume;\n                    }\n                });\n\n                // default iOS to false, which will be updated in the timeout above.\n                return false;\n            }\n            return canControl;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    /**\n     * Check if the volume can be muted in this browser/device.\n     * Some devices, e.g. iOS, don't allow changing volume\n     * but permits muting/unmuting.\n     *\n     * @return {boolean}\n     *      - True if volume can be muted\n     *      - False otherwise\n     */\n    Html5.canMuteVolume = function () {\n        try {\n            const muted = Html5.TEST_VID.muted;\n\n            // in some versions of iOS muted property doesn't always\n            // work, so we want to set both property and attribute\n            Html5.TEST_VID.muted = !muted;\n            if (Html5.TEST_VID.muted) {\n                setAttribute(Html5.TEST_VID, 'muted', 'muted');\n            } else {\n                removeAttribute(Html5.TEST_VID, 'muted', 'muted');\n            }\n            return muted !== Html5.TEST_VID.muted;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    /**\n     * Check if the playback rate can be changed in this browser/device.\n     *\n     * @return {boolean}\n     *         - True if playback rate can be controlled\n     *         - False otherwise\n     */\n    Html5.canControlPlaybackRate = function () {\n        // Playback rate API is implemented in Android Chrome, but doesn't do anything\n        // https://github.com/videojs/video.js/issues/3180\n        if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {\n            return false;\n        }\n        // IE will error if Windows Media Player not installed #3315\n        try {\n            const playbackRate = Html5.TEST_VID.playbackRate;\n            Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;\n            return playbackRate !== Html5.TEST_VID.playbackRate;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    /**\n     * Check if we can override a video/audio elements attributes, with\n     * Object.defineProperty.\n     *\n     * @return {boolean}\n     *         - True if builtin attributes can be overridden\n     *         - False otherwise\n     */\n    Html5.canOverrideAttributes = function () {\n        // if we cannot overwrite the src/innerHTML property, there is no support\n        // iOS 7 safari for instance cannot do this.\n        try {\n            const noop = () => {};\n            Object.defineProperty(document.createElement('video'), 'src', {\n                get: noop,\n                set: noop\n            });\n            Object.defineProperty(document.createElement('audio'), 'src', {\n                get: noop,\n                set: noop\n            });\n            Object.defineProperty(document.createElement('video'), 'innerHTML', {\n                get: noop,\n                set: noop\n            });\n            Object.defineProperty(document.createElement('audio'), 'innerHTML', {\n                get: noop,\n                set: noop\n            });\n        } catch (e) {\n            return false;\n        }\n        return true;\n    };\n\n    /**\n     * Check to see if native `TextTrack`s are supported by this browser/device.\n     *\n     * @return {boolean}\n     *         - True if native `TextTrack`s are supported.\n     *         - False otherwise\n     */\n    Html5.supportsNativeTextTracks = function () {\n        return IS_ANY_SAFARI || IS_IOS && IS_CHROME;\n    };\n\n    /**\n     * Check to see if native `VideoTrack`s are supported by this browser/device\n     *\n     * @return {boolean}\n     *        - True if native `VideoTrack`s are supported.\n     *        - False otherwise\n     */\n    Html5.supportsNativeVideoTracks = function () {\n        return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);\n    };\n\n    /**\n     * Check to see if native `AudioTrack`s are supported by this browser/device\n     *\n     * @return {boolean}\n     *        - True if native `AudioTrack`s are supported.\n     *        - False otherwise\n     */\n    Html5.supportsNativeAudioTracks = function () {\n        return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);\n    };\n\n    /**\n     * An array of events available on the Html5 tech.\n     *\n     * @private\n     * @type {Array}\n     */\n    Html5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'resize', 'volumechange'];\n\n    /**\n     * Boolean indicating whether the `Tech` supports volume control.\n     *\n     * @type {boolean}\n     * @default {@link Html5.canControlVolume}\n     */\n    /**\n     * Boolean indicating whether the `Tech` supports muting volume.\n     *\n     * @type {boolean}\n     * @default {@link Html5.canMuteVolume}\n     */\n\n    /**\n     * Boolean indicating whether the `Tech` supports changing the speed at which the media\n     * plays. Examples:\n     *   - Set player to play 2x (twice) as fast\n     *   - Set player to play 0.5x (half) as fast\n     *\n     * @type {boolean}\n     * @default {@link Html5.canControlPlaybackRate}\n     */\n\n    /**\n     * Boolean indicating whether the `Tech` supports the `sourceset` event.\n     *\n     * @type {boolean}\n     * @default\n     */\n    /**\n     * Boolean indicating whether the `HTML5` tech currently supports native `TextTrack`s.\n     *\n     * @type {boolean}\n     * @default {@link Html5.supportsNativeTextTracks}\n     */\n    /**\n     * Boolean indicating whether the `HTML5` tech currently supports native `VideoTrack`s.\n     *\n     * @type {boolean}\n     * @default {@link Html5.supportsNativeVideoTracks}\n     */\n    /**\n     * Boolean indicating whether the `HTML5` tech currently supports native `AudioTrack`s.\n     *\n     * @type {boolean}\n     * @default {@link Html5.supportsNativeAudioTracks}\n     */\n    [['featuresMuteControl', 'canMuteVolume'], ['featuresPlaybackRate', 'canControlPlaybackRate'], ['featuresSourceset', 'canOverrideAttributes'], ['featuresNativeTextTracks', 'supportsNativeTextTracks'], ['featuresNativeVideoTracks', 'supportsNativeVideoTracks'], ['featuresNativeAudioTracks', 'supportsNativeAudioTracks']].forEach(function ([key, fn]) {\n        defineLazyProperty(Html5.prototype, key, () => Html5[fn](), true);\n    });\n    Html5.prototype.featuresVolumeControl = Html5.canControlVolume();\n\n    /**\n     * Boolean indicating whether the `HTML5` tech currently supports the media element\n     * moving in the DOM. iOS breaks if you move the media element, so this is set this to\n     * false there. Everywhere else this should be true.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Html5.prototype.movingMediaElementInDOM = !IS_IOS;\n\n    // TODO: Previous comment: No longer appears to be used. Can probably be removed.\n    //       Is this true?\n    /**\n     * Boolean indicating whether the `HTML5` tech currently supports automatic media resize\n     * when going into fullscreen.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Html5.prototype.featuresFullscreenResize = true;\n\n    /**\n     * Boolean indicating whether the `HTML5` tech currently supports the progress event.\n     * If this is false, manual `progress` events will be triggered instead.\n     *\n     * @type {boolean}\n     * @default\n     */\n    Html5.prototype.featuresProgressEvents = true;\n\n    /**\n     * Boolean indicating whether the `HTML5` tech currently supports the timeupdate event.\n     * If this is false, manual `timeupdate` events will be triggered instead.\n     *\n     * @default\n     */\n    Html5.prototype.featuresTimeupdateEvents = true;\n\n    /**\n     * Whether the HTML5 el supports `requestVideoFrameCallback`\n     *\n     * @type {boolean}\n     */\n    Html5.prototype.featuresVideoFrameCallback = !!(Html5.TEST_VID && Html5.TEST_VID.requestVideoFrameCallback);\n    Html5.disposeMediaElement = function (el) {\n        if (!el) {\n            return;\n        }\n        if (el.parentNode) {\n            el.parentNode.removeChild(el);\n        }\n\n        // remove any child track or source nodes to prevent their loading\n        while (el.hasChildNodes()) {\n            el.removeChild(el.firstChild);\n        }\n\n        // remove any src reference. not setting `src=''` because that causes a warning\n        // in firefox\n        el.removeAttribute('src');\n\n        // force the media element to update its loading state by calling load()\n        // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)\n        if (typeof el.load === 'function') {\n            // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n            (function () {\n                try {\n                    el.load();\n                } catch (e) {\n                    // not supported\n                }\n            })();\n        }\n    };\n    Html5.resetMediaElement = function (el) {\n        if (!el) {\n            return;\n        }\n        const sources = el.querySelectorAll('source');\n        let i = sources.length;\n        while (i--) {\n            el.removeChild(sources[i]);\n        }\n\n        // remove any src reference.\n        // not setting `src=''` because that throws an error\n        el.removeAttribute('src');\n        if (typeof el.load === 'function') {\n            // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)\n            (function () {\n                try {\n                    el.load();\n                } catch (e) {\n                    // satisfy linter\n                }\n            })();\n        }\n    };\n\n    /* Native HTML5 element property wrapping ----------------------------------- */\n    // Wrap native boolean attributes with getters that check both property and attribute\n    // The list is as followed:\n    // muted, defaultMuted, autoplay, controls, loop, playsinline\n    [\n        /**\n         * Get the value of `muted` from the media element. `muted` indicates\n         * that the volume for the media should be set to silent. This does not actually change\n         * the `volume` attribute.\n         *\n         * @method Html5#muted\n         * @return {boolean}\n         *         - True if the value of `volume` should be ignored and the audio set to silent.\n         *         - False if the value of `volume` should be used.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n         */\n        'muted',\n        /**\n         * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates\n         * whether the media should start muted or not. Only changes the default state of the\n         * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the\n         * current state.\n         *\n         * @method Html5#defaultMuted\n         * @return {boolean}\n         *         - The value of `defaultMuted` from the media element.\n         *         - True indicates that the media should start muted.\n         *         - False indicates that the media should not start muted\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n         */\n        'defaultMuted',\n        /**\n         * Get the value of `autoplay` from the media element. `autoplay` indicates\n         * that the media should start to play as soon as the page is ready.\n         *\n         * @method Html5#autoplay\n         * @return {boolean}\n         *         - The value of `autoplay` from the media element.\n         *         - True indicates that the media should start as soon as the page loads.\n         *         - False indicates that the media should not start as soon as the page loads.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n         */\n        'autoplay',\n        /**\n         * Get the value of `controls` from the media element. `controls` indicates\n         * whether the native media controls should be shown or hidden.\n         *\n         * @method Html5#controls\n         * @return {boolean}\n         *         - The value of `controls` from the media element.\n         *         - True indicates that native controls should be showing.\n         *         - False indicates that native controls should be hidden.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}\n         */\n        'controls',\n        /**\n         * Get the value of `loop` from the media element. `loop` indicates\n         * that the media should return to the start of the media and continue playing once\n         * it reaches the end.\n         *\n         * @method Html5#loop\n         * @return {boolean}\n         *         - The value of `loop` from the media element.\n         *         - True indicates that playback should seek back to start once\n         *           the end of a media is reached.\n         *         - False indicates that playback should not loop back to the start when the\n         *           end of the media is reached.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n         */\n        'loop',\n        /**\n         * Get the value of `playsinline` from the media element. `playsinline` indicates\n         * to the browser that non-fullscreen playback is preferred when fullscreen\n         * playback is the native default, such as in iOS Safari.\n         *\n         * @method Html5#playsinline\n         * @return {boolean}\n         *         - The value of `playsinline` from the media element.\n         *         - True indicates that the media should play inline.\n         *         - False indicates that the media should not play inline.\n         *\n         * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n         */\n        'playsinline'].forEach(function (prop) {\n        Html5.prototype[prop] = function () {\n            return this.el_[prop] || this.el_.hasAttribute(prop);\n        };\n    });\n\n    // Wrap native boolean attributes with setters that set both property and attribute\n    // The list is as followed:\n    // setMuted, setDefaultMuted, setAutoplay, setLoop, setPlaysinline\n    // setControls is special-cased above\n    [\n        /**\n         * Set the value of `muted` on the media element. `muted` indicates that the current\n         * audio level should be silent.\n         *\n         * @method Html5#setMuted\n         * @param {boolean} muted\n         *        - True if the audio should be set to silent\n         *        - False otherwise\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}\n         */\n        'muted',\n        /**\n         * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current\n         * audio level should be silent, but will only effect the muted level on initial playback..\n         *\n         * @method Html5.prototype.setDefaultMuted\n         * @param {boolean} defaultMuted\n         *        - True if the audio should be set to silent\n         *        - False otherwise\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}\n         */\n        'defaultMuted',\n        /**\n         * Set the value of `autoplay` on the media element. `autoplay` indicates\n         * that the media should start to play as soon as the page is ready.\n         *\n         * @method Html5#setAutoplay\n         * @param {boolean} autoplay\n         *         - True indicates that the media should start as soon as the page loads.\n         *         - False indicates that the media should not start as soon as the page loads.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}\n         */\n        'autoplay',\n        /**\n         * Set the value of `loop` on the media element. `loop` indicates\n         * that the media should return to the start of the media and continue playing once\n         * it reaches the end.\n         *\n         * @method Html5#setLoop\n         * @param {boolean} loop\n         *         - True indicates that playback should seek back to start once\n         *           the end of a media is reached.\n         *         - False indicates that playback should not loop back to the start when the\n         *           end of the media is reached.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}\n         */\n        'loop',\n        /**\n         * Set the value of `playsinline` from the media element. `playsinline` indicates\n         * to the browser that non-fullscreen playback is preferred when fullscreen\n         * playback is the native default, such as in iOS Safari.\n         *\n         * @method Html5#setPlaysinline\n         * @param {boolean} playsinline\n         *         - True indicates that the media should play inline.\n         *         - False indicates that the media should not play inline.\n         *\n         * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n         */\n        'playsinline'].forEach(function (prop) {\n        Html5.prototype['set' + toTitleCase$1(prop)] = function (v) {\n            this.el_[prop] = v;\n            if (v) {\n                this.el_.setAttribute(prop, prop);\n            } else {\n                this.el_.removeAttribute(prop);\n            }\n        };\n    });\n\n    // Wrap native properties with a getter\n    // The list is as followed\n    // paused, currentTime, buffered, volume, poster, preload, error, seeking\n    // seekable, ended, playbackRate, defaultPlaybackRate, disablePictureInPicture\n    // played, networkState, readyState, videoWidth, videoHeight, crossOrigin\n    [\n        /**\n         * Get the value of `paused` from the media element. `paused` indicates whether the media element\n         * is currently paused or not.\n         *\n         * @method Html5#paused\n         * @return {boolean}\n         *         The value of `paused` from the media element.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}\n         */\n        'paused',\n        /**\n         * Get the value of `currentTime` from the media element. `currentTime` indicates\n         * the current second that the media is at in playback.\n         *\n         * @method Html5#currentTime\n         * @return {number}\n         *         The value of `currentTime` from the media element.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}\n         */\n        'currentTime',\n        /**\n         * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`\n         * object that represents the parts of the media that are already downloaded and\n         * available for playback.\n         *\n         * @method Html5#buffered\n         * @return {TimeRange}\n         *         The value of `buffered` from the media element.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}\n         */\n        'buffered',\n        /**\n         * Get the value of `volume` from the media element. `volume` indicates\n         * the current playback volume of audio for a media. `volume` will be a value from 0\n         * (silent) to 1 (loudest and default).\n         *\n         * @method Html5#volume\n         * @return {number}\n         *         The value of `volume` from the media element. Value will be between 0-1.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n         */\n        'volume',\n        /**\n         * Get the value of `poster` from the media element. `poster` indicates\n         * that the url of an image file that can/will be shown when no media data is available.\n         *\n         * @method Html5#poster\n         * @return {string}\n         *         The value of `poster` from the media element. Value will be a url to an\n         *         image.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}\n         */\n        'poster',\n        /**\n         * Get the value of `preload` from the media element. `preload` indicates\n         * what should download before the media is interacted with. It can have the following\n         * values:\n         * - none: nothing should be downloaded\n         * - metadata: poster and the first few frames of the media may be downloaded to get\n         *   media dimensions and other metadata\n         * - auto: allow the media and metadata for the media to be downloaded before\n         *    interaction\n         *\n         * @method Html5#preload\n         * @return {string}\n         *         The value of `preload` from the media element. Will be 'none', 'metadata',\n         *         or 'auto'.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n         */\n        'preload',\n        /**\n         * Get the value of the `error` from the media element. `error` indicates any\n         * MediaError that may have occurred during playback. If error returns null there is no\n         * current error.\n         *\n         * @method Html5#error\n         * @return {MediaError|null}\n         *         The value of `error` from the media element. Will be `MediaError` if there\n         *         is a current error and null otherwise.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}\n         */\n        'error',\n        /**\n         * Get the value of `seeking` from the media element. `seeking` indicates whether the\n         * media is currently seeking to a new position or not.\n         *\n         * @method Html5#seeking\n         * @return {boolean}\n         *         - The value of `seeking` from the media element.\n         *         - True indicates that the media is currently seeking to a new position.\n         *         - False indicates that the media is not seeking to a new position at this time.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}\n         */\n        'seeking',\n        /**\n         * Get the value of `seekable` from the media element. `seekable` returns a\n         * `TimeRange` object indicating ranges of time that can currently be `seeked` to.\n         *\n         * @method Html5#seekable\n         * @return {TimeRange}\n         *         The value of `seekable` from the media element. A `TimeRange` object\n         *         indicating the current ranges of time that can be seeked to.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}\n         */\n        'seekable',\n        /**\n         * Get the value of `ended` from the media element. `ended` indicates whether\n         * the media has reached the end or not.\n         *\n         * @method Html5#ended\n         * @return {boolean}\n         *         - The value of `ended` from the media element.\n         *         - True indicates that the media has ended.\n         *         - False indicates that the media has not ended.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}\n         */\n        'ended',\n        /**\n         * Get the value of `playbackRate` from the media element. `playbackRate` indicates\n         * the rate at which the media is currently playing back. Examples:\n         *   - if playbackRate is set to 2, media will play twice as fast.\n         *   - if playbackRate is set to 0.5, media will play half as fast.\n         *\n         * @method Html5#playbackRate\n         * @return {number}\n         *         The value of `playbackRate` from the media element. A number indicating\n         *         the current playback speed of the media, where 1 is normal speed.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n         */\n        'playbackRate',\n        /**\n         * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates\n         * the rate at which the media is currently playing back. This value will not indicate the current\n         * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.\n         *\n         * Examples:\n         *   - if defaultPlaybackRate is set to 2, media will play twice as fast.\n         *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.\n         *\n         * @method Html5.prototype.defaultPlaybackRate\n         * @return {number}\n         *         The value of `defaultPlaybackRate` from the media element. A number indicating\n         *         the current playback speed of the media, where 1 is normal speed.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n         */\n        'defaultPlaybackRate',\n        /**\n         * Get the value of 'disablePictureInPicture' from the video element.\n         *\n         * @method Html5#disablePictureInPicture\n         * @return {boolean} value\n         *         - The value of `disablePictureInPicture` from the video element.\n         *         - True indicates that the video can't be played in Picture-In-Picture mode\n         *         - False indicates that the video can be played in Picture-In-Picture mode\n         *\n         * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}\n         */\n        'disablePictureInPicture',\n        /**\n         * Get the value of `played` from the media element. `played` returns a `TimeRange`\n         * object representing points in the media timeline that have been played.\n         *\n         * @method Html5#played\n         * @return {TimeRange}\n         *         The value of `played` from the media element. A `TimeRange` object indicating\n         *         the ranges of time that have been played.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}\n         */\n        'played',\n        /**\n         * Get the value of `networkState` from the media element. `networkState` indicates\n         * the current network state. It returns an enumeration from the following list:\n         * - 0: NETWORK_EMPTY\n         * - 1: NETWORK_IDLE\n         * - 2: NETWORK_LOADING\n         * - 3: NETWORK_NO_SOURCE\n         *\n         * @method Html5#networkState\n         * @return {number}\n         *         The value of `networkState` from the media element. This will be a number\n         *         from the list in the description.\n         *\n         * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}\n         */\n        'networkState',\n        /**\n         * Get the value of `readyState` from the media element. `readyState` indicates\n         * the current state of the media element. It returns an enumeration from the\n         * following list:\n         * - 0: HAVE_NOTHING\n         * - 1: HAVE_METADATA\n         * - 2: HAVE_CURRENT_DATA\n         * - 3: HAVE_FUTURE_DATA\n         * - 4: HAVE_ENOUGH_DATA\n         *\n         * @method Html5#readyState\n         * @return {number}\n         *         The value of `readyState` from the media element. This will be a number\n         *         from the list in the description.\n         *\n         * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}\n         */\n        'readyState',\n        /**\n         * Get the value of `videoWidth` from the video element. `videoWidth` indicates\n         * the current width of the video in css pixels.\n         *\n         * @method Html5#videoWidth\n         * @return {number}\n         *         The value of `videoWidth` from the video element. This will be a number\n         *         in css pixels.\n         *\n         * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n         */\n        'videoWidth',\n        /**\n         * Get the value of `videoHeight` from the video element. `videoHeight` indicates\n         * the current height of the video in css pixels.\n         *\n         * @method Html5#videoHeight\n         * @return {number}\n         *         The value of `videoHeight` from the video element. This will be a number\n         *         in css pixels.\n         *\n         * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}\n         */\n        'videoHeight',\n        /**\n         * Get the value of `crossOrigin` from the media element. `crossOrigin` indicates\n         * to the browser that should sent the cookies along with the requests for the\n         * different assets/playlists\n         *\n         * @method Html5#crossOrigin\n         * @return {string}\n         *         - anonymous indicates that the media should not sent cookies.\n         *         - use-credentials indicates that the media should sent cookies along the requests.\n         *\n         * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}\n         */\n        'crossOrigin'].forEach(function (prop) {\n        Html5.prototype[prop] = function () {\n            return this.el_[prop];\n        };\n    });\n\n    // Wrap native properties with a setter in this format:\n    // set + toTitleCase(name)\n    // The list is as follows:\n    // setVolume, setSrc, setPoster, setPreload, setPlaybackRate, setDefaultPlaybackRate,\n    // setDisablePictureInPicture, setCrossOrigin\n    [\n        /**\n         * Set the value of `volume` on the media element. `volume` indicates the current\n         * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and\n         * so on.\n         *\n         * @method Html5#setVolume\n         * @param {number} percentAsDecimal\n         *        The volume percent as a decimal. Valid range is from 0-1.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}\n         */\n        'volume',\n        /**\n         * Set the value of `src` on the media element. `src` indicates the current\n         * {@link Tech~SourceObject} for the media.\n         *\n         * @method Html5#setSrc\n         * @param {Tech~SourceObject} src\n         *        The source object to set as the current source.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}\n         */\n        'src',\n        /**\n         * Set the value of `poster` on the media element. `poster` is the url to\n         * an image file that can/will be shown when no media data is available.\n         *\n         * @method Html5#setPoster\n         * @param {string} poster\n         *        The url to an image that should be used as the `poster` for the media\n         *        element.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}\n         */\n        'poster',\n        /**\n         * Set the value of `preload` on the media element. `preload` indicates\n         * what should download before the media is interacted with. It can have the following\n         * values:\n         * - none: nothing should be downloaded\n         * - metadata: poster and the first few frames of the media may be downloaded to get\n         *   media dimensions and other metadata\n         * - auto: allow the media and metadata for the media to be downloaded before\n         *    interaction\n         *\n         * @method Html5#setPreload\n         * @param {string} preload\n         *         The value of `preload` to set on the media element. Must be 'none', 'metadata',\n         *         or 'auto'.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}\n         */\n        'preload',\n        /**\n         * Set the value of `playbackRate` on the media element. `playbackRate` indicates\n         * the rate at which the media should play back. Examples:\n         *   - if playbackRate is set to 2, media will play twice as fast.\n         *   - if playbackRate is set to 0.5, media will play half as fast.\n         *\n         * @method Html5#setPlaybackRate\n         * @return {number}\n         *         The value of `playbackRate` from the media element. A number indicating\n         *         the current playback speed of the media, where 1 is normal speed.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}\n         */\n        'playbackRate',\n        /**\n         * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates\n         * the rate at which the media should play back upon initial startup. Changing this value\n         * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.\n         *\n         * Example Values:\n         *   - if playbackRate is set to 2, media will play twice as fast.\n         *   - if playbackRate is set to 0.5, media will play half as fast.\n         *\n         * @method Html5.prototype.setDefaultPlaybackRate\n         * @return {number}\n         *         The value of `defaultPlaybackRate` from the media element. A number indicating\n         *         the current playback speed of the media, where 1 is normal speed.\n         *\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}\n         */\n        'defaultPlaybackRate',\n        /**\n         * Prevents the browser from suggesting a Picture-in-Picture context menu\n         * or to request Picture-in-Picture automatically in some cases.\n         *\n         * @method Html5#setDisablePictureInPicture\n         * @param {boolean} value\n         *         The true value will disable Picture-in-Picture mode.\n         *\n         * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}\n         */\n        'disablePictureInPicture',\n        /**\n         * Set the value of `crossOrigin` from the media element. `crossOrigin` indicates\n         * to the browser that should sent the cookies along with the requests for the\n         * different assets/playlists\n         *\n         * @method Html5#setCrossOrigin\n         * @param {string} crossOrigin\n         *         - anonymous indicates that the media should not sent cookies.\n         *         - use-credentials indicates that the media should sent cookies along the requests.\n         *\n         * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}\n         */\n        'crossOrigin'].forEach(function (prop) {\n        Html5.prototype['set' + toTitleCase$1(prop)] = function (v) {\n            this.el_[prop] = v;\n        };\n    });\n\n    // wrap native functions with a function\n    // The list is as follows:\n    // pause, load, play\n    [\n        /**\n         * A wrapper around the media elements `pause` function. This will call the `HTML5`\n         * media elements `pause` function.\n         *\n         * @method Html5#pause\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}\n         */\n        'pause',\n        /**\n         * A wrapper around the media elements `load` function. This will call the `HTML5`s\n         * media element `load` function.\n         *\n         * @method Html5#load\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}\n         */\n        'load',\n        /**\n         * A wrapper around the media elements `play` function. This will call the `HTML5`s\n         * media element `play` function.\n         *\n         * @method Html5#play\n         * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}\n         */\n        'play'].forEach(function (prop) {\n        Html5.prototype[prop] = function () {\n            return this.el_[prop]();\n        };\n    });\n    Tech.withSourceHandlers(Html5);\n\n    /**\n     * Native source handler for Html5, simply passes the source to the media element.\n     *\n     * @property {Tech~SourceObject} source\n     *        The source object\n     *\n     * @property {Html5} tech\n     *        The instance of the HTML5 tech.\n     */\n    Html5.nativeSourceHandler = {};\n\n    /**\n     * Check if the media element can play the given mime type.\n     *\n     * @param {string} type\n     *        The mimetype to check\n     *\n     * @return {string}\n     *         'probably', 'maybe', or '' (empty string)\n     */\n    Html5.nativeSourceHandler.canPlayType = function (type) {\n        // IE without MediaPlayer throws an error (#519)\n        try {\n            return Html5.TEST_VID.canPlayType(type);\n        } catch (e) {\n            return '';\n        }\n    };\n\n    /**\n     * Check if the media element can handle a source natively.\n     *\n     * @param {Tech~SourceObject} source\n     *         The source object\n     *\n     * @param {Object} [options]\n     *         Options to be passed to the tech.\n     *\n     * @return {string}\n     *         'probably', 'maybe', or '' (empty string).\n     */\n    Html5.nativeSourceHandler.canHandleSource = function (source, options) {\n        // If a type was provided we should rely on that\n        if (source.type) {\n            return Html5.nativeSourceHandler.canPlayType(source.type);\n\n            // If no type, fall back to checking 'video/[EXTENSION]'\n        } else if (source.src) {\n            const ext = getFileExtension(source.src);\n            return Html5.nativeSourceHandler.canPlayType(`video/${ext}`);\n        }\n        return '';\n    };\n\n    /**\n     * Pass the source to the native media element.\n     *\n     * @param {Tech~SourceObject} source\n     *        The source object\n     *\n     * @param {Html5} tech\n     *        The instance of the Html5 tech\n     *\n     * @param {Object} [options]\n     *        The options to pass to the source\n     */\n    Html5.nativeSourceHandler.handleSource = function (source, tech, options) {\n        tech.setSrc(source.src);\n    };\n\n    /**\n     * A noop for the native dispose function, as cleanup is not needed.\n     */\n    Html5.nativeSourceHandler.dispose = function () {};\n\n    // Register the native source handler\n    Html5.registerSourceHandler(Html5.nativeSourceHandler);\n    Tech.registerTech('Html5', Html5);\n\n    /**\n     * @file player.js\n     */\n\n        // The following tech events are simply re-triggered\n        // on the player when they happen\n    const TECH_EVENTS_RETRIGGER = [\n            /**\n             * Fired while the user agent is downloading media data.\n             *\n             * @event Player#progress\n             * @type {Event}\n             */\n            /**\n             * Retrigger the `progress` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechProgress_\n             * @fires Player#progress\n             * @listens Tech#progress\n             */\n            'progress',\n            /**\n             * Fires when the loading of an audio/video is aborted.\n             *\n             * @event Player#abort\n             * @type {Event}\n             */\n            /**\n             * Retrigger the `abort` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechAbort_\n             * @fires Player#abort\n             * @listens Tech#abort\n             */\n            'abort',\n            /**\n             * Fires when the browser is intentionally not getting media data.\n             *\n             * @event Player#suspend\n             * @type {Event}\n             */\n            /**\n             * Retrigger the `suspend` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechSuspend_\n             * @fires Player#suspend\n             * @listens Tech#suspend\n             */\n            'suspend',\n            /**\n             * Fires when the current playlist is empty.\n             *\n             * @event Player#emptied\n             * @type {Event}\n             */\n            /**\n             * Retrigger the `emptied` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechEmptied_\n             * @fires Player#emptied\n             * @listens Tech#emptied\n             */\n            'emptied',\n            /**\n             * Fires when the browser is trying to get media data, but data is not available.\n             *\n             * @event Player#stalled\n             * @type {Event}\n             */\n            /**\n             * Retrigger the `stalled` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechStalled_\n             * @fires Player#stalled\n             * @listens Tech#stalled\n             */\n            'stalled',\n            /**\n             * Fires when the browser has loaded meta data for the audio/video.\n             *\n             * @event Player#loadedmetadata\n             * @type {Event}\n             */\n            /**\n             * Retrigger the `loadedmetadata` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechLoadedmetadata_\n             * @fires Player#loadedmetadata\n             * @listens Tech#loadedmetadata\n             */\n            'loadedmetadata',\n            /**\n             * Fires when the browser has loaded the current frame of the audio/video.\n             *\n             * @event Player#loadeddata\n             * @type {event}\n             */\n            /**\n             * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechLoaddeddata_\n             * @fires Player#loadeddata\n             * @listens Tech#loadeddata\n             */\n            'loadeddata',\n            /**\n             * Fires when the current playback position has changed.\n             *\n             * @event Player#timeupdate\n             * @type {event}\n             */\n            /**\n             * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechTimeUpdate_\n             * @fires Player#timeupdate\n             * @listens Tech#timeupdate\n             */\n            'timeupdate',\n            /**\n             * Fires when the video's intrinsic dimensions change\n             *\n             * @event Player#resize\n             * @type {event}\n             */\n            /**\n             * Retrigger the `resize` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechResize_\n             * @fires Player#resize\n             * @listens Tech#resize\n             */\n            'resize',\n            /**\n             * Fires when the volume has been changed\n             *\n             * @event Player#volumechange\n             * @type {event}\n             */\n            /**\n             * Retrigger the `volumechange` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechVolumechange_\n             * @fires Player#volumechange\n             * @listens Tech#volumechange\n             */\n            'volumechange',\n            /**\n             * Fires when the text track has been changed\n             *\n             * @event Player#texttrackchange\n             * @type {event}\n             */\n            /**\n             * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.\n             *\n             * @private\n             * @method Player#handleTechTexttrackchange_\n             * @fires Player#texttrackchange\n             * @listens Tech#texttrackchange\n             */\n            'texttrackchange'];\n\n    // events to queue when playback rate is zero\n    // this is a hash for the sole purpose of mapping non-camel-cased event names\n    // to camel-cased function names\n    const TECH_EVENTS_QUEUE = {\n        canplay: 'CanPlay',\n        canplaythrough: 'CanPlayThrough',\n        playing: 'Playing',\n        seeked: 'Seeked'\n    };\n    const BREAKPOINT_ORDER = ['tiny', 'xsmall', 'small', 'medium', 'large', 'xlarge', 'huge'];\n    const BREAKPOINT_CLASSES = {};\n\n    // grep: vjs-layout-tiny\n    // grep: vjs-layout-x-small\n    // grep: vjs-layout-small\n    // grep: vjs-layout-medium\n    // grep: vjs-layout-large\n    // grep: vjs-layout-x-large\n    // grep: vjs-layout-huge\n    BREAKPOINT_ORDER.forEach(k => {\n        const v = k.charAt(0) === 'x' ? `x-${k.substring(1)}` : k;\n        BREAKPOINT_CLASSES[k] = `vjs-layout-${v}`;\n    });\n    const DEFAULT_BREAKPOINTS = {\n        tiny: 210,\n        xsmall: 320,\n        small: 425,\n        medium: 768,\n        large: 1440,\n        xlarge: 2560,\n        huge: Infinity\n    };\n\n    /**\n     * An instance of the `Player` class is created when any of the Video.js setup methods\n     * are used to initialize a video.\n     *\n     * After an instance has been created it can be accessed globally in three ways:\n     * 1. By calling `videojs.getPlayer('example_video_1');`\n     * 2. By calling `videojs('example_video_1');` (not recomended)\n     * 2. By using it directly via  `videojs.players.example_video_1;`\n     *\n     * @extends Component\n     * @global\n     */\n    class Player extends Component$1 {\n        /**\n         * Create an instance of this class.\n         *\n         * @param {Element} tag\n         *        The original video DOM element used for configuring options.\n         *\n         * @param {Object} [options]\n         *        Object of option names and values.\n         *\n         * @param {Function} [ready]\n         *        Ready callback function.\n         */\n        constructor(tag, options, ready) {\n            // Make sure tag ID exists\n            tag.id = tag.id || options.id || `vjs_video_${newGUID()}`;\n\n            // Set Options\n            // The options argument overrides options set in the video tag\n            // which overrides globally set options.\n            // This latter part coincides with the load order\n            // (tag must exist before Player)\n            options = Object.assign(Player.getTagSettings(tag), options);\n\n            // Delay the initialization of children because we need to set up\n            // player properties first, and can't use `this` before `super()`\n            options.initChildren = false;\n\n            // Same with creating the element\n            options.createEl = false;\n\n            // don't auto mixin the evented mixin\n            options.evented = false;\n\n            // we don't want the player to report touch activity on itself\n            // see enableTouchActivity in Component\n            options.reportTouchActivity = false;\n\n            // If language is not set, get the closest lang attribute\n            if (!options.language) {\n                const closest = tag.closest('[lang]');\n                if (closest) {\n                    options.language = closest.getAttribute('lang');\n                }\n            }\n\n            // Run base component initializing with new options\n            super(null, options, ready);\n\n            // Create bound methods for document listeners.\n            this.boundDocumentFullscreenChange_ = e => this.documentFullscreenChange_(e);\n            this.boundFullWindowOnEscKey_ = e => this.fullWindowOnEscKey(e);\n            this.boundUpdateStyleEl_ = e => this.updateStyleEl_(e);\n            this.boundApplyInitTime_ = e => this.applyInitTime_(e);\n            this.boundUpdateCurrentBreakpoint_ = e => this.updateCurrentBreakpoint_(e);\n            this.boundHandleTechClick_ = e => this.handleTechClick_(e);\n            this.boundHandleTechDoubleClick_ = e => this.handleTechDoubleClick_(e);\n            this.boundHandleTechTouchStart_ = e => this.handleTechTouchStart_(e);\n            this.boundHandleTechTouchMove_ = e => this.handleTechTouchMove_(e);\n            this.boundHandleTechTouchEnd_ = e => this.handleTechTouchEnd_(e);\n            this.boundHandleTechTap_ = e => this.handleTechTap_(e);\n\n            // default isFullscreen_ to false\n            this.isFullscreen_ = false;\n\n            // create logger\n            this.log = createLogger(this.id_);\n\n            // Hold our own reference to fullscreen api so it can be mocked in tests\n            this.fsApi_ = FullscreenApi;\n\n            // Tracks when a tech changes the poster\n            this.isPosterFromTech_ = false;\n\n            // Holds callback info that gets queued when playback rate is zero\n            // and a seek is happening\n            this.queuedCallbacks_ = [];\n\n            // Turn off API access because we're loading a new tech that might load asynchronously\n            this.isReady_ = false;\n\n            // Init state hasStarted_\n            this.hasStarted_ = false;\n\n            // Init state userActive_\n            this.userActive_ = false;\n\n            // Init debugEnabled_\n            this.debugEnabled_ = false;\n\n            // Init state audioOnlyMode_\n            this.audioOnlyMode_ = false;\n\n            // Init state audioPosterMode_\n            this.audioPosterMode_ = false;\n\n            // Init state audioOnlyCache_\n            this.audioOnlyCache_ = {\n                playerHeight: null,\n                hiddenChildren: []\n            };\n\n            // if the global option object was accidentally blown away by\n            // someone, bail early with an informative error\n            if (!this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) {\n                throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');\n            }\n\n            // Store the original tag used to set options\n            this.tag = tag;\n\n            // Store the tag attributes used to restore html5 element\n            this.tagAttributes = tag && getAttributes(tag);\n\n            // Update current language\n            this.language(this.options_.language);\n\n            // Update Supported Languages\n            if (options.languages) {\n                // Normalise player option languages to lowercase\n                const languagesToLower = {};\n                Object.getOwnPropertyNames(options.languages).forEach(function (name) {\n                    languagesToLower[name.toLowerCase()] = options.languages[name];\n                });\n                this.languages_ = languagesToLower;\n            } else {\n                this.languages_ = Player.prototype.options_.languages;\n            }\n            this.resetCache_();\n\n            // Set poster\n            this.poster_ = options.poster || '';\n\n            // Set controls\n            this.controls_ = !!options.controls;\n\n            // Original tag settings stored in options\n            // now remove immediately so native controls don't flash.\n            // May be turned back on by HTML5 tech if nativeControlsForTouch is true\n            tag.controls = false;\n            tag.removeAttribute('controls');\n            this.changingSrc_ = false;\n            this.playCallbacks_ = [];\n            this.playTerminatedQueue_ = [];\n\n            // the attribute overrides the option\n            if (tag.hasAttribute('autoplay')) {\n                this.autoplay(true);\n            } else {\n                // otherwise use the setter to validate and\n                // set the correct value.\n                this.autoplay(this.options_.autoplay);\n            }\n\n            // check plugins\n            if (options.plugins) {\n                Object.keys(options.plugins).forEach(name => {\n                    if (typeof this[name] !== 'function') {\n                        throw new Error(`plugin \"${name}\" does not exist`);\n                    }\n                });\n            }\n\n            /*\n       * Store the internal state of scrubbing\n       *\n       * @private\n       * @return {Boolean} True if the user is scrubbing\n       */\n            this.scrubbing_ = false;\n            this.el_ = this.createEl();\n\n            // Make this an evented object and use `el_` as its event bus.\n            evented(this, {\n                eventBusKey: 'el_'\n            });\n\n            // listen to document and player fullscreenchange handlers so we receive those events\n            // before a user can receive them so we can update isFullscreen appropriately.\n            // make sure that we listen to fullscreenchange events before everything else to make sure that\n            // our isFullscreen method is updated properly for internal components as well as external.\n            if (this.fsApi_.requestFullscreen) {\n                on(document, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);\n                this.on(this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);\n            }\n            if (this.fluid_) {\n                this.on(['playerreset', 'resize'], this.boundUpdateStyleEl_);\n            }\n            // We also want to pass the original player options to each component and plugin\n            // as well so they don't need to reach back into the player for options later.\n            // We also need to do another copy of this.options_ so we don't end up with\n            // an infinite loop.\n            const playerOptionsCopy = merge$2(this.options_);\n\n            // Load plugins\n            if (options.plugins) {\n                Object.keys(options.plugins).forEach(name => {\n                    this[name](options.plugins[name]);\n                });\n            }\n\n            // Enable debug mode to fire debugon event for all plugins.\n            if (options.debug) {\n                this.debug(true);\n            }\n            this.options_.playerOptions = playerOptionsCopy;\n            this.middleware_ = [];\n            this.playbackRates(options.playbackRates);\n            this.initChildren();\n\n            // Set isAudio based on whether or not an audio tag was used\n            this.isAudio(tag.nodeName.toLowerCase() === 'audio');\n\n            // Update controls className. Can't do this when the controls are initially\n            // set because the element doesn't exist yet.\n            if (this.controls()) {\n                this.addClass('vjs-controls-enabled');\n            } else {\n                this.addClass('vjs-controls-disabled');\n            }\n\n            // Set ARIA label and region role depending on player type\n            this.el_.setAttribute('role', 'region');\n            if (this.isAudio()) {\n                this.el_.setAttribute('aria-label', this.localize('Audio Player'));\n            } else {\n                this.el_.setAttribute('aria-label', this.localize('Video Player'));\n            }\n            if (this.isAudio()) {\n                this.addClass('vjs-audio');\n            }\n\n            // TODO: Make this smarter. Toggle user state between touching/mousing\n            // using events, since devices can have both touch and mouse events.\n            // TODO: Make this check be performed again when the window switches between monitors\n            // (See https://github.com/videojs/video.js/issues/5683)\n            if (TOUCH_ENABLED) {\n                this.addClass('vjs-touch-enabled');\n            }\n\n            // iOS Safari has broken hover handling\n            if (!IS_IOS) {\n                this.addClass('vjs-workinghover');\n            }\n\n            // Make player easily findable by ID\n            Player.players[this.id_] = this;\n\n            // Add a major version class to aid css in plugins\n            const majorVersion = version$5.split('.')[0];\n            this.addClass(`vjs-v${majorVersion}`);\n\n            // When the player is first initialized, trigger activity so components\n            // like the control bar show themselves if needed\n            this.userActive(true);\n            this.reportUserActivity();\n            this.one('play', e => this.listenForUserActivity_(e));\n            this.on('keydown', e => this.handleKeyDown(e));\n            this.on('languagechange', e => this.handleLanguagechange(e));\n            this.breakpoints(this.options_.breakpoints);\n            this.responsive(this.options_.responsive);\n\n            // Calling both the audio mode methods after the player is fully\n            // setup to be able to listen to the events triggered by them\n            this.on('ready', () => {\n                // Calling the audioPosterMode method first so that\n                // the audioOnlyMode can take precedence when both options are set to true\n                this.audioPosterMode(this.options_.audioPosterMode);\n                this.audioOnlyMode(this.options_.audioOnlyMode);\n            });\n        }\n\n        /**\n         * Destroys the video player and does any necessary cleanup.\n         *\n         * This is especially helpful if you are dynamically adding and removing videos\n         * to/from the DOM.\n         *\n         * @fires Player#dispose\n         */\n        dispose() {\n            /**\n             * Called when the player is being disposed of.\n             *\n             * @event Player#dispose\n             * @type {Event}\n             */\n            this.trigger('dispose');\n            // prevent dispose from being called twice\n            this.off('dispose');\n\n            // Make sure all player-specific document listeners are unbound. This is\n            off(document, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);\n            off(document, 'keydown', this.boundFullWindowOnEscKey_);\n            if (this.styleEl_ && this.styleEl_.parentNode) {\n                this.styleEl_.parentNode.removeChild(this.styleEl_);\n                this.styleEl_ = null;\n            }\n\n            // Kill reference to this player\n            Player.players[this.id_] = null;\n            if (this.tag && this.tag.player) {\n                this.tag.player = null;\n            }\n            if (this.el_ && this.el_.player) {\n                this.el_.player = null;\n            }\n            if (this.tech_) {\n                this.tech_.dispose();\n                this.isPosterFromTech_ = false;\n                this.poster_ = '';\n            }\n            if (this.playerElIngest_) {\n                this.playerElIngest_ = null;\n            }\n            if (this.tag) {\n                this.tag = null;\n            }\n            clearCacheForPlayer(this);\n\n            // remove all event handlers for track lists\n            // all tracks and track listeners are removed on\n            // tech dispose\n            ALL.names.forEach(name => {\n                const props = ALL[name];\n                const list = this[props.getterName]();\n\n                // if it is not a native list\n                // we have to manually remove event listeners\n                if (list && list.off) {\n                    list.off();\n                }\n            });\n\n            // the actual .el_ is removed here, or replaced if\n            super.dispose({\n                restoreEl: this.options_.restoreEl\n            });\n        }\n\n        /**\n         * Create the `Player`'s DOM element.\n         *\n         * @return {Element}\n         *         The DOM element that gets created.\n         */\n        createEl() {\n            let tag = this.tag;\n            let el;\n            let playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute('data-vjs-player');\n            const divEmbed = this.tag.tagName.toLowerCase() === 'video-js';\n            if (playerElIngest) {\n                el = this.el_ = tag.parentNode;\n            } else if (!divEmbed) {\n                el = this.el_ = super.createEl('div');\n            }\n\n            // Copy over all the attributes from the tag, including ID and class\n            // ID will now reference player box, not the video tag\n            const attrs = getAttributes(tag);\n            if (divEmbed) {\n                el = this.el_ = tag;\n                tag = this.tag = document.createElement('video');\n                while (el.children.length) {\n                    tag.appendChild(el.firstChild);\n                }\n                if (!hasClass(el, 'video-js')) {\n                    addClass(el, 'video-js');\n                }\n                el.appendChild(tag);\n                playerElIngest = this.playerElIngest_ = el;\n                // move properties over from our custom `video-js` element\n                // to our new `video` element. This will move things like\n                // `src` or `controls` that were set via js before the player\n                // was initialized.\n                Object.keys(el).forEach(k => {\n                    try {\n                        tag[k] = el[k];\n                    } catch (e) {\n                        // we got a a property like outerHTML which we can't actually copy, ignore it\n                    }\n                });\n            }\n\n            // set tabindex to -1 to remove the video element from the focus order\n            tag.setAttribute('tabindex', '-1');\n            attrs.tabindex = '-1';\n\n            // Workaround for #4583 on Chrome (on Windows) with JAWS.\n            // See https://github.com/FreedomScientific/VFO-standards-support/issues/78\n            // Note that we can't detect if JAWS is being used, but this ARIA attribute\n            // doesn't change behavior of Chrome if JAWS is not being used\n            if (IS_CHROME && IS_WINDOWS) {\n                tag.setAttribute('role', 'application');\n                attrs.role = 'application';\n            }\n\n            // Remove width/height attrs from tag so CSS can make it 100% width/height\n            tag.removeAttribute('width');\n            tag.removeAttribute('height');\n            if ('width' in attrs) {\n                delete attrs.width;\n            }\n            if ('height' in attrs) {\n                delete attrs.height;\n            }\n            Object.getOwnPropertyNames(attrs).forEach(function (attr) {\n                // don't copy over the class attribute to the player element when we're in a div embed\n                // the class is already set up properly in the divEmbed case\n                // and we want to make sure that the `video-js` class doesn't get lost\n                if (!(divEmbed && attr === 'class')) {\n                    el.setAttribute(attr, attrs[attr]);\n                }\n                if (divEmbed) {\n                    tag.setAttribute(attr, attrs[attr]);\n                }\n            });\n\n            // Update tag id/class for use as HTML5 playback tech\n            // Might think we should do this after embedding in container so .vjs-tech class\n            // doesn't flash 100% width/height, but class only applies with .video-js parent\n            tag.playerId = tag.id;\n            tag.id += '_html5_api';\n            tag.className = 'vjs-tech';\n\n            // Make player findable on elements\n            tag.player = el.player = this;\n            // Default state of video is paused\n            this.addClass('vjs-paused');\n\n            // Add a style element in the player that we'll use to set the width/height\n            // of the player in a way that's still overridable by CSS, just like the\n            // video element\n            if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true) {\n                this.styleEl_ = createStyleElement('vjs-styles-dimensions');\n                const defaultsStyleEl = $('.vjs-styles-defaults');\n                const head = $('head');\n                head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);\n            }\n            this.fill_ = false;\n            this.fluid_ = false;\n\n            // Pass in the width/height/aspectRatio options which will update the style el\n            this.width(this.options_.width);\n            this.height(this.options_.height);\n            this.fill(this.options_.fill);\n            this.fluid(this.options_.fluid);\n            this.aspectRatio(this.options_.aspectRatio);\n            // support both crossOrigin and crossorigin to reduce confusion and issues around the name\n            this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);\n\n            // Hide any links within the video/audio tag,\n            // because IE doesn't hide them completely from screen readers.\n            const links = tag.getElementsByTagName('a');\n            for (let i = 0; i < links.length; i++) {\n                const linkEl = links.item(i);\n                addClass(linkEl, 'vjs-hidden');\n                linkEl.setAttribute('hidden', 'hidden');\n            }\n\n            // insertElFirst seems to cause the networkState to flicker from 3 to 2, so\n            // keep track of the original for later so we can know if the source originally failed\n            tag.initNetworkState_ = tag.networkState;\n\n            // Wrap video tag in div (el/box) container\n            if (tag.parentNode && !playerElIngest) {\n                tag.parentNode.insertBefore(el, tag);\n            }\n\n            // insert the tag as the first child of the player element\n            // then manually add it to the children array so that this.addChild\n            // will work properly for other components\n            //\n            // Breaks iPhone, fixed in HTML5 setup.\n            prependTo(tag, el);\n            this.children_.unshift(tag);\n\n            // Set lang attr on player to ensure CSS :lang() in consistent with player\n            // if it's been set to something different to the doc\n            this.el_.setAttribute('lang', this.language_);\n            this.el_.setAttribute('translate', 'no');\n            this.el_ = el;\n            return el;\n        }\n\n        /**\n         * Get or set the `Player`'s crossOrigin option. For the HTML5 player, this\n         * sets the `crossOrigin` property on the `<video>` tag to control the CORS\n         * behavior.\n         *\n         * @see [Video Element Attributes]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-crossorigin}\n         *\n         * @param {string|null} [value]\n         *        The value to set the `Player`'s crossOrigin to. If an argument is\n         *        given, must be one of `'anonymous'` or `'use-credentials'`, or 'null'.\n         *\n         * @return {string|null|undefined}\n         *         - The current crossOrigin value of the `Player` when getting.\n         *         - undefined when setting\n         */\n        crossOrigin(value) {\n            // `null` can be set to unset a value\n            if (typeof value === 'undefined') {\n                return this.techGet_('crossOrigin');\n            }\n            if (value !== null && value !== 'anonymous' && value !== 'use-credentials') {\n                log$1.warn(`crossOrigin must be null,  \"anonymous\" or \"use-credentials\", given \"${value}\"`);\n                return;\n            }\n            this.techCall_('setCrossOrigin', value);\n            if (this.posterImage) {\n                this.posterImage.crossOrigin(value);\n            }\n            return;\n        }\n\n        /**\n         * A getter/setter for the `Player`'s width. Returns the player's configured value.\n         * To get the current width use `currentWidth()`.\n         *\n         * @param {number} [value]\n         *        The value to set the `Player`'s width to.\n         *\n         * @return {number}\n         *         The current width of the `Player` when getting.\n         */\n        width(value) {\n            return this.dimension('width', value);\n        }\n\n        /**\n         * A getter/setter for the `Player`'s height. Returns the player's configured value.\n         * To get the current height use `currentheight()`.\n         *\n         * @param {number} [value]\n         *        The value to set the `Player`'s height to.\n         *\n         * @return {number}\n         *         The current height of the `Player` when getting.\n         */\n        height(value) {\n            return this.dimension('height', value);\n        }\n\n        /**\n         * A getter/setter for the `Player`'s width & height.\n         *\n         * @param {string} dimension\n         *        This string can be:\n         *        - 'width'\n         *        - 'height'\n         *\n         * @param {number} [value]\n         *        Value for dimension specified in the first argument.\n         *\n         * @return {number}\n         *         The dimension arguments value when getting (width/height).\n         */\n        dimension(dimension, value) {\n            const privDimension = dimension + '_';\n            if (value === undefined) {\n                return this[privDimension] || 0;\n            }\n            if (value === '' || value === 'auto') {\n                // If an empty string is given, reset the dimension to be automatic\n                this[privDimension] = undefined;\n                this.updateStyleEl_();\n                return;\n            }\n            const parsedVal = parseFloat(value);\n            if (isNaN(parsedVal)) {\n                log$1.error(`Improper value \"${value}\" supplied for for ${dimension}`);\n                return;\n            }\n            this[privDimension] = parsedVal;\n            this.updateStyleEl_();\n        }\n\n        /**\n         * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.\n         *\n         * Turning this on will turn off fill mode.\n         *\n         * @param {boolean} [bool]\n         *        - A value of true adds the class.\n         *        - A value of false removes the class.\n         *        - No value will be a getter.\n         *\n         * @return {boolean|undefined}\n         *         - The value of fluid when getting.\n         *         - `undefined` when setting.\n         */\n        fluid(bool) {\n            if (bool === undefined) {\n                return !!this.fluid_;\n            }\n            this.fluid_ = !!bool;\n            if (isEvented(this)) {\n                this.off(['playerreset', 'resize'], this.boundUpdateStyleEl_);\n            }\n            if (bool) {\n                this.addClass('vjs-fluid');\n                this.fill(false);\n                addEventedCallback(this, () => {\n                    this.on(['playerreset', 'resize'], this.boundUpdateStyleEl_);\n                });\n            } else {\n                this.removeClass('vjs-fluid');\n            }\n            this.updateStyleEl_();\n        }\n\n        /**\n         * A getter/setter/toggler for the vjs-fill `className` on the `Player`.\n         *\n         * Turning this on will turn off fluid mode.\n         *\n         * @param {boolean} [bool]\n         *        - A value of true adds the class.\n         *        - A value of false removes the class.\n         *        - No value will be a getter.\n         *\n         * @return {boolean|undefined}\n         *         - The value of fluid when getting.\n         *         - `undefined` when setting.\n         */\n        fill(bool) {\n            if (bool === undefined) {\n                return !!this.fill_;\n            }\n            this.fill_ = !!bool;\n            if (bool) {\n                this.addClass('vjs-fill');\n                this.fluid(false);\n            } else {\n                this.removeClass('vjs-fill');\n            }\n        }\n\n        /**\n         * Get/Set the aspect ratio\n         *\n         * @param {string} [ratio]\n         *        Aspect ratio for player\n         *\n         * @return {string|undefined}\n         *         returns the current aspect ratio when getting\n         */\n\n        /**\n         * A getter/setter for the `Player`'s aspect ratio.\n         *\n         * @param {string} [ratio]\n         *        The value to set the `Player`'s aspect ratio to.\n         *\n         * @return {string|undefined}\n         *         - The current aspect ratio of the `Player` when getting.\n         *         - undefined when setting\n         */\n        aspectRatio(ratio) {\n            if (ratio === undefined) {\n                return this.aspectRatio_;\n            }\n\n            // Check for width:height format\n            if (!/^\\d+\\:\\d+$/.test(ratio)) {\n                throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');\n            }\n            this.aspectRatio_ = ratio;\n\n            // We're assuming if you set an aspect ratio you want fluid mode,\n            // because in fixed mode you could calculate width and height yourself.\n            this.fluid(true);\n            this.updateStyleEl_();\n        }\n\n        /**\n         * Update styles of the `Player` element (height, width and aspect ratio).\n         *\n         * @private\n         * @listens Tech#loadedmetadata\n         */\n        updateStyleEl_() {\n            if (window.VIDEOJS_NO_DYNAMIC_STYLE === true) {\n                const width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;\n                const height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;\n                const techEl = this.tech_ && this.tech_.el();\n                if (techEl) {\n                    if (width >= 0) {\n                        techEl.width = width;\n                    }\n                    if (height >= 0) {\n                        techEl.height = height;\n                    }\n                }\n                return;\n            }\n            let width;\n            let height;\n            let aspectRatio;\n            let idClass;\n\n            // The aspect ratio is either used directly or to calculate width and height.\n            if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {\n                // Use any aspectRatio that's been specifically set\n                aspectRatio = this.aspectRatio_;\n            } else if (this.videoWidth() > 0) {\n                // Otherwise try to get the aspect ratio from the video metadata\n                aspectRatio = this.videoWidth() + ':' + this.videoHeight();\n            } else {\n                // Or use a default. The video element's is 2:1, but 16:9 is more common.\n                aspectRatio = '16:9';\n            }\n\n            // Get the ratio as a decimal we can use to calculate dimensions\n            const ratioParts = aspectRatio.split(':');\n            const ratioMultiplier = ratioParts[1] / ratioParts[0];\n            if (this.width_ !== undefined) {\n                // Use any width that's been specifically set\n                width = this.width_;\n            } else if (this.height_ !== undefined) {\n                // Or calculate the width from the aspect ratio if a height has been set\n                width = this.height_ / ratioMultiplier;\n            } else {\n                // Or use the video's metadata, or use the video el's default of 300\n                width = this.videoWidth() || 300;\n            }\n            if (this.height_ !== undefined) {\n                // Use any height that's been specifically set\n                height = this.height_;\n            } else {\n                // Otherwise calculate the height from the ratio and the width\n                height = width * ratioMultiplier;\n            }\n\n            // Ensure the CSS class is valid by starting with an alpha character\n            if (/^[^a-zA-Z]/.test(this.id())) {\n                idClass = 'dimensions-' + this.id();\n            } else {\n                idClass = this.id() + '-dimensions';\n            }\n\n            // Ensure the right class is still on the player for the style element\n            this.addClass(idClass);\n            setTextContent(this.styleEl_, `\n      .${idClass} {\n        width: ${width}px;\n        height: ${height}px;\n      }\n\n      .${idClass}.vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: ${ratioMultiplier * 100}%;\n      }\n    `);\n        }\n\n        /**\n         * Load/Create an instance of playback {@link Tech} including element\n         * and API methods. Then append the `Tech` element in `Player` as a child.\n         *\n         * @param {string} techName\n         *        name of the playback technology\n         *\n         * @param {string} source\n         *        video source\n         *\n         * @private\n         */\n        loadTech_(techName, source) {\n            // Pause and remove current playback technology\n            if (this.tech_) {\n                this.unloadTech_();\n            }\n            const titleTechName = toTitleCase$1(techName);\n            const camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);\n\n            // get rid of the HTML5 video tag as soon as we are using another tech\n            if (titleTechName !== 'Html5' && this.tag) {\n                Tech.getTech('Html5').disposeMediaElement(this.tag);\n                this.tag.player = null;\n                this.tag = null;\n            }\n            this.techName_ = titleTechName;\n\n            // Turn off API access because we're loading a new tech that might load asynchronously\n            this.isReady_ = false;\n            let autoplay = this.autoplay();\n\n            // if autoplay is a string (or `true` with normalizeAutoplay: true) we pass false to the tech\n            // because the player is going to handle autoplay on `loadstart`\n            if (typeof this.autoplay() === 'string' || this.autoplay() === true && this.options_.normalizeAutoplay) {\n                autoplay = false;\n            }\n\n            // Grab tech-specific options from player options and add source and parent element to use.\n            const techOptions = {\n                source,\n                autoplay,\n                'nativeControlsForTouch': this.options_.nativeControlsForTouch,\n                'playerId': this.id(),\n                'techId': `${this.id()}_${camelTechName}_api`,\n                'playsinline': this.options_.playsinline,\n                'preload': this.options_.preload,\n                'loop': this.options_.loop,\n                'disablePictureInPicture': this.options_.disablePictureInPicture,\n                'muted': this.options_.muted,\n                'poster': this.poster(),\n                'language': this.language(),\n                'playerElIngest': this.playerElIngest_ || false,\n                'vtt.js': this.options_['vtt.js'],\n                'canOverridePoster': !!this.options_.techCanOverridePoster,\n                'enableSourceset': this.options_.enableSourceset\n            };\n            ALL.names.forEach(name => {\n                const props = ALL[name];\n                techOptions[props.getterName] = this[props.privateName];\n            });\n            Object.assign(techOptions, this.options_[titleTechName]);\n            Object.assign(techOptions, this.options_[camelTechName]);\n            Object.assign(techOptions, this.options_[techName.toLowerCase()]);\n            if (this.tag) {\n                techOptions.tag = this.tag;\n            }\n            if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {\n                techOptions.startTime = this.cache_.currentTime;\n            }\n\n            // Initialize tech instance\n            const TechClass = Tech.getTech(techName);\n            if (!TechClass) {\n                throw new Error(`No Tech named '${titleTechName}' exists! '${titleTechName}' should be registered using videojs.registerTech()'`);\n            }\n            this.tech_ = new TechClass(techOptions);\n\n            // player.triggerReady is always async, so don't need this to be async\n            this.tech_.ready(bind_(this, this.handleTechReady_), true);\n            textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);\n\n            // Listen to all HTML5-defined events and trigger them on the player\n            TECH_EVENTS_RETRIGGER.forEach(event => {\n                this.on(this.tech_, event, e => this[`handleTech${toTitleCase$1(event)}_`](e));\n            });\n            Object.keys(TECH_EVENTS_QUEUE).forEach(event => {\n                this.on(this.tech_, event, eventObj => {\n                    if (this.tech_.playbackRate() === 0 && this.tech_.seeking()) {\n                        this.queuedCallbacks_.push({\n                            callback: this[`handleTech${TECH_EVENTS_QUEUE[event]}_`].bind(this),\n                            event: eventObj\n                        });\n                        return;\n                    }\n                    this[`handleTech${TECH_EVENTS_QUEUE[event]}_`](eventObj);\n                });\n            });\n            this.on(this.tech_, 'loadstart', e => this.handleTechLoadStart_(e));\n            this.on(this.tech_, 'sourceset', e => this.handleTechSourceset_(e));\n            this.on(this.tech_, 'waiting', e => this.handleTechWaiting_(e));\n            this.on(this.tech_, 'ended', e => this.handleTechEnded_(e));\n            this.on(this.tech_, 'seeking', e => this.handleTechSeeking_(e));\n            this.on(this.tech_, 'play', e => this.handleTechPlay_(e));\n            this.on(this.tech_, 'pause', e => this.handleTechPause_(e));\n            this.on(this.tech_, 'durationchange', e => this.handleTechDurationChange_(e));\n            this.on(this.tech_, 'fullscreenchange', (e, data) => this.handleTechFullscreenChange_(e, data));\n            this.on(this.tech_, 'fullscreenerror', (e, err) => this.handleTechFullscreenError_(e, err));\n            this.on(this.tech_, 'enterpictureinpicture', e => this.handleTechEnterPictureInPicture_(e));\n            this.on(this.tech_, 'leavepictureinpicture', e => this.handleTechLeavePictureInPicture_(e));\n            this.on(this.tech_, 'error', e => this.handleTechError_(e));\n            this.on(this.tech_, 'posterchange', e => this.handleTechPosterChange_(e));\n            this.on(this.tech_, 'textdata', e => this.handleTechTextData_(e));\n            this.on(this.tech_, 'ratechange', e => this.handleTechRateChange_(e));\n            this.on(this.tech_, 'loadedmetadata', this.boundUpdateStyleEl_);\n            this.usingNativeControls(this.techGet_('controls'));\n            if (this.controls() && !this.usingNativeControls()) {\n                this.addTechControlsListeners_();\n            }\n\n            // Add the tech element in the DOM if it was not already there\n            // Make sure to not insert the original video element if using Html5\n            if (this.tech_.el().parentNode !== this.el() && (titleTechName !== 'Html5' || !this.tag)) {\n                prependTo(this.tech_.el(), this.el());\n            }\n\n            // Get rid of the original video tag reference after the first tech is loaded\n            if (this.tag) {\n                this.tag.player = null;\n                this.tag = null;\n            }\n        }\n\n        /**\n         * Unload and dispose of the current playback {@link Tech}.\n         *\n         * @private\n         */\n        unloadTech_() {\n            // Save the current text tracks so that we can reuse the same text tracks with the next tech\n            ALL.names.forEach(name => {\n                const props = ALL[name];\n                this[props.privateName] = this[props.getterName]();\n            });\n            this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);\n            this.isReady_ = false;\n            this.tech_.dispose();\n            this.tech_ = false;\n            if (this.isPosterFromTech_) {\n                this.poster_ = '';\n                this.trigger('posterchange');\n            }\n            this.isPosterFromTech_ = false;\n        }\n\n        /**\n         * Return a reference to the current {@link Tech}.\n         * It will print a warning by default about the danger of using the tech directly\n         * but any argument that is passed in will silence the warning.\n         *\n         * @param {*} [safety]\n         *        Anything passed in to silence the warning\n         *\n         * @return {Tech}\n         *         The Tech\n         */\n        tech(safety) {\n            if (safety === undefined) {\n                log$1.warn('Using the tech directly can be dangerous. I hope you know what you\\'re doing.\\n' + 'See https://github.com/videojs/video.js/issues/2617 for more info.\\n');\n            }\n            return this.tech_;\n        }\n\n        /**\n         * Set up click and touch listeners for the playback element\n         *\n         * - On desktops: a click on the video itself will toggle playback\n         * - On mobile devices: a click on the video toggles controls\n         *   which is done by toggling the user state between active and\n         *   inactive\n         * - A tap can signal that a user has become active or has become inactive\n         *   e.g. a quick tap on an iPhone movie should reveal the controls. Another\n         *   quick tap should hide them again (signaling the user is in an inactive\n         *   viewing state)\n         * - In addition to this, we still want the user to be considered inactive after\n         *   a few seconds of inactivity.\n         *\n         * > Note: the only part of iOS interaction we can't mimic with this setup\n         * is a touch and hold on the video element counting as activity in order to\n         * keep the controls showing, but that shouldn't be an issue. A touch and hold\n         * on any controls will still keep the user active\n         *\n         * @private\n         */\n        addTechControlsListeners_() {\n            // Make sure to remove all the previous listeners in case we are called multiple times.\n            this.removeTechControlsListeners_();\n            this.on(this.tech_, 'click', this.boundHandleTechClick_);\n            this.on(this.tech_, 'dblclick', this.boundHandleTechDoubleClick_);\n\n            // If the controls were hidden we don't want that to change without a tap event\n            // so we'll check if the controls were already showing before reporting user\n            // activity\n            this.on(this.tech_, 'touchstart', this.boundHandleTechTouchStart_);\n            this.on(this.tech_, 'touchmove', this.boundHandleTechTouchMove_);\n            this.on(this.tech_, 'touchend', this.boundHandleTechTouchEnd_);\n\n            // The tap listener needs to come after the touchend listener because the tap\n            // listener cancels out any reportedUserActivity when setting userActive(false)\n            this.on(this.tech_, 'tap', this.boundHandleTechTap_);\n        }\n\n        /**\n         * Remove the listeners used for click and tap controls. This is needed for\n         * toggling to controls disabled, where a tap/touch should do nothing.\n         *\n         * @private\n         */\n        removeTechControlsListeners_() {\n            // We don't want to just use `this.off()` because there might be other needed\n            // listeners added by techs that extend this.\n            this.off(this.tech_, 'tap', this.boundHandleTechTap_);\n            this.off(this.tech_, 'touchstart', this.boundHandleTechTouchStart_);\n            this.off(this.tech_, 'touchmove', this.boundHandleTechTouchMove_);\n            this.off(this.tech_, 'touchend', this.boundHandleTechTouchEnd_);\n            this.off(this.tech_, 'click', this.boundHandleTechClick_);\n            this.off(this.tech_, 'dblclick', this.boundHandleTechDoubleClick_);\n        }\n\n        /**\n         * Player waits for the tech to be ready\n         *\n         * @private\n         */\n        handleTechReady_() {\n            this.triggerReady();\n\n            // Keep the same volume as before\n            if (this.cache_.volume) {\n                this.techCall_('setVolume', this.cache_.volume);\n            }\n\n            // Look if the tech found a higher resolution poster while loading\n            this.handleTechPosterChange_();\n\n            // Update the duration if available\n            this.handleTechDurationChange_();\n        }\n\n        /**\n         * Retrigger the `loadstart` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#loadstart\n         * @listens Tech#loadstart\n         * @private\n         */\n        handleTechLoadStart_() {\n            // TODO: Update to use `emptied` event instead. See #1277.\n\n            this.removeClass('vjs-ended', 'vjs-seeking');\n\n            // reset the error state\n            this.error(null);\n\n            // Update the duration\n            this.handleTechDurationChange_();\n            if (!this.paused()) {\n                /**\n                 * Fired when the user agent begins looking for media data\n                 *\n                 * @event Player#loadstart\n                 * @type {Event}\n                 */\n                this.trigger('loadstart');\n            } else {\n                // reset the hasStarted state\n                this.hasStarted(false);\n                this.trigger('loadstart');\n            }\n\n            // autoplay happens after loadstart for the browser,\n            // so we mimic that behavior\n            this.manualAutoplay_(this.autoplay() === true && this.options_.normalizeAutoplay ? 'play' : this.autoplay());\n        }\n\n        /**\n         * Handle autoplay string values, rather than the typical boolean\n         * values that should be handled by the tech. Note that this is not\n         * part of any specification. Valid values and what they do can be\n         * found on the autoplay getter at Player#autoplay()\n         */\n        manualAutoplay_(type) {\n            if (!this.tech_ || typeof type !== 'string') {\n                return;\n            }\n\n            // Save original muted() value, set muted to true, and attempt to play().\n            // On promise rejection, restore muted from saved value\n            const resolveMuted = () => {\n                const previouslyMuted = this.muted();\n                this.muted(true);\n                const restoreMuted = () => {\n                    this.muted(previouslyMuted);\n                };\n\n                // restore muted on play terminatation\n                this.playTerminatedQueue_.push(restoreMuted);\n                const mutedPromise = this.play();\n                if (!isPromise(mutedPromise)) {\n                    return;\n                }\n                return mutedPromise.catch(err => {\n                    restoreMuted();\n                    throw new Error(`Rejection at manualAutoplay. Restoring muted value. ${err ? err : ''}`);\n                });\n            };\n            let promise;\n\n            // if muted defaults to true\n            // the only thing we can do is call play\n            if (type === 'any' && !this.muted()) {\n                promise = this.play();\n                if (isPromise(promise)) {\n                    promise = promise.catch(resolveMuted);\n                }\n            } else if (type === 'muted' && !this.muted()) {\n                promise = resolveMuted();\n            } else {\n                promise = this.play();\n            }\n            if (!isPromise(promise)) {\n                return;\n            }\n            return promise.then(() => {\n                this.trigger({\n                    type: 'autoplay-success',\n                    autoplay: type\n                });\n            }).catch(() => {\n                this.trigger({\n                    type: 'autoplay-failure',\n                    autoplay: type\n                });\n            });\n        }\n\n        /**\n         * Update the internal source caches so that we return the correct source from\n         * `src()`, `currentSource()`, and `currentSources()`.\n         *\n         * > Note: `currentSources` will not be updated if the source that is passed in exists\n         *         in the current `currentSources` cache.\n         *\n         *\n         * @param {Tech~SourceObject} srcObj\n         *        A string or object source to update our caches to.\n         */\n        updateSourceCaches_(srcObj = '') {\n            let src = srcObj;\n            let type = '';\n            if (typeof src !== 'string') {\n                src = srcObj.src;\n                type = srcObj.type;\n            }\n\n            // make sure all the caches are set to default values\n            // to prevent null checking\n            this.cache_.source = this.cache_.source || {};\n            this.cache_.sources = this.cache_.sources || [];\n\n            // try to get the type of the src that was passed in\n            if (src && !type) {\n                type = findMimetype(this, src);\n            }\n\n            // update `currentSource` cache always\n            this.cache_.source = merge$2({}, srcObj, {\n                src,\n                type\n            });\n            const matchingSources = this.cache_.sources.filter(s => s.src && s.src === src);\n            const sourceElSources = [];\n            const sourceEls = this.$$('source');\n            const matchingSourceEls = [];\n            for (let i = 0; i < sourceEls.length; i++) {\n                const sourceObj = getAttributes(sourceEls[i]);\n                sourceElSources.push(sourceObj);\n                if (sourceObj.src && sourceObj.src === src) {\n                    matchingSourceEls.push(sourceObj.src);\n                }\n            }\n\n            // if we have matching source els but not matching sources\n            // the current source cache is not up to date\n            if (matchingSourceEls.length && !matchingSources.length) {\n                this.cache_.sources = sourceElSources;\n                // if we don't have matching source or source els set the\n                // sources cache to the `currentSource` cache\n            } else if (!matchingSources.length) {\n                this.cache_.sources = [this.cache_.source];\n            }\n\n            // update the tech `src` cache\n            this.cache_.src = src;\n        }\n\n        /**\n         * *EXPERIMENTAL* Fired when the source is set or changed on the {@link Tech}\n         * causing the media element to reload.\n         *\n         * It will fire for the initial source and each subsequent source.\n         * This event is a custom event from Video.js and is triggered by the {@link Tech}.\n         *\n         * The event object for this event contains a `src` property that will contain the source\n         * that was available when the event was triggered. This is generally only necessary if Video.js\n         * is switching techs while the source was being changed.\n         *\n         * It is also fired when `load` is called on the player (or media element)\n         * because the {@link https://html.spec.whatwg.org/multipage/media.html#dom-media-load|specification for `load`}\n         * says that the resource selection algorithm needs to be aborted and restarted.\n         * In this case, it is very likely that the `src` property will be set to the\n         * empty string `\"\"` to indicate we do not know what the source will be but\n         * that it is changing.\n         *\n         * *This event is currently still experimental and may change in minor releases.*\n         * __To use this, pass `enableSourceset` option to the player.__\n         *\n         * @event Player#sourceset\n         * @type {Event}\n         * @prop {string} src\n         *                The source url available when the `sourceset` was triggered.\n         *                It will be an empty string if we cannot know what the source is\n         *                but know that the source will change.\n         */\n        /**\n         * Retrigger the `sourceset` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#sourceset\n         * @listens Tech#sourceset\n         * @private\n         */\n        handleTechSourceset_(event) {\n            // only update the source cache when the source\n            // was not updated using the player api\n            if (!this.changingSrc_) {\n                let updateSourceCaches = src => this.updateSourceCaches_(src);\n                const playerSrc = this.currentSource().src;\n                const eventSrc = event.src;\n\n                // if we have a playerSrc that is not a blob, and a tech src that is a blob\n                if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) {\n                    // if both the tech source and the player source were updated we assume\n                    // something like @videojs/http-streaming did the sourceset and skip updating the source cache.\n                    if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) {\n                        updateSourceCaches = () => {};\n                    }\n                }\n\n                // update the source to the initial source right away\n                // in some cases this will be empty string\n                updateSourceCaches(eventSrc);\n\n                // if the `sourceset` `src` was an empty string\n                // wait for a `loadstart` to update the cache to `currentSrc`.\n                // If a sourceset happens before a `loadstart`, we reset the state\n                if (!event.src) {\n                    this.tech_.any(['sourceset', 'loadstart'], e => {\n                        // if a sourceset happens before a `loadstart` there\n                        // is nothing to do as this `handleTechSourceset_`\n                        // will be called again and this will be handled there.\n                        if (e.type === 'sourceset') {\n                            return;\n                        }\n                        const techSrc = this.techGet('currentSrc');\n                        this.lastSource_.tech = techSrc;\n                        this.updateSourceCaches_(techSrc);\n                    });\n                }\n            }\n            this.lastSource_ = {\n                player: this.currentSource().src,\n                tech: event.src\n            };\n            this.trigger({\n                src: event.src,\n                type: 'sourceset'\n            });\n        }\n\n        /**\n         * Add/remove the vjs-has-started class\n         *\n         *\n         * @param {boolean} request\n         *        - true: adds the class\n         *        - false: remove the class\n         *\n         * @return {boolean}\n         *         the boolean value of hasStarted_\n         */\n        hasStarted(request) {\n            if (request === undefined) {\n                // act as getter, if we have no request to change\n                return this.hasStarted_;\n            }\n            if (request === this.hasStarted_) {\n                return;\n            }\n            this.hasStarted_ = request;\n            if (this.hasStarted_) {\n                this.addClass('vjs-has-started');\n            } else {\n                this.removeClass('vjs-has-started');\n            }\n        }\n\n        /**\n         * Fired whenever the media begins or resumes playback\n         *\n         * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}\n         * @fires Player#play\n         * @listens Tech#play\n         * @private\n         */\n        handleTechPlay_() {\n            this.removeClass('vjs-ended', 'vjs-paused');\n            this.addClass('vjs-playing');\n\n            // hide the poster when the user hits play\n            this.hasStarted(true);\n            /**\n             * Triggered whenever an {@link Tech#play} event happens. Indicates that\n             * playback has started or resumed.\n             *\n             * @event Player#play\n             * @type {Event}\n             */\n            this.trigger('play');\n        }\n\n        /**\n         * Retrigger the `ratechange` event that was triggered by the {@link Tech}.\n         *\n         * If there were any events queued while the playback rate was zero, fire\n         * those events now.\n         *\n         * @private\n         * @method Player#handleTechRateChange_\n         * @fires Player#ratechange\n         * @listens Tech#ratechange\n         */\n        handleTechRateChange_() {\n            if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {\n                this.queuedCallbacks_.forEach(queued => queued.callback(queued.event));\n                this.queuedCallbacks_ = [];\n            }\n            this.cache_.lastPlaybackRate = this.tech_.playbackRate();\n            /**\n             * Fires when the playing speed of the audio/video is changed\n             *\n             * @event Player#ratechange\n             * @type {event}\n             */\n            this.trigger('ratechange');\n        }\n\n        /**\n         * Retrigger the `waiting` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#waiting\n         * @listens Tech#waiting\n         * @private\n         */\n        handleTechWaiting_() {\n            this.addClass('vjs-waiting');\n            /**\n             * A readyState change on the DOM element has caused playback to stop.\n             *\n             * @event Player#waiting\n             * @type {Event}\n             */\n            this.trigger('waiting');\n\n            // Browsers may emit a timeupdate event after a waiting event. In order to prevent\n            // premature removal of the waiting class, wait for the time to change.\n            const timeWhenWaiting = this.currentTime();\n            const timeUpdateListener = () => {\n                if (timeWhenWaiting !== this.currentTime()) {\n                    this.removeClass('vjs-waiting');\n                    this.off('timeupdate', timeUpdateListener);\n                }\n            };\n            this.on('timeupdate', timeUpdateListener);\n        }\n\n        /**\n         * Retrigger the `canplay` event that was triggered by the {@link Tech}.\n         * > Note: This is not consistent between browsers. See #1351\n         *\n         * @fires Player#canplay\n         * @listens Tech#canplay\n         * @private\n         */\n        handleTechCanPlay_() {\n            this.removeClass('vjs-waiting');\n            /**\n             * The media has a readyState of HAVE_FUTURE_DATA or greater.\n             *\n             * @event Player#canplay\n             * @type {Event}\n             */\n            this.trigger('canplay');\n        }\n\n        /**\n         * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#canplaythrough\n         * @listens Tech#canplaythrough\n         * @private\n         */\n        handleTechCanPlayThrough_() {\n            this.removeClass('vjs-waiting');\n            /**\n             * The media has a readyState of HAVE_ENOUGH_DATA or greater. This means that the\n             * entire media file can be played without buffering.\n             *\n             * @event Player#canplaythrough\n             * @type {Event}\n             */\n            this.trigger('canplaythrough');\n        }\n\n        /**\n         * Retrigger the `playing` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#playing\n         * @listens Tech#playing\n         * @private\n         */\n        handleTechPlaying_() {\n            this.removeClass('vjs-waiting');\n            /**\n             * The media is no longer blocked from playback, and has started playing.\n             *\n             * @event Player#playing\n             * @type {Event}\n             */\n            this.trigger('playing');\n        }\n\n        /**\n         * Retrigger the `seeking` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#seeking\n         * @listens Tech#seeking\n         * @private\n         */\n        handleTechSeeking_() {\n            this.addClass('vjs-seeking');\n            /**\n             * Fired whenever the player is jumping to a new time\n             *\n             * @event Player#seeking\n             * @type {Event}\n             */\n            this.trigger('seeking');\n        }\n\n        /**\n         * Retrigger the `seeked` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#seeked\n         * @listens Tech#seeked\n         * @private\n         */\n        handleTechSeeked_() {\n            this.removeClass('vjs-seeking', 'vjs-ended');\n            /**\n             * Fired when the player has finished jumping to a new time\n             *\n             * @event Player#seeked\n             * @type {Event}\n             */\n            this.trigger('seeked');\n        }\n\n        /**\n         * Retrigger the `pause` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#pause\n         * @listens Tech#pause\n         * @private\n         */\n        handleTechPause_() {\n            this.removeClass('vjs-playing');\n            this.addClass('vjs-paused');\n            /**\n             * Fired whenever the media has been paused\n             *\n             * @event Player#pause\n             * @type {Event}\n             */\n            this.trigger('pause');\n        }\n\n        /**\n         * Retrigger the `ended` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#ended\n         * @listens Tech#ended\n         * @private\n         */\n        handleTechEnded_() {\n            this.addClass('vjs-ended');\n            this.removeClass('vjs-waiting');\n            if (this.options_.loop) {\n                this.currentTime(0);\n                this.play();\n            } else if (!this.paused()) {\n                this.pause();\n            }\n\n            /**\n             * Fired when the end of the media resource is reached (currentTime == duration)\n             *\n             * @event Player#ended\n             * @type {Event}\n             */\n            this.trigger('ended');\n        }\n\n        /**\n         * Fired when the duration of the media resource is first known or changed\n         *\n         * @listens Tech#durationchange\n         * @private\n         */\n        handleTechDurationChange_() {\n            this.duration(this.techGet_('duration'));\n        }\n\n        /**\n         * Handle a click on the media element to play/pause\n         *\n         * @param {Event} event\n         *        the event that caused this function to trigger\n         *\n         * @listens Tech#click\n         * @private\n         */\n        handleTechClick_(event) {\n            // When controls are disabled a click should not toggle playback because\n            // the click is considered a control\n            if (!this.controls_) {\n                return;\n            }\n            if (this.options_ === undefined || this.options_.userActions === undefined || this.options_.userActions.click === undefined || this.options_.userActions.click !== false) {\n                if (this.options_ !== undefined && this.options_.userActions !== undefined && typeof this.options_.userActions.click === 'function') {\n                    this.options_.userActions.click.call(this, event);\n                } else if (this.paused()) {\n                    silencePromise(this.play());\n                } else {\n                    this.pause();\n                }\n            }\n        }\n\n        /**\n         * Handle a double-click on the media element to enter/exit fullscreen\n         *\n         * @param {Event} event\n         *        the event that caused this function to trigger\n         *\n         * @listens Tech#dblclick\n         * @private\n         */\n        handleTechDoubleClick_(event) {\n            if (!this.controls_) {\n                return;\n            }\n\n            // we do not want to toggle fullscreen state\n            // when double-clicking inside a control bar or a modal\n            const inAllowedEls = Array.prototype.some.call(this.$$('.vjs-control-bar, .vjs-modal-dialog'), el => el.contains(event.target));\n            if (!inAllowedEls) {\n                /*\n         * options.userActions.doubleClick\n         *\n         * If `undefined` or `true`, double-click toggles fullscreen if controls are present\n         * Set to `false` to disable double-click handling\n         * Set to a function to substitute an external double-click handler\n         */\n                if (this.options_ === undefined || this.options_.userActions === undefined || this.options_.userActions.doubleClick === undefined || this.options_.userActions.doubleClick !== false) {\n                    if (this.options_ !== undefined && this.options_.userActions !== undefined && typeof this.options_.userActions.doubleClick === 'function') {\n                        this.options_.userActions.doubleClick.call(this, event);\n                    } else if (this.isFullscreen()) {\n                        this.exitFullscreen();\n                    } else {\n                        this.requestFullscreen();\n                    }\n                }\n            }\n        }\n\n        /**\n         * Handle a tap on the media element. It will toggle the user\n         * activity state, which hides and shows the controls.\n         *\n         * @listens Tech#tap\n         * @private\n         */\n        handleTechTap_() {\n            this.userActive(!this.userActive());\n        }\n\n        /**\n         * Handle touch to start\n         *\n         * @listens Tech#touchstart\n         * @private\n         */\n        handleTechTouchStart_() {\n            this.userWasActive = this.userActive();\n        }\n\n        /**\n         * Handle touch to move\n         *\n         * @listens Tech#touchmove\n         * @private\n         */\n        handleTechTouchMove_() {\n            if (this.userWasActive) {\n                this.reportUserActivity();\n            }\n        }\n\n        /**\n         * Handle touch to end\n         *\n         * @param {Event} event\n         *        the touchend event that triggered\n         *        this function\n         *\n         * @listens Tech#touchend\n         * @private\n         */\n        handleTechTouchEnd_(event) {\n            // Stop the mouse events from also happening\n            if (event.cancelable) {\n                event.preventDefault();\n            }\n        }\n\n        /**\n         * @private\n         */\n        toggleFullscreenClass_() {\n            if (this.isFullscreen()) {\n                this.addClass('vjs-fullscreen');\n            } else {\n                this.removeClass('vjs-fullscreen');\n            }\n        }\n\n        /**\n         * when the document fschange event triggers it calls this\n         */\n        documentFullscreenChange_(e) {\n            const targetPlayer = e.target.player;\n\n            // if another player was fullscreen\n            // do a null check for targetPlayer because older firefox's would put document as e.target\n            if (targetPlayer && targetPlayer !== this) {\n                return;\n            }\n            const el = this.el();\n            let isFs = document[this.fsApi_.fullscreenElement] === el;\n            if (!isFs && el.matches) {\n                isFs = el.matches(':' + this.fsApi_.fullscreen);\n            } else if (!isFs && el.msMatchesSelector) {\n                isFs = el.msMatchesSelector(':' + this.fsApi_.fullscreen);\n            }\n            this.isFullscreen(isFs);\n        }\n\n        /**\n         * Handle Tech Fullscreen Change\n         *\n         * @param {Event} event\n         *        the fullscreenchange event that triggered this function\n         *\n         * @param {Object} data\n         *        the data that was sent with the event\n         *\n         * @private\n         * @listens Tech#fullscreenchange\n         * @fires Player#fullscreenchange\n         */\n        handleTechFullscreenChange_(event, data) {\n            if (data) {\n                if (data.nativeIOSFullscreen) {\n                    this.addClass('vjs-ios-native-fs');\n                    this.tech_.one('webkitendfullscreen', () => {\n                        this.removeClass('vjs-ios-native-fs');\n                    });\n                }\n                this.isFullscreen(data.isFullscreen);\n            }\n        }\n        handleTechFullscreenError_(event, err) {\n            this.trigger('fullscreenerror', err);\n        }\n\n        /**\n         * @private\n         */\n        togglePictureInPictureClass_() {\n            if (this.isInPictureInPicture()) {\n                this.addClass('vjs-picture-in-picture');\n            } else {\n                this.removeClass('vjs-picture-in-picture');\n            }\n        }\n\n        /**\n         * Handle Tech Enter Picture-in-Picture.\n         *\n         * @param {Event} event\n         *        the enterpictureinpicture event that triggered this function\n         *\n         * @private\n         * @listens Tech#enterpictureinpicture\n         */\n        handleTechEnterPictureInPicture_(event) {\n            this.isInPictureInPicture(true);\n        }\n\n        /**\n         * Handle Tech Leave Picture-in-Picture.\n         *\n         * @param {Event} event\n         *        the leavepictureinpicture event that triggered this function\n         *\n         * @private\n         * @listens Tech#leavepictureinpicture\n         */\n        handleTechLeavePictureInPicture_(event) {\n            this.isInPictureInPicture(false);\n        }\n\n        /**\n         * Fires when an error occurred during the loading of an audio/video.\n         *\n         * @private\n         * @listens Tech#error\n         */\n        handleTechError_() {\n            const error = this.tech_.error();\n            this.error(error);\n        }\n\n        /**\n         * Retrigger the `textdata` event that was triggered by the {@link Tech}.\n         *\n         * @fires Player#textdata\n         * @listens Tech#textdata\n         * @private\n         */\n        handleTechTextData_() {\n            let data = null;\n            if (arguments.length > 1) {\n                data = arguments[1];\n            }\n\n            /**\n             * Fires when we get a textdata event from tech\n             *\n             * @event Player#textdata\n             * @type {Event}\n             */\n            this.trigger('textdata', data);\n        }\n\n        /**\n         * Get object for cached values.\n         *\n         * @return {Object}\n         *         get the current object cache\n         */\n        getCache() {\n            return this.cache_;\n        }\n\n        /**\n         * Resets the internal cache object.\n         *\n         * Using this function outside the player constructor or reset method may\n         * have unintended side-effects.\n         *\n         * @private\n         */\n        resetCache_() {\n            this.cache_ = {\n                // Right now, the currentTime is not _really_ cached because it is always\n                // retrieved from the tech (see: currentTime). However, for completeness,\n                // we set it to zero here to ensure that if we do start actually caching\n                // it, we reset it along with everything else.\n                currentTime: 0,\n                initTime: 0,\n                inactivityTimeout: this.options_.inactivityTimeout,\n                duration: NaN,\n                lastVolume: 1,\n                lastPlaybackRate: this.defaultPlaybackRate(),\n                media: null,\n                src: '',\n                source: {},\n                sources: [],\n                playbackRates: [],\n                volume: 1\n            };\n        }\n\n        /**\n         * Pass values to the playback tech\n         *\n         * @param {string} [method]\n         *        the method to call\n         *\n         * @param {Object} arg\n         *        the argument to pass\n         *\n         * @private\n         */\n        techCall_(method, arg) {\n            // If it's not ready yet, call method when it is\n\n            this.ready(function () {\n                if (method in allowedSetters) {\n                    return set(this.middleware_, this.tech_, method, arg);\n                } else if (method in allowedMediators) {\n                    return mediate(this.middleware_, this.tech_, method, arg);\n                }\n                try {\n                    if (this.tech_) {\n                        this.tech_[method](arg);\n                    }\n                } catch (e) {\n                    log$1(e);\n                    throw e;\n                }\n            }, true);\n        }\n\n        /**\n         * Mediate attempt to call playback tech method\n         * and return the value of the method called.\n         *\n         * @param {string} method\n         *        Tech method\n         *\n         * @return {*}\n         *         Value returned by the tech method called, undefined if tech\n         *         is not ready or tech method is not present\n         *\n         * @private\n         */\n        techGet_(method) {\n            if (!this.tech_ || !this.tech_.isReady_) {\n                return;\n            }\n            if (method in allowedGetters) {\n                return get(this.middleware_, this.tech_, method);\n            } else if (method in allowedMediators) {\n                return mediate(this.middleware_, this.tech_, method);\n            }\n\n            // Log error when playback tech object is present but method\n            // is undefined or unavailable\n            try {\n                return this.tech_[method]();\n            } catch (e) {\n                // When building additional tech libs, an expected method may not be defined yet\n                if (this.tech_[method] === undefined) {\n                    log$1(`Video.js: ${method} method not defined for ${this.techName_} playback technology.`, e);\n                    throw e;\n                }\n\n                // When a method isn't available on the object it throws a TypeError\n                if (e.name === 'TypeError') {\n                    log$1(`Video.js: ${method} unavailable on ${this.techName_} playback technology element.`, e);\n                    this.tech_.isReady_ = false;\n                    throw e;\n                }\n\n                // If error unknown, just log and throw\n                log$1(e);\n                throw e;\n            }\n        }\n\n        /**\n         * Attempt to begin playback at the first opportunity.\n         *\n         * @return {Promise|undefined}\n         *         Returns a promise if the browser supports Promises (or one\n         *         was passed in as an option). This promise will be resolved on\n         *         the return value of play. If this is undefined it will fulfill the\n         *         promise chain otherwise the promise chain will be fulfilled when\n         *         the promise from play is fulfilled.\n         */\n        play() {\n            return new Promise(resolve => {\n                this.play_(resolve);\n            });\n        }\n\n        /**\n         * The actual logic for play, takes a callback that will be resolved on the\n         * return value of play. This allows us to resolve to the play promise if there\n         * is one on modern browsers.\n         *\n         * @private\n         * @param {Function} [callback]\n         *        The callback that should be called when the techs play is actually called\n         */\n        play_(callback = silencePromise) {\n            this.playCallbacks_.push(callback);\n            const isSrcReady = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc()));\n            const isSafariOrIOS = Boolean(IS_ANY_SAFARI || IS_IOS);\n\n            // treat calls to play_ somewhat like the `one` event function\n            if (this.waitToPlay_) {\n                this.off(['ready', 'loadstart'], this.waitToPlay_);\n                this.waitToPlay_ = null;\n            }\n\n            // if the player/tech is not ready or the src itself is not ready\n            // queue up a call to play on `ready` or `loadstart`\n            if (!this.isReady_ || !isSrcReady) {\n                this.waitToPlay_ = e => {\n                    this.play_();\n                };\n                this.one(['ready', 'loadstart'], this.waitToPlay_);\n\n                // if we are in Safari, there is a high chance that loadstart will trigger after the gesture timeperiod\n                // in that case, we need to prime the video element by calling load so it'll be ready in time\n                if (!isSrcReady && isSafariOrIOS) {\n                    this.load();\n                }\n                return;\n            }\n\n            // If the player/tech is ready and we have a source, we can attempt playback.\n            const val = this.techGet_('play');\n\n            // For native playback, reset the progress bar if we get a play call from a replay.\n            const isNativeReplay = isSafariOrIOS && this.hasClass('vjs-ended');\n            if (isNativeReplay) {\n                this.resetProgressBar_();\n            }\n            // play was terminated if the returned value is null\n            if (val === null) {\n                this.runPlayTerminatedQueue_();\n            } else {\n                this.runPlayCallbacks_(val);\n            }\n        }\n\n        /**\n         * These functions will be run when if play is terminated. If play\n         * runPlayCallbacks_ is run these function will not be run. This allows us\n         * to differentiate between a terminated play and an actual call to play.\n         */\n        runPlayTerminatedQueue_() {\n            const queue = this.playTerminatedQueue_.slice(0);\n            this.playTerminatedQueue_ = [];\n            queue.forEach(function (q) {\n                q();\n            });\n        }\n\n        /**\n         * When a callback to play is delayed we have to run these\n         * callbacks when play is actually called on the tech. This function\n         * runs the callbacks that were delayed and accepts the return value\n         * from the tech.\n         *\n         * @param {undefined|Promise} val\n         *        The return value from the tech.\n         */\n        runPlayCallbacks_(val) {\n            const callbacks = this.playCallbacks_.slice(0);\n            this.playCallbacks_ = [];\n            // clear play terminatedQueue since we finished a real play\n            this.playTerminatedQueue_ = [];\n            callbacks.forEach(function (cb) {\n                cb(val);\n            });\n        }\n\n        /**\n         * Pause the video playback\n         *\n         * @return {Player}\n         *         A reference to the player object this function was called on\n         */\n        pause() {\n            this.techCall_('pause');\n        }\n\n        /**\n         * Check if the player is paused or has yet to play\n         *\n         * @return {boolean}\n         *         - false: if the media is currently playing\n         *         - true: if media is not currently playing\n         */\n        paused() {\n            // The initial state of paused should be true (in Safari it's actually false)\n            return this.techGet_('paused') === false ? false : true;\n        }\n\n        /**\n         * Get a TimeRange object representing the current ranges of time that the user\n         * has played.\n         *\n         * @return { import('./utils/time').TimeRange }\n         *         A time range object that represents all the increments of time that have\n         *         been played.\n         */\n        played() {\n            return this.techGet_('played') || createTimeRanges$1(0, 0);\n        }\n\n        /**\n         * Returns whether or not the user is \"scrubbing\". Scrubbing is\n         * when the user has clicked the progress bar handle and is\n         * dragging it along the progress bar.\n         *\n         * @param {boolean} [isScrubbing]\n         *        whether the user is or is not scrubbing\n         *\n         * @return {boolean}\n         *         The value of scrubbing when getting\n         */\n        scrubbing(isScrubbing) {\n            if (typeof isScrubbing === 'undefined') {\n                return this.scrubbing_;\n            }\n            this.scrubbing_ = !!isScrubbing;\n            this.techCall_('setScrubbing', this.scrubbing_);\n            if (isScrubbing) {\n                this.addClass('vjs-scrubbing');\n            } else {\n                this.removeClass('vjs-scrubbing');\n            }\n        }\n\n        /**\n         * Get or set the current time (in seconds)\n         *\n         * @param {number|string} [seconds]\n         *        The time to seek to in seconds\n         *\n         * @return {number}\n         *         - the current time in seconds when getting\n         */\n        currentTime(seconds) {\n            if (typeof seconds !== 'undefined') {\n                if (seconds < 0) {\n                    seconds = 0;\n                }\n                if (!this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {\n                    this.cache_.initTime = seconds;\n                    this.off('canplay', this.boundApplyInitTime_);\n                    this.one('canplay', this.boundApplyInitTime_);\n                    return;\n                }\n                this.techCall_('setCurrentTime', seconds);\n                this.cache_.initTime = 0;\n                return;\n            }\n\n            // cache last currentTime and return. default to 0 seconds\n            //\n            // Caching the currentTime is meant to prevent a massive amount of reads on the tech's\n            // currentTime when scrubbing, but may not provide much performance benefit after all.\n            // Should be tested. Also something has to read the actual current time or the cache will\n            // never get updated.\n            this.cache_.currentTime = this.techGet_('currentTime') || 0;\n            return this.cache_.currentTime;\n        }\n\n        /**\n         * Apply the value of initTime stored in cache as currentTime.\n         *\n         * @private\n         */\n        applyInitTime_() {\n            this.currentTime(this.cache_.initTime);\n        }\n\n        /**\n         * Normally gets the length in time of the video in seconds;\n         * in all but the rarest use cases an argument will NOT be passed to the method\n         *\n         * > **NOTE**: The video must have started loading before the duration can be\n         * known, and depending on preload behaviour may not be known until the video starts\n         * playing.\n         *\n         * @fires Player#durationchange\n         *\n         * @param {number} [seconds]\n         *        The duration of the video to set in seconds\n         *\n         * @return {number}\n         *         - The duration of the video in seconds when getting\n         */\n        duration(seconds) {\n            if (seconds === undefined) {\n                // return NaN if the duration is not known\n                return this.cache_.duration !== undefined ? this.cache_.duration : NaN;\n            }\n            seconds = parseFloat(seconds);\n\n            // Standardize on Infinity for signaling video is live\n            if (seconds < 0) {\n                seconds = Infinity;\n            }\n            if (seconds !== this.cache_.duration) {\n                // Cache the last set value for optimized scrubbing\n                this.cache_.duration = seconds;\n                if (seconds === Infinity) {\n                    this.addClass('vjs-live');\n                } else {\n                    this.removeClass('vjs-live');\n                }\n                if (!isNaN(seconds)) {\n                    // Do not fire durationchange unless the duration value is known.\n                    // @see [Spec]{@link https://www.w3.org/TR/2011/WD-html5-20110113/video.html#media-element-load-algorithm}\n\n                    /**\n                     * @event Player#durationchange\n                     * @type {Event}\n                     */\n                    this.trigger('durationchange');\n                }\n            }\n        }\n\n        /**\n         * Calculates how much time is left in the video. Not part\n         * of the native video API.\n         *\n         * @return {number}\n         *         The time remaining in seconds\n         */\n        remainingTime() {\n            return this.duration() - this.currentTime();\n        }\n\n        /**\n         * A remaining time function that is intended to be used when\n         * the time is to be displayed directly to the user.\n         *\n         * @return {number}\n         *         The rounded time remaining in seconds\n         */\n        remainingTimeDisplay() {\n            return Math.floor(this.duration()) - Math.floor(this.currentTime());\n        }\n\n        //\n        // Kind of like an array of portions of the video that have been downloaded.\n\n        /**\n         * Get a TimeRange object with an array of the times of the video\n         * that have been downloaded. If you just want the percent of the\n         * video that's been downloaded, use bufferedPercent.\n         *\n         * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}\n         *\n         * @return { import('./utils/time').TimeRange }\n         *         A mock {@link TimeRanges} object (following HTML spec)\n         */\n        buffered() {\n            let buffered = this.techGet_('buffered');\n            if (!buffered || !buffered.length) {\n                buffered = createTimeRanges$1(0, 0);\n            }\n            return buffered;\n        }\n\n        /**\n         * Get the percent (as a decimal) of the video that's been downloaded.\n         * This method is not a part of the native HTML video API.\n         *\n         * @return {number}\n         *         A decimal between 0 and 1 representing the percent\n         *         that is buffered 0 being 0% and 1 being 100%\n         */\n        bufferedPercent() {\n            return bufferedPercent(this.buffered(), this.duration());\n        }\n\n        /**\n         * Get the ending time of the last buffered time range\n         * This is used in the progress bar to encapsulate all time ranges.\n         *\n         * @return {number}\n         *         The end of the last buffered time range\n         */\n        bufferedEnd() {\n            const buffered = this.buffered();\n            const duration = this.duration();\n            let end = buffered.end(buffered.length - 1);\n            if (end > duration) {\n                end = duration;\n            }\n            return end;\n        }\n\n        /**\n         * Get or set the current volume of the media\n         *\n         * @param  {number} [percentAsDecimal]\n         *         The new volume as a decimal percent:\n         *         - 0 is muted/0%/off\n         *         - 1.0 is 100%/full\n         *         - 0.5 is half volume or 50%\n         *\n         * @return {number}\n         *         The current volume as a percent when getting\n         */\n        volume(percentAsDecimal) {\n            let vol;\n            if (percentAsDecimal !== undefined) {\n                // Force value to between 0 and 1\n                vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));\n                this.cache_.volume = vol;\n                this.techCall_('setVolume', vol);\n                if (vol > 0) {\n                    this.lastVolume_(vol);\n                }\n                return;\n            }\n\n            // Default to 1 when returning current volume.\n            vol = parseFloat(this.techGet_('volume'));\n            return isNaN(vol) ? 1 : vol;\n        }\n\n        /**\n         * Get the current muted state, or turn mute on or off\n         *\n         * @param {boolean} [muted]\n         *        - true to mute\n         *        - false to unmute\n         *\n         * @return {boolean}\n         *         - true if mute is on and getting\n         *         - false if mute is off and getting\n         */\n        muted(muted) {\n            if (muted !== undefined) {\n                this.techCall_('setMuted', muted);\n                return;\n            }\n            return this.techGet_('muted') || false;\n        }\n\n        /**\n         * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted\n         * indicates the state of muted on initial playback.\n         *\n         * ```js\n         *   var myPlayer = videojs('some-player-id');\n         *\n         *   myPlayer.src(\"http://www.example.com/path/to/video.mp4\");\n         *\n         *   // get, should be false\n         *   console.log(myPlayer.defaultMuted());\n         *   // set to true\n         *   myPlayer.defaultMuted(true);\n         *   // get should be true\n         *   console.log(myPlayer.defaultMuted());\n         * ```\n         *\n         * @param {boolean} [defaultMuted]\n         *        - true to mute\n         *        - false to unmute\n         *\n         * @return {boolean|Player}\n         *         - true if defaultMuted is on and getting\n         *         - false if defaultMuted is off and getting\n         *         - A reference to the current player when setting\n         */\n        defaultMuted(defaultMuted) {\n            if (defaultMuted !== undefined) {\n                return this.techCall_('setDefaultMuted', defaultMuted);\n            }\n            return this.techGet_('defaultMuted') || false;\n        }\n\n        /**\n         * Get the last volume, or set it\n         *\n         * @param  {number} [percentAsDecimal]\n         *         The new last volume as a decimal percent:\n         *         - 0 is muted/0%/off\n         *         - 1.0 is 100%/full\n         *         - 0.5 is half volume or 50%\n         *\n         * @return {number}\n         *         the current value of lastVolume as a percent when getting\n         *\n         * @private\n         */\n        lastVolume_(percentAsDecimal) {\n            if (percentAsDecimal !== undefined && percentAsDecimal !== 0) {\n                this.cache_.lastVolume = percentAsDecimal;\n                return;\n            }\n            return this.cache_.lastVolume;\n        }\n\n        /**\n         * Check if current tech can support native fullscreen\n         * (e.g. with built in controls like iOS)\n         *\n         * @return {boolean}\n         *         if native fullscreen is supported\n         */\n        supportsFullScreen() {\n            return this.techGet_('supportsFullScreen') || false;\n        }\n\n        /**\n         * Check if the player is in fullscreen mode or tell the player that it\n         * is or is not in fullscreen mode.\n         *\n         * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official\n         * property and instead document.fullscreenElement is used. But isFullscreen is\n         * still a valuable property for internal player workings.\n         *\n         * @param  {boolean} [isFS]\n         *         Set the players current fullscreen state\n         *\n         * @return {boolean}\n         *         - true if fullscreen is on and getting\n         *         - false if fullscreen is off and getting\n         */\n        isFullscreen(isFS) {\n            if (isFS !== undefined) {\n                const oldValue = this.isFullscreen_;\n                this.isFullscreen_ = Boolean(isFS);\n\n                // if we changed fullscreen state and we're in prefixed mode, trigger fullscreenchange\n                // this is the only place where we trigger fullscreenchange events for older browsers\n                // fullWindow mode is treated as a prefixed event and will get a fullscreenchange event as well\n                if (this.isFullscreen_ !== oldValue && this.fsApi_.prefixed) {\n                    /**\n                     * @event Player#fullscreenchange\n                     * @type {Event}\n                     */\n                    this.trigger('fullscreenchange');\n                }\n                this.toggleFullscreenClass_();\n                return;\n            }\n            return this.isFullscreen_;\n        }\n\n        /**\n         * Increase the size of the video to full screen\n         * In some browsers, full screen is not supported natively, so it enters\n         * \"full window mode\", where the video fills the browser window.\n         * In browsers and devices that support native full screen, sometimes the\n         * browser's default controls will be shown, and not the Video.js custom skin.\n         * This includes most mobile devices (iOS, Android) and older versions of\n         * Safari.\n         *\n         * @param  {Object} [fullscreenOptions]\n         *         Override the player fullscreen options\n         *\n         * @fires Player#fullscreenchange\n         */\n        requestFullscreen(fullscreenOptions) {\n            if (this.isInPictureInPicture()) {\n                this.exitPictureInPicture();\n            }\n            const self = this;\n            return new Promise((resolve, reject) => {\n                function offHandler() {\n                    self.off('fullscreenerror', errorHandler);\n                    self.off('fullscreenchange', changeHandler);\n                }\n                function changeHandler() {\n                    offHandler();\n                    resolve();\n                }\n                function errorHandler(e, err) {\n                    offHandler();\n                    reject(err);\n                }\n                self.one('fullscreenchange', changeHandler);\n                self.one('fullscreenerror', errorHandler);\n                const promise = self.requestFullscreenHelper_(fullscreenOptions);\n                if (promise) {\n                    promise.then(offHandler, offHandler);\n                    promise.then(resolve, reject);\n                }\n            });\n        }\n        requestFullscreenHelper_(fullscreenOptions) {\n            let fsOptions;\n\n            // Only pass fullscreen options to requestFullscreen in spec-compliant browsers.\n            // Use defaults or player configured option unless passed directly to this method.\n            if (!this.fsApi_.prefixed) {\n                fsOptions = this.options_.fullscreen && this.options_.fullscreen.options || {};\n                if (fullscreenOptions !== undefined) {\n                    fsOptions = fullscreenOptions;\n                }\n            }\n\n            // This method works as follows:\n            // 1. if a fullscreen api is available, use it\n            //   1. call requestFullscreen with potential options\n            //   2. if we got a promise from above, use it to update isFullscreen()\n            // 2. otherwise, if the tech supports fullscreen, call `enterFullScreen` on it.\n            //   This is particularly used for iPhone, older iPads, and non-safari browser on iOS.\n            // 3. otherwise, use \"fullWindow\" mode\n            if (this.fsApi_.requestFullscreen) {\n                const promise = this.el_[this.fsApi_.requestFullscreen](fsOptions);\n\n                // Even on browsers with promise support this may not return a promise\n                if (promise) {\n                    promise.then(() => this.isFullscreen(true), () => this.isFullscreen(false));\n                }\n                return promise;\n            } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {\n                // we can't take the video.js controls fullscreen but we can go fullscreen\n                // with native controls\n                this.techCall_('enterFullScreen');\n            } else {\n                // fullscreen isn't supported so we'll just stretch the video element to\n                // fill the viewport\n                this.enterFullWindow();\n            }\n        }\n\n        /**\n         * Return the video to its normal size after having been in full screen mode\n         *\n         * @fires Player#fullscreenchange\n         */\n        exitFullscreen() {\n            const self = this;\n            return new Promise((resolve, reject) => {\n                function offHandler() {\n                    self.off('fullscreenerror', errorHandler);\n                    self.off('fullscreenchange', changeHandler);\n                }\n                function changeHandler() {\n                    offHandler();\n                    resolve();\n                }\n                function errorHandler(e, err) {\n                    offHandler();\n                    reject(err);\n                }\n                self.one('fullscreenchange', changeHandler);\n                self.one('fullscreenerror', errorHandler);\n                const promise = self.exitFullscreenHelper_();\n                if (promise) {\n                    promise.then(offHandler, offHandler);\n                    // map the promise to our resolve/reject methods\n                    promise.then(resolve, reject);\n                }\n            });\n        }\n        exitFullscreenHelper_() {\n            if (this.fsApi_.requestFullscreen) {\n                const promise = document[this.fsApi_.exitFullscreen]();\n\n                // Even on browsers with promise support this may not return a promise\n                if (promise) {\n                    // we're splitting the promise here, so, we want to catch the\n                    // potential error so that this chain doesn't have unhandled errors\n                    silencePromise(promise.then(() => this.isFullscreen(false)));\n                }\n                return promise;\n            } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {\n                this.techCall_('exitFullScreen');\n            } else {\n                this.exitFullWindow();\n            }\n        }\n\n        /**\n         * When fullscreen isn't supported we can stretch the\n         * video container to as wide as the browser will let us.\n         *\n         * @fires Player#enterFullWindow\n         */\n        enterFullWindow() {\n            this.isFullscreen(true);\n            this.isFullWindow = true;\n\n            // Storing original doc overflow value to return to when fullscreen is off\n            this.docOrigOverflow = document.documentElement.style.overflow;\n\n            // Add listener for esc key to exit fullscreen\n            on(document, 'keydown', this.boundFullWindowOnEscKey_);\n\n            // Hide any scroll bars\n            document.documentElement.style.overflow = 'hidden';\n\n            // Apply fullscreen styles\n            addClass(document.body, 'vjs-full-window');\n\n            /**\n             * @event Player#enterFullWindow\n             * @type {Event}\n             */\n            this.trigger('enterFullWindow');\n        }\n\n        /**\n         * Check for call to either exit full window or\n         * full screen on ESC key\n         *\n         * @param {string} event\n         *        Event to check for key press\n         */\n        fullWindowOnEscKey(event) {\n            if (keycode.isEventKey(event, 'Esc')) {\n                if (this.isFullscreen() === true) {\n                    if (!this.isFullWindow) {\n                        this.exitFullscreen();\n                    } else {\n                        this.exitFullWindow();\n                    }\n                }\n            }\n        }\n\n        /**\n         * Exit full window\n         *\n         * @fires Player#exitFullWindow\n         */\n        exitFullWindow() {\n            this.isFullscreen(false);\n            this.isFullWindow = false;\n            off(document, 'keydown', this.boundFullWindowOnEscKey_);\n\n            // Unhide scroll bars.\n            document.documentElement.style.overflow = this.docOrigOverflow;\n\n            // Remove fullscreen styles\n            removeClass(document.body, 'vjs-full-window');\n\n            // Resize the box, controller, and poster to original sizes\n            // this.positionAll();\n            /**\n             * @event Player#exitFullWindow\n             * @type {Event}\n             */\n            this.trigger('exitFullWindow');\n        }\n\n        /**\n         * Disable Picture-in-Picture mode.\n         *\n         * @param {boolean} value\n         *                  - true will disable Picture-in-Picture mode\n         *                  - false will enable Picture-in-Picture mode\n         */\n        disablePictureInPicture(value) {\n            if (value === undefined) {\n                return this.techGet_('disablePictureInPicture');\n            }\n            this.techCall_('setDisablePictureInPicture', value);\n            this.options_.disablePictureInPicture = value;\n            this.trigger('disablepictureinpicturechanged');\n        }\n\n        /**\n         * Check if the player is in Picture-in-Picture mode or tell the player that it\n         * is or is not in Picture-in-Picture mode.\n         *\n         * @param  {boolean} [isPiP]\n         *         Set the players current Picture-in-Picture state\n         *\n         * @return {boolean}\n         *         - true if Picture-in-Picture is on and getting\n         *         - false if Picture-in-Picture is off and getting\n         */\n        isInPictureInPicture(isPiP) {\n            if (isPiP !== undefined) {\n                this.isInPictureInPicture_ = !!isPiP;\n                this.togglePictureInPictureClass_();\n                return;\n            }\n            return !!this.isInPictureInPicture_;\n        }\n\n        /**\n         * Create a floating video window always on top of other windows so that users may\n         * continue consuming media while they interact with other content sites, or\n         * applications on their device.\n         *\n         * This can use document picture-in-picture or element picture in picture\n         *\n         * Set `enableDocumentPictureInPicture` to `true` to use docPiP on a supported browser\n         * Else set `disablePictureInPicture` to `false` to disable elPiP on a supported browser\n         *\n         *\n         * @see [Spec]{@link https://w3c.github.io/picture-in-picture/}\n         * @see [Spec]{@link https://wicg.github.io/document-picture-in-picture/}\n         *\n         * @fires Player#enterpictureinpicture\n         *\n         * @return {Promise}\n         *         A promise with a Picture-in-Picture window.\n         */\n        requestPictureInPicture() {\n            if (this.options_.enableDocumentPictureInPicture && window.documentPictureInPicture) {\n                const pipContainer = document.createElement(this.el().tagName);\n                pipContainer.classList = this.el().classList;\n                pipContainer.classList.add('vjs-pip-container');\n                if (this.posterImage) {\n                    pipContainer.appendChild(this.posterImage.el().cloneNode(true));\n                }\n                if (this.titleBar) {\n                    pipContainer.appendChild(this.titleBar.el().cloneNode(true));\n                }\n                pipContainer.appendChild(createEl('p', {\n                    className: 'vjs-pip-text'\n                }, {}, this.localize('Playing in picture-in-picture')));\n                return window.documentPictureInPicture.requestWindow({\n                    // The aspect ratio won't be correct, Chrome bug https://crbug.com/1407629\n                    initialAspectRatio: this.videoWidth() / this.videoHeight(),\n                    copyStyleSheets: true\n                }).then(pipWindow => {\n                    this.el_.parentNode.insertBefore(pipContainer, this.el_);\n                    pipWindow.document.body.append(this.el_);\n                    pipWindow.document.body.classList.add('vjs-pip-window');\n                    this.player_.isInPictureInPicture(true);\n                    this.player_.trigger('enterpictureinpicture');\n\n                    // Listen for the PiP closing event to move the video back.\n                    pipWindow.addEventListener('unload', event => {\n                        const pipVideo = event.target.querySelector('.video-js');\n                        pipContainer.replaceWith(pipVideo);\n                        this.player_.isInPictureInPicture(false);\n                        this.player_.trigger('leavepictureinpicture');\n                    });\n                    return pipWindow;\n                });\n            }\n            if ('pictureInPictureEnabled' in document && this.disablePictureInPicture() === false) {\n                /**\n                 * This event fires when the player enters picture in picture mode\n                 *\n                 * @event Player#enterpictureinpicture\n                 * @type {Event}\n                 */\n                return this.techGet_('requestPictureInPicture');\n            }\n            return Promise.reject('No PiP mode is available');\n        }\n\n        /**\n         * Exit Picture-in-Picture mode.\n         *\n         * @see [Spec]{@link https://wicg.github.io/picture-in-picture}\n         *\n         * @fires Player#leavepictureinpicture\n         *\n         * @return {Promise}\n         *         A promise.\n         */\n        exitPictureInPicture() {\n            if (window.documentPictureInPicture && window.documentPictureInPicture.window) {\n                // With documentPictureInPicture, Player#leavepictureinpicture is fired in the unload handler\n                window.documentPictureInPicture.window.close();\n                return Promise.resolve();\n            }\n            if ('pictureInPictureEnabled' in document) {\n                /**\n                 * This event fires when the player leaves picture in picture mode\n                 *\n                 * @event Player#leavepictureinpicture\n                 * @type {Event}\n                 */\n                return document.exitPictureInPicture();\n            }\n        }\n\n        /**\n         * Called when this Player has focus and a key gets pressed down, or when\n         * any Component of this player receives a key press that it doesn't handle.\n         * This allows player-wide hotkeys (either as defined below, or optionally\n         * by an external function).\n         *\n         * @param {Event} event\n         *        The `keydown` event that caused this function to be called.\n         *\n         * @listens keydown\n         */\n        handleKeyDown(event) {\n            const {\n                userActions\n            } = this.options_;\n\n            // Bail out if hotkeys are not configured.\n            if (!userActions || !userActions.hotkeys) {\n                return;\n            }\n\n            // Function that determines whether or not to exclude an element from\n            // hotkeys handling.\n            const excludeElement = el => {\n                const tagName = el.tagName.toLowerCase();\n\n                // The first and easiest test is for `contenteditable` elements.\n                if (el.isContentEditable) {\n                    return true;\n                }\n\n                // Inputs matching these types will still trigger hotkey handling as\n                // they are not text inputs.\n                const allowedInputTypes = ['button', 'checkbox', 'hidden', 'radio', 'reset', 'submit'];\n                if (tagName === 'input') {\n                    return allowedInputTypes.indexOf(el.type) === -1;\n                }\n\n                // The final test is by tag name. These tags will be excluded entirely.\n                const excludedTags = ['textarea'];\n                return excludedTags.indexOf(tagName) !== -1;\n            };\n\n            // Bail out if the user is focused on an interactive form element.\n            if (excludeElement(this.el_.ownerDocument.activeElement)) {\n                return;\n            }\n            if (typeof userActions.hotkeys === 'function') {\n                userActions.hotkeys.call(this, event);\n            } else {\n                this.handleHotkeys(event);\n            }\n        }\n\n        /**\n         * Called when this Player receives a hotkey keydown event.\n         * Supported player-wide hotkeys are:\n         *\n         *   f          - toggle fullscreen\n         *   m          - toggle mute\n         *   k or Space - toggle play/pause\n         *\n         * @param {Event} event\n         *        The `keydown` event that caused this function to be called.\n         */\n        handleHotkeys(event) {\n            const hotkeys = this.options_.userActions ? this.options_.userActions.hotkeys : {};\n\n            // set fullscreenKey, muteKey, playPauseKey from `hotkeys`, use defaults if not set\n            const {\n                fullscreenKey = keydownEvent => keycode.isEventKey(keydownEvent, 'f'),\n                muteKey = keydownEvent => keycode.isEventKey(keydownEvent, 'm'),\n                playPauseKey = keydownEvent => keycode.isEventKey(keydownEvent, 'k') || keycode.isEventKey(keydownEvent, 'Space')\n            } = hotkeys;\n            if (fullscreenKey.call(this, event)) {\n                event.preventDefault();\n                event.stopPropagation();\n                const FSToggle = Component$1.getComponent('FullscreenToggle');\n                if (document[this.fsApi_.fullscreenEnabled] !== false) {\n                    FSToggle.prototype.handleClick.call(this, event);\n                }\n            } else if (muteKey.call(this, event)) {\n                event.preventDefault();\n                event.stopPropagation();\n                const MuteToggle = Component$1.getComponent('MuteToggle');\n                MuteToggle.prototype.handleClick.call(this, event);\n            } else if (playPauseKey.call(this, event)) {\n                event.preventDefault();\n                event.stopPropagation();\n                const PlayToggle = Component$1.getComponent('PlayToggle');\n                PlayToggle.prototype.handleClick.call(this, event);\n            }\n        }\n\n        /**\n         * Check whether the player can play a given mimetype\n         *\n         * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype\n         *\n         * @param {string} type\n         *        The mimetype to check\n         *\n         * @return {string}\n         *         'probably', 'maybe', or '' (empty string)\n         */\n        canPlayType(type) {\n            let can;\n\n            // Loop through each playback technology in the options order\n            for (let i = 0, j = this.options_.techOrder; i < j.length; i++) {\n                const techName = j[i];\n                let tech = Tech.getTech(techName);\n\n                // Support old behavior of techs being registered as components.\n                // Remove once that deprecated behavior is removed.\n                if (!tech) {\n                    tech = Component$1.getComponent(techName);\n                }\n\n                // Check if the current tech is defined before continuing\n                if (!tech) {\n                    log$1.error(`The \"${techName}\" tech is undefined. Skipped browser support check for that tech.`);\n                    continue;\n                }\n\n                // Check if the browser supports this technology\n                if (tech.isSupported()) {\n                    can = tech.canPlayType(type);\n                    if (can) {\n                        return can;\n                    }\n                }\n            }\n            return '';\n        }\n\n        /**\n         * Select source based on tech-order or source-order\n         * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,\n         * defaults to tech-order selection\n         *\n         * @param {Array} sources\n         *        The sources for a media asset\n         *\n         * @return {Object|boolean}\n         *         Object of source and tech order or false\n         */\n        selectSource(sources) {\n            // Get only the techs specified in `techOrder` that exist and are supported by the\n            // current platform\n            const techs = this.options_.techOrder.map(techName => {\n                return [techName, Tech.getTech(techName)];\n            }).filter(([techName, tech]) => {\n                // Check if the current tech is defined before continuing\n                if (tech) {\n                    // Check if the browser supports this technology\n                    return tech.isSupported();\n                }\n                log$1.error(`The \"${techName}\" tech is undefined. Skipped browser support check for that tech.`);\n                return false;\n            });\n\n            // Iterate over each `innerArray` element once per `outerArray` element and execute\n            // `tester` with both. If `tester` returns a non-falsy value, exit early and return\n            // that value.\n            const findFirstPassingTechSourcePair = function (outerArray, innerArray, tester) {\n                let found;\n                outerArray.some(outerChoice => {\n                    return innerArray.some(innerChoice => {\n                        found = tester(outerChoice, innerChoice);\n                        if (found) {\n                            return true;\n                        }\n                    });\n                });\n                return found;\n            };\n            let foundSourceAndTech;\n            const flip = fn => (a, b) => fn(b, a);\n            const finder = ([techName, tech], source) => {\n                if (tech.canPlaySource(source, this.options_[techName.toLowerCase()])) {\n                    return {\n                        source,\n                        tech: techName\n                    };\n                }\n            };\n\n            // Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources\n            // to select from them based on their priority.\n            if (this.options_.sourceOrder) {\n                // Source-first ordering\n                foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));\n            } else {\n                // Tech-first ordering\n                foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);\n            }\n            return foundSourceAndTech || false;\n        }\n\n        /**\n         * Executes source setting and getting logic\n         *\n         * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]\n         *        A SourceObject, an array of SourceObjects, or a string referencing\n         *        a URL to a media source. It is _highly recommended_ that an object\n         *        or array of objects is used here, so that source selection\n         *        algorithms can take the `type` into account.\n         *\n         *        If not provided, this method acts as a getter.\n         * @param {boolean} isRetry\n         *        Indicates whether this is being called internally as a result of a retry\n         *\n         * @return {string|undefined}\n         *         If the `source` argument is missing, returns the current source\n         *         URL. Otherwise, returns nothing/undefined.\n         */\n        handleSrc_(source, isRetry) {\n            // getter usage\n            if (typeof source === 'undefined') {\n                return this.cache_.src || '';\n            }\n\n            // Reset retry behavior for new source\n            if (this.resetRetryOnError_) {\n                this.resetRetryOnError_();\n            }\n\n            // filter out invalid sources and turn our source into\n            // an array of source objects\n            const sources = filterSource(source);\n\n            // if a source was passed in then it is invalid because\n            // it was filtered to a zero length Array. So we have to\n            // show an error\n            if (!sources.length) {\n                this.setTimeout(function () {\n                    this.error({\n                        code: 4,\n                        message: this.options_.notSupportedMessage\n                    });\n                }, 0);\n                return;\n            }\n\n            // initial sources\n            this.changingSrc_ = true;\n\n            // Only update the cached source list if we are not retrying a new source after error,\n            // since in that case we want to include the failed source(s) in the cache\n            if (!isRetry) {\n                this.cache_.sources = sources;\n            }\n            this.updateSourceCaches_(sources[0]);\n\n            // middlewareSource is the source after it has been changed by middleware\n            setSource(this, sources[0], (middlewareSource, mws) => {\n                this.middleware_ = mws;\n\n                // since sourceSet is async we have to update the cache again after we select a source since\n                // the source that is selected could be out of order from the cache update above this callback.\n                if (!isRetry) {\n                    this.cache_.sources = sources;\n                }\n                this.updateSourceCaches_(middlewareSource);\n                const err = this.src_(middlewareSource);\n                if (err) {\n                    if (sources.length > 1) {\n                        return this.handleSrc_(sources.slice(1));\n                    }\n                    this.changingSrc_ = false;\n\n                    // We need to wrap this in a timeout to give folks a chance to add error event handlers\n                    this.setTimeout(function () {\n                        this.error({\n                            code: 4,\n                            message: this.options_.notSupportedMessage\n                        });\n                    }, 0);\n\n                    // we could not find an appropriate tech, but let's still notify the delegate that this is it\n                    // this needs a better comment about why this is needed\n                    this.triggerReady();\n                    return;\n                }\n                setTech(mws, this.tech_);\n            });\n\n            // Try another available source if this one fails before playback.\n            if (sources.length > 1) {\n                const retry = () => {\n                    // Remove the error modal\n                    this.error(null);\n                    this.handleSrc_(sources.slice(1), true);\n                };\n                const stopListeningForErrors = () => {\n                    this.off('error', retry);\n                };\n                this.one('error', retry);\n                this.one('playing', stopListeningForErrors);\n                this.resetRetryOnError_ = () => {\n                    this.off('error', retry);\n                    this.off('playing', stopListeningForErrors);\n                };\n            }\n        }\n\n        /**\n         * Get or set the video source.\n         *\n         * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]\n         *        A SourceObject, an array of SourceObjects, or a string referencing\n         *        a URL to a media source. It is _highly recommended_ that an object\n         *        or array of objects is used here, so that source selection\n         *        algorithms can take the `type` into account.\n         *\n         *        If not provided, this method acts as a getter.\n         *\n         * @return {string|undefined}\n         *         If the `source` argument is missing, returns the current source\n         *         URL. Otherwise, returns nothing/undefined.\n         */\n        src(source) {\n            return this.handleSrc_(source, false);\n        }\n\n        /**\n         * Set the source object on the tech, returns a boolean that indicates whether\n         * there is a tech that can play the source or not\n         *\n         * @param {Tech~SourceObject} source\n         *        The source object to set on the Tech\n         *\n         * @return {boolean}\n         *         - True if there is no Tech to playback this source\n         *         - False otherwise\n         *\n         * @private\n         */\n        src_(source) {\n            const sourceTech = this.selectSource([source]);\n            if (!sourceTech) {\n                return true;\n            }\n            if (!titleCaseEquals(sourceTech.tech, this.techName_)) {\n                this.changingSrc_ = true;\n                // load this technology with the chosen source\n                this.loadTech_(sourceTech.tech, sourceTech.source);\n                this.tech_.ready(() => {\n                    this.changingSrc_ = false;\n                });\n                return false;\n            }\n\n            // wait until the tech is ready to set the source\n            // and set it synchronously if possible (#2326)\n            this.ready(function () {\n                // The setSource tech method was added with source handlers\n                // so older techs won't support it\n                // We need to check the direct prototype for the case where subclasses\n                // of the tech do not support source handlers\n                if (this.tech_.constructor.prototype.hasOwnProperty('setSource')) {\n                    this.techCall_('setSource', source);\n                } else {\n                    this.techCall_('src', source.src);\n                }\n                this.changingSrc_ = false;\n            }, true);\n            return false;\n        }\n\n        /**\n         * Begin loading the src data.\n         */\n        load() {\n            this.techCall_('load');\n        }\n\n        /**\n         * Reset the player. Loads the first tech in the techOrder,\n         * removes all the text tracks in the existing `tech`,\n         * and calls `reset` on the `tech`.\n         */\n        reset() {\n            if (this.paused()) {\n                this.doReset_();\n            } else {\n                const playPromise = this.play();\n                silencePromise(playPromise.then(() => this.doReset_()));\n            }\n        }\n        doReset_() {\n            if (this.tech_) {\n                this.tech_.clearTracks('text');\n            }\n            this.resetCache_();\n            this.poster('');\n            this.loadTech_(this.options_.techOrder[0], null);\n            this.techCall_('reset');\n            this.resetControlBarUI_();\n            if (isEvented(this)) {\n                this.trigger('playerreset');\n            }\n        }\n\n        /**\n         * Reset Control Bar's UI by calling sub-methods that reset\n         * all of Control Bar's components\n         */\n        resetControlBarUI_() {\n            this.resetProgressBar_();\n            this.resetPlaybackRate_();\n            this.resetVolumeBar_();\n        }\n\n        /**\n         * Reset tech's progress so progress bar is reset in the UI\n         */\n        resetProgressBar_() {\n            this.currentTime(0);\n            const {\n                currentTimeDisplay,\n                durationDisplay,\n                progressControl,\n                remainingTimeDisplay\n            } = this.controlBar || {};\n            const {\n                seekBar\n            } = progressControl || {};\n            if (currentTimeDisplay) {\n                currentTimeDisplay.updateContent();\n            }\n            if (durationDisplay) {\n                durationDisplay.updateContent();\n            }\n            if (remainingTimeDisplay) {\n                remainingTimeDisplay.updateContent();\n            }\n            if (seekBar) {\n                seekBar.update();\n                if (seekBar.loadProgressBar) {\n                    seekBar.loadProgressBar.update();\n                }\n            }\n        }\n\n        /**\n         * Reset Playback ratio\n         */\n        resetPlaybackRate_() {\n            this.playbackRate(this.defaultPlaybackRate());\n            this.handleTechRateChange_();\n        }\n\n        /**\n         * Reset Volume bar\n         */\n        resetVolumeBar_() {\n            this.volume(1.0);\n            this.trigger('volumechange');\n        }\n\n        /**\n         * Returns all of the current source objects.\n         *\n         * @return {Tech~SourceObject[]}\n         *         The current source objects\n         */\n        currentSources() {\n            const source = this.currentSource();\n            const sources = [];\n\n            // assume `{}` or `{ src }`\n            if (Object.keys(source).length !== 0) {\n                sources.push(source);\n            }\n            return this.cache_.sources || sources;\n        }\n\n        /**\n         * Returns the current source object.\n         *\n         * @return {Tech~SourceObject}\n         *         The current source object\n         */\n        currentSource() {\n            return this.cache_.source || {};\n        }\n\n        /**\n         * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4\n         * Can be used in conjunction with `currentType` to assist in rebuilding the current source object.\n         *\n         * @return {string}\n         *         The current source\n         */\n        currentSrc() {\n            return this.currentSource() && this.currentSource().src || '';\n        }\n\n        /**\n         * Get the current source type e.g. video/mp4\n         * This can allow you rebuild the current source object so that you could load the same\n         * source and tech later\n         *\n         * @return {string}\n         *         The source MIME type\n         */\n        currentType() {\n            return this.currentSource() && this.currentSource().type || '';\n        }\n\n        /**\n         * Get or set the preload attribute\n         *\n         * @param {boolean} [value]\n         *        - true means that we should preload\n         *        - false means that we should not preload\n         *\n         * @return {string}\n         *         The preload attribute value when getting\n         */\n        preload(value) {\n            if (value !== undefined) {\n                this.techCall_('setPreload', value);\n                this.options_.preload = value;\n                return;\n            }\n            return this.techGet_('preload');\n        }\n\n        /**\n         * Get or set the autoplay option. When this is a boolean it will\n         * modify the attribute on the tech. When this is a string the attribute on\n         * the tech will be removed and `Player` will handle autoplay on loadstarts.\n         *\n         * @param {boolean|string} [value]\n         *        - true: autoplay using the browser behavior\n         *        - false: do not autoplay\n         *        - 'play': call play() on every loadstart\n         *        - 'muted': call muted() then play() on every loadstart\n         *        - 'any': call play() on every loadstart. if that fails call muted() then play().\n         *        - *: values other than those listed here will be set `autoplay` to true\n         *\n         * @return {boolean|string}\n         *         The current value of autoplay when getting\n         */\n        autoplay(value) {\n            // getter usage\n            if (value === undefined) {\n                return this.options_.autoplay || false;\n            }\n            let techAutoplay;\n\n            // if the value is a valid string set it to that, or normalize `true` to 'play', if need be\n            if (typeof value === 'string' && /(any|play|muted)/.test(value) || value === true && this.options_.normalizeAutoplay) {\n                this.options_.autoplay = value;\n                this.manualAutoplay_(typeof value === 'string' ? value : 'play');\n                techAutoplay = false;\n\n                // any falsy value sets autoplay to false in the browser,\n                // lets do the same\n            } else if (!value) {\n                this.options_.autoplay = false;\n\n                // any other value (ie truthy) sets autoplay to true\n            } else {\n                this.options_.autoplay = true;\n            }\n            techAutoplay = typeof techAutoplay === 'undefined' ? this.options_.autoplay : techAutoplay;\n\n            // if we don't have a tech then we do not queue up\n            // a setAutoplay call on tech ready. We do this because the\n            // autoplay option will be passed in the constructor and we\n            // do not need to set it twice\n            if (this.tech_) {\n                this.techCall_('setAutoplay', techAutoplay);\n            }\n        }\n\n        /**\n         * Set or unset the playsinline attribute.\n         * Playsinline tells the browser that non-fullscreen playback is preferred.\n         *\n         * @param {boolean} [value]\n         *        - true means that we should try to play inline by default\n         *        - false means that we should use the browser's default playback mode,\n         *          which in most cases is inline. iOS Safari is a notable exception\n         *          and plays fullscreen by default.\n         *\n         * @return {string|Player}\n         *         - the current value of playsinline\n         *         - the player when setting\n         *\n         * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}\n         */\n        playsinline(value) {\n            if (value !== undefined) {\n                this.techCall_('setPlaysinline', value);\n                this.options_.playsinline = value;\n                return this;\n            }\n            return this.techGet_('playsinline');\n        }\n\n        /**\n         * Get or set the loop attribute on the video element.\n         *\n         * @param {boolean} [value]\n         *        - true means that we should loop the video\n         *        - false means that we should not loop the video\n         *\n         * @return {boolean}\n         *         The current value of loop when getting\n         */\n        loop(value) {\n            if (value !== undefined) {\n                this.techCall_('setLoop', value);\n                this.options_.loop = value;\n                return;\n            }\n            return this.techGet_('loop');\n        }\n\n        /**\n         * Get or set the poster image source url\n         *\n         * @fires Player#posterchange\n         *\n         * @param {string} [src]\n         *        Poster image source URL\n         *\n         * @return {string}\n         *         The current value of poster when getting\n         */\n        poster(src) {\n            if (src === undefined) {\n                return this.poster_;\n            }\n\n            // The correct way to remove a poster is to set as an empty string\n            // other falsey values will throw errors\n            if (!src) {\n                src = '';\n            }\n            if (src === this.poster_) {\n                return;\n            }\n\n            // update the internal poster variable\n            this.poster_ = src;\n\n            // update the tech's poster\n            this.techCall_('setPoster', src);\n            this.isPosterFromTech_ = false;\n\n            // alert components that the poster has been set\n            /**\n             * This event fires when the poster image is changed on the player.\n             *\n             * @event Player#posterchange\n             * @type {Event}\n             */\n            this.trigger('posterchange');\n        }\n\n        /**\n         * Some techs (e.g. YouTube) can provide a poster source in an\n         * asynchronous way. We want the poster component to use this\n         * poster source so that it covers up the tech's controls.\n         * (YouTube's play button). However we only want to use this\n         * source if the player user hasn't set a poster through\n         * the normal APIs.\n         *\n         * @fires Player#posterchange\n         * @listens Tech#posterchange\n         * @private\n         */\n        handleTechPosterChange_() {\n            if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {\n                const newPoster = this.tech_.poster() || '';\n                if (newPoster !== this.poster_) {\n                    this.poster_ = newPoster;\n                    this.isPosterFromTech_ = true;\n\n                    // Let components know the poster has changed\n                    this.trigger('posterchange');\n                }\n            }\n        }\n\n        /**\n         * Get or set whether or not the controls are showing.\n         *\n         * @fires Player#controlsenabled\n         *\n         * @param {boolean} [bool]\n         *        - true to turn controls on\n         *        - false to turn controls off\n         *\n         * @return {boolean}\n         *         The current value of controls when getting\n         */\n        controls(bool) {\n            if (bool === undefined) {\n                return !!this.controls_;\n            }\n            bool = !!bool;\n\n            // Don't trigger a change event unless it actually changed\n            if (this.controls_ === bool) {\n                return;\n            }\n            this.controls_ = bool;\n            if (this.usingNativeControls()) {\n                this.techCall_('setControls', bool);\n            }\n            if (this.controls_) {\n                this.removeClass('vjs-controls-disabled');\n                this.addClass('vjs-controls-enabled');\n                /**\n                 * @event Player#controlsenabled\n                 * @type {Event}\n                 */\n                this.trigger('controlsenabled');\n                if (!this.usingNativeControls()) {\n                    this.addTechControlsListeners_();\n                }\n            } else {\n                this.removeClass('vjs-controls-enabled');\n                this.addClass('vjs-controls-disabled');\n                /**\n                 * @event Player#controlsdisabled\n                 * @type {Event}\n                 */\n                this.trigger('controlsdisabled');\n                if (!this.usingNativeControls()) {\n                    this.removeTechControlsListeners_();\n                }\n            }\n        }\n\n        /**\n         * Toggle native controls on/off. Native controls are the controls built into\n         * devices (e.g. default iPhone controls) or other techs\n         * (e.g. Vimeo Controls)\n         * **This should only be set by the current tech, because only the tech knows\n         * if it can support native controls**\n         *\n         * @fires Player#usingnativecontrols\n         * @fires Player#usingcustomcontrols\n         *\n         * @param {boolean} [bool]\n         *        - true to turn native controls on\n         *        - false to turn native controls off\n         *\n         * @return {boolean}\n         *         The current value of native controls when getting\n         */\n        usingNativeControls(bool) {\n            if (bool === undefined) {\n                return !!this.usingNativeControls_;\n            }\n            bool = !!bool;\n\n            // Don't trigger a change event unless it actually changed\n            if (this.usingNativeControls_ === bool) {\n                return;\n            }\n            this.usingNativeControls_ = bool;\n            if (this.usingNativeControls_) {\n                this.addClass('vjs-using-native-controls');\n\n                /**\n                 * player is using the native device controls\n                 *\n                 * @event Player#usingnativecontrols\n                 * @type {Event}\n                 */\n                this.trigger('usingnativecontrols');\n            } else {\n                this.removeClass('vjs-using-native-controls');\n\n                /**\n                 * player is using the custom HTML controls\n                 *\n                 * @event Player#usingcustomcontrols\n                 * @type {Event}\n                 */\n                this.trigger('usingcustomcontrols');\n            }\n        }\n\n        /**\n         * Set or get the current MediaError\n         *\n         * @fires Player#error\n         *\n         * @param  {MediaError|string|number} [err]\n         *         A MediaError or a string/number to be turned\n         *         into a MediaError\n         *\n         * @return {MediaError|null}\n         *         The current MediaError when getting (or null)\n         */\n        error(err) {\n            if (err === undefined) {\n                return this.error_ || null;\n            }\n\n            // allow hooks to modify error object\n            hooks('beforeerror').forEach(hookFunction => {\n                const newErr = hookFunction(this, err);\n                if (!(isObject$1(newErr) && !Array.isArray(newErr) || typeof newErr === 'string' || typeof newErr === 'number' || newErr === null)) {\n                    this.log.error('please return a value that MediaError expects in beforeerror hooks');\n                    return;\n                }\n                err = newErr;\n            });\n\n            // Suppress the first error message for no compatible source until\n            // user interaction\n            if (this.options_.suppressNotSupportedError && err && err.code === 4) {\n                const triggerSuppressedError = function () {\n                    this.error(err);\n                };\n                this.options_.suppressNotSupportedError = false;\n                this.any(['click', 'touchstart'], triggerSuppressedError);\n                this.one('loadstart', function () {\n                    this.off(['click', 'touchstart'], triggerSuppressedError);\n                });\n                return;\n            }\n\n            // restoring to default\n            if (err === null) {\n                this.error_ = err;\n                this.removeClass('vjs-error');\n                if (this.errorDisplay) {\n                    this.errorDisplay.close();\n                }\n                return;\n            }\n            this.error_ = new MediaError(err);\n\n            // add the vjs-error classname to the player\n            this.addClass('vjs-error');\n\n            // log the name of the error type and any message\n            // IE11 logs \"[object object]\" and required you to expand message to see error object\n            log$1.error(`(CODE:${this.error_.code} ${MediaError.errorTypes[this.error_.code]})`, this.error_.message, this.error_);\n\n            /**\n             * @event Player#error\n             * @type {Event}\n             */\n            this.trigger('error');\n\n            // notify hooks of the per player error\n            hooks('error').forEach(hookFunction => hookFunction(this, this.error_));\n            return;\n        }\n\n        /**\n         * Report user activity\n         *\n         * @param {Object} event\n         *        Event object\n         */\n        reportUserActivity(event) {\n            this.userActivity_ = true;\n        }\n\n        /**\n         * Get/set if user is active\n         *\n         * @fires Player#useractive\n         * @fires Player#userinactive\n         *\n         * @param {boolean} [bool]\n         *        - true if the user is active\n         *        - false if the user is inactive\n         *\n         * @return {boolean}\n         *         The current value of userActive when getting\n         */\n        userActive(bool) {\n            if (bool === undefined) {\n                return this.userActive_;\n            }\n            bool = !!bool;\n            if (bool === this.userActive_) {\n                return;\n            }\n            this.userActive_ = bool;\n            if (this.userActive_) {\n                this.userActivity_ = true;\n                this.removeClass('vjs-user-inactive');\n                this.addClass('vjs-user-active');\n                /**\n                 * @event Player#useractive\n                 * @type {Event}\n                 */\n                this.trigger('useractive');\n                return;\n            }\n\n            // Chrome/Safari/IE have bugs where when you change the cursor it can\n            // trigger a mousemove event. This causes an issue when you're hiding\n            // the cursor when the user is inactive, and a mousemove signals user\n            // activity. Making it impossible to go into inactive mode. Specifically\n            // this happens in fullscreen when we really need to hide the cursor.\n            //\n            // When this gets resolved in ALL browsers it can be removed\n            // https://code.google.com/p/chromium/issues/detail?id=103041\n            if (this.tech_) {\n                this.tech_.one('mousemove', function (e) {\n                    e.stopPropagation();\n                    e.preventDefault();\n                });\n            }\n            this.userActivity_ = false;\n            this.removeClass('vjs-user-active');\n            this.addClass('vjs-user-inactive');\n            /**\n             * @event Player#userinactive\n             * @type {Event}\n             */\n            this.trigger('userinactive');\n        }\n\n        /**\n         * Listen for user activity based on timeout value\n         *\n         * @private\n         */\n        listenForUserActivity_() {\n            let mouseInProgress;\n            let lastMoveX;\n            let lastMoveY;\n            const handleActivity = bind_(this, this.reportUserActivity);\n            const handleMouseMove = function (e) {\n                // #1068 - Prevent mousemove spamming\n                // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970\n                if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {\n                    lastMoveX = e.screenX;\n                    lastMoveY = e.screenY;\n                    handleActivity();\n                }\n            };\n            const handleMouseDown = function () {\n                handleActivity();\n                // For as long as the they are touching the device or have their mouse down,\n                // we consider them active even if they're not moving their finger or mouse.\n                // So we want to continue to update that they are active\n                this.clearInterval(mouseInProgress);\n                // Setting userActivity=true now and setting the interval to the same time\n                // as the activityCheck interval (250) should ensure we never miss the\n                // next activityCheck\n                mouseInProgress = this.setInterval(handleActivity, 250);\n            };\n            const handleMouseUpAndMouseLeave = function (event) {\n                handleActivity();\n                // Stop the interval that maintains activity if the mouse/touch is down\n                this.clearInterval(mouseInProgress);\n            };\n\n            // Any mouse movement will be considered user activity\n            this.on('mousedown', handleMouseDown);\n            this.on('mousemove', handleMouseMove);\n            this.on('mouseup', handleMouseUpAndMouseLeave);\n            this.on('mouseleave', handleMouseUpAndMouseLeave);\n            const controlBar = this.getChild('controlBar');\n\n            // Fixes bug on Android & iOS where when tapping progressBar (when control bar is displayed)\n            // controlBar would no longer be hidden by default timeout.\n            if (controlBar && !IS_IOS && !IS_ANDROID) {\n                controlBar.on('mouseenter', function (event) {\n                    if (this.player().options_.inactivityTimeout !== 0) {\n                        this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout;\n                    }\n                    this.player().options_.inactivityTimeout = 0;\n                });\n                controlBar.on('mouseleave', function (event) {\n                    this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;\n                });\n            }\n\n            // Listen for keyboard navigation\n            // Shouldn't need to use inProgress interval because of key repeat\n            this.on('keydown', handleActivity);\n            this.on('keyup', handleActivity);\n\n            // Run an interval every 250 milliseconds instead of stuffing everything into\n            // the mousemove/touchmove function itself, to prevent performance degradation.\n            // `this.reportUserActivity` simply sets this.userActivity_ to true, which\n            // then gets picked up by this loop\n            // http://ejohn.org/blog/learning-from-twitter/\n            let inactivityTimeout;\n            this.setInterval(function () {\n                // Check to see if mouse/touch activity has happened\n                if (!this.userActivity_) {\n                    return;\n                }\n\n                // Reset the activity tracker\n                this.userActivity_ = false;\n\n                // If the user state was inactive, set the state to active\n                this.userActive(true);\n\n                // Clear any existing inactivity timeout to start the timer over\n                this.clearTimeout(inactivityTimeout);\n                const timeout = this.options_.inactivityTimeout;\n                if (timeout <= 0) {\n                    return;\n                }\n\n                // In <timeout> milliseconds, if no more activity has occurred the\n                // user will be considered inactive\n                inactivityTimeout = this.setTimeout(function () {\n                    // Protect against the case where the inactivityTimeout can trigger just\n                    // before the next user activity is picked up by the activity check loop\n                    // causing a flicker\n                    if (!this.userActivity_) {\n                        this.userActive(false);\n                    }\n                }, timeout);\n            }, 250);\n        }\n\n        /**\n         * Gets or sets the current playback rate. A playback rate of\n         * 1.0 represents normal speed and 0.5 would indicate half-speed\n         * playback, for instance.\n         *\n         * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate\n         *\n         * @param {number} [rate]\n         *       New playback rate to set.\n         *\n         * @return {number}\n         *         The current playback rate when getting or 1.0\n         */\n        playbackRate(rate) {\n            if (rate !== undefined) {\n                // NOTE: this.cache_.lastPlaybackRate is set from the tech handler\n                // that is registered above\n                this.techCall_('setPlaybackRate', rate);\n                return;\n            }\n            if (this.tech_ && this.tech_.featuresPlaybackRate) {\n                return this.cache_.lastPlaybackRate || this.techGet_('playbackRate');\n            }\n            return 1.0;\n        }\n\n        /**\n         * Gets or sets the current default playback rate. A default playback rate of\n         * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.\n         * defaultPlaybackRate will only represent what the initial playbackRate of a video was, not\n         * not the current playbackRate.\n         *\n         * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate\n         *\n         * @param {number} [rate]\n         *       New default playback rate to set.\n         *\n         * @return {number|Player}\n         *         - The default playback rate when getting or 1.0\n         *         - the player when setting\n         */\n        defaultPlaybackRate(rate) {\n            if (rate !== undefined) {\n                return this.techCall_('setDefaultPlaybackRate', rate);\n            }\n            if (this.tech_ && this.tech_.featuresPlaybackRate) {\n                return this.techGet_('defaultPlaybackRate');\n            }\n            return 1.0;\n        }\n\n        /**\n         * Gets or sets the audio flag\n         *\n         * @param {boolean} bool\n         *        - true signals that this is an audio player\n         *        - false signals that this is not an audio player\n         *\n         * @return {boolean}\n         *         The current value of isAudio when getting\n         */\n        isAudio(bool) {\n            if (bool !== undefined) {\n                this.isAudio_ = !!bool;\n                return;\n            }\n            return !!this.isAudio_;\n        }\n        enableAudioOnlyUI_() {\n            // Update styling immediately to show the control bar so we can get its height\n            this.addClass('vjs-audio-only-mode');\n            const playerChildren = this.children();\n            const controlBar = this.getChild('ControlBar');\n            const controlBarHeight = controlBar && controlBar.currentHeight();\n\n            // Hide all player components except the control bar. Control bar components\n            // needed only for video are hidden with CSS\n            playerChildren.forEach(child => {\n                if (child === controlBar) {\n                    return;\n                }\n                if (child.el_ && !child.hasClass('vjs-hidden')) {\n                    child.hide();\n                    this.audioOnlyCache_.hiddenChildren.push(child);\n                }\n            });\n            this.audioOnlyCache_.playerHeight = this.currentHeight();\n\n            // Set the player height the same as the control bar\n            this.height(controlBarHeight);\n            this.trigger('audioonlymodechange');\n        }\n        disableAudioOnlyUI_() {\n            this.removeClass('vjs-audio-only-mode');\n\n            // Show player components that were previously hidden\n            this.audioOnlyCache_.hiddenChildren.forEach(child => child.show());\n\n            // Reset player height\n            this.height(this.audioOnlyCache_.playerHeight);\n            this.trigger('audioonlymodechange');\n        }\n\n        /**\n         * Get the current audioOnlyMode state or set audioOnlyMode to true or false.\n         *\n         * Setting this to `true` will hide all player components except the control bar,\n         * as well as control bar components needed only for video.\n         *\n         * @param {boolean} [value]\n         *         The value to set audioOnlyMode to.\n         *\n         * @return {Promise|boolean}\n         *        A Promise is returned when setting the state, and a boolean when getting\n         *        the present state\n         */\n        audioOnlyMode(value) {\n            if (typeof value !== 'boolean' || value === this.audioOnlyMode_) {\n                return this.audioOnlyMode_;\n            }\n            this.audioOnlyMode_ = value;\n\n            // Enable Audio Only Mode\n            if (value) {\n                const exitPromises = [];\n\n                // Fullscreen and PiP are not supported in audioOnlyMode, so exit if we need to.\n                if (this.isInPictureInPicture()) {\n                    exitPromises.push(this.exitPictureInPicture());\n                }\n                if (this.isFullscreen()) {\n                    exitPromises.push(this.exitFullscreen());\n                }\n                if (this.audioPosterMode()) {\n                    exitPromises.push(this.audioPosterMode(false));\n                }\n                return Promise.all(exitPromises).then(() => this.enableAudioOnlyUI_());\n            }\n\n            // Disable Audio Only Mode\n            return Promise.resolve().then(() => this.disableAudioOnlyUI_());\n        }\n        enablePosterModeUI_() {\n            // Hide the video element and show the poster image to enable posterModeUI\n            const tech = this.tech_ && this.tech_;\n            tech.hide();\n            this.addClass('vjs-audio-poster-mode');\n            this.trigger('audiopostermodechange');\n        }\n        disablePosterModeUI_() {\n            // Show the video element and hide the poster image to disable posterModeUI\n            const tech = this.tech_ && this.tech_;\n            tech.show();\n            this.removeClass('vjs-audio-poster-mode');\n            this.trigger('audiopostermodechange');\n        }\n\n        /**\n         * Get the current audioPosterMode state or set audioPosterMode to true or false\n         *\n         * @param {boolean} [value]\n         *         The value to set audioPosterMode to.\n         *\n         * @return {Promise|boolean}\n         *         A Promise is returned when setting the state, and a boolean when getting\n         *        the present state\n         */\n        audioPosterMode(value) {\n            if (typeof value !== 'boolean' || value === this.audioPosterMode_) {\n                return this.audioPosterMode_;\n            }\n            this.audioPosterMode_ = value;\n            if (value) {\n                if (this.audioOnlyMode()) {\n                    const audioOnlyModePromise = this.audioOnlyMode(false);\n                    return audioOnlyModePromise.then(() => {\n                        // enable audio poster mode after audio only mode is disabled\n                        this.enablePosterModeUI_();\n                    });\n                }\n                return Promise.resolve().then(() => {\n                    // enable audio poster mode\n                    this.enablePosterModeUI_();\n                });\n            }\n            return Promise.resolve().then(() => {\n                // disable audio poster mode\n                this.disablePosterModeUI_();\n            });\n        }\n\n        /**\n         * A helper method for adding a {@link TextTrack} to our\n         * {@link TextTrackList}.\n         *\n         * In addition to the W3C settings we allow adding additional info through options.\n         *\n         * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack\n         *\n         * @param {string} [kind]\n         *        the kind of TextTrack you are adding\n         *\n         * @param {string} [label]\n         *        the label to give the TextTrack label\n         *\n         * @param {string} [language]\n         *        the language to set on the TextTrack\n         *\n         * @return {TextTrack|undefined}\n         *         the TextTrack that was added or undefined\n         *         if there is no tech\n         */\n        addTextTrack(kind, label, language) {\n            if (this.tech_) {\n                return this.tech_.addTextTrack(kind, label, language);\n            }\n        }\n\n        /**\n         * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}.\n         *\n         * @param {Object} options\n         *        Options to pass to {@link HTMLTrackElement} during creation. See\n         *        {@link HTMLTrackElement} for object properties that you should use.\n         *\n         * @param {boolean} [manualCleanup=false] if set to true, the TextTrack will not be removed\n         *                                        from the TextTrackList and HtmlTrackElementList\n         *                                        after a source change\n         *\n         * @return { import('./tracks/html-track-element').default }\n         *         the HTMLTrackElement that was created and added\n         *         to the HtmlTrackElementList and the remote\n         *         TextTrackList\n         *\n         */\n        addRemoteTextTrack(options, manualCleanup) {\n            if (this.tech_) {\n                return this.tech_.addRemoteTextTrack(options, manualCleanup);\n            }\n        }\n\n        /**\n         * Remove a remote {@link TextTrack} from the respective\n         * {@link TextTrackList} and {@link HtmlTrackElementList}.\n         *\n         * @param {Object} track\n         *        Remote {@link TextTrack} to remove\n         *\n         * @return {undefined}\n         *         does not return anything\n         */\n        removeRemoteTextTrack(obj = {}) {\n            let {\n                track\n            } = obj;\n            if (!track) {\n                track = obj;\n            }\n\n            // destructure the input into an object with a track argument, defaulting to arguments[0]\n            // default the whole argument to an empty object if nothing was passed in\n\n            if (this.tech_) {\n                return this.tech_.removeRemoteTextTrack(track);\n            }\n        }\n\n        /**\n         * Gets available media playback quality metrics as specified by the W3C's Media\n         * Playback Quality API.\n         *\n         * @see [Spec]{@link https://wicg.github.io/media-playback-quality}\n         *\n         * @return {Object|undefined}\n         *         An object with supported media playback quality metrics or undefined if there\n         *         is no tech or the tech does not support it.\n         */\n        getVideoPlaybackQuality() {\n            return this.techGet_('getVideoPlaybackQuality');\n        }\n\n        /**\n         * Get video width\n         *\n         * @return {number}\n         *         current video width\n         */\n        videoWidth() {\n            return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;\n        }\n\n        /**\n         * Get video height\n         *\n         * @return {number}\n         *         current video height\n         */\n        videoHeight() {\n            return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;\n        }\n\n        /**\n         * The player's language code.\n         *\n         * Changing the language will trigger\n         * [languagechange]{@link Player#event:languagechange}\n         * which Components can use to update control text.\n         * ClickableComponent will update its control text by default on\n         * [languagechange]{@link Player#event:languagechange}.\n         *\n         * @fires Player#languagechange\n         *\n         * @param {string} [code]\n         *        the language code to set the player to\n         *\n         * @return {string}\n         *         The current language code when getting\n         */\n        language(code) {\n            if (code === undefined) {\n                return this.language_;\n            }\n            if (this.language_ !== String(code).toLowerCase()) {\n                this.language_ = String(code).toLowerCase();\n\n                // during first init, it's possible some things won't be evented\n                if (isEvented(this)) {\n                    /**\n                     * fires when the player language change\n                     *\n                     * @event Player#languagechange\n                     * @type {Event}\n                     */\n                    this.trigger('languagechange');\n                }\n            }\n        }\n\n        /**\n         * Get the player's language dictionary\n         * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time\n         * Languages specified directly in the player options have precedence\n         *\n         * @return {Array}\n         *         An array of of supported languages\n         */\n        languages() {\n            return merge$2(Player.prototype.options_.languages, this.languages_);\n        }\n\n        /**\n         * returns a JavaScript object representing the current track\n         * information. **DOES not return it as JSON**\n         *\n         * @return {Object}\n         *         Object representing the current of track info\n         */\n        toJSON() {\n            const options = merge$2(this.options_);\n            const tracks = options.tracks;\n            options.tracks = [];\n            for (let i = 0; i < tracks.length; i++) {\n                let track = tracks[i];\n\n                // deep merge tracks and null out player so no circular references\n                track = merge$2(track);\n                track.player = undefined;\n                options.tracks[i] = track;\n            }\n            return options;\n        }\n\n        /**\n         * Creates a simple modal dialog (an instance of the {@link ModalDialog}\n         * component) that immediately overlays the player with arbitrary\n         * content and removes itself when closed.\n         *\n         * @param {string|Function|Element|Array|null} content\n         *        Same as {@link ModalDialog#content}'s param of the same name.\n         *        The most straight-forward usage is to provide a string or DOM\n         *        element.\n         *\n         * @param {Object} [options]\n         *        Extra options which will be passed on to the {@link ModalDialog}.\n         *\n         * @return {ModalDialog}\n         *         the {@link ModalDialog} that was created\n         */\n        createModal(content, options) {\n            options = options || {};\n            options.content = content || '';\n            const modal = new ModalDialog(this, options);\n            this.addChild(modal);\n            modal.on('dispose', () => {\n                this.removeChild(modal);\n            });\n            modal.open();\n            return modal;\n        }\n\n        /**\n         * Change breakpoint classes when the player resizes.\n         *\n         * @private\n         */\n        updateCurrentBreakpoint_() {\n            if (!this.responsive()) {\n                return;\n            }\n            const currentBreakpoint = this.currentBreakpoint();\n            const currentWidth = this.currentWidth();\n            for (let i = 0; i < BREAKPOINT_ORDER.length; i++) {\n                const candidateBreakpoint = BREAKPOINT_ORDER[i];\n                const maxWidth = this.breakpoints_[candidateBreakpoint];\n                if (currentWidth <= maxWidth) {\n                    // The current breakpoint did not change, nothing to do.\n                    if (currentBreakpoint === candidateBreakpoint) {\n                        return;\n                    }\n\n                    // Only remove a class if there is a current breakpoint.\n                    if (currentBreakpoint) {\n                        this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]);\n                    }\n                    this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]);\n                    this.breakpoint_ = candidateBreakpoint;\n                    break;\n                }\n            }\n        }\n\n        /**\n         * Removes the current breakpoint.\n         *\n         * @private\n         */\n        removeCurrentBreakpoint_() {\n            const className = this.currentBreakpointClass();\n            this.breakpoint_ = '';\n            if (className) {\n                this.removeClass(className);\n            }\n        }\n\n        /**\n         * Get or set breakpoints on the player.\n         *\n         * Calling this method with an object or `true` will remove any previous\n         * custom breakpoints and start from the defaults again.\n         *\n         * @param  {Object|boolean} [breakpoints]\n         *         If an object is given, it can be used to provide custom\n         *         breakpoints. If `true` is given, will set default breakpoints.\n         *         If this argument is not given, will simply return the current\n         *         breakpoints.\n         *\n         * @param  {number} [breakpoints.tiny]\n         *         The maximum width for the \"vjs-layout-tiny\" class.\n         *\n         * @param  {number} [breakpoints.xsmall]\n         *         The maximum width for the \"vjs-layout-x-small\" class.\n         *\n         * @param  {number} [breakpoints.small]\n         *         The maximum width for the \"vjs-layout-small\" class.\n         *\n         * @param  {number} [breakpoints.medium]\n         *         The maximum width for the \"vjs-layout-medium\" class.\n         *\n         * @param  {number} [breakpoints.large]\n         *         The maximum width for the \"vjs-layout-large\" class.\n         *\n         * @param  {number} [breakpoints.xlarge]\n         *         The maximum width for the \"vjs-layout-x-large\" class.\n         *\n         * @param  {number} [breakpoints.huge]\n         *         The maximum width for the \"vjs-layout-huge\" class.\n         *\n         * @return {Object}\n         *         An object mapping breakpoint names to maximum width values.\n         */\n        breakpoints(breakpoints) {\n            // Used as a getter.\n            if (breakpoints === undefined) {\n                return Object.assign(this.breakpoints_);\n            }\n            this.breakpoint_ = '';\n            this.breakpoints_ = Object.assign({}, DEFAULT_BREAKPOINTS, breakpoints);\n\n            // When breakpoint definitions change, we need to update the currently\n            // selected breakpoint.\n            this.updateCurrentBreakpoint_();\n\n            // Clone the breakpoints before returning.\n            return Object.assign(this.breakpoints_);\n        }\n\n        /**\n         * Get or set a flag indicating whether or not this player should adjust\n         * its UI based on its dimensions.\n         *\n         * @param  {boolean} value\n         *         Should be `true` if the player should adjust its UI based on its\n         *         dimensions; otherwise, should be `false`.\n         *\n         * @return {boolean}\n         *         Will be `true` if this player should adjust its UI based on its\n         *         dimensions; otherwise, will be `false`.\n         */\n        responsive(value) {\n            // Used as a getter.\n            if (value === undefined) {\n                return this.responsive_;\n            }\n            value = Boolean(value);\n            const current = this.responsive_;\n\n            // Nothing changed.\n            if (value === current) {\n                return;\n            }\n\n            // The value actually changed, set it.\n            this.responsive_ = value;\n\n            // Start listening for breakpoints and set the initial breakpoint if the\n            // player is now responsive.\n            if (value) {\n                this.on('playerresize', this.boundUpdateCurrentBreakpoint_);\n                this.updateCurrentBreakpoint_();\n\n                // Stop listening for breakpoints if the player is no longer responsive.\n            } else {\n                this.off('playerresize', this.boundUpdateCurrentBreakpoint_);\n                this.removeCurrentBreakpoint_();\n            }\n            return value;\n        }\n\n        /**\n         * Get current breakpoint name, if any.\n         *\n         * @return {string}\n         *         If there is currently a breakpoint set, returns a the key from the\n         *         breakpoints object matching it. Otherwise, returns an empty string.\n         */\n        currentBreakpoint() {\n            return this.breakpoint_;\n        }\n\n        /**\n         * Get the current breakpoint class name.\n         *\n         * @return {string}\n         *         The matching class name (e.g. `\"vjs-layout-tiny\"` or\n         *         `\"vjs-layout-large\"`) for the current breakpoint. Empty string if\n         *         there is no current breakpoint.\n         */\n        currentBreakpointClass() {\n            return BREAKPOINT_CLASSES[this.breakpoint_] || '';\n        }\n\n        /**\n         * An object that describes a single piece of media.\n         *\n         * Properties that are not part of this type description will be retained; so,\n         * this can be viewed as a generic metadata storage mechanism as well.\n         *\n         * @see      {@link https://wicg.github.io/mediasession/#the-mediametadata-interface}\n         * @typedef  {Object} Player~MediaObject\n         *\n         * @property {string} [album]\n         *           Unused, except if this object is passed to the `MediaSession`\n         *           API.\n         *\n         * @property {string} [artist]\n         *           Unused, except if this object is passed to the `MediaSession`\n         *           API.\n         *\n         * @property {Object[]} [artwork]\n         *           Unused, except if this object is passed to the `MediaSession`\n         *           API. If not specified, will be populated via the `poster`, if\n         *           available.\n         *\n         * @property {string} [poster]\n         *           URL to an image that will display before playback.\n         *\n         * @property {Tech~SourceObject|Tech~SourceObject[]|string} [src]\n         *           A single source object, an array of source objects, or a string\n         *           referencing a URL to a media source. It is _highly recommended_\n         *           that an object or array of objects is used here, so that source\n         *           selection algorithms can take the `type` into account.\n         *\n         * @property {string} [title]\n         *           Unused, except if this object is passed to the `MediaSession`\n         *           API.\n         *\n         * @property {Object[]} [textTracks]\n         *           An array of objects to be used to create text tracks, following\n         *           the {@link https://www.w3.org/TR/html50/embedded-content-0.html#the-track-element|native track element format}.\n         *           For ease of removal, these will be created as \"remote\" text\n         *           tracks and set to automatically clean up on source changes.\n         *\n         *           These objects may have properties like `src`, `kind`, `label`,\n         *           and `language`, see {@link Tech#createRemoteTextTrack}.\n         */\n\n        /**\n         * Populate the player using a {@link Player~MediaObject|MediaObject}.\n         *\n         * @param  {Player~MediaObject} media\n         *         A media object.\n         *\n         * @param  {Function} ready\n         *         A callback to be called when the player is ready.\n         */\n        loadMedia(media, ready) {\n            if (!media || typeof media !== 'object') {\n                return;\n            }\n            this.reset();\n\n            // Clone the media object so it cannot be mutated from outside.\n            this.cache_.media = merge$2(media);\n            const {\n                artist,\n                artwork,\n                description,\n                poster,\n                src,\n                textTracks,\n                title\n            } = this.cache_.media;\n\n            // If `artwork` is not given, create it using `poster`.\n            if (!artwork && poster) {\n                this.cache_.media.artwork = [{\n                    src: poster,\n                    type: getMimetype(poster)\n                }];\n            }\n            if (src) {\n                this.src(src);\n            }\n            if (poster) {\n                this.poster(poster);\n            }\n            if (Array.isArray(textTracks)) {\n                textTracks.forEach(tt => this.addRemoteTextTrack(tt, false));\n            }\n            if (this.titleBar) {\n                this.titleBar.update({\n                    title,\n                    description: description || artist || ''\n                });\n            }\n            this.ready(ready);\n        }\n\n        /**\n         * Get a clone of the current {@link Player~MediaObject} for this player.\n         *\n         * If the `loadMedia` method has not been used, will attempt to return a\n         * {@link Player~MediaObject} based on the current state of the player.\n         *\n         * @return {Player~MediaObject}\n         */\n        getMedia() {\n            if (!this.cache_.media) {\n                const poster = this.poster();\n                const src = this.currentSources();\n                const textTracks = Array.prototype.map.call(this.remoteTextTracks(), tt => ({\n                    kind: tt.kind,\n                    label: tt.label,\n                    language: tt.language,\n                    src: tt.src\n                }));\n                const media = {\n                    src,\n                    textTracks\n                };\n                if (poster) {\n                    media.poster = poster;\n                    media.artwork = [{\n                        src: media.poster,\n                        type: getMimetype(media.poster)\n                    }];\n                }\n                return media;\n            }\n            return merge$2(this.cache_.media);\n        }\n\n        /**\n         * Gets tag settings\n         *\n         * @param {Element} tag\n         *        The player tag\n         *\n         * @return {Object}\n         *         An object containing all of the settings\n         *         for a player tag\n         */\n        static getTagSettings(tag) {\n            const baseOptions = {\n                sources: [],\n                tracks: []\n            };\n            const tagOptions = getAttributes(tag);\n            const dataSetup = tagOptions['data-setup'];\n            if (hasClass(tag, 'vjs-fill')) {\n                tagOptions.fill = true;\n            }\n            if (hasClass(tag, 'vjs-fluid')) {\n                tagOptions.fluid = true;\n            }\n\n            // Check if data-setup attr exists.\n            if (dataSetup !== null) {\n                // Parse options JSON\n                // If empty string, make it a parsable json object.\n                const [err, data] = tuple(dataSetup || '{}');\n                if (err) {\n                    log$1.error(err);\n                }\n                Object.assign(tagOptions, data);\n            }\n            Object.assign(baseOptions, tagOptions);\n\n            // Get tag children settings\n            if (tag.hasChildNodes()) {\n                const children = tag.childNodes;\n                for (let i = 0, j = children.length; i < j; i++) {\n                    const child = children[i];\n                    // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/\n                    const childName = child.nodeName.toLowerCase();\n                    if (childName === 'source') {\n                        baseOptions.sources.push(getAttributes(child));\n                    } else if (childName === 'track') {\n                        baseOptions.tracks.push(getAttributes(child));\n                    }\n                }\n            }\n            return baseOptions;\n        }\n\n        /**\n         * Set debug mode to enable/disable logs at info level.\n         *\n         * @param {boolean} enabled\n         * @fires Player#debugon\n         * @fires Player#debugoff\n         */\n        debug(enabled) {\n            if (enabled === undefined) {\n                return this.debugEnabled_;\n            }\n            if (enabled) {\n                this.trigger('debugon');\n                this.previousLogLevel_ = this.log.level;\n                this.log.level('debug');\n                this.debugEnabled_ = true;\n            } else {\n                this.trigger('debugoff');\n                this.log.level(this.previousLogLevel_);\n                this.previousLogLevel_ = undefined;\n                this.debugEnabled_ = false;\n            }\n        }\n\n        /**\n         * Set or get current playback rates.\n         * Takes an array and updates the playback rates menu with the new items.\n         * Pass in an empty array to hide the menu.\n         * Values other than arrays are ignored.\n         *\n         * @fires Player#playbackrateschange\n         * @param {number[]} newRates\n         *                   The new rates that the playback rates menu should update to.\n         *                   An empty array will hide the menu\n         * @return {number[]} When used as a getter will return the current playback rates\n         */\n        playbackRates(newRates) {\n            if (newRates === undefined) {\n                return this.cache_.playbackRates;\n            }\n\n            // ignore any value that isn't an array\n            if (!Array.isArray(newRates)) {\n                return;\n            }\n\n            // ignore any arrays that don't only contain numbers\n            if (!newRates.every(rate => typeof rate === 'number')) {\n                return;\n            }\n            this.cache_.playbackRates = newRates;\n\n            /**\n             * fires when the playback rates in a player are changed\n             *\n             * @event Player#playbackrateschange\n             * @type {Event}\n             */\n            this.trigger('playbackrateschange');\n        }\n    }\n\n    /**\n     * Get the {@link VideoTrackList}\n     *\n     * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist\n     *\n     * @return {VideoTrackList}\n     *         the current video track list\n     *\n     * @method Player.prototype.videoTracks\n     */\n\n    /**\n     * Get the {@link AudioTrackList}\n     *\n     * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist\n     *\n     * @return {AudioTrackList}\n     *         the current audio track list\n     *\n     * @method Player.prototype.audioTracks\n     */\n\n    /**\n     * Get the {@link TextTrackList}\n     *\n     * @link http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks\n     *\n     * @return {TextTrackList}\n     *         the current text track list\n     *\n     * @method Player.prototype.textTracks\n     */\n\n    /**\n     * Get the remote {@link TextTrackList}\n     *\n     * @return {TextTrackList}\n     *         The current remote text track list\n     *\n     * @method Player.prototype.remoteTextTracks\n     */\n\n    /**\n     * Get the remote {@link HtmlTrackElementList} tracks.\n     *\n     * @return {HtmlTrackElementList}\n     *         The current remote text track element list\n     *\n     * @method Player.prototype.remoteTextTrackEls\n     */\n\n    ALL.names.forEach(function (name) {\n        const props = ALL[name];\n        Player.prototype[props.getterName] = function () {\n            if (this.tech_) {\n                return this.tech_[props.getterName]();\n            }\n\n            // if we have not yet loadTech_, we create {video,audio,text}Tracks_\n            // these will be passed to the tech during loading\n            this[props.privateName] = this[props.privateName] || new props.ListClass();\n            return this[props.privateName];\n        };\n    });\n\n    /**\n     * Get or set the `Player`'s crossorigin option. For the HTML5 player, this\n     * sets the `crossOrigin` property on the `<video>` tag to control the CORS\n     * behavior.\n     *\n     * @see [Video Element Attributes]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#attr-crossorigin}\n     *\n     * @param {string} [value]\n     *        The value to set the `Player`'s crossorigin to. If an argument is\n     *        given, must be one of `anonymous` or `use-credentials`.\n     *\n     * @return {string|undefined}\n     *         - The current crossorigin value of the `Player` when getting.\n     *         - undefined when setting\n     */\n    Player.prototype.crossorigin = Player.prototype.crossOrigin;\n\n    /**\n     * Global enumeration of players.\n     *\n     * The keys are the player IDs and the values are either the {@link Player}\n     * instance or `null` for disposed players.\n     *\n     * @type {Object}\n     */\n    Player.players = {};\n    const navigator = window.navigator;\n\n    /*\n   * Player instance options, surfaced using options\n   * options = Player.prototype.options_\n   * Make changes in options, not here.\n   *\n   * @type {Object}\n   * @private\n   */\n    Player.prototype.options_ = {\n        // Default order of fallback technology\n        techOrder: Tech.defaultTechOrder_,\n        html5: {},\n        // enable sourceset by default\n        enableSourceset: true,\n        // default inactivity timeout\n        inactivityTimeout: 2000,\n        // default playback rates\n        playbackRates: [],\n        // Add playback rate selection by adding rates\n        // 'playbackRates': [0.5, 1, 1.5, 2],\n        liveui: false,\n        // Included control sets\n        children: ['mediaLoader', 'posterImage', 'titleBar', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'liveTracker', 'controlBar', 'errorDisplay', 'textTrackSettings', 'resizeManager'],\n        language: navigator && (navigator.languages && navigator.languages[0] || navigator.userLanguage || navigator.language) || 'en',\n        // locales and their language translations\n        languages: {},\n        // Default message to show when a video cannot be played.\n        notSupportedMessage: 'No compatible source was found for this media.',\n        normalizeAutoplay: false,\n        fullscreen: {\n            options: {\n                navigationUI: 'hide'\n            }\n        },\n        breakpoints: {},\n        responsive: false,\n        audioOnlyMode: false,\n        audioPosterMode: false\n    };\n    [\n        /**\n         * Returns whether or not the player is in the \"ended\" state.\n         *\n         * @return {Boolean} True if the player is in the ended state, false if not.\n         * @method Player#ended\n         */\n        'ended',\n        /**\n         * Returns whether or not the player is in the \"seeking\" state.\n         *\n         * @return {Boolean} True if the player is in the seeking state, false if not.\n         * @method Player#seeking\n         */\n        'seeking',\n        /**\n         * Returns the TimeRanges of the media that are currently available\n         * for seeking to.\n         *\n         * @return {TimeRanges} the seekable intervals of the media timeline\n         * @method Player#seekable\n         */\n        'seekable',\n        /**\n         * Returns the current state of network activity for the element, from\n         * the codes in the list below.\n         * - NETWORK_EMPTY (numeric value 0)\n         *   The element has not yet been initialised. All attributes are in\n         *   their initial states.\n         * - NETWORK_IDLE (numeric value 1)\n         *   The element's resource selection algorithm is active and has\n         *   selected a resource, but it is not actually using the network at\n         *   this time.\n         * - NETWORK_LOADING (numeric value 2)\n         *   The user agent is actively trying to download data.\n         * - NETWORK_NO_SOURCE (numeric value 3)\n         *   The element's resource selection algorithm is active, but it has\n         *   not yet found a resource to use.\n         *\n         * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states\n         * @return {number} the current network activity state\n         * @method Player#networkState\n         */\n        'networkState',\n        /**\n         * Returns a value that expresses the current state of the element\n         * with respect to rendering the current playback position, from the\n         * codes in the list below.\n         * - HAVE_NOTHING (numeric value 0)\n         *   No information regarding the media resource is available.\n         * - HAVE_METADATA (numeric value 1)\n         *   Enough of the resource has been obtained that the duration of the\n         *   resource is available.\n         * - HAVE_CURRENT_DATA (numeric value 2)\n         *   Data for the immediate current playback position is available.\n         * - HAVE_FUTURE_DATA (numeric value 3)\n         *   Data for the immediate current playback position is available, as\n         *   well as enough data for the user agent to advance the current\n         *   playback position in the direction of playback.\n         * - HAVE_ENOUGH_DATA (numeric value 4)\n         *   The user agent estimates that enough data is available for\n         *   playback to proceed uninterrupted.\n         *\n         * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate\n         * @return {number} the current playback rendering state\n         * @method Player#readyState\n         */\n        'readyState'].forEach(function (fn) {\n        Player.prototype[fn] = function () {\n            return this.techGet_(fn);\n        };\n    });\n    TECH_EVENTS_RETRIGGER.forEach(function (event) {\n        Player.prototype[`handleTech${toTitleCase$1(event)}_`] = function () {\n            return this.trigger(event);\n        };\n    });\n\n    /**\n     * Fired when the player has initial duration and dimension information\n     *\n     * @event Player#loadedmetadata\n     * @type {Event}\n     */\n\n    /**\n     * Fired when the player has downloaded data at the current playback position\n     *\n     * @event Player#loadeddata\n     * @type {Event}\n     */\n\n    /**\n     * Fired when the current playback position has changed *\n     * During playback this is fired every 15-250 milliseconds, depending on the\n     * playback technology in use.\n     *\n     * @event Player#timeupdate\n     * @type {Event}\n     */\n\n    /**\n     * Fired when the volume changes\n     *\n     * @event Player#volumechange\n     * @type {Event}\n     */\n\n    /**\n     * Reports whether or not a player has a plugin available.\n     *\n     * This does not report whether or not the plugin has ever been initialized\n     * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.\n     *\n     * @method Player#hasPlugin\n     * @param  {string}  name\n     *         The name of a plugin.\n     *\n     * @return {boolean}\n     *         Whether or not this player has the requested plugin available.\n     */\n\n    /**\n     * Reports whether or not a player is using a plugin by name.\n     *\n     * For basic plugins, this only reports whether the plugin has _ever_ been\n     * initialized on this player.\n     *\n     * @method Player#usingPlugin\n     * @param  {string} name\n     *         The name of a plugin.\n     *\n     * @return {boolean}\n     *         Whether or not this player is using the requested plugin.\n     */\n\n    Component$1.registerComponent('Player', Player);\n\n    /**\n     * @file plugin.js\n     */\n\n    /**\n     * The base plugin name.\n     *\n     * @private\n     * @constant\n     * @type {string}\n     */\n    const BASE_PLUGIN_NAME = 'plugin';\n\n    /**\n     * The key on which a player's active plugins cache is stored.\n     *\n     * @private\n     * @constant\n     * @type     {string}\n     */\n    const PLUGIN_CACHE_KEY = 'activePlugins_';\n\n    /**\n     * Stores registered plugins in a private space.\n     *\n     * @private\n     * @type    {Object}\n     */\n    const pluginStorage = {};\n\n    /**\n     * Reports whether or not a plugin has been registered.\n     *\n     * @private\n     * @param   {string} name\n     *          The name of a plugin.\n     *\n     * @return {boolean}\n     *          Whether or not the plugin has been registered.\n     */\n    const pluginExists = name => pluginStorage.hasOwnProperty(name);\n\n    /**\n     * Get a single registered plugin by name.\n     *\n     * @private\n     * @param   {string} name\n     *          The name of a plugin.\n     *\n     * @return {typeof Plugin|Function|undefined}\n     *          The plugin (or undefined).\n     */\n    const getPlugin = name => pluginExists(name) ? pluginStorage[name] : undefined;\n\n    /**\n     * Marks a plugin as \"active\" on a player.\n     *\n     * Also, ensures that the player has an object for tracking active plugins.\n     *\n     * @private\n     * @param   {Player} player\n     *          A Video.js player instance.\n     *\n     * @param   {string} name\n     *          The name of a plugin.\n     */\n    const markPluginAsActive = (player, name) => {\n        player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};\n        player[PLUGIN_CACHE_KEY][name] = true;\n    };\n\n    /**\n     * Triggers a pair of plugin setup events.\n     *\n     * @private\n     * @param  {Player} player\n     *         A Video.js player instance.\n     *\n     * @param  {Plugin~PluginEventHash} hash\n     *         A plugin event hash.\n     *\n     * @param  {boolean} [before]\n     *         If true, prefixes the event name with \"before\". In other words,\n     *         use this to trigger \"beforepluginsetup\" instead of \"pluginsetup\".\n     */\n    const triggerSetupEvent = (player, hash, before) => {\n        const eventName = (before ? 'before' : '') + 'pluginsetup';\n        player.trigger(eventName, hash);\n        player.trigger(eventName + ':' + hash.name, hash);\n    };\n\n    /**\n     * Takes a basic plugin function and returns a wrapper function which marks\n     * on the player that the plugin has been activated.\n     *\n     * @private\n     * @param   {string} name\n     *          The name of the plugin.\n     *\n     * @param   {Function} plugin\n     *          The basic plugin.\n     *\n     * @return {Function}\n     *          A wrapper function for the given plugin.\n     */\n    const createBasicPlugin = function (name, plugin) {\n        const basicPluginWrapper = function () {\n            // We trigger the \"beforepluginsetup\" and \"pluginsetup\" events on the player\n            // regardless, but we want the hash to be consistent with the hash provided\n            // for advanced plugins.\n            //\n            // The only potentially counter-intuitive thing here is the `instance` in\n            // the \"pluginsetup\" event is the value returned by the `plugin` function.\n            triggerSetupEvent(this, {\n                name,\n                plugin,\n                instance: null\n            }, true);\n            const instance = plugin.apply(this, arguments);\n            markPluginAsActive(this, name);\n            triggerSetupEvent(this, {\n                name,\n                plugin,\n                instance\n            });\n            return instance;\n        };\n        Object.keys(plugin).forEach(function (prop) {\n            basicPluginWrapper[prop] = plugin[prop];\n        });\n        return basicPluginWrapper;\n    };\n\n    /**\n     * Takes a plugin sub-class and returns a factory function for generating\n     * instances of it.\n     *\n     * This factory function will replace itself with an instance of the requested\n     * sub-class of Plugin.\n     *\n     * @private\n     * @param   {string} name\n     *          The name of the plugin.\n     *\n     * @param   {Plugin} PluginSubClass\n     *          The advanced plugin.\n     *\n     * @return {Function}\n     */\n    const createPluginFactory = (name, PluginSubClass) => {\n        // Add a `name` property to the plugin prototype so that each plugin can\n        // refer to itself by name.\n        PluginSubClass.prototype.name = name;\n        return function (...args) {\n            triggerSetupEvent(this, {\n                name,\n                plugin: PluginSubClass,\n                instance: null\n            }, true);\n            const instance = new PluginSubClass(...[this, ...args]);\n\n            // The plugin is replaced by a function that returns the current instance.\n            this[name] = () => instance;\n            triggerSetupEvent(this, instance.getEventHash());\n            return instance;\n        };\n    };\n\n    /**\n     * Parent class for all advanced plugins.\n     *\n     * @mixes   module:evented~EventedMixin\n     * @mixes   module:stateful~StatefulMixin\n     * @fires   Player#beforepluginsetup\n     * @fires   Player#beforepluginsetup:$name\n     * @fires   Player#pluginsetup\n     * @fires   Player#pluginsetup:$name\n     * @listens Player#dispose\n     * @throws  {Error}\n     *          If attempting to instantiate the base {@link Plugin} class\n     *          directly instead of via a sub-class.\n     */\n    class Plugin {\n        /**\n         * Creates an instance of this class.\n         *\n         * Sub-classes should call `super` to ensure plugins are properly initialized.\n         *\n         * @param {Player} player\n         *        A Video.js player instance.\n         */\n        constructor(player) {\n            if (this.constructor === Plugin) {\n                throw new Error('Plugin must be sub-classed; not directly instantiated.');\n            }\n            this.player = player;\n            if (!this.log) {\n                this.log = this.player.log.createLogger(this.name);\n            }\n\n            // Make this object evented, but remove the added `trigger` method so we\n            // use the prototype version instead.\n            evented(this);\n            delete this.trigger;\n            stateful(this, this.constructor.defaultState);\n            markPluginAsActive(player, this.name);\n\n            // Auto-bind the dispose method so we can use it as a listener and unbind\n            // it later easily.\n            this.dispose = this.dispose.bind(this);\n\n            // If the player is disposed, dispose the plugin.\n            player.on('dispose', this.dispose);\n        }\n\n        /**\n         * Get the version of the plugin that was set on <pluginName>.VERSION\n         */\n        version() {\n            return this.constructor.VERSION;\n        }\n\n        /**\n         * Each event triggered by plugins includes a hash of additional data with\n         * conventional properties.\n         *\n         * This returns that object or mutates an existing hash.\n         *\n         * @param   {Object} [hash={}]\n         *          An object to be used as event an event hash.\n         *\n         * @return {Plugin~PluginEventHash}\n         *          An event hash object with provided properties mixed-in.\n         */\n        getEventHash(hash = {}) {\n            hash.name = this.name;\n            hash.plugin = this.constructor;\n            hash.instance = this;\n            return hash;\n        }\n\n        /**\n         * Triggers an event on the plugin object and overrides\n         * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.\n         *\n         * @param   {string|Object} event\n         *          An event type or an object with a type property.\n         *\n         * @param   {Object} [hash={}]\n         *          Additional data hash to merge with a\n         *          {@link Plugin~PluginEventHash|PluginEventHash}.\n         *\n         * @return {boolean}\n         *          Whether or not default was prevented.\n         */\n        trigger(event, hash = {}) {\n            return trigger(this.eventBusEl_, event, this.getEventHash(hash));\n        }\n\n        /**\n         * Handles \"statechanged\" events on the plugin. No-op by default, override by\n         * subclassing.\n         *\n         * @abstract\n         * @param    {Event} e\n         *           An event object provided by a \"statechanged\" event.\n         *\n         * @param    {Object} e.changes\n         *           An object describing changes that occurred with the \"statechanged\"\n         *           event.\n         */\n        handleStateChanged(e) {}\n\n        /**\n         * Disposes a plugin.\n         *\n         * Subclasses can override this if they want, but for the sake of safety,\n         * it's probably best to subscribe the \"dispose\" event.\n         *\n         * @fires Plugin#dispose\n         */\n        dispose() {\n            const {\n                name,\n                player\n            } = this;\n\n            /**\n             * Signals that a advanced plugin is about to be disposed.\n             *\n             * @event Plugin#dispose\n             * @type  {Event}\n             */\n            this.trigger('dispose');\n            this.off();\n            player.off('dispose', this.dispose);\n\n            // Eliminate any possible sources of leaking memory by clearing up\n            // references between the player and the plugin instance and nulling out\n            // the plugin's state and replacing methods with a function that throws.\n            player[PLUGIN_CACHE_KEY][name] = false;\n            this.player = this.state = null;\n\n            // Finally, replace the plugin name on the player with a new factory\n            // function, so that the plugin is ready to be set up again.\n            player[name] = createPluginFactory(name, pluginStorage[name]);\n        }\n\n        /**\n         * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).\n         *\n         * @param   {string|Function} plugin\n         *          If a string, matches the name of a plugin. If a function, will be\n         *          tested directly.\n         *\n         * @return {boolean}\n         *          Whether or not a plugin is a basic plugin.\n         */\n        static isBasic(plugin) {\n            const p = typeof plugin === 'string' ? getPlugin(plugin) : plugin;\n            return typeof p === 'function' && !Plugin.prototype.isPrototypeOf(p.prototype);\n        }\n\n        /**\n         * Register a Video.js plugin.\n         *\n         * @param   {string} name\n         *          The name of the plugin to be registered. Must be a string and\n         *          must not match an existing plugin or a method on the `Player`\n         *          prototype.\n         *\n         * @param   {typeof Plugin|Function} plugin\n         *          A sub-class of `Plugin` or a function for basic plugins.\n         *\n         * @return {typeof Plugin|Function}\n         *          For advanced plugins, a factory function for that plugin. For\n         *          basic plugins, a wrapper function that initializes the plugin.\n         */\n        static registerPlugin(name, plugin) {\n            if (typeof name !== 'string') {\n                throw new Error(`Illegal plugin name, \"${name}\", must be a string, was ${typeof name}.`);\n            }\n            if (pluginExists(name)) {\n                log$1.warn(`A plugin named \"${name}\" already exists. You may want to avoid re-registering plugins!`);\n            } else if (Player.prototype.hasOwnProperty(name)) {\n                throw new Error(`Illegal plugin name, \"${name}\", cannot share a name with an existing player method!`);\n            }\n            if (typeof plugin !== 'function') {\n                throw new Error(`Illegal plugin for \"${name}\", must be a function, was ${typeof plugin}.`);\n            }\n            pluginStorage[name] = plugin;\n\n            // Add a player prototype method for all sub-classed plugins (but not for\n            // the base Plugin class).\n            if (name !== BASE_PLUGIN_NAME) {\n                if (Plugin.isBasic(plugin)) {\n                    Player.prototype[name] = createBasicPlugin(name, plugin);\n                } else {\n                    Player.prototype[name] = createPluginFactory(name, plugin);\n                }\n            }\n            return plugin;\n        }\n\n        /**\n         * De-register a Video.js plugin.\n         *\n         * @param  {string} name\n         *         The name of the plugin to be de-registered. Must be a string that\n         *         matches an existing plugin.\n         *\n         * @throws {Error}\n         *         If an attempt is made to de-register the base plugin.\n         */\n        static deregisterPlugin(name) {\n            if (name === BASE_PLUGIN_NAME) {\n                throw new Error('Cannot de-register base plugin.');\n            }\n            if (pluginExists(name)) {\n                delete pluginStorage[name];\n                delete Player.prototype[name];\n            }\n        }\n\n        /**\n         * Gets an object containing multiple Video.js plugins.\n         *\n         * @param   {Array} [names]\n         *          If provided, should be an array of plugin names. Defaults to _all_\n         *          plugin names.\n         *\n         * @return {Object|undefined}\n         *          An object containing plugin(s) associated with their name(s) or\n         *          `undefined` if no matching plugins exist).\n         */\n        static getPlugins(names = Object.keys(pluginStorage)) {\n            let result;\n            names.forEach(name => {\n                const plugin = getPlugin(name);\n                if (plugin) {\n                    result = result || {};\n                    result[name] = plugin;\n                }\n            });\n            return result;\n        }\n\n        /**\n         * Gets a plugin's version, if available\n         *\n         * @param   {string} name\n         *          The name of a plugin.\n         *\n         * @return {string}\n         *          The plugin's version or an empty string.\n         */\n        static getPluginVersion(name) {\n            const plugin = getPlugin(name);\n            return plugin && plugin.VERSION || '';\n        }\n    }\n\n    /**\n     * Gets a plugin by name if it exists.\n     *\n     * @static\n     * @method   getPlugin\n     * @memberOf Plugin\n     * @param    {string} name\n     *           The name of a plugin.\n     *\n     * @returns  {typeof Plugin|Function|undefined}\n     *           The plugin (or `undefined`).\n     */\n    Plugin.getPlugin = getPlugin;\n\n    /**\n     * The name of the base plugin class as it is registered.\n     *\n     * @type {string}\n     */\n    Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;\n    Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);\n\n    /**\n     * Documented in player.js\n     *\n     * @ignore\n     */\n    Player.prototype.usingPlugin = function (name) {\n        return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;\n    };\n\n    /**\n     * Documented in player.js\n     *\n     * @ignore\n     */\n    Player.prototype.hasPlugin = function (name) {\n        return !!pluginExists(name);\n    };\n\n    /**\n     * Signals that a plugin is about to be set up on a player.\n     *\n     * @event    Player#beforepluginsetup\n     * @type     {Plugin~PluginEventHash}\n     */\n\n    /**\n     * Signals that a plugin is about to be set up on a player - by name. The name\n     * is the name of the plugin.\n     *\n     * @event    Player#beforepluginsetup:$name\n     * @type     {Plugin~PluginEventHash}\n     */\n\n    /**\n     * Signals that a plugin has just been set up on a player.\n     *\n     * @event    Player#pluginsetup\n     * @type     {Plugin~PluginEventHash}\n     */\n\n    /**\n     * Signals that a plugin has just been set up on a player - by name. The name\n     * is the name of the plugin.\n     *\n     * @event    Player#pluginsetup:$name\n     * @type     {Plugin~PluginEventHash}\n     */\n\n    /**\n     * @typedef  {Object} Plugin~PluginEventHash\n     *\n     * @property {string} instance\n     *           For basic plugins, the return value of the plugin function. For\n     *           advanced plugins, the plugin instance on which the event is fired.\n     *\n     * @property {string} name\n     *           The name of the plugin.\n     *\n     * @property {string} plugin\n     *           For basic plugins, the plugin function. For advanced plugins, the\n     *           plugin class/constructor.\n     */\n\n    /**\n     * @file deprecate.js\n     * @module deprecate\n     */\n\n    /**\n     * Decorate a function with a deprecation message the first time it is called.\n     *\n     * @param  {string}   message\n     *         A deprecation message to log the first time the returned function\n     *         is called.\n     *\n     * @param  {Function} fn\n     *         The function to be deprecated.\n     *\n     * @return {Function}\n     *         A wrapper function that will log a deprecation warning the first\n     *         time it is called. The return value will be the return value of\n     *         the wrapped function.\n     */\n    function deprecate(message, fn) {\n        let warned = false;\n        return function (...args) {\n            if (!warned) {\n                log$1.warn(message);\n            }\n            warned = true;\n            return fn.apply(this, args);\n        };\n    }\n\n    /**\n     * Internal function used to mark a function as deprecated in the next major\n     * version with consistent messaging.\n     *\n     * @param  {number}   major   The major version where it will be removed\n     * @param  {string}   oldName The old function name\n     * @param  {string}   newName The new function name\n     * @param  {Function} fn      The function to deprecate\n     * @return {Function}         The decorated function\n     */\n    function deprecateForMajor(major, oldName, newName, fn) {\n        return deprecate(`${oldName} is deprecated and will be removed in ${major}.0; please use ${newName} instead.`, fn);\n    }\n\n    /**\n     * @file video.js\n     * @module videojs\n     */\n\n    /**\n     * Normalize an `id` value by trimming off a leading `#`\n     *\n     * @private\n     * @param   {string} id\n     *          A string, maybe with a leading `#`.\n     *\n     * @return {string}\n     *          The string, without any leading `#`.\n     */\n    const normalizeId = id => id.indexOf('#') === 0 ? id.slice(1) : id;\n\n    /**\n     * A callback that is called when a component is ready. Does not have any\n     * parameters and any callback value will be ignored. See: {@link Component~ReadyCallback}\n     *\n     * @callback ReadyCallback\n     */\n\n    /**\n     * The `videojs()` function doubles as the main function for users to create a\n     * {@link Player} instance as well as the main library namespace.\n     *\n     * It can also be used as a getter for a pre-existing {@link Player} instance.\n     * However, we _strongly_ recommend using `videojs.getPlayer()` for this\n     * purpose because it avoids any potential for unintended initialization.\n     *\n     * Due to [limitations](https://github.com/jsdoc3/jsdoc/issues/955#issuecomment-313829149)\n     * of our JSDoc template, we cannot properly document this as both a function\n     * and a namespace, so its function signature is documented here.\n     *\n     * #### Arguments\n     * ##### id\n     * string|Element, **required**\n     *\n     * Video element or video element ID.\n     *\n     * ##### options\n     * Object, optional\n     *\n     * Options object for providing settings.\n     * See: [Options Guide](https://docs.videojs.com/tutorial-options.html).\n     *\n     * ##### ready\n     * {@link Component~ReadyCallback}, optional\n     *\n     * A function to be called when the {@link Player} and {@link Tech} are ready.\n     *\n     * #### Return Value\n     *\n     * The `videojs()` function returns a {@link Player} instance.\n     *\n     * @namespace\n     *\n     * @borrows AudioTrack as AudioTrack\n     * @borrows Component.getComponent as getComponent\n     * @borrows module:events.on as on\n     * @borrows module:events.one as one\n     * @borrows module:events.off as off\n     * @borrows module:events.trigger as trigger\n     * @borrows EventTarget as EventTarget\n     * @borrows module:middleware.use as use\n     * @borrows Player.players as players\n     * @borrows Plugin.registerPlugin as registerPlugin\n     * @borrows Plugin.deregisterPlugin as deregisterPlugin\n     * @borrows Plugin.getPlugins as getPlugins\n     * @borrows Plugin.getPlugin as getPlugin\n     * @borrows Plugin.getPluginVersion as getPluginVersion\n     * @borrows Tech.getTech as getTech\n     * @borrows Tech.registerTech as registerTech\n     * @borrows TextTrack as TextTrack\n     * @borrows VideoTrack as VideoTrack\n     *\n     * @param  {string|Element} id\n     *         Video element or video element ID.\n     *\n     * @param  {Object} [options]\n     *         Options object for providing settings.\n     *         See: [Options Guide](https://docs.videojs.com/tutorial-options.html).\n     *\n     * @param  {ReadyCallback} [ready]\n     *         A function to be called when the {@link Player} and {@link Tech} are\n     *         ready.\n     *\n     * @return {Player}\n     *         The `videojs()` function returns a {@link Player|Player} instance.\n     */\n    function videojs(id, options, ready) {\n        let player = videojs.getPlayer(id);\n        if (player) {\n            if (options) {\n                log$1.warn(`Player \"${id}\" is already initialised. Options will not be applied.`);\n            }\n            if (ready) {\n                player.ready(ready);\n            }\n            return player;\n        }\n        const el = typeof id === 'string' ? $('#' + normalizeId(id)) : id;\n        if (!isEl(el)) {\n            throw new TypeError('The element or ID supplied is not valid. (videojs)');\n        }\n\n        // document.body.contains(el) will only check if el is contained within that one document.\n        // This causes problems for elements in iframes.\n        // Instead, use the element's ownerDocument instead of the global document.\n        // This will make sure that the element is indeed in the dom of that document.\n        // Additionally, check that the document in question has a default view.\n        // If the document is no longer attached to the dom, the defaultView of the document will be null.\n        if (!el.ownerDocument.defaultView || !el.ownerDocument.body.contains(el)) {\n            log$1.warn('The element supplied is not included in the DOM');\n        }\n        options = options || {};\n\n        // Store a copy of the el before modification, if it is to be restored in destroy()\n        // If div ingest, store the parent div\n        if (options.restoreEl === true) {\n            options.restoreEl = (el.parentNode && el.parentNode.hasAttribute('data-vjs-player') ? el.parentNode : el).cloneNode(true);\n        }\n        hooks('beforesetup').forEach(hookFunction => {\n            const opts = hookFunction(el, merge$2(options));\n            if (!isObject$1(opts) || Array.isArray(opts)) {\n                log$1.error('please return an object in beforesetup hooks');\n                return;\n            }\n            options = merge$2(options, opts);\n        });\n\n        // We get the current \"Player\" component here in case an integration has\n        // replaced it with a custom player.\n        const PlayerComponent = Component$1.getComponent('Player');\n        player = new PlayerComponent(el, options, ready);\n        hooks('setup').forEach(hookFunction => hookFunction(player));\n        return player;\n    }\n    videojs.hooks_ = hooks_;\n    videojs.hooks = hooks;\n    videojs.hook = hook;\n    videojs.hookOnce = hookOnce;\n    videojs.removeHook = removeHook;\n\n    // Add default styles\n    if (window.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {\n        let style = $('.vjs-styles-defaults');\n        if (!style) {\n            style = createStyleElement('vjs-styles-defaults');\n            const head = $('head');\n            if (head) {\n                head.insertBefore(style, head.firstChild);\n            }\n            setTextContent(style, `\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: 56.25%\n      }\n    `);\n        }\n    }\n\n    // Run Auto-load players\n    // You have to wait at least once in case this script is loaded after your\n    // video in the DOM (weird behavior only with minified version)\n    autoSetupTimeout(1, videojs);\n\n    /**\n     * Current Video.js version. Follows [semantic versioning](https://semver.org/).\n     *\n     * @type {string}\n     */\n    videojs.VERSION = version$5;\n\n    /**\n     * The global options object. These are the settings that take effect\n     * if no overrides are specified when the player is created.\n     *\n     * @type {Object}\n     */\n    videojs.options = Player.prototype.options_;\n\n    /**\n     * Get an object with the currently created players, keyed by player ID\n     *\n     * @return {Object}\n     *         The created players\n     */\n    videojs.getPlayers = () => Player.players;\n\n    /**\n     * Get a single player based on an ID or DOM element.\n     *\n     * This is useful if you want to check if an element or ID has an associated\n     * Video.js player, but not create one if it doesn't.\n     *\n     * @param   {string|Element} id\n     *          An HTML element - `<video>`, `<audio>`, or `<video-js>` -\n     *          or a string matching the `id` of such an element.\n     *\n     * @return {Player|undefined}\n     *          A player instance or `undefined` if there is no player instance\n     *          matching the argument.\n     */\n    videojs.getPlayer = id => {\n        const players = Player.players;\n        let tag;\n        if (typeof id === 'string') {\n            const nId = normalizeId(id);\n            const player = players[nId];\n            if (player) {\n                return player;\n            }\n            tag = $('#' + nId);\n        } else {\n            tag = id;\n        }\n        if (isEl(tag)) {\n            const {\n                player,\n                playerId\n            } = tag;\n\n            // Element may have a `player` property referring to an already created\n            // player instance. If so, return that.\n            if (player || players[playerId]) {\n                return player || players[playerId];\n            }\n        }\n    };\n\n    /**\n     * Returns an array of all current players.\n     *\n     * @return {Array}\n     *         An array of all players. The array will be in the order that\n     *         `Object.keys` provides, which could potentially vary between\n     *         JavaScript engines.\n     *\n     */\n    videojs.getAllPlayers = () =>\n        // Disposed players leave a key with a `null` value, so we need to make sure\n        // we filter those out.\n        Object.keys(Player.players).map(k => Player.players[k]).filter(Boolean);\n    videojs.players = Player.players;\n    videojs.getComponent = Component$1.getComponent;\n\n    /**\n     * Register a component so it can referred to by name. Used when adding to other\n     * components, either through addChild `component.addChild('myComponent')` or through\n     * default children options  `{ children: ['myComponent'] }`.\n     *\n     * > NOTE: You could also just initialize the component before adding.\n     * `component.addChild(new MyComponent());`\n     *\n     * @param {string} name\n     *        The class name of the component\n     *\n     * @param {Component} comp\n     *        The component class\n     *\n     * @return {Component}\n     *         The newly registered component\n     */\n    videojs.registerComponent = (name, comp) => {\n        if (Tech.isTech(comp)) {\n            log$1.warn(`The ${name} tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)`);\n        }\n        Component$1.registerComponent.call(Component$1, name, comp);\n    };\n    videojs.getTech = Tech.getTech;\n    videojs.registerTech = Tech.registerTech;\n    videojs.use = use;\n\n    /**\n     * An object that can be returned by a middleware to signify\n     * that the middleware is being terminated.\n     *\n     * @type {object}\n     * @property {object} middleware.TERMINATOR\n     */\n    Object.defineProperty(videojs, 'middleware', {\n        value: {},\n        writeable: false,\n        enumerable: true\n    });\n    Object.defineProperty(videojs.middleware, 'TERMINATOR', {\n        value: TERMINATOR,\n        writeable: false,\n        enumerable: true\n    });\n\n    /**\n     * A reference to the {@link module:browser|browser utility module} as an object.\n     *\n     * @type {Object}\n     * @see  {@link module:browser|browser}\n     */\n    videojs.browser = browser;\n\n    /**\n     * A reference to the {@link module:obj|obj utility module} as an object.\n     *\n     * @type {Object}\n     * @see  {@link module:obj|obj}\n     */\n    videojs.obj = Obj;\n\n    /**\n     * Deprecated reference to the {@link module:obj.merge|merge function}\n     *\n     * @type {Function}\n     * @see {@link module:obj.merge|merge}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.obj.merge instead.\n     */\n    videojs.mergeOptions = deprecateForMajor(9, 'videojs.mergeOptions', 'videojs.obj.merge', merge$2);\n\n    /**\n     * Deprecated reference to the {@link module:obj.defineLazyProperty|defineLazyProperty function}\n     *\n     * @type {Function}\n     * @see {@link module:obj.defineLazyProperty|defineLazyProperty}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.obj.defineLazyProperty instead.\n     */\n    videojs.defineLazyProperty = deprecateForMajor(9, 'videojs.defineLazyProperty', 'videojs.obj.defineLazyProperty', defineLazyProperty);\n\n    /**\n     * Deprecated reference to the {@link module:fn.bind_|fn.bind_ function}\n     *\n     * @type {Function}\n     * @see {@link module:fn.bind_|fn.bind_}\n     * @deprecated Deprecated and will be removed in 9.0. Please use native Function.prototype.bind instead.\n     */\n    videojs.bind = deprecateForMajor(9, 'videojs.bind', 'native Function.prototype.bind', bind_);\n    videojs.registerPlugin = Plugin.registerPlugin;\n    videojs.deregisterPlugin = Plugin.deregisterPlugin;\n\n    /**\n     * Deprecated method to register a plugin with Video.js\n     *\n     * @deprecated Deprecated and will be removed in 9.0. Use videojs.registerPlugin() instead.\n     *\n     * @param {string} name\n     *        The plugin name\n     *\n     * @param {Plugin|Function} plugin\n     *         The plugin sub-class or function\n     */\n    videojs.plugin = (name, plugin) => {\n        log$1.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');\n        return Plugin.registerPlugin(name, plugin);\n    };\n    videojs.getPlugins = Plugin.getPlugins;\n    videojs.getPlugin = Plugin.getPlugin;\n    videojs.getPluginVersion = Plugin.getPluginVersion;\n\n    /**\n     * Adding languages so that they're available to all players.\n     * Example: `videojs.addLanguage('es', { 'Hello': 'Hola' });`\n     *\n     * @param {string} code\n     *        The language code or dictionary property\n     *\n     * @param {Object} data\n     *        The data values to be translated\n     *\n     * @return {Object}\n     *         The resulting language dictionary object\n     */\n    videojs.addLanguage = function (code, data) {\n        code = ('' + code).toLowerCase();\n        videojs.options.languages = merge$2(videojs.options.languages, {\n            [code]: data\n        });\n        return videojs.options.languages[code];\n    };\n\n    /**\n     * A reference to the {@link module:log|log utility module} as an object.\n     *\n     * @type {Function}\n     * @see  {@link module:log|log}\n     */\n    videojs.log = log$1;\n    videojs.createLogger = createLogger;\n\n    /**\n     * A reference to the {@link module:time|time utility module} as an object.\n     *\n     * @type {Object}\n     * @see {@link module:time|time}\n     */\n    videojs.time = Time;\n\n    /**\n     * Deprecated reference to the {@link module:time.createTimeRanges|createTimeRanges function}\n     *\n     * @type {Function}\n     * @see {@link module:time.createTimeRanges|createTimeRanges}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.createTimeRanges instead.\n     */\n    videojs.createTimeRange = deprecateForMajor(9, 'videojs.createTimeRange', 'videojs.time.createTimeRanges', createTimeRanges$1);\n\n    /**\n     * Deprecated reference to the {@link module:time.createTimeRanges|createTimeRanges function}\n     *\n     * @type {Function}\n     * @see {@link module:time.createTimeRanges|createTimeRanges}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.createTimeRanges instead.\n     */\n    videojs.createTimeRanges = deprecateForMajor(9, 'videojs.createTimeRanges', 'videojs.time.createTimeRanges', createTimeRanges$1);\n\n    /**\n     * Deprecated reference to the {@link module:time.formatTime|formatTime function}\n     *\n     * @type {Function}\n     * @see {@link module:time.formatTime|formatTime}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.format instead.\n     */\n    videojs.formatTime = deprecateForMajor(9, 'videojs.formatTime', 'videojs.time.formatTime', formatTime);\n\n    /**\n     * Deprecated reference to the {@link module:time.setFormatTime|setFormatTime function}\n     *\n     * @type {Function}\n     * @see {@link module:time.setFormatTime|setFormatTime}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.setFormat instead.\n     */\n    videojs.setFormatTime = deprecateForMajor(9, 'videojs.setFormatTime', 'videojs.time.setFormatTime', setFormatTime);\n\n    /**\n     * Deprecated reference to the {@link module:time.resetFormatTime|resetFormatTime function}\n     *\n     * @type {Function}\n     * @see {@link module:time.resetFormatTime|resetFormatTime}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.time.resetFormat instead.\n     */\n    videojs.resetFormatTime = deprecateForMajor(9, 'videojs.resetFormatTime', 'videojs.time.resetFormatTime', resetFormatTime);\n\n    /**\n     * Deprecated reference to the {@link module:url.parseUrl|Url.parseUrl function}\n     *\n     * @type {Function}\n     * @see {@link module:url.parseUrl|parseUrl}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.url.parseUrl instead.\n     */\n    videojs.parseUrl = deprecateForMajor(9, 'videojs.parseUrl', 'videojs.url.parseUrl', parseUrl);\n\n    /**\n     * Deprecated reference to the {@link module:url.isCrossOrigin|Url.isCrossOrigin function}\n     *\n     * @type {Function}\n     * @see {@link module:url.isCrossOrigin|isCrossOrigin}\n     * @deprecated Deprecated and will be removed in 9.0. Please use videojs.url.isCrossOrigin instead.\n     */\n    videojs.isCrossOrigin = deprecateForMajor(9, 'videojs.isCrossOrigin', 'videojs.url.isCrossOrigin', isCrossOrigin);\n    videojs.EventTarget = EventTarget$2;\n    videojs.any = any;\n    videojs.on = on;\n    videojs.one = one;\n    videojs.off = off;\n    videojs.trigger = trigger;\n\n    /**\n     * A cross-browser XMLHttpRequest wrapper.\n     *\n     * @function\n     * @param    {Object} options\n     *           Settings for the request.\n     *\n     * @return   {XMLHttpRequest|XDomainRequest}\n     *           The request object.\n     *\n     * @see      https://github.com/Raynos/xhr\n     */\n    videojs.xhr = lib;\n    videojs.TextTrack = TextTrack;\n    videojs.AudioTrack = AudioTrack;\n    videojs.VideoTrack = VideoTrack;\n    ['isEl', 'isTextNode', 'createEl', 'hasClass', 'addClass', 'removeClass', 'toggleClass', 'setAttributes', 'getAttributes', 'emptyEl', 'appendContent', 'insertContent'].forEach(k => {\n        videojs[k] = function () {\n            log$1.warn(`videojs.${k}() is deprecated; use videojs.dom.${k}() instead`);\n            return Dom[k].apply(null, arguments);\n        };\n    });\n    videojs.computedStyle = deprecateForMajor(9, 'videojs.computedStyle', 'videojs.dom.computedStyle', computedStyle);\n\n    /**\n     * A reference to the {@link module:dom|DOM utility module} as an object.\n     *\n     * @type {Object}\n     * @see {@link module:dom|dom}\n     */\n    videojs.dom = Dom;\n\n    /**\n     * A reference to the {@link module:fn|fn utility module} as an object.\n     *\n     * @type {Object}\n     * @see {@link module:fn|fn}\n     */\n    videojs.fn = Fn;\n\n    /**\n     * A reference to the {@link module:num|num utility module} as an object.\n     *\n     * @type {Object}\n     * @see {@link module:num|num}\n     */\n    videojs.num = Num;\n\n    /**\n     * A reference to the {@link module:str|str utility module} as an object.\n     *\n     * @type {Object}\n     * @see {@link module:str|str}\n     */\n    videojs.str = Str;\n\n    /**\n     * A reference to the {@link module:url|URL utility module} as an object.\n     *\n     * @type {Object}\n     * @see {@link module:url|url}\n     */\n    videojs.url = Url;\n\n    createCommonjsModule(function (module, exports) {\n        /*! @name videojs-contrib-quality-levels @version 3.0.0 @license Apache-2.0 */\n        (function (global, factory) {\n            module.exports = factory(videojs) ;\n        })(commonjsGlobal, function (videojs) {\n\n            function _interopDefaultLegacy(e) {\n                return e && typeof e === 'object' && 'default' in e ? e : {\n                    'default': e\n                };\n            }\n            var videojs__default = /*#__PURE__*/_interopDefaultLegacy(videojs);\n\n            /**\n             * A single QualityLevel.\n             *\n             * interface QualityLevel {\n             *   readonly attribute DOMString id;\n             *            attribute DOMString label;\n             *   readonly attribute long width;\n             *   readonly attribute long height;\n             *   readonly attribute long bitrate;\n             *            attribute boolean enabled;\n             * };\n             *\n             * @class QualityLevel\n             */\n            class QualityLevel {\n                /**\n                 * Creates a QualityLevel\n                 *\n                 * @param {Representation|Object} representation The representation of the quality level\n                 * @param {string}   representation.id        Unique id of the QualityLevel\n                 * @param {number=}  representation.width     Resolution width of the QualityLevel\n                 * @param {number=}  representation.height    Resolution height of the QualityLevel\n                 * @param {number}   representation.bandwidth Bitrate of the QualityLevel\n                 * @param {number=}  representation.frameRate Frame-rate of the QualityLevel\n                 * @param {Function} representation.enabled   Callback to enable/disable QualityLevel\n                 */\n                constructor(representation) {\n                    let level = this; // eslint-disable-line\n\n                    level.id = representation.id;\n                    level.label = level.id;\n                    level.width = representation.width;\n                    level.height = representation.height;\n                    level.bitrate = representation.bandwidth;\n                    level.frameRate = representation.frameRate;\n                    level.enabled_ = representation.enabled;\n                    Object.defineProperty(level, 'enabled', {\n                        /**\n                         * Get whether the QualityLevel is enabled.\n                         *\n                         * @return {boolean} True if the QualityLevel is enabled.\n                         */\n                        get() {\n                            return level.enabled_();\n                        },\n                        /**\n                         * Enable or disable the QualityLevel.\n                         *\n                         * @param {boolean} enable true to enable QualityLevel, false to disable.\n                         */\n                        set(enable) {\n                            level.enabled_(enable);\n                        }\n                    });\n                    return level;\n                }\n            }\n\n            /**\n             * A list of QualityLevels.\n             *\n             * interface QualityLevelList : EventTarget {\n             *   getter QualityLevel (unsigned long index);\n             *   readonly attribute unsigned long length;\n             *   readonly attribute long selectedIndex;\n             *\n             *   void addQualityLevel(QualityLevel qualityLevel)\n             *   void removeQualityLevel(QualityLevel remove)\n             *   QualityLevel? getQualityLevelById(DOMString id);\n             *\n             *   attribute EventHandler onchange;\n             *   attribute EventHandler onaddqualitylevel;\n             *   attribute EventHandler onremovequalitylevel;\n             * };\n             *\n             * @extends videojs.EventTarget\n             * @class QualityLevelList\n             */\n\n            class QualityLevelList extends videojs__default['default'].EventTarget {\n                constructor() {\n                    super();\n                    let list = this; // eslint-disable-line\n\n                    list.levels_ = [];\n                    list.selectedIndex_ = -1;\n                    /**\n                     * Get the index of the currently selected QualityLevel.\n                     *\n                     * @returns {number} The index of the selected QualityLevel. -1 if none selected.\n                     * @readonly\n                     */\n\n                    Object.defineProperty(list, 'selectedIndex', {\n                        get() {\n                            return list.selectedIndex_;\n                        }\n                    });\n                    /**\n                     * Get the length of the list of QualityLevels.\n                     *\n                     * @returns {number} The length of the list.\n                     * @readonly\n                     */\n\n                    Object.defineProperty(list, 'length', {\n                        get() {\n                            return list.levels_.length;\n                        }\n                    });\n                    return list;\n                }\n                /**\n                 * Adds a quality level to the list.\n                 *\n                 * @param {Representation|Object} representation The representation of the quality level\n                 * @param {string}   representation.id        Unique id of the QualityLevel\n                 * @param {number=}  representation.width     Resolution width of the QualityLevel\n                 * @param {number=}  representation.height    Resolution height of the QualityLevel\n                 * @param {number}   representation.bandwidth Bitrate of the QualityLevel\n                 * @param {number=}  representation.frameRate Frame-rate of the QualityLevel\n                 * @param {Function} representation.enabled   Callback to enable/disable QualityLevel\n                 * @return {QualityLevel} the QualityLevel added to the list\n                 * @method addQualityLevel\n                 */\n\n                addQualityLevel(representation) {\n                    let qualityLevel = this.getQualityLevelById(representation.id); // Do not add duplicate quality levels\n\n                    if (qualityLevel) {\n                        return qualityLevel;\n                    }\n                    const index = this.levels_.length;\n                    qualityLevel = new QualityLevel(representation);\n                    if (!('' + index in this)) {\n                        Object.defineProperty(this, index, {\n                            get() {\n                                return this.levels_[index];\n                            }\n                        });\n                    }\n                    this.levels_.push(qualityLevel);\n                    this.trigger({\n                        qualityLevel,\n                        type: 'addqualitylevel'\n                    });\n                    return qualityLevel;\n                }\n                /**\n                 * Removes a quality level from the list.\n                 *\n                 * @param {QualityLevel} remove QualityLevel to remove to the list.\n                 * @return {QualityLevel|null} the QualityLevel removed or null if nothing removed\n                 * @method removeQualityLevel\n                 */\n\n                removeQualityLevel(qualityLevel) {\n                    let removed = null;\n                    for (let i = 0, l = this.length; i < l; i++) {\n                        if (this[i] === qualityLevel) {\n                            removed = this.levels_.splice(i, 1)[0];\n                            if (this.selectedIndex_ === i) {\n                                this.selectedIndex_ = -1;\n                            } else if (this.selectedIndex_ > i) {\n                                this.selectedIndex_--;\n                            }\n                            break;\n                        }\n                    }\n                    if (removed) {\n                        this.trigger({\n                            qualityLevel,\n                            type: 'removequalitylevel'\n                        });\n                    }\n                    return removed;\n                }\n                /**\n                 * Searches for a QualityLevel with the given id.\n                 *\n                 * @param {string} id The id of the QualityLevel to find.\n                 * @return {QualityLevel|null} The QualityLevel with id, or null if not found.\n                 * @method getQualityLevelById\n                 */\n\n                getQualityLevelById(id) {\n                    for (let i = 0, l = this.length; i < l; i++) {\n                        const level = this[i];\n                        if (level.id === id) {\n                            return level;\n                        }\n                    }\n                    return null;\n                }\n                /**\n                 * Resets the list of QualityLevels to empty\n                 *\n                 * @method dispose\n                 */\n\n                dispose() {\n                    this.selectedIndex_ = -1;\n                    this.levels_.length = 0;\n                }\n            }\n            /**\n             * change - The selected QualityLevel has changed.\n             * addqualitylevel - A QualityLevel has been added to the QualityLevelList.\n             * removequalitylevel - A QualityLevel has been removed from the QualityLevelList.\n             */\n\n            QualityLevelList.prototype.allowedEvents_ = {\n                change: 'change',\n                addqualitylevel: 'addqualitylevel',\n                removequalitylevel: 'removequalitylevel'\n            }; // emulate attribute EventHandler support to allow for feature detection\n\n            for (const event in QualityLevelList.prototype.allowedEvents_) {\n                QualityLevelList.prototype['on' + event] = null;\n            }\n            var version = \"3.0.0\";\n            const registerPlugin = videojs__default['default'].registerPlugin || videojs__default['default'].plugin;\n            /**\n             * Initialization function for the qualityLevels plugin. Sets up the QualityLevelList and\n             * event handlers.\n             *\n             * @param {Player} player Player object.\n             * @param {Object} options Plugin options object.\n             * @function initPlugin\n             */\n\n            const initPlugin = function (player, options) {\n                const originalPluginFn = player.qualityLevels;\n                const qualityLevelList = new QualityLevelList();\n                const disposeHandler = function () {\n                    qualityLevelList.dispose();\n                    player.qualityLevels = originalPluginFn;\n                    player.off('dispose', disposeHandler);\n                };\n                player.on('dispose', disposeHandler);\n                player.qualityLevels = () => qualityLevelList;\n                player.qualityLevels.VERSION = version;\n                return qualityLevelList;\n            };\n            /**\n             * A video.js plugin.\n             *\n             * In the plugin function, the value of `this` is a video.js `Player`\n             * instance. You cannot rely on the player being in a \"ready\" state here,\n             * depending on how the plugin is invoked. This may or may not be important\n             * to you; if not, remove the wait for \"ready\"!\n             *\n             * @param {Object} options Plugin options object\n             * @function qualityLevels\n             */\n\n            const qualityLevels = function (options) {\n                return initPlugin(this, videojs__default['default'].mergeOptions({}, options));\n            }; // Register the plugin with video.js.\n\n            registerPlugin('qualityLevels', qualityLevels); // Include the version number.\n\n            qualityLevels.VERSION = version;\n            return qualityLevels;\n        });\n    });\n\n    var urlToolkit = createCommonjsModule(function (module, exports) {\n        // see https://tools.ietf.org/html/rfc1808\n\n        (function (root) {\n            var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n            var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n            var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n            var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n            var URLToolkit = {\n                // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n                // E.g\n                // With opts.alwaysNormalize = false (default, spec compliant)\n                // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n                // With opts.alwaysNormalize = true (not spec compliant)\n                // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n                buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n                    opts = opts || {};\n                    // remove any remaining space and CRLF\n                    baseURL = baseURL.trim();\n                    relativeURL = relativeURL.trim();\n                    if (!relativeURL) {\n                        // 2a) If the embedded URL is entirely empty, it inherits the\n                        // entire base URL (i.e., is set equal to the base URL)\n                        // and we are done.\n                        if (!opts.alwaysNormalize) {\n                            return baseURL;\n                        }\n                        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n                        if (!basePartsForNormalise) {\n                            throw new Error('Error trying to parse base URL.');\n                        }\n                        basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);\n                        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n                    }\n                    var relativeParts = URLToolkit.parseURL(relativeURL);\n                    if (!relativeParts) {\n                        throw new Error('Error trying to parse relative URL.');\n                    }\n                    if (relativeParts.scheme) {\n                        // 2b) If the embedded URL starts with a scheme name, it is\n                        // interpreted as an absolute URL and we are done.\n                        if (!opts.alwaysNormalize) {\n                            return relativeURL;\n                        }\n                        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n                        return URLToolkit.buildURLFromParts(relativeParts);\n                    }\n                    var baseParts = URLToolkit.parseURL(baseURL);\n                    if (!baseParts) {\n                        throw new Error('Error trying to parse base URL.');\n                    }\n                    if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n                        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n                        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n                        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n                        baseParts.netLoc = pathParts[1];\n                        baseParts.path = pathParts[2];\n                    }\n                    if (baseParts.netLoc && !baseParts.path) {\n                        baseParts.path = '/';\n                    }\n                    var builtParts = {\n                        // 2c) Otherwise, the embedded URL inherits the scheme of\n                        // the base URL.\n                        scheme: baseParts.scheme,\n                        netLoc: relativeParts.netLoc,\n                        path: null,\n                        params: relativeParts.params,\n                        query: relativeParts.query,\n                        fragment: relativeParts.fragment\n                    };\n                    if (!relativeParts.netLoc) {\n                        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n                        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n                        // (if any) of the base URL.\n                        builtParts.netLoc = baseParts.netLoc;\n                        // 4) If the embedded URL path is preceded by a slash \"/\", the\n                        // path is not relative and we skip to Step 7.\n                        if (relativeParts.path[0] !== '/') {\n                            if (!relativeParts.path) {\n                                // 5) If the embedded URL path is empty (and not preceded by a\n                                // slash), then the embedded URL inherits the base URL path\n                                builtParts.path = baseParts.path;\n                                // 5a) if the embedded URL's <params> is non-empty, we skip to\n                                // step 7; otherwise, it inherits the <params> of the base\n                                // URL (if any) and\n                                if (!relativeParts.params) {\n                                    builtParts.params = baseParts.params;\n                                    // 5b) if the embedded URL's <query> is non-empty, we skip to\n                                    // step 7; otherwise, it inherits the <query> of the base\n                                    // URL (if any) and we skip to step 7.\n                                    if (!relativeParts.query) {\n                                        builtParts.query = baseParts.query;\n                                    }\n                                }\n                            } else {\n                                // 6) The last segment of the base URL's path (anything\n                                // following the rightmost slash \"/\", or the entire path if no\n                                // slash is present) is removed and the embedded URL's path is\n                                // appended in its place.\n                                var baseURLPath = baseParts.path;\n                                var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) + relativeParts.path;\n                                builtParts.path = URLToolkit.normalizePath(newPath);\n                            }\n                        }\n                    }\n                    if (builtParts.path === null) {\n                        builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;\n                    }\n                    return URLToolkit.buildURLFromParts(builtParts);\n                },\n                parseURL: function (url) {\n                    var parts = URL_REGEX.exec(url);\n                    if (!parts) {\n                        return null;\n                    }\n                    return {\n                        scheme: parts[1] || '',\n                        netLoc: parts[2] || '',\n                        path: parts[3] || '',\n                        params: parts[4] || '',\n                        query: parts[5] || '',\n                        fragment: parts[6] || ''\n                    };\n                },\n                normalizePath: function (path) {\n                    // The following operations are\n                    // then applied, in order, to the new path:\n                    // 6a) All occurrences of \"./\", where \".\" is a complete path\n                    // segment, are removed.\n                    // 6b) If the path ends with \".\" as a complete path segment,\n                    // that \".\" is removed.\n                    path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n                    // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n                    // complete path segment not equal to \"..\", are removed.\n                    // Removal of these path segments is performed iteratively,\n                    // removing the leftmost matching pattern on each iteration,\n                    // until no matching pattern remains.\n                    // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n                    // complete path segment not equal to \"..\", that\n                    // \"<segment>/..\" is removed.\n                    while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) {}\n                    return path.split('').reverse().join('');\n                },\n                buildURLFromParts: function (parts) {\n                    return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;\n                }\n            };\n            module.exports = URLToolkit;\n        })();\n    });\n\n    var DEFAULT_LOCATION$1 = 'http://example.com';\n    var resolveUrl$2 = function resolveUrl(baseUrl, relativeUrl) {\n        // return early if we don't need to resolve\n        if (/^[a-z]+:/i.test(relativeUrl)) {\n            return relativeUrl;\n        } // if baseUrl is a data URI, ignore it and resolve everything relative to window.location\n\n        if (/^data:/.test(baseUrl)) {\n            baseUrl = window.location && window.location.href || '';\n        } // IE11 supports URL but not the URL constructor\n        // feature detect the behavior we want\n\n        var nativeURL = typeof window.URL === 'function';\n        var protocolLess = /^\\/\\//.test(baseUrl); // remove location if window.location isn't available (i.e. we're in node)\n        // and if baseUrl isn't an absolute url\n\n        var removeLocation = !window.location && !/\\/\\//i.test(baseUrl); // if the base URL is relative then combine with the current location\n\n        if (nativeURL) {\n            baseUrl = new window.URL(baseUrl, window.location || DEFAULT_LOCATION$1);\n        } else if (!/\\/\\//i.test(baseUrl)) {\n            baseUrl = urlToolkit.buildAbsoluteURL(window.location && window.location.href || '', baseUrl);\n        }\n        if (nativeURL) {\n            var newUrl = new URL(relativeUrl, baseUrl); // if we're a protocol-less url, remove the protocol\n            // and if we're location-less, remove the location\n            // otherwise, return the url unmodified\n\n            if (removeLocation) {\n                return newUrl.href.slice(DEFAULT_LOCATION$1.length);\n            } else if (protocolLess) {\n                return newUrl.href.slice(newUrl.protocol.length);\n            }\n            return newUrl.href;\n        }\n        return urlToolkit.buildAbsoluteURL(baseUrl, relativeUrl);\n    };\n\n    /**\n     * @file stream.js\n     */\n\n    /**\n     * A lightweight readable stream implemention that handles event dispatching.\n     *\n     * @class Stream\n     */\n    var Stream = /*#__PURE__*/function () {\n        function Stream() {\n            this.listeners = {};\n        }\n        /**\n         * Add a listener for a specified event type.\n         *\n         * @param {string} type the event name\n         * @param {Function} listener the callback to be invoked when an event of\n         * the specified type occurs\n         */\n\n        var _proto = Stream.prototype;\n        _proto.on = function on(type, listener) {\n            if (!this.listeners[type]) {\n                this.listeners[type] = [];\n            }\n            this.listeners[type].push(listener);\n        }\n        /**\n         * Remove a listener for a specified event type.\n         *\n         * @param {string} type the event name\n         * @param {Function} listener  a function previously registered for this\n         * type of event through `on`\n         * @return {boolean} if we could turn it off or not\n         */;\n\n        _proto.off = function off(type, listener) {\n            if (!this.listeners[type]) {\n                return false;\n            }\n            var index = this.listeners[type].indexOf(listener); // TODO: which is better?\n            // In Video.js we slice listener functions\n            // on trigger so that it does not mess up the order\n            // while we loop through.\n            //\n            // Here we slice on off so that the loop in trigger\n            // can continue using it's old reference to loop without\n            // messing up the order.\n\n            this.listeners[type] = this.listeners[type].slice(0);\n            this.listeners[type].splice(index, 1);\n            return index > -1;\n        }\n        /**\n         * Trigger an event of the specified type on this stream. Any additional\n         * arguments to this function are passed as parameters to event listeners.\n         *\n         * @param {string} type the event name\n         */;\n\n        _proto.trigger = function trigger(type) {\n            var callbacks = this.listeners[type];\n            if (!callbacks) {\n                return;\n            } // Slicing the arguments on every invocation of this method\n            // can add a significant amount of overhead. Avoid the\n            // intermediate object creation for the common case of a\n            // single callback argument\n\n            if (arguments.length === 2) {\n                var length = callbacks.length;\n                for (var i = 0; i < length; ++i) {\n                    callbacks[i].call(this, arguments[1]);\n                }\n            } else {\n                var args = Array.prototype.slice.call(arguments, 1);\n                var _length = callbacks.length;\n                for (var _i = 0; _i < _length; ++_i) {\n                    callbacks[_i].apply(this, args);\n                }\n            }\n        }\n        /**\n         * Destroys the stream and cleans up.\n         */;\n\n        _proto.dispose = function dispose() {\n            this.listeners = {};\n        }\n        /**\n         * Forwards all `data` events on this stream to the destination stream. The\n         * destination stream should provide a method `push` to receive the data\n         * events as they arrive.\n         *\n         * @param {Stream} destination the stream that will receive all `data` events\n         * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n         */;\n\n        _proto.pipe = function pipe(destination) {\n            this.on('data', function (data) {\n                destination.push(data);\n            });\n        };\n        return Stream;\n    }();\n\n    var atob$1 = function atob(s) {\n        return window.atob ? window.atob(s) : Buffer.from(s, 'base64').toString('binary');\n    };\n    function decodeB64ToUint8Array$1(b64Text) {\n        var decodedString = atob$1(b64Text);\n        var array = new Uint8Array(decodedString.length);\n        for (var i = 0; i < decodedString.length; i++) {\n            array[i] = decodedString.charCodeAt(i);\n        }\n        return array;\n    }\n\n    /*! @name m3u8-parser @version 6.0.0 @license Apache-2.0 */\n\n    /**\n     * @file m3u8/line-stream.js\n     */\n    /**\n     * A stream that buffers string input and generates a `data` event for each\n     * line.\n     *\n     * @class LineStream\n     * @extends Stream\n     */\n\n    class LineStream extends Stream {\n        constructor() {\n            super();\n            this.buffer = '';\n        }\n        /**\n         * Add new data to be parsed.\n         *\n         * @param {string} data the text to process\n         */\n\n        push(data) {\n            let nextNewline;\n            this.buffer += data;\n            nextNewline = this.buffer.indexOf('\\n');\n            for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n                this.trigger('data', this.buffer.substring(0, nextNewline));\n                this.buffer = this.buffer.substring(nextNewline + 1);\n            }\n        }\n    }\n    const TAB = String.fromCharCode(0x09);\n    const parseByterange = function (byterangeString) {\n        // optionally match and capture 0+ digits before `@`\n        // optionally match and capture 0+ digits after `@`\n        const match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || '');\n        const result = {};\n        if (match[1]) {\n            result.length = parseInt(match[1], 10);\n        }\n        if (match[2]) {\n            result.offset = parseInt(match[2], 10);\n        }\n        return result;\n    };\n    /**\n     * \"forgiving\" attribute list psuedo-grammar:\n     * attributes -> keyvalue (',' keyvalue)*\n     * keyvalue   -> key '=' value\n     * key        -> [^=]*\n     * value      -> '\"' [^\"]* '\"' | [^,]*\n     */\n\n    const attributeSeparator = function () {\n        const key = '[^=]*';\n        const value = '\"[^\"]*\"|[^,]*';\n        const keyvalue = '(?:' + key + ')=(?:' + value + ')';\n        return new RegExp('(?:^|,)(' + keyvalue + ')');\n    };\n    /**\n     * Parse attributes from a line given the separator\n     *\n     * @param {string} attributes the attribute line to parse\n     */\n\n    const parseAttributes$1 = function (attributes) {\n        const result = {};\n        if (!attributes) {\n            return result;\n        } // split the string using attributes as the separator\n\n        const attrs = attributes.split(attributeSeparator());\n        let i = attrs.length;\n        let attr;\n        while (i--) {\n            // filter out unmatched portions of the string\n            if (attrs[i] === '') {\n                continue;\n            } // split the key and value\n\n            attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n\n            attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n            attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n            attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n            result[attr[0]] = attr[1];\n        }\n        return result;\n    };\n    /**\n     * A line-level M3U8 parser event stream. It expects to receive input one\n     * line at a time and performs a context-free parse of its contents. A stream\n     * interpretation of a manifest can be useful if the manifest is expected to\n     * be too large to fit comfortably into memory or the entirety of the input\n     * is not immediately available. Otherwise, it's probably much easier to work\n     * with a regular `Parser` object.\n     *\n     * Produces `data` events with an object that captures the parser's\n     * interpretation of the input. That object has a property `tag` that is one\n     * of `uri`, `comment`, or `tag`. URIs only have a single additional\n     * property, `line`, which captures the entirety of the input without\n     * interpretation. Comments similarly have a single additional property\n     * `text` which is the input without the leading `#`.\n     *\n     * Tags always have a property `tagType` which is the lower-cased version of\n     * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n     * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n     * tags are given the tag type `unknown` and a single additional property\n     * `data` with the remainder of the input.\n     *\n     * @class ParseStream\n     * @extends Stream\n     */\n\n    class ParseStream extends Stream {\n        constructor() {\n            super();\n            this.customParsers = [];\n            this.tagMappers = [];\n        }\n        /**\n         * Parses an additional line of input.\n         *\n         * @param {string} line a single line of an M3U8 file to parse\n         */\n\n        push(line) {\n            let match;\n            let event; // strip whitespace\n\n            line = line.trim();\n            if (line.length === 0) {\n                // ignore empty lines\n                return;\n            } // URIs\n\n            if (line[0] !== '#') {\n                this.trigger('data', {\n                    type: 'uri',\n                    uri: line\n                });\n                return;\n            } // map tags\n\n            const newLines = this.tagMappers.reduce((acc, mapper) => {\n                const mappedLine = mapper(line); // skip if unchanged\n\n                if (mappedLine === line) {\n                    return acc;\n                }\n                return acc.concat([mappedLine]);\n            }, [line]);\n            newLines.forEach(newLine => {\n                for (let i = 0; i < this.customParsers.length; i++) {\n                    if (this.customParsers[i].call(this, newLine)) {\n                        return;\n                    }\n                } // Comments\n\n                if (newLine.indexOf('#EXT') !== 0) {\n                    this.trigger('data', {\n                        type: 'comment',\n                        text: newLine.slice(1)\n                    });\n                    return;\n                } // strip off any carriage returns here so the regex matching\n                // doesn't have to account for them.\n\n                newLine = newLine.replace('\\r', ''); // Tags\n\n                match = /^#EXTM3U/.exec(newLine);\n                if (match) {\n                    this.trigger('data', {\n                        type: 'tag',\n                        tagType: 'm3u'\n                    });\n                    return;\n                }\n                match = /^#EXTINF:([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'inf'\n                    };\n                    if (match[1]) {\n                        event.duration = parseFloat(match[1]);\n                    }\n                    if (match[2]) {\n                        event.title = match[2];\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'targetduration'\n                    };\n                    if (match[1]) {\n                        event.duration = parseInt(match[1], 10);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-VERSION:([0-9.]*)?/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'version'\n                    };\n                    if (match[1]) {\n                        event.version = parseInt(match[1], 10);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-MEDIA-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'media-sequence'\n                    };\n                    if (match[1]) {\n                        event.number = parseInt(match[1], 10);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'discontinuity-sequence'\n                    };\n                    if (match[1]) {\n                        event.number = parseInt(match[1], 10);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'playlist-type'\n                    };\n                    if (match[1]) {\n                        event.playlistType = match[1];\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-BYTERANGE:(.*)?$/.exec(newLine);\n                if (match) {\n                    event = _extends$1(parseByterange(match[1]), {\n                        type: 'tag',\n                        tagType: 'byterange'\n                    });\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'allow-cache'\n                    };\n                    if (match[1]) {\n                        event.allowed = !/NO/.test(match[1]);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-MAP:(.*)$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'map'\n                    };\n                    if (match[1]) {\n                        const attributes = parseAttributes$1(match[1]);\n                        if (attributes.URI) {\n                            event.uri = attributes.URI;\n                        }\n                        if (attributes.BYTERANGE) {\n                            event.byterange = parseByterange(attributes.BYTERANGE);\n                        }\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-STREAM-INF:(.*)$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'stream-inf'\n                    };\n                    if (match[1]) {\n                        event.attributes = parseAttributes$1(match[1]);\n                        if (event.attributes.RESOLUTION) {\n                            const split = event.attributes.RESOLUTION.split('x');\n                            const resolution = {};\n                            if (split[0]) {\n                                resolution.width = parseInt(split[0], 10);\n                            }\n                            if (split[1]) {\n                                resolution.height = parseInt(split[1], 10);\n                            }\n                            event.attributes.RESOLUTION = resolution;\n                        }\n                        if (event.attributes.BANDWIDTH) {\n                            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n                        }\n                        if (event.attributes['FRAME-RATE']) {\n                            event.attributes['FRAME-RATE'] = parseFloat(event.attributes['FRAME-RATE']);\n                        }\n                        if (event.attributes['PROGRAM-ID']) {\n                            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n                        }\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-MEDIA:(.*)$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'media'\n                    };\n                    if (match[1]) {\n                        event.attributes = parseAttributes$1(match[1]);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-ENDLIST/.exec(newLine);\n                if (match) {\n                    this.trigger('data', {\n                        type: 'tag',\n                        tagType: 'endlist'\n                    });\n                    return;\n                }\n                match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n                if (match) {\n                    this.trigger('data', {\n                        type: 'tag',\n                        tagType: 'discontinuity'\n                    });\n                    return;\n                }\n                match = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'program-date-time'\n                    };\n                    if (match[1]) {\n                        event.dateTimeString = match[1];\n                        event.dateTimeObject = new Date(match[1]);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-KEY:(.*)$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'key'\n                    };\n                    if (match[1]) {\n                        event.attributes = parseAttributes$1(match[1]); // parse the IV string into a Uint32Array\n\n                        if (event.attributes.IV) {\n                            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n                                event.attributes.IV = event.attributes.IV.substring(2);\n                            }\n                            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n                            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n                            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n                            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n                            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n                            event.attributes.IV = new Uint32Array(event.attributes.IV);\n                        }\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-START:(.*)$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'start'\n                    };\n                    if (match[1]) {\n                        event.attributes = parseAttributes$1(match[1]);\n                        event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n                        event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'cue-out-cont'\n                    };\n                    if (match[1]) {\n                        event.data = match[1];\n                    } else {\n                        event.data = '';\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-CUE-OUT:(.*)?$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'cue-out'\n                    };\n                    if (match[1]) {\n                        event.data = match[1];\n                    } else {\n                        event.data = '';\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-CUE-IN:(.*)?$/.exec(newLine);\n                if (match) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'cue-in'\n                    };\n                    if (match[1]) {\n                        event.data = match[1];\n                    } else {\n                        event.data = '';\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);\n                if (match && match[1]) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'skip'\n                    };\n                    event.attributes = parseAttributes$1(match[1]);\n                    if (event.attributes.hasOwnProperty('SKIPPED-SEGMENTS')) {\n                        event.attributes['SKIPPED-SEGMENTS'] = parseInt(event.attributes['SKIPPED-SEGMENTS'], 10);\n                    }\n                    if (event.attributes.hasOwnProperty('RECENTLY-REMOVED-DATERANGES')) {\n                        event.attributes['RECENTLY-REMOVED-DATERANGES'] = event.attributes['RECENTLY-REMOVED-DATERANGES'].split(TAB);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-PART:(.*)$/.exec(newLine);\n                if (match && match[1]) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'part'\n                    };\n                    event.attributes = parseAttributes$1(match[1]);\n                    ['DURATION'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = parseFloat(event.attributes[key]);\n                        }\n                    });\n                    ['INDEPENDENT', 'GAP'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = /YES/.test(event.attributes[key]);\n                        }\n                    });\n                    if (event.attributes.hasOwnProperty('BYTERANGE')) {\n                        event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);\n                    }\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);\n                if (match && match[1]) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'server-control'\n                    };\n                    event.attributes = parseAttributes$1(match[1]);\n                    ['CAN-SKIP-UNTIL', 'PART-HOLD-BACK', 'HOLD-BACK'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = parseFloat(event.attributes[key]);\n                        }\n                    });\n                    ['CAN-SKIP-DATERANGES', 'CAN-BLOCK-RELOAD'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = /YES/.test(event.attributes[key]);\n                        }\n                    });\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);\n                if (match && match[1]) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'part-inf'\n                    };\n                    event.attributes = parseAttributes$1(match[1]);\n                    ['PART-TARGET'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = parseFloat(event.attributes[key]);\n                        }\n                    });\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);\n                if (match && match[1]) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'preload-hint'\n                    };\n                    event.attributes = parseAttributes$1(match[1]);\n                    ['BYTERANGE-START', 'BYTERANGE-LENGTH'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = parseInt(event.attributes[key], 10);\n                            const subkey = key === 'BYTERANGE-LENGTH' ? 'length' : 'offset';\n                            event.attributes.byterange = event.attributes.byterange || {};\n                            event.attributes.byterange[subkey] = event.attributes[key]; // only keep the parsed byterange object.\n\n                            delete event.attributes[key];\n                        }\n                    });\n                    this.trigger('data', event);\n                    return;\n                }\n                match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);\n                if (match && match[1]) {\n                    event = {\n                        type: 'tag',\n                        tagType: 'rendition-report'\n                    };\n                    event.attributes = parseAttributes$1(match[1]);\n                    ['LAST-MSN', 'LAST-PART'].forEach(function (key) {\n                        if (event.attributes.hasOwnProperty(key)) {\n                            event.attributes[key] = parseInt(event.attributes[key], 10);\n                        }\n                    });\n                    this.trigger('data', event);\n                    return;\n                } // unknown tag type\n\n                this.trigger('data', {\n                    type: 'tag',\n                    data: newLine.slice(4)\n                });\n            });\n        }\n        /**\n         * Add a parser for custom headers\n         *\n         * @param {Object}   options              a map of options for the added parser\n         * @param {RegExp}   options.expression   a regular expression to match the custom header\n         * @param {string}   options.customType   the custom type to register to the output\n         * @param {Function} [options.dataParser] function to parse the line into an object\n         * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n         */\n\n        addParser({\n                      expression,\n                      customType,\n                      dataParser,\n                      segment\n                  }) {\n            if (typeof dataParser !== 'function') {\n                dataParser = line => line;\n            }\n            this.customParsers.push(line => {\n                const match = expression.exec(line);\n                if (match) {\n                    this.trigger('data', {\n                        type: 'custom',\n                        data: dataParser(line),\n                        customType,\n                        segment\n                    });\n                    return true;\n                }\n            });\n        }\n        /**\n         * Add a custom header mapper\n         *\n         * @param {Object}   options\n         * @param {RegExp}   options.expression   a regular expression to match the custom header\n         * @param {Function} options.map          function to translate tag into a different tag\n         */\n\n        addTagMapper({\n                         expression,\n                         map\n                     }) {\n            const mapFn = line => {\n                if (expression.test(line)) {\n                    return map(line);\n                }\n                return line;\n            };\n            this.tagMappers.push(mapFn);\n        }\n    }\n    const camelCase = str => str.toLowerCase().replace(/-(\\w)/g, a => a[1].toUpperCase());\n    const camelCaseKeys = function (attributes) {\n        const result = {};\n        Object.keys(attributes).forEach(function (key) {\n            result[camelCase(key)] = attributes[key];\n        });\n        return result;\n    }; // set SERVER-CONTROL hold back based upon targetDuration and partTargetDuration\n    // we need this helper because defaults are based upon targetDuration and\n    // partTargetDuration being set, but they may not be if SERVER-CONTROL appears before\n    // target durations are set.\n\n    const setHoldBack = function (manifest) {\n        const {\n            serverControl,\n            targetDuration,\n            partTargetDuration\n        } = manifest;\n        if (!serverControl) {\n            return;\n        }\n        const tag = '#EXT-X-SERVER-CONTROL';\n        const hb = 'holdBack';\n        const phb = 'partHoldBack';\n        const minTargetDuration = targetDuration && targetDuration * 3;\n        const minPartDuration = partTargetDuration && partTargetDuration * 2;\n        if (targetDuration && !serverControl.hasOwnProperty(hb)) {\n            serverControl[hb] = minTargetDuration;\n            this.trigger('info', {\n                message: `${tag} defaulting HOLD-BACK to targetDuration * 3 (${minTargetDuration}).`\n            });\n        }\n        if (minTargetDuration && serverControl[hb] < minTargetDuration) {\n            this.trigger('warn', {\n                message: `${tag} clamping HOLD-BACK (${serverControl[hb]}) to targetDuration * 3 (${minTargetDuration})`\n            });\n            serverControl[hb] = minTargetDuration;\n        } // default no part hold back to part target duration * 3\n\n        if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {\n            serverControl[phb] = partTargetDuration * 3;\n            this.trigger('info', {\n                message: `${tag} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${serverControl[phb]}).`\n            });\n        } // if part hold back is too small default it to part target duration * 2\n\n        if (partTargetDuration && serverControl[phb] < minPartDuration) {\n            this.trigger('warn', {\n                message: `${tag} clamping PART-HOLD-BACK (${serverControl[phb]}) to partTargetDuration * 2 (${minPartDuration}).`\n            });\n            serverControl[phb] = minPartDuration;\n        }\n    };\n    /**\n     * A parser for M3U8 files. The current interpretation of the input is\n     * exposed as a property `manifest` on parser objects. It's just two lines to\n     * create and parse a manifest once you have the contents available as a string:\n     *\n     * ```js\n     * var parser = new m3u8.Parser();\n     * parser.push(xhr.responseText);\n     * ```\n     *\n     * New input can later be applied to update the manifest object by calling\n     * `push` again.\n     *\n     * The parser attempts to create a usable manifest object even if the\n     * underlying input is somewhat nonsensical. It emits `info` and `warning`\n     * events during the parse if it encounters input that seems invalid or\n     * requires some property of the manifest object to be defaulted.\n     *\n     * @class Parser\n     * @extends Stream\n     */\n\n    class Parser extends Stream {\n        constructor() {\n            super();\n            this.lineStream = new LineStream();\n            this.parseStream = new ParseStream();\n            this.lineStream.pipe(this.parseStream);\n            /* eslint-disable consistent-this */\n\n            const self = this;\n            /* eslint-enable consistent-this */\n\n            const uris = [];\n            let currentUri = {}; // if specified, the active EXT-X-MAP definition\n\n            let currentMap; // if specified, the active decryption key\n\n            let key;\n            let hasParts = false;\n            const noop = function () {};\n            const defaultMediaGroups = {\n                'AUDIO': {},\n                'VIDEO': {},\n                'CLOSED-CAPTIONS': {},\n                'SUBTITLES': {}\n            }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\n            // used in MPDs with Widevine encrypted streams.\n\n            const widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities\n\n            let currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n\n            this.manifest = {\n                allowCache: true,\n                discontinuityStarts: [],\n                segments: []\n            }; // keep track of the last seen segment's byte range end, as segments are not required\n            // to provide the offset, in which case it defaults to the next byte after the\n            // previous segment\n\n            let lastByterangeEnd = 0; // keep track of the last seen part's byte range end.\n\n            let lastPartByterangeEnd = 0;\n            this.on('end', () => {\n                // only add preloadSegment if we don't yet have a uri for it.\n                // and we actually have parts/preloadHints\n                if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {\n                    return;\n                }\n                if (!currentUri.map && currentMap) {\n                    currentUri.map = currentMap;\n                }\n                if (!currentUri.key && key) {\n                    currentUri.key = key;\n                }\n                if (!currentUri.timeline && typeof currentTimeline === 'number') {\n                    currentUri.timeline = currentTimeline;\n                }\n                this.manifest.preloadSegment = currentUri;\n            }); // update the manifest with the m3u8 entry from the parse stream\n\n            this.parseStream.on('data', function (entry) {\n                let mediaGroup;\n                let rendition;\n                ({\n                    tag() {\n                        // switch based on the tag type\n                        (({\n                            version() {\n                                if (entry.version) {\n                                    this.manifest.version = entry.version;\n                                }\n                            },\n                            'allow-cache'() {\n                                this.manifest.allowCache = entry.allowed;\n                                if (!('allowed' in entry)) {\n                                    this.trigger('info', {\n                                        message: 'defaulting allowCache to YES'\n                                    });\n                                    this.manifest.allowCache = true;\n                                }\n                            },\n                            byterange() {\n                                const byterange = {};\n                                if ('length' in entry) {\n                                    currentUri.byterange = byterange;\n                                    byterange.length = entry.length;\n                                    if (!('offset' in entry)) {\n                                        /*\n                     * From the latest spec (as of this writing):\n                     * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2\n                     *\n                     * Same text since EXT-X-BYTERANGE's introduction in draft 7:\n                     * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)\n                     *\n                     * \"If o [offset] is not present, the sub-range begins at the next byte\n                     * following the sub-range of the previous media segment.\"\n                     */\n                                        entry.offset = lastByterangeEnd;\n                                    }\n                                }\n                                if ('offset' in entry) {\n                                    currentUri.byterange = byterange;\n                                    byterange.offset = entry.offset;\n                                }\n                                lastByterangeEnd = byterange.offset + byterange.length;\n                            },\n                            endlist() {\n                                this.manifest.endList = true;\n                            },\n                            inf() {\n                                if (!('mediaSequence' in this.manifest)) {\n                                    this.manifest.mediaSequence = 0;\n                                    this.trigger('info', {\n                                        message: 'defaulting media sequence to zero'\n                                    });\n                                }\n                                if (!('discontinuitySequence' in this.manifest)) {\n                                    this.manifest.discontinuitySequence = 0;\n                                    this.trigger('info', {\n                                        message: 'defaulting discontinuity sequence to zero'\n                                    });\n                                }\n                                if (entry.duration > 0) {\n                                    currentUri.duration = entry.duration;\n                                }\n                                if (entry.duration === 0) {\n                                    currentUri.duration = 0.01;\n                                    this.trigger('info', {\n                                        message: 'updating zero segment duration to a small value'\n                                    });\n                                }\n                                this.manifest.segments = uris;\n                            },\n                            key() {\n                                if (!entry.attributes) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring key declaration without attribute list'\n                                    });\n                                    return;\n                                } // clear the active encryption key\n\n                                if (entry.attributes.METHOD === 'NONE') {\n                                    key = null;\n                                    return;\n                                }\n                                if (!entry.attributes.URI) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring key declaration without URI'\n                                    });\n                                    return;\n                                }\n                                if (entry.attributes.KEYFORMAT === 'com.apple.streamingkeydelivery') {\n                                    this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                                    this.manifest.contentProtection['com.apple.fps.1_0'] = {\n                                        attributes: entry.attributes\n                                    };\n                                    return;\n                                }\n                                if (entry.attributes.KEYFORMAT === 'com.microsoft.playready') {\n                                    this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                                    this.manifest.contentProtection['com.microsoft.playready'] = {\n                                        uri: entry.attributes.URI\n                                    };\n                                    return;\n                                } // check if the content is encrypted for Widevine\n                                // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\n\n                                if (entry.attributes.KEYFORMAT === widevineUuid) {\n                                    const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\n                                    if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\n                                        this.trigger('warn', {\n                                            message: 'invalid key method provided for Widevine'\n                                        });\n                                        return;\n                                    }\n                                    if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {\n                                        this.trigger('warn', {\n                                            message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'\n                                        });\n                                    }\n                                    if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {\n                                        this.trigger('warn', {\n                                            message: 'invalid key URI provided for Widevine'\n                                        });\n                                        return;\n                                    }\n                                    if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {\n                                        this.trigger('warn', {\n                                            message: 'invalid key ID provided for Widevine'\n                                        });\n                                        return;\n                                    } // if Widevine key attributes are valid, store them as `contentProtection`\n                                    // on the manifest to emulate Widevine tag structure in a DASH mpd\n\n                                    this.manifest.contentProtection = this.manifest.contentProtection || {};\n                                    this.manifest.contentProtection['com.widevine.alpha'] = {\n                                        attributes: {\n                                            schemeIdUri: entry.attributes.KEYFORMAT,\n                                            // remove '0x' from the key id string\n                                            keyId: entry.attributes.KEYID.substring(2)\n                                        },\n                                        // decode the base64-encoded PSSH box\n                                        pssh: decodeB64ToUint8Array$1(entry.attributes.URI.split(',')[1])\n                                    };\n                                    return;\n                                }\n                                if (!entry.attributes.METHOD) {\n                                    this.trigger('warn', {\n                                        message: 'defaulting key method to AES-128'\n                                    });\n                                } // setup an encryption key for upcoming segments\n\n                                key = {\n                                    method: entry.attributes.METHOD || 'AES-128',\n                                    uri: entry.attributes.URI\n                                };\n                                if (typeof entry.attributes.IV !== 'undefined') {\n                                    key.iv = entry.attributes.IV;\n                                }\n                            },\n                            'media-sequence'() {\n                                if (!isFinite(entry.number)) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring invalid media sequence: ' + entry.number\n                                    });\n                                    return;\n                                }\n                                this.manifest.mediaSequence = entry.number;\n                            },\n                            'discontinuity-sequence'() {\n                                if (!isFinite(entry.number)) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                                    });\n                                    return;\n                                }\n                                this.manifest.discontinuitySequence = entry.number;\n                                currentTimeline = entry.number;\n                            },\n                            'playlist-type'() {\n                                if (!/VOD|EVENT/.test(entry.playlistType)) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring unknown playlist type: ' + entry.playlist\n                                    });\n                                    return;\n                                }\n                                this.manifest.playlistType = entry.playlistType;\n                            },\n                            map() {\n                                currentMap = {};\n                                if (entry.uri) {\n                                    currentMap.uri = entry.uri;\n                                }\n                                if (entry.byterange) {\n                                    currentMap.byterange = entry.byterange;\n                                }\n                                if (key) {\n                                    currentMap.key = key;\n                                }\n                            },\n                            'stream-inf'() {\n                                this.manifest.playlists = uris;\n                                this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n                                if (!entry.attributes) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring empty stream-inf attributes'\n                                    });\n                                    return;\n                                }\n                                if (!currentUri.attributes) {\n                                    currentUri.attributes = {};\n                                }\n                                _extends$1(currentUri.attributes, entry.attributes);\n                            },\n                            media() {\n                                this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n                                if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring incomplete or missing media group'\n                                    });\n                                    return;\n                                } // find the media group, creating defaults as necessary\n\n                                const mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n                                mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n                                mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\n\n                                rendition = {\n                                    default: /yes/i.test(entry.attributes.DEFAULT)\n                                };\n                                if (rendition.default) {\n                                    rendition.autoselect = true;\n                                } else {\n                                    rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n                                }\n                                if (entry.attributes.LANGUAGE) {\n                                    rendition.language = entry.attributes.LANGUAGE;\n                                }\n                                if (entry.attributes.URI) {\n                                    rendition.uri = entry.attributes.URI;\n                                }\n                                if (entry.attributes['INSTREAM-ID']) {\n                                    rendition.instreamId = entry.attributes['INSTREAM-ID'];\n                                }\n                                if (entry.attributes.CHARACTERISTICS) {\n                                    rendition.characteristics = entry.attributes.CHARACTERISTICS;\n                                }\n                                if (entry.attributes.FORCED) {\n                                    rendition.forced = /yes/i.test(entry.attributes.FORCED);\n                                } // insert the new rendition\n\n                                mediaGroup[entry.attributes.NAME] = rendition;\n                            },\n                            discontinuity() {\n                                currentTimeline += 1;\n                                currentUri.discontinuity = true;\n                                this.manifest.discontinuityStarts.push(uris.length);\n                            },\n                            'program-date-time'() {\n                                if (typeof this.manifest.dateTimeString === 'undefined') {\n                                    // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                                    // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                                    // to the manifest object\n                                    // TODO: Consider removing this in future major version\n                                    this.manifest.dateTimeString = entry.dateTimeString;\n                                    this.manifest.dateTimeObject = entry.dateTimeObject;\n                                }\n                                currentUri.dateTimeString = entry.dateTimeString;\n                                currentUri.dateTimeObject = entry.dateTimeObject;\n                            },\n                            targetduration() {\n                                if (!isFinite(entry.duration) || entry.duration < 0) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring invalid target duration: ' + entry.duration\n                                    });\n                                    return;\n                                }\n                                this.manifest.targetDuration = entry.duration;\n                                setHoldBack.call(this, this.manifest);\n                            },\n                            start() {\n                                if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                                    this.trigger('warn', {\n                                        message: 'ignoring start declaration without appropriate attribute list'\n                                    });\n                                    return;\n                                }\n                                this.manifest.start = {\n                                    timeOffset: entry.attributes['TIME-OFFSET'],\n                                    precise: entry.attributes.PRECISE\n                                };\n                            },\n                            'cue-out'() {\n                                currentUri.cueOut = entry.data;\n                            },\n                            'cue-out-cont'() {\n                                currentUri.cueOutCont = entry.data;\n                            },\n                            'cue-in'() {\n                                currentUri.cueIn = entry.data;\n                            },\n                            'skip'() {\n                                this.manifest.skip = camelCaseKeys(entry.attributes);\n                                this.warnOnMissingAttributes_('#EXT-X-SKIP', entry.attributes, ['SKIPPED-SEGMENTS']);\n                            },\n                            'part'() {\n                                hasParts = true; // parts are always specifed before a segment\n\n                                const segmentIndex = this.manifest.segments.length;\n                                const part = camelCaseKeys(entry.attributes);\n                                currentUri.parts = currentUri.parts || [];\n                                currentUri.parts.push(part);\n                                if (part.byterange) {\n                                    if (!part.byterange.hasOwnProperty('offset')) {\n                                        part.byterange.offset = lastPartByterangeEnd;\n                                    }\n                                    lastPartByterangeEnd = part.byterange.offset + part.byterange.length;\n                                }\n                                const partIndex = currentUri.parts.length - 1;\n                                this.warnOnMissingAttributes_(`#EXT-X-PART #${partIndex} for segment #${segmentIndex}`, entry.attributes, ['URI', 'DURATION']);\n                                if (this.manifest.renditionReports) {\n                                    this.manifest.renditionReports.forEach((r, i) => {\n                                        if (!r.hasOwnProperty('lastPart')) {\n                                            this.trigger('warn', {\n                                                message: `#EXT-X-RENDITION-REPORT #${i} lacks required attribute(s): LAST-PART`\n                                            });\n                                        }\n                                    });\n                                }\n                            },\n                            'server-control'() {\n                                const attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);\n                                if (!attrs.hasOwnProperty('canBlockReload')) {\n                                    attrs.canBlockReload = false;\n                                    this.trigger('info', {\n                                        message: '#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false'\n                                    });\n                                }\n                                setHoldBack.call(this, this.manifest);\n                                if (attrs.canSkipDateranges && !attrs.hasOwnProperty('canSkipUntil')) {\n                                    this.trigger('warn', {\n                                        message: '#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set'\n                                    });\n                                }\n                            },\n                            'preload-hint'() {\n                                // parts are always specifed before a segment\n                                const segmentIndex = this.manifest.segments.length;\n                                const hint = camelCaseKeys(entry.attributes);\n                                const isPart = hint.type && hint.type === 'PART';\n                                currentUri.preloadHints = currentUri.preloadHints || [];\n                                currentUri.preloadHints.push(hint);\n                                if (hint.byterange) {\n                                    if (!hint.byterange.hasOwnProperty('offset')) {\n                                        // use last part byterange end or zero if not a part.\n                                        hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;\n                                        if (isPart) {\n                                            lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;\n                                        }\n                                    }\n                                }\n                                const index = currentUri.preloadHints.length - 1;\n                                this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex}`, entry.attributes, ['TYPE', 'URI']);\n                                if (!hint.type) {\n                                    return;\n                                } // search through all preload hints except for the current one for\n                                // a duplicate type.\n\n                                for (let i = 0; i < currentUri.preloadHints.length - 1; i++) {\n                                    const otherHint = currentUri.preloadHints[i];\n                                    if (!otherHint.type) {\n                                        continue;\n                                    }\n                                    if (otherHint.type === hint.type) {\n                                        this.trigger('warn', {\n                                            message: `#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex} has the same TYPE ${hint.type} as preload hint #${i}`\n                                        });\n                                    }\n                                }\n                            },\n                            'rendition-report'() {\n                                const report = camelCaseKeys(entry.attributes);\n                                this.manifest.renditionReports = this.manifest.renditionReports || [];\n                                this.manifest.renditionReports.push(report);\n                                const index = this.manifest.renditionReports.length - 1;\n                                const required = ['LAST-MSN', 'URI'];\n                                if (hasParts) {\n                                    required.push('LAST-PART');\n                                }\n                                this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${index}`, entry.attributes, required);\n                            },\n                            'part-inf'() {\n                                this.manifest.partInf = camelCaseKeys(entry.attributes);\n                                this.warnOnMissingAttributes_('#EXT-X-PART-INF', entry.attributes, ['PART-TARGET']);\n                                if (this.manifest.partInf.partTarget) {\n                                    this.manifest.partTargetDuration = this.manifest.partInf.partTarget;\n                                }\n                                setHoldBack.call(this, this.manifest);\n                            }\n                        })[entry.tagType] || noop).call(self);\n                    },\n                    uri() {\n                        currentUri.uri = entry.uri;\n                        uris.push(currentUri); // if no explicit duration was declared, use the target duration\n\n                        if (this.manifest.targetDuration && !('duration' in currentUri)) {\n                            this.trigger('warn', {\n                                message: 'defaulting segment duration to the target duration'\n                            });\n                            currentUri.duration = this.manifest.targetDuration;\n                        } // annotate with encryption information, if necessary\n\n                        if (key) {\n                            currentUri.key = key;\n                        }\n                        currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n\n                        if (currentMap) {\n                            currentUri.map = currentMap;\n                        } // reset the last byterange end as it needs to be 0 between parts\n\n                        lastPartByterangeEnd = 0; // prepare for the next URI\n\n                        currentUri = {};\n                    },\n                    comment() {// comments are not important for playback\n                    },\n                    custom() {\n                        // if this is segment-level data attach the output to the segment\n                        if (entry.segment) {\n                            currentUri.custom = currentUri.custom || {};\n                            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n                        } else {\n                            this.manifest.custom = this.manifest.custom || {};\n                            this.manifest.custom[entry.customType] = entry.data;\n                        }\n                    }\n                })[entry.type].call(self);\n            });\n        }\n        warnOnMissingAttributes_(identifier, attributes, required) {\n            const missing = [];\n            required.forEach(function (key) {\n                if (!attributes.hasOwnProperty(key)) {\n                    missing.push(key);\n                }\n            });\n            if (missing.length) {\n                this.trigger('warn', {\n                    message: `${identifier} lacks required attribute(s): ${missing.join(', ')}`\n                });\n            }\n        }\n        /**\n         * Parse the input string and update the manifest object.\n         *\n         * @param {string} chunk a potentially incomplete portion of the manifest\n         */\n\n        push(chunk) {\n            this.lineStream.push(chunk);\n        }\n        /**\n         * Flush any remaining input. This can be handy if the last line of an M3U8\n         * manifest did not contain a trailing newline but the file has been\n         * completely received.\n         */\n\n        end() {\n            // flush any buffered input\n            this.lineStream.push('\\n');\n            this.trigger('end');\n        }\n        /**\n         * Add an additional parser for non-standard tags\n         *\n         * @param {Object}   options              a map of options for the added parser\n         * @param {RegExp}   options.expression   a regular expression to match the custom header\n         * @param {string}   options.type         the type to register to the output\n         * @param {Function} [options.dataParser] function to parse the line into an object\n         * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n         */\n\n        addParser(options) {\n            this.parseStream.addParser(options);\n        }\n        /**\n         * Add a custom header mapper\n         *\n         * @param {Object}   options\n         * @param {RegExp}   options.expression   a regular expression to match the custom header\n         * @param {Function} options.map          function to translate tag into a different tag\n         */\n\n        addTagMapper(options) {\n            this.parseStream.addTagMapper(options);\n        }\n    }\n\n    var regexs = {\n        // to determine mime types\n        mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,\n        webm: /^(vp0?[89]|av0?1|opus|vorbis)/,\n        ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,\n        // to determine if a codec is audio or video\n        video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,\n        audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,\n        text: /^(stpp.ttml.im1t)/,\n        // mux.js support regex\n        muxerVideo: /^(avc0?1)/,\n        muxerAudio: /^(mp4a)/,\n        // match nothing as muxer does not support text right now.\n        // there cannot never be a character before the start of a string\n        // so this matches nothing.\n        muxerText: /a^/\n    };\n    var mediaTypes = ['video', 'audio', 'text'];\n    var upperMediaTypes = ['Video', 'Audio', 'Text'];\n    /**\n     * Replace the old apple-style `avc1.<dd>.<dd>` codec string with the standard\n     * `avc1.<hhhhhh>`\n     *\n     * @param {string} codec\n     *        Codec string to translate\n     * @return {string}\n     *         The translated codec string\n     */\n\n    var translateLegacyCodec = function translateLegacyCodec(codec) {\n        if (!codec) {\n            return codec;\n        }\n        return codec.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (orig, profile, avcLevel) {\n            var profileHex = ('00' + Number(profile).toString(16)).slice(-2);\n            var avcLevelHex = ('00' + Number(avcLevel).toString(16)).slice(-2);\n            return 'avc1.' + profileHex + '00' + avcLevelHex;\n        });\n    };\n    /**\n     * @typedef {Object} ParsedCodecInfo\n     * @property {number} codecCount\n     *           Number of codecs parsed\n     * @property {string} [videoCodec]\n     *           Parsed video codec (if found)\n     * @property {string} [videoObjectTypeIndicator]\n     *           Video object type indicator (if found)\n     * @property {string|null} audioProfile\n     *           Audio profile\n     */\n\n    /**\n     * Parses a codec string to retrieve the number of codecs specified, the video codec and\n     * object type indicator, and the audio profile.\n     *\n     * @param {string} [codecString]\n     *        The codec string to parse\n     * @return {ParsedCodecInfo}\n     *         Parsed codec info\n     */\n\n    var parseCodecs = function parseCodecs(codecString) {\n        if (codecString === void 0) {\n            codecString = '';\n        }\n        var codecs = codecString.split(',');\n        var result = [];\n        codecs.forEach(function (codec) {\n            codec = codec.trim();\n            var codecType;\n            mediaTypes.forEach(function (name) {\n                var match = regexs[name].exec(codec.toLowerCase());\n                if (!match || match.length <= 1) {\n                    return;\n                }\n                codecType = name; // maintain codec case\n\n                var type = codec.substring(0, match[1].length);\n                var details = codec.replace(type, '');\n                result.push({\n                    type: type,\n                    details: details,\n                    mediaType: name\n                });\n            });\n            if (!codecType) {\n                result.push({\n                    type: codec,\n                    details: '',\n                    mediaType: 'unknown'\n                });\n            }\n        });\n        return result;\n    };\n    /**\n     * Returns a ParsedCodecInfo object for the default alternate audio playlist if there is\n     * a default alternate audio playlist for the provided audio group.\n     *\n     * @param {Object} master\n     *        The master playlist\n     * @param {string} audioGroupId\n     *        ID of the audio group for which to find the default codec info\n     * @return {ParsedCodecInfo}\n     *         Parsed codec info\n     */\n\n    var codecsFromDefault = function codecsFromDefault(master, audioGroupId) {\n        if (!master.mediaGroups.AUDIO || !audioGroupId) {\n            return null;\n        }\n        var audioGroup = master.mediaGroups.AUDIO[audioGroupId];\n        if (!audioGroup) {\n            return null;\n        }\n        for (var name in audioGroup) {\n            var audioType = audioGroup[name];\n            if (audioType.default && audioType.playlists) {\n                // codec should be the same for all playlists within the audio type\n                return parseCodecs(audioType.playlists[0].attributes.CODECS);\n            }\n        }\n        return null;\n    };\n    var isAudioCodec = function isAudioCodec(codec) {\n        if (codec === void 0) {\n            codec = '';\n        }\n        return regexs.audio.test(codec.trim().toLowerCase());\n    };\n    var isTextCodec = function isTextCodec(codec) {\n        if (codec === void 0) {\n            codec = '';\n        }\n        return regexs.text.test(codec.trim().toLowerCase());\n    };\n    var getMimeForCodec = function getMimeForCodec(codecString) {\n        if (!codecString || typeof codecString !== 'string') {\n            return;\n        }\n        var codecs = codecString.toLowerCase().split(',').map(function (c) {\n            return translateLegacyCodec(c.trim());\n        }); // default to video type\n\n        var type = 'video'; // only change to audio type if the only codec we have is\n        // audio\n\n        if (codecs.length === 1 && isAudioCodec(codecs[0])) {\n            type = 'audio';\n        } else if (codecs.length === 1 && isTextCodec(codecs[0])) {\n            // text uses application/<container> for now\n            type = 'application';\n        } // default the container to mp4\n\n        var container = 'mp4'; // every codec must be able to go into the container\n        // for that container to be the correct one\n\n        if (codecs.every(function (c) {\n            return regexs.mp4.test(c);\n        })) {\n            container = 'mp4';\n        } else if (codecs.every(function (c) {\n            return regexs.webm.test(c);\n        })) {\n            container = 'webm';\n        } else if (codecs.every(function (c) {\n            return regexs.ogg.test(c);\n        })) {\n            container = 'ogg';\n        }\n        return type + \"/\" + container + \";codecs=\\\"\" + codecString + \"\\\"\";\n    };\n    var browserSupportsCodec = function browserSupportsCodec(codecString) {\n        if (codecString === void 0) {\n            codecString = '';\n        }\n        return window.MediaSource && window.MediaSource.isTypeSupported && window.MediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;\n    };\n    var muxerSupportsCodec = function muxerSupportsCodec(codecString) {\n        if (codecString === void 0) {\n            codecString = '';\n        }\n        return codecString.toLowerCase().split(',').every(function (codec) {\n            codec = codec.trim(); // any match is supported.\n\n            for (var i = 0; i < upperMediaTypes.length; i++) {\n                var type = upperMediaTypes[i];\n                if (regexs[\"muxer\" + type].test(codec)) {\n                    return true;\n                }\n            }\n            return false;\n        });\n    };\n    var DEFAULT_AUDIO_CODEC = 'mp4a.40.2';\n    var DEFAULT_VIDEO_CODEC = 'avc1.4d400d';\n\n    var MPEGURL_REGEX = /^(audio|video|application)\\/(x-|vnd\\.apple\\.)?mpegurl/i;\n    var DASH_REGEX = /^application\\/dash\\+xml/i;\n    /**\n     * Returns a string that describes the type of source based on a video source object's\n     * media type.\n     *\n     * @see {@link https://dev.w3.org/html5/pf-summary/video.html#dom-source-type|Source Type}\n     *\n     * @param {string} type\n     *        Video source object media type\n     * @return {('hls'|'dash'|'vhs-json'|null)}\n     *         VHS source type string\n     */\n\n    var simpleTypeFromSourceType = function simpleTypeFromSourceType(type) {\n        if (MPEGURL_REGEX.test(type)) {\n            return 'hls';\n        }\n        if (DASH_REGEX.test(type)) {\n            return 'dash';\n        } // Denotes the special case of a manifest object passed to http-streaming instead of a\n        // source URL.\n        //\n        // See https://en.wikipedia.org/wiki/Media_type for details on specifying media types.\n        //\n        // In this case, vnd stands for vendor, video.js for the organization, VHS for this\n        // project, and the +json suffix identifies the structure of the media type.\n\n        if (type === 'application/vnd.videojs.vhs+json') {\n            return 'vhs-json';\n        }\n        return null;\n    };\n\n    // const log2 = Math.log2 ? Math.log2 : (x) => (Math.log(x) / Math.log(2));\n    // we used to do this with log2 but BigInt does not support builtin math\n    // Math.ceil(log2(x));\n\n    var countBits = function countBits(x) {\n        return x.toString(2).length;\n    }; // count the number of whole bytes it would take to represent a number\n\n    var countBytes = function countBytes(x) {\n        return Math.ceil(countBits(x) / 8);\n    };\n    var isArrayBufferView = function isArrayBufferView(obj) {\n        if (ArrayBuffer.isView === 'function') {\n            return ArrayBuffer.isView(obj);\n        }\n        return obj && obj.buffer instanceof ArrayBuffer;\n    };\n    var isTypedArray = function isTypedArray(obj) {\n        return isArrayBufferView(obj);\n    };\n    var toUint8 = function toUint8(bytes) {\n        if (bytes instanceof Uint8Array) {\n            return bytes;\n        }\n        if (!Array.isArray(bytes) && !isTypedArray(bytes) && !(bytes instanceof ArrayBuffer)) {\n            // any non-number or NaN leads to empty uint8array\n            // eslint-disable-next-line\n            if (typeof bytes !== 'number' || typeof bytes === 'number' && bytes !== bytes) {\n                bytes = 0;\n            } else {\n                bytes = [bytes];\n            }\n        }\n        return new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);\n    };\n    var BigInt = window.BigInt || Number;\n    var BYTE_TABLE = [BigInt('0x1'), BigInt('0x100'), BigInt('0x10000'), BigInt('0x1000000'), BigInt('0x100000000'), BigInt('0x10000000000'), BigInt('0x1000000000000'), BigInt('0x100000000000000'), BigInt('0x10000000000000000')];\n    (function () {\n        var a = new Uint16Array([0xFFCC]);\n        var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n        if (b[0] === 0xFF) {\n            return 'big';\n        }\n        if (b[0] === 0xCC) {\n            return 'little';\n        }\n        return 'unknown';\n    })();\n    var bytesToNumber = function bytesToNumber(bytes, _temp) {\n        var _ref = _temp === void 0 ? {} : _temp,\n            _ref$signed = _ref.signed,\n            signed = _ref$signed === void 0 ? false : _ref$signed,\n            _ref$le = _ref.le,\n            le = _ref$le === void 0 ? false : _ref$le;\n        bytes = toUint8(bytes);\n        var fn = le ? 'reduce' : 'reduceRight';\n        var obj = bytes[fn] ? bytes[fn] : Array.prototype[fn];\n        var number = obj.call(bytes, function (total, byte, i) {\n            var exponent = le ? i : Math.abs(i + 1 - bytes.length);\n            return total + BigInt(byte) * BYTE_TABLE[exponent];\n        }, BigInt(0));\n        if (signed) {\n            var max = BYTE_TABLE[bytes.length] / BigInt(2) - BigInt(1);\n            number = BigInt(number);\n            if (number > max) {\n                number -= max;\n                number -= max;\n                number -= BigInt(2);\n            }\n        }\n        return Number(number);\n    };\n    var numberToBytes = function numberToBytes(number, _temp2) {\n        var _ref2 = _temp2 === void 0 ? {} : _temp2,\n            _ref2$le = _ref2.le,\n            le = _ref2$le === void 0 ? false : _ref2$le;\n\n        // eslint-disable-next-line\n        if (typeof number !== 'bigint' && typeof number !== 'number' || typeof number === 'number' && number !== number) {\n            number = 0;\n        }\n        number = BigInt(number);\n        var byteCount = countBytes(number);\n        var bytes = new Uint8Array(new ArrayBuffer(byteCount));\n        for (var i = 0; i < byteCount; i++) {\n            var byteIndex = le ? i : Math.abs(i + 1 - bytes.length);\n            bytes[byteIndex] = Number(number / BYTE_TABLE[i] & BigInt(0xFF));\n            if (number < 0) {\n                bytes[byteIndex] = Math.abs(~bytes[byteIndex]);\n                bytes[byteIndex] -= i === 0 ? 1 : 2;\n            }\n        }\n        return bytes;\n    };\n    var stringToBytes = function stringToBytes(string, stringIsBytes) {\n        if (typeof string !== 'string' && string && typeof string.toString === 'function') {\n            string = string.toString();\n        }\n        if (typeof string !== 'string') {\n            return new Uint8Array();\n        } // If the string already is bytes, we don't have to do this\n        // otherwise we do this so that we split multi length characters\n        // into individual bytes\n\n        if (!stringIsBytes) {\n            string = unescape(encodeURIComponent(string));\n        }\n        var view = new Uint8Array(string.length);\n        for (var i = 0; i < string.length; i++) {\n            view[i] = string.charCodeAt(i);\n        }\n        return view;\n    };\n    var concatTypedArrays = function concatTypedArrays() {\n        for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {\n            buffers[_key] = arguments[_key];\n        }\n        buffers = buffers.filter(function (b) {\n            return b && (b.byteLength || b.length) && typeof b !== 'string';\n        });\n        if (buffers.length <= 1) {\n            // for 0 length we will return empty uint8\n            // for 1 length we return the first uint8\n            return toUint8(buffers[0]);\n        }\n        var totalLen = buffers.reduce(function (total, buf, i) {\n            return total + (buf.byteLength || buf.length);\n        }, 0);\n        var tempBuffer = new Uint8Array(totalLen);\n        var offset = 0;\n        buffers.forEach(function (buf) {\n            buf = toUint8(buf);\n            tempBuffer.set(buf, offset);\n            offset += buf.byteLength;\n        });\n        return tempBuffer;\n    };\n    /**\n     * Check if the bytes \"b\" are contained within bytes \"a\".\n     *\n     * @param {Uint8Array|Array} a\n     *        Bytes to check in\n     *\n     * @param {Uint8Array|Array} b\n     *        Bytes to check for\n     *\n     * @param {Object} options\n     *        options\n     *\n     * @param {Array|Uint8Array} [offset=0]\n     *        offset to use when looking at bytes in a\n     *\n     * @param {Array|Uint8Array} [mask=[]]\n     *        mask to use on bytes before comparison.\n     *\n     * @return {boolean}\n     *         If all bytes in b are inside of a, taking into account\n     *         bit masks.\n     */\n\n    var bytesMatch = function bytesMatch(a, b, _temp3) {\n        var _ref3 = _temp3 === void 0 ? {} : _temp3,\n            _ref3$offset = _ref3.offset,\n            offset = _ref3$offset === void 0 ? 0 : _ref3$offset,\n            _ref3$mask = _ref3.mask,\n            mask = _ref3$mask === void 0 ? [] : _ref3$mask;\n        a = toUint8(a);\n        b = toUint8(b); // ie 11 does not support uint8 every\n\n        var fn = b.every ? b.every : Array.prototype.every;\n        return b.length && a.length - offset >= b.length &&\n            // ie 11 doesn't support every on uin8\n            fn.call(b, function (bByte, i) {\n                var aByte = mask[i] ? mask[i] & a[offset + i] : a[offset + i];\n                return bByte === aByte;\n            });\n    };\n\n    var DEFAULT_LOCATION = 'http://example.com';\n    var resolveUrl$1 = function resolveUrl(baseUrl, relativeUrl) {\n        // return early if we don't need to resolve\n        if (/^[a-z]+:/i.test(relativeUrl)) {\n            return relativeUrl;\n        } // if baseUrl is a data URI, ignore it and resolve everything relative to window.location\n\n        if (/^data:/.test(baseUrl)) {\n            baseUrl = window.location && window.location.href || '';\n        } // IE11 supports URL but not the URL constructor\n        // feature detect the behavior we want\n\n        var nativeURL = typeof window.URL === 'function';\n        var protocolLess = /^\\/\\//.test(baseUrl); // remove location if window.location isn't available (i.e. we're in node)\n        // and if baseUrl isn't an absolute url\n\n        var removeLocation = !window.location && !/\\/\\//i.test(baseUrl); // if the base URL is relative then combine with the current location\n\n        if (nativeURL) {\n            baseUrl = new window.URL(baseUrl, window.location || DEFAULT_LOCATION);\n        } else if (!/\\/\\//i.test(baseUrl)) {\n            baseUrl = urlToolkit.buildAbsoluteURL(window.location && window.location.href || '', baseUrl);\n        }\n        if (nativeURL) {\n            var newUrl = new URL(relativeUrl, baseUrl); // if we're a protocol-less url, remove the protocol\n            // and if we're location-less, remove the location\n            // otherwise, return the url unmodified\n\n            if (removeLocation) {\n                return newUrl.href.slice(DEFAULT_LOCATION.length);\n            } else if (protocolLess) {\n                return newUrl.href.slice(newUrl.protocol.length);\n            }\n            return newUrl.href;\n        }\n        return urlToolkit.buildAbsoluteURL(baseUrl, relativeUrl);\n    };\n\n    /**\n     * Loops through all supported media groups in master and calls the provided\n     * callback for each group\n     *\n     * @param {Object} master\n     *        The parsed master manifest object\n     * @param {string[]} groups\n     *        The media groups to call the callback for\n     * @param {Function} callback\n     *        Callback to call for each media group\n     */\n    var forEachMediaGroup$1 = function forEachMediaGroup(master, groups, callback) {\n        groups.forEach(function (mediaType) {\n            for (var groupKey in master.mediaGroups[mediaType]) {\n                for (var labelKey in master.mediaGroups[mediaType][groupKey]) {\n                    var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];\n                    callback(mediaProperties, mediaType, groupKey, labelKey);\n                }\n            }\n        });\n    };\n\n    var atob = function atob(s) {\n        return window.atob ? window.atob(s) : Buffer.from(s, 'base64').toString('binary');\n    };\n    function decodeB64ToUint8Array(b64Text) {\n        var decodedString = atob(b64Text);\n        var array = new Uint8Array(decodedString.length);\n        for (var i = 0; i < decodedString.length; i++) {\n            array[i] = decodedString.charCodeAt(i);\n        }\n        return array;\n    }\n\n    /**\n     * Ponyfill for `Array.prototype.find` which is only available in ES6 runtimes.\n     *\n     * Works with anything that has a `length` property and index access properties, including NodeList.\n     *\n     * @template {unknown} T\n     * @param {Array<T> | ({length:number, [number]: T})} list\n     * @param {function (item: T, index: number, list:Array<T> | ({length:number, [number]: T})):boolean} predicate\n     * @param {Partial<Pick<ArrayConstructor['prototype'], 'find'>>?} ac `Array.prototype` by default,\n     * \t\t\t\tallows injecting a custom implementation in tests\n     * @returns {T | undefined}\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find\n     * @see https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.find\n     */\n    function find$1(list, predicate, ac) {\n        if (ac === undefined) {\n            ac = Array.prototype;\n        }\n        if (list && typeof ac.find === 'function') {\n            return ac.find.call(list, predicate);\n        }\n        for (var i = 0; i < list.length; i++) {\n            if (Object.prototype.hasOwnProperty.call(list, i)) {\n                var item = list[i];\n                if (predicate.call(undefined, item, i, list)) {\n                    return item;\n                }\n            }\n        }\n    }\n\n    /**\n     * \"Shallow freezes\" an object to render it immutable.\n     * Uses `Object.freeze` if available,\n     * otherwise the immutability is only in the type.\n     *\n     * Is used to create \"enum like\" objects.\n     *\n     * @template T\n     * @param {T} object the object to freeze\n     * @param {Pick<ObjectConstructor, 'freeze'> = Object} oc `Object` by default,\n     * \t\t\t\tallows to inject custom object constructor for tests\n     * @returns {Readonly<T>}\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\n     */\n    function freeze(object, oc) {\n        if (oc === undefined) {\n            oc = Object;\n        }\n        return oc && typeof oc.freeze === 'function' ? oc.freeze(object) : object;\n    }\n\n    /**\n     * Since we can not rely on `Object.assign` we provide a simplified version\n     * that is sufficient for our needs.\n     *\n     * @param {Object} target\n     * @param {Object | null | undefined} source\n     *\n     * @returns {Object} target\n     * @throws TypeError if target is not an object\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n     * @see https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign\n     */\n    function assign(target, source) {\n        if (target === null || typeof target !== 'object') {\n            throw new TypeError('target is not an object');\n        }\n        for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * All mime types that are allowed as input to `DOMParser.parseFromString`\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#Argument02 MDN\n     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#domparsersupportedtype WHATWG HTML Spec\n     * @see DOMParser.prototype.parseFromString\n     */\n    var MIME_TYPE = freeze({\n        /**\n         * `text/html`, the only mime type that triggers treating an XML document as HTML.\n         *\n         * @see DOMParser.SupportedType.isHTML\n         * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration\n         * @see https://en.wikipedia.org/wiki/HTML Wikipedia\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN\n         * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec\n         */\n        HTML: 'text/html',\n        /**\n         * Helper method to check a mime type if it indicates an HTML document\n         *\n         * @param {string} [value]\n         * @returns {boolean}\n         *\n         * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration\n         * @see https://en.wikipedia.org/wiki/HTML Wikipedia\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN\n         * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring \t */\n        isHTML: function (value) {\n            return value === MIME_TYPE.HTML;\n        },\n        /**\n         * `application/xml`, the standard mime type for XML documents.\n         *\n         * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration\n         * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303\n         * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia\n         */\n        XML_APPLICATION: 'application/xml',\n        /**\n         * `text/html`, an alias for `application/xml`.\n         *\n         * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303\n         * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration\n         * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia\n         */\n        XML_TEXT: 'text/xml',\n        /**\n         * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,\n         * but is parsed as an XML document.\n         *\n         * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration\n         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec\n         * @see https://en.wikipedia.org/wiki/XHTML Wikipedia\n         */\n        XML_XHTML_APPLICATION: 'application/xhtml+xml',\n        /**\n         * `image/svg+xml`,\n         *\n         * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration\n         * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1\n         * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia\n         */\n        XML_SVG_IMAGE: 'image/svg+xml'\n    });\n\n    /**\n     * Namespaces that are used in this code base.\n     *\n     * @see http://www.w3.org/TR/REC-xml-names\n     */\n    var NAMESPACE$3 = freeze({\n        /**\n         * The XHTML namespace.\n         *\n         * @see http://www.w3.org/1999/xhtml\n         */\n        HTML: 'http://www.w3.org/1999/xhtml',\n        /**\n         * Checks if `uri` equals `NAMESPACE.HTML`.\n         *\n         * @param {string} [uri]\n         *\n         * @see NAMESPACE.HTML\n         */\n        isHTML: function (uri) {\n            return uri === NAMESPACE$3.HTML;\n        },\n        /**\n         * The SVG namespace.\n         *\n         * @see http://www.w3.org/2000/svg\n         */\n        SVG: 'http://www.w3.org/2000/svg',\n        /**\n         * The `xml:` namespace.\n         *\n         * @see http://www.w3.org/XML/1998/namespace\n         */\n        XML: 'http://www.w3.org/XML/1998/namespace',\n        /**\n         * The `xmlns:` namespace\n         *\n         * @see https://www.w3.org/2000/xmlns/\n         */\n        XMLNS: 'http://www.w3.org/2000/xmlns/'\n    });\n    var assign_1 = assign;\n    var find_1 = find$1;\n    var freeze_1 = freeze;\n    var MIME_TYPE_1 = MIME_TYPE;\n    var NAMESPACE_1 = NAMESPACE$3;\n    var conventions = {\n        assign: assign_1,\n        find: find_1,\n        freeze: freeze_1,\n        MIME_TYPE: MIME_TYPE_1,\n        NAMESPACE: NAMESPACE_1\n    };\n\n    var find = conventions.find;\n    var NAMESPACE$2 = conventions.NAMESPACE;\n\n    /**\n     * A prerequisite for `[].filter`, to drop elements that are empty\n     * @param {string} input\n     * @returns {boolean}\n     */\n    function notEmptyString(input) {\n        return input !== '';\n    }\n    /**\n     * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace\n     * @see https://infra.spec.whatwg.org/#ascii-whitespace\n     *\n     * @param {string} input\n     * @returns {string[]} (can be empty)\n     */\n    function splitOnASCIIWhitespace(input) {\n        // U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE\n        return input ? input.split(/[\\t\\n\\f\\r ]+/).filter(notEmptyString) : [];\n    }\n\n    /**\n     * Adds element as a key to current if it is not already present.\n     *\n     * @param {Record<string, boolean | undefined>} current\n     * @param {string} element\n     * @returns {Record<string, boolean | undefined>}\n     */\n    function orderedSetReducer(current, element) {\n        if (!current.hasOwnProperty(element)) {\n            current[element] = true;\n        }\n        return current;\n    }\n\n    /**\n     * @see https://infra.spec.whatwg.org/#ordered-set\n     * @param {string} input\n     * @returns {string[]}\n     */\n    function toOrderedSet(input) {\n        if (!input) return [];\n        var list = splitOnASCIIWhitespace(input);\n        return Object.keys(list.reduce(orderedSetReducer, {}));\n    }\n\n    /**\n     * Uses `list.indexOf` to implement something like `Array.prototype.includes`,\n     * which we can not rely on being available.\n     *\n     * @param {any[]} list\n     * @returns {function(any): boolean}\n     */\n    function arrayIncludes(list) {\n        return function (element) {\n            return list && list.indexOf(element) !== -1;\n        };\n    }\n    function copy(src, dest) {\n        for (var p in src) {\n            if (Object.prototype.hasOwnProperty.call(src, p)) {\n                dest[p] = src[p];\n            }\n        }\n    }\n\n    /**\n     ^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*((?:.*\\{\\s*?[\\r\\n][\\s\\S]*?^})|\\S.*?(?=[;\\r\\n]));?\n     ^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*(\\S.*?(?=[;\\r\\n]));?\n     */\n    function _extends(Class, Super) {\n        var pt = Class.prototype;\n        if (!(pt instanceof Super)) {\n            function t() {}\n            t.prototype = Super.prototype;\n            t = new t();\n            copy(pt, t);\n            Class.prototype = pt = t;\n        }\n        if (pt.constructor != Class) {\n            if (typeof Class != 'function') {\n                console.error(\"unknown Class:\" + Class);\n            }\n            pt.constructor = Class;\n        }\n    }\n\n    // Node Types\n    var NodeType = {};\n    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;\n    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;\n    var TEXT_NODE = NodeType.TEXT_NODE = 3;\n    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;\n    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;\n    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;\n    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;\n    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;\n    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;\n    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;\n    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;\n    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;\n\n    // ExceptionCode\n    var ExceptionCode = {};\n    var ExceptionMessage = {};\n    ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = \"Index size error\", 1);\n    ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = \"DOMString size error\", 2);\n    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = \"Hierarchy request error\", 3);\n    ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = \"Wrong document\", 4);\n    ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = \"Invalid character\", 5);\n    ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = \"No data allowed\", 6);\n    ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = \"No modification allowed\", 7);\n    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = \"Not found\", 8);\n    ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = \"Not supported\", 9);\n    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = \"Attribute in use\", 10);\n    //level2\n    ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = \"Invalid state\", 11);\n    ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = \"Syntax error\", 12);\n    ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = \"Invalid modification\", 13);\n    ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = \"Invalid namespace\", 14);\n    ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = \"Invalid access\", 15);\n\n    /**\n     * DOM Level 2\n     * Object DOMException\n     * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html\n     * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html\n     */\n    function DOMException(code, message) {\n        if (message instanceof Error) {\n            var error = message;\n        } else {\n            error = this;\n            Error.call(this, ExceptionMessage[code]);\n            this.message = ExceptionMessage[code];\n            if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);\n        }\n        error.code = code;\n        if (message) this.message = this.message + \": \" + message;\n        return error;\n    }\n    DOMException.prototype = Error.prototype;\n    copy(ExceptionCode, DOMException);\n\n    /**\n     * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177\n     * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.\n     * The items in the NodeList are accessible via an integral index, starting from 0.\n     */\n    function NodeList() {}\n    NodeList.prototype = {\n        /**\n         * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.\n         * @standard level1\n         */\n        length: 0,\n        /**\n         * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.\n         * @standard level1\n         * @param index  unsigned long\n         *   Index into the collection.\n         * @return Node\n         * \tThe node at the indexth position in the NodeList, or null if that is not a valid index.\n         */\n        item: function (index) {\n            return this[index] || null;\n        },\n        toString: function (isHTML, nodeFilter) {\n            for (var buf = [], i = 0; i < this.length; i++) {\n                serializeToString(this[i], buf, isHTML, nodeFilter);\n            }\n            return buf.join('');\n        },\n        /**\n         * @private\n         * @param {function (Node):boolean} predicate\n         * @returns {Node[]}\n         */\n        filter: function (predicate) {\n            return Array.prototype.filter.call(this, predicate);\n        },\n        /**\n         * @private\n         * @param {Node} item\n         * @returns {number}\n         */\n        indexOf: function (item) {\n            return Array.prototype.indexOf.call(this, item);\n        }\n    };\n    function LiveNodeList(node, refresh) {\n        this._node = node;\n        this._refresh = refresh;\n        _updateLiveList(this);\n    }\n    function _updateLiveList(list) {\n        var inc = list._node._inc || list._node.ownerDocument._inc;\n        if (list._inc != inc) {\n            var ls = list._refresh(list._node);\n            //console.log(ls.length)\n            __set__(list, 'length', ls.length);\n            copy(ls, list);\n            list._inc = inc;\n        }\n    }\n    LiveNodeList.prototype.item = function (i) {\n        _updateLiveList(this);\n        return this[i];\n    };\n    _extends(LiveNodeList, NodeList);\n\n    /**\n     * Objects implementing the NamedNodeMap interface are used\n     * to represent collections of nodes that can be accessed by name.\n     * Note that NamedNodeMap does not inherit from NodeList;\n     * NamedNodeMaps are not maintained in any particular order.\n     * Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index,\n     * but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,\n     * and does not imply that the DOM specifies an order to these Nodes.\n     * NamedNodeMap objects in the DOM are live.\n     * used for attributes or DocumentType entities\n     */\n    function NamedNodeMap() {}\n    function _findNodeIndex(list, node) {\n        var i = list.length;\n        while (i--) {\n            if (list[i] === node) {\n                return i;\n            }\n        }\n    }\n    function _addNamedNode(el, list, newAttr, oldAttr) {\n        if (oldAttr) {\n            list[_findNodeIndex(list, oldAttr)] = newAttr;\n        } else {\n            list[list.length++] = newAttr;\n        }\n        if (el) {\n            newAttr.ownerElement = el;\n            var doc = el.ownerDocument;\n            if (doc) {\n                oldAttr && _onRemoveAttribute(doc, el, oldAttr);\n                _onAddAttribute(doc, el, newAttr);\n            }\n        }\n    }\n    function _removeNamedNode(el, list, attr) {\n        //console.log('remove attr:'+attr)\n        var i = _findNodeIndex(list, attr);\n        if (i >= 0) {\n            var lastIndex = list.length - 1;\n            while (i < lastIndex) {\n                list[i] = list[++i];\n            }\n            list.length = lastIndex;\n            if (el) {\n                var doc = el.ownerDocument;\n                if (doc) {\n                    _onRemoveAttribute(doc, el, attr);\n                    attr.ownerElement = null;\n                }\n            }\n        } else {\n            throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + '@' + attr));\n        }\n    }\n    NamedNodeMap.prototype = {\n        length: 0,\n        item: NodeList.prototype.item,\n        getNamedItem: function (key) {\n            //\t\tif(key.indexOf(':')>0 || key == 'xmlns'){\n            //\t\t\treturn null;\n            //\t\t}\n            //console.log()\n            var i = this.length;\n            while (i--) {\n                var attr = this[i];\n                //console.log(attr.nodeName,key)\n                if (attr.nodeName == key) {\n                    return attr;\n                }\n            }\n        },\n        setNamedItem: function (attr) {\n            var el = attr.ownerElement;\n            if (el && el != this._ownerElement) {\n                throw new DOMException(INUSE_ATTRIBUTE_ERR);\n            }\n            var oldAttr = this.getNamedItem(attr.nodeName);\n            _addNamedNode(this._ownerElement, this, attr, oldAttr);\n            return oldAttr;\n        },\n        /* returns Node */\n        setNamedItemNS: function (attr) {\n            // raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR\n            var el = attr.ownerElement,\n                oldAttr;\n            if (el && el != this._ownerElement) {\n                throw new DOMException(INUSE_ATTRIBUTE_ERR);\n            }\n            oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);\n            _addNamedNode(this._ownerElement, this, attr, oldAttr);\n            return oldAttr;\n        },\n        /* returns Node */\n        removeNamedItem: function (key) {\n            var attr = this.getNamedItem(key);\n            _removeNamedNode(this._ownerElement, this, attr);\n            return attr;\n        },\n        // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR\n\n        //for level2\n        removeNamedItemNS: function (namespaceURI, localName) {\n            var attr = this.getNamedItemNS(namespaceURI, localName);\n            _removeNamedNode(this._ownerElement, this, attr);\n            return attr;\n        },\n        getNamedItemNS: function (namespaceURI, localName) {\n            var i = this.length;\n            while (i--) {\n                var node = this[i];\n                if (node.localName == localName && node.namespaceURI == namespaceURI) {\n                    return node;\n                }\n            }\n            return null;\n        }\n    };\n\n    /**\n     * The DOMImplementation interface represents an object providing methods\n     * which are not dependent on any particular document.\n     * Such an object is returned by the `Document.implementation` property.\n     *\n     * __The individual methods describe the differences compared to the specs.__\n     *\n     * @constructor\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN\n     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core (Initial)\n     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core\n     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core\n     * @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard\n     */\n    function DOMImplementation$1() {}\n    DOMImplementation$1.prototype = {\n        /**\n         * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.\n         * The different implementations fairly diverged in what kind of features were reported.\n         * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.\n         *\n         * @deprecated It is deprecated and modern browsers return true in all cases.\n         *\n         * @param {string} feature\n         * @param {string} [version]\n         * @returns {boolean} always true\n         *\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN\n         * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core\n         * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard\n         */\n        hasFeature: function (feature, version) {\n            return true;\n        },\n        /**\n         * Creates an XML Document object of the specified type with its document element.\n         *\n         * __It behaves slightly different from the description in the living standard__:\n         * - There is no interface/class `XMLDocument`, it returns a `Document` instance.\n         * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.\n         * - this implementation is not validating names or qualified names\n         *   (when parsing XML strings, the SAX parser takes care of that)\n         *\n         * @param {string|null} namespaceURI\n         * @param {string} qualifiedName\n         * @param {DocumentType=null} doctype\n         * @returns {Document}\n         *\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN\n         * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)\n         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core\n         *\n         * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract\n         * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names\n         * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names\n         */\n        createDocument: function (namespaceURI, qualifiedName, doctype) {\n            var doc = new Document();\n            doc.implementation = this;\n            doc.childNodes = new NodeList();\n            doc.doctype = doctype || null;\n            if (doctype) {\n                doc.appendChild(doctype);\n            }\n            if (qualifiedName) {\n                var root = doc.createElementNS(namespaceURI, qualifiedName);\n                doc.appendChild(root);\n            }\n            return doc;\n        },\n        /**\n         * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.\n         *\n         * __This behavior is slightly different from the in the specs__:\n         * - this implementation is not validating names or qualified names\n         *   (when parsing XML strings, the SAX parser takes care of that)\n         *\n         * @param {string} qualifiedName\n         * @param {string} [publicId]\n         * @param {string} [systemId]\n         * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation\n         * \t\t\t\t  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`\n         *\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN\n         * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core\n         * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard\n         *\n         * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract\n         * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names\n         * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names\n         */\n        createDocumentType: function (qualifiedName, publicId, systemId) {\n            var node = new DocumentType();\n            node.name = qualifiedName;\n            node.nodeName = qualifiedName;\n            node.publicId = publicId || '';\n            node.systemId = systemId || '';\n            return node;\n        }\n    };\n\n    /**\n     * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247\n     */\n\n    function Node() {}\n    Node.prototype = {\n        firstChild: null,\n        lastChild: null,\n        previousSibling: null,\n        nextSibling: null,\n        attributes: null,\n        parentNode: null,\n        childNodes: null,\n        ownerDocument: null,\n        nodeValue: null,\n        namespaceURI: null,\n        prefix: null,\n        localName: null,\n        // Modified in DOM Level 2:\n        insertBefore: function (newChild, refChild) {\n            //raises\n            return _insertBefore(this, newChild, refChild);\n        },\n        replaceChild: function (newChild, oldChild) {\n            //raises\n            _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);\n            if (oldChild) {\n                this.removeChild(oldChild);\n            }\n        },\n        removeChild: function (oldChild) {\n            return _removeChild(this, oldChild);\n        },\n        appendChild: function (newChild) {\n            return this.insertBefore(newChild, null);\n        },\n        hasChildNodes: function () {\n            return this.firstChild != null;\n        },\n        cloneNode: function (deep) {\n            return cloneNode(this.ownerDocument || this, this, deep);\n        },\n        // Modified in DOM Level 2:\n        normalize: function () {\n            var child = this.firstChild;\n            while (child) {\n                var next = child.nextSibling;\n                if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {\n                    this.removeChild(next);\n                    child.appendData(next.data);\n                } else {\n                    child.normalize();\n                    child = next;\n                }\n            }\n        },\n        // Introduced in DOM Level 2:\n        isSupported: function (feature, version) {\n            return this.ownerDocument.implementation.hasFeature(feature, version);\n        },\n        // Introduced in DOM Level 2:\n        hasAttributes: function () {\n            return this.attributes.length > 0;\n        },\n        /**\n         * Look up the prefix associated to the given namespace URI, starting from this node.\n         * **The default namespace declarations are ignored by this method.**\n         * See Namespace Prefix Lookup for details on the algorithm used by this method.\n         *\n         * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._\n         *\n         * @param {string | null} namespaceURI\n         * @returns {string | null}\n         * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix\n         * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo\n         * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix\n         * @see https://github.com/xmldom/xmldom/issues/322\n         */\n        lookupPrefix: function (namespaceURI) {\n            var el = this;\n            while (el) {\n                var map = el._nsMap;\n                //console.dir(map)\n                if (map) {\n                    for (var n in map) {\n                        if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {\n                            return n;\n                        }\n                    }\n                }\n                el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;\n            }\n            return null;\n        },\n        // Introduced in DOM Level 3:\n        lookupNamespaceURI: function (prefix) {\n            var el = this;\n            while (el) {\n                var map = el._nsMap;\n                //console.dir(map)\n                if (map) {\n                    if (Object.prototype.hasOwnProperty.call(map, prefix)) {\n                        return map[prefix];\n                    }\n                }\n                el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;\n            }\n            return null;\n        },\n        // Introduced in DOM Level 3:\n        isDefaultNamespace: function (namespaceURI) {\n            var prefix = this.lookupPrefix(namespaceURI);\n            return prefix == null;\n        }\n    };\n    function _xmlEncoder(c) {\n        return c == '<' && '&lt;' || c == '>' && '&gt;' || c == '&' && '&amp;' || c == '\"' && '&quot;' || '&#' + c.charCodeAt() + ';';\n    }\n    copy(NodeType, Node);\n    copy(NodeType, Node.prototype);\n\n    /**\n     * @param callback return true for continue,false for break\n     * @return boolean true: break visit;\n     */\n    function _visitNode(node, callback) {\n        if (callback(node)) {\n            return true;\n        }\n        if (node = node.firstChild) {\n            do {\n                if (_visitNode(node, callback)) {\n                    return true;\n                }\n            } while (node = node.nextSibling);\n        }\n    }\n    function Document() {\n        this.ownerDocument = this;\n    }\n    function _onAddAttribute(doc, el, newAttr) {\n        doc && doc._inc++;\n        var ns = newAttr.namespaceURI;\n        if (ns === NAMESPACE$2.XMLNS) {\n            //update namespace\n            el._nsMap[newAttr.prefix ? newAttr.localName : ''] = newAttr.value;\n        }\n    }\n    function _onRemoveAttribute(doc, el, newAttr, remove) {\n        doc && doc._inc++;\n        var ns = newAttr.namespaceURI;\n        if (ns === NAMESPACE$2.XMLNS) {\n            //update namespace\n            delete el._nsMap[newAttr.prefix ? newAttr.localName : ''];\n        }\n    }\n\n    /**\n     * Updates `el.childNodes`, updating the indexed items and it's `length`.\n     * Passing `newChild` means it will be appended.\n     * Otherwise it's assumed that an item has been removed,\n     * and `el.firstNode` and it's `.nextSibling` are used\n     * to walk the current list of child nodes.\n     *\n     * @param {Document} doc\n     * @param {Node} el\n     * @param {Node} [newChild]\n     * @private\n     */\n    function _onUpdateChild(doc, el, newChild) {\n        if (doc && doc._inc) {\n            doc._inc++;\n            //update childNodes\n            var cs = el.childNodes;\n            if (newChild) {\n                cs[cs.length++] = newChild;\n            } else {\n                var child = el.firstChild;\n                var i = 0;\n                while (child) {\n                    cs[i++] = child;\n                    child = child.nextSibling;\n                }\n                cs.length = i;\n                delete cs[cs.length];\n            }\n        }\n    }\n\n    /**\n     * Removes the connections between `parentNode` and `child`\n     * and any existing `child.previousSibling` or `child.nextSibling`.\n     *\n     * @see https://github.com/xmldom/xmldom/issues/135\n     * @see https://github.com/xmldom/xmldom/issues/145\n     *\n     * @param {Node} parentNode\n     * @param {Node} child\n     * @returns {Node} the child that was removed.\n     * @private\n     */\n    function _removeChild(parentNode, child) {\n        var previous = child.previousSibling;\n        var next = child.nextSibling;\n        if (previous) {\n            previous.nextSibling = next;\n        } else {\n            parentNode.firstChild = next;\n        }\n        if (next) {\n            next.previousSibling = previous;\n        } else {\n            parentNode.lastChild = previous;\n        }\n        child.parentNode = null;\n        child.previousSibling = null;\n        child.nextSibling = null;\n        _onUpdateChild(parentNode.ownerDocument, parentNode);\n        return child;\n    }\n\n    /**\n     * Returns `true` if `node` can be a parent for insertion.\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    function hasValidParentNodeType(node) {\n        return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);\n    }\n\n    /**\n     * Returns `true` if `node` can be inserted according to it's `nodeType`.\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    function hasInsertableNodeType(node) {\n        return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);\n    }\n\n    /**\n     * Returns true if `node` is a DOCTYPE node\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    function isDocTypeNode(node) {\n        return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;\n    }\n\n    /**\n     * Returns true if the node is an element\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    function isElementNode(node) {\n        return node && node.nodeType === Node.ELEMENT_NODE;\n    }\n    /**\n     * Returns true if `node` is a text node\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    function isTextNode(node) {\n        return node && node.nodeType === Node.TEXT_NODE;\n    }\n\n    /**\n     * Check if en element node can be inserted before `child`, or at the end if child is falsy,\n     * according to the presence and position of a doctype node on the same level.\n     *\n     * @param {Document} doc The document node\n     * @param {Node} child the node that would become the nextSibling if the element would be inserted\n     * @returns {boolean} `true` if an element can be inserted before child\n     * @private\n     * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n     */\n    function isElementInsertionPossible(doc, child) {\n        var parentChildNodes = doc.childNodes || [];\n        if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {\n            return false;\n        }\n        var docTypeNode = find(parentChildNodes, isDocTypeNode);\n        return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));\n    }\n\n    /**\n     * Check if en element node can be inserted before `child`, or at the end if child is falsy,\n     * according to the presence and position of a doctype node on the same level.\n     *\n     * @param {Node} doc The document node\n     * @param {Node} child the node that would become the nextSibling if the element would be inserted\n     * @returns {boolean} `true` if an element can be inserted before child\n     * @private\n     * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n     */\n    function isElementReplacementPossible(doc, child) {\n        var parentChildNodes = doc.childNodes || [];\n        function hasElementChildThatIsNotChild(node) {\n            return isElementNode(node) && node !== child;\n        }\n        if (find(parentChildNodes, hasElementChildThatIsNotChild)) {\n            return false;\n        }\n        var docTypeNode = find(parentChildNodes, isDocTypeNode);\n        return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));\n    }\n\n    /**\n     * @private\n     * Steps 1-5 of the checks before inserting and before replacing a child are the same.\n     *\n     * @param {Node} parent the parent node to insert `node` into\n     * @param {Node} node the node to insert\n     * @param {Node=} child the node that should become the `nextSibling` of `node`\n     * @returns {Node}\n     * @throws DOMException for several node combinations that would create a DOM that is not well-formed.\n     * @throws DOMException if `child` is provided but is not a child of `parent`.\n     * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n     * @see https://dom.spec.whatwg.org/#concept-node-replace\n     */\n    function assertPreInsertionValidity1to5(parent, node, child) {\n        // 1. If `parent` is not a Document, DocumentFragment, or Element node, then throw a \"HierarchyRequestError\" DOMException.\n        if (!hasValidParentNodeType(parent)) {\n            throw new DOMException(HIERARCHY_REQUEST_ERR, 'Unexpected parent node type ' + parent.nodeType);\n        }\n        // 2. If `node` is a host-including inclusive ancestor of `parent`, then throw a \"HierarchyRequestError\" DOMException.\n        // not implemented!\n        // 3. If `child` is non-null and its parent is not `parent`, then throw a \"NotFoundError\" DOMException.\n        if (child && child.parentNode !== parent) {\n            throw new DOMException(NOT_FOUND_ERR, 'child not in parent');\n        }\n        if (\n            // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a \"HierarchyRequestError\" DOMException.\n            !hasInsertableNodeType(node) ||\n            // 5. If either `node` is a Text node and `parent` is a document,\n            // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0\n            // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)\n            // or `node` is a doctype and `parent` is not a document, then throw a \"HierarchyRequestError\" DOMException.\n            isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE) {\n            throw new DOMException(HIERARCHY_REQUEST_ERR, 'Unexpected node type ' + node.nodeType + ' for parent node type ' + parent.nodeType);\n        }\n    }\n\n    /**\n     * @private\n     * Step 6 of the checks before inserting and before replacing a child are different.\n     *\n     * @param {Document} parent the parent node to insert `node` into\n     * @param {Node} node the node to insert\n     * @param {Node | undefined} child the node that should become the `nextSibling` of `node`\n     * @returns {Node}\n     * @throws DOMException for several node combinations that would create a DOM that is not well-formed.\n     * @throws DOMException if `child` is provided but is not a child of `parent`.\n     * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n     * @see https://dom.spec.whatwg.org/#concept-node-replace\n     */\n    function assertPreInsertionValidityInDocument(parent, node, child) {\n        var parentChildNodes = parent.childNodes || [];\n        var nodeChildNodes = node.childNodes || [];\n\n        // DocumentFragment\n        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n            var nodeChildElements = nodeChildNodes.filter(isElementNode);\n            // If node has more than one element child or has a Text node child.\n            if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');\n            }\n            // Otherwise, if `node` has one element child and either `parent` has an element child,\n            // `child` is a doctype, or `child` is non-null and a doctype is following `child`.\n            if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');\n            }\n        }\n        // Element\n        if (isElementNode(node)) {\n            // `parent` has an element child, `child` is a doctype,\n            // or `child` is non-null and a doctype is following `child`.\n            if (!isElementInsertionPossible(parent, child)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');\n            }\n        }\n        // DocumentType\n        if (isDocTypeNode(node)) {\n            // `parent` has a doctype child,\n            if (find(parentChildNodes, isDocTypeNode)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');\n            }\n            var parentElementChild = find(parentChildNodes, isElementNode);\n            // `child` is non-null and an element is preceding `child`,\n            if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');\n            }\n            // or `child` is null and `parent` has an element child.\n            if (!child && parentElementChild) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can not be appended since element is present');\n            }\n        }\n    }\n\n    /**\n     * @private\n     * Step 6 of the checks before inserting and before replacing a child are different.\n     *\n     * @param {Document} parent the parent node to insert `node` into\n     * @param {Node} node the node to insert\n     * @param {Node | undefined} child the node that should become the `nextSibling` of `node`\n     * @returns {Node}\n     * @throws DOMException for several node combinations that would create a DOM that is not well-formed.\n     * @throws DOMException if `child` is provided but is not a child of `parent`.\n     * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n     * @see https://dom.spec.whatwg.org/#concept-node-replace\n     */\n    function assertPreReplacementValidityInDocument(parent, node, child) {\n        var parentChildNodes = parent.childNodes || [];\n        var nodeChildNodes = node.childNodes || [];\n\n        // DocumentFragment\n        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n            var nodeChildElements = nodeChildNodes.filter(isElementNode);\n            // If `node` has more than one element child or has a Text node child.\n            if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');\n            }\n            // Otherwise, if `node` has one element child and either `parent` has an element child that is not `child` or a doctype is following `child`.\n            if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');\n            }\n        }\n        // Element\n        if (isElementNode(node)) {\n            // `parent` has an element child that is not `child` or a doctype is following `child`.\n            if (!isElementReplacementPossible(parent, child)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');\n            }\n        }\n        // DocumentType\n        if (isDocTypeNode(node)) {\n            function hasDoctypeChildThatIsNotChild(node) {\n                return isDocTypeNode(node) && node !== child;\n            }\n\n            // `parent` has a doctype child that is not `child`,\n            if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');\n            }\n            var parentElementChild = find(parentChildNodes, isElementNode);\n            // or an element is preceding `child`.\n            if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {\n                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');\n            }\n        }\n    }\n\n    /**\n     * @private\n     * @param {Node} parent the parent node to insert `node` into\n     * @param {Node} node the node to insert\n     * @param {Node=} child the node that should become the `nextSibling` of `node`\n     * @returns {Node}\n     * @throws DOMException for several node combinations that would create a DOM that is not well-formed.\n     * @throws DOMException if `child` is provided but is not a child of `parent`.\n     * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity\n     */\n    function _insertBefore(parent, node, child, _inDocumentAssertion) {\n        // To ensure pre-insertion validity of a node into a parent before a child, run these steps:\n        assertPreInsertionValidity1to5(parent, node, child);\n\n        // If parent is a document, and any of the statements below, switched on the interface node implements,\n        // are true, then throw a \"HierarchyRequestError\" DOMException.\n        if (parent.nodeType === Node.DOCUMENT_NODE) {\n            (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);\n        }\n        var cp = node.parentNode;\n        if (cp) {\n            cp.removeChild(node); //remove and update\n        }\n\n        if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {\n            var newFirst = node.firstChild;\n            if (newFirst == null) {\n                return node;\n            }\n            var newLast = node.lastChild;\n        } else {\n            newFirst = newLast = node;\n        }\n        var pre = child ? child.previousSibling : parent.lastChild;\n        newFirst.previousSibling = pre;\n        newLast.nextSibling = child;\n        if (pre) {\n            pre.nextSibling = newFirst;\n        } else {\n            parent.firstChild = newFirst;\n        }\n        if (child == null) {\n            parent.lastChild = newLast;\n        } else {\n            child.previousSibling = newLast;\n        }\n        do {\n            newFirst.parentNode = parent;\n        } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));\n        _onUpdateChild(parent.ownerDocument || parent, parent);\n        //console.log(parent.lastChild.nextSibling == null)\n        if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {\n            node.firstChild = node.lastChild = null;\n        }\n        return node;\n    }\n\n    /**\n     * Appends `newChild` to `parentNode`.\n     * If `newChild` is already connected to a `parentNode` it is first removed from it.\n     *\n     * @see https://github.com/xmldom/xmldom/issues/135\n     * @see https://github.com/xmldom/xmldom/issues/145\n     * @param {Node} parentNode\n     * @param {Node} newChild\n     * @returns {Node}\n     * @private\n     */\n    function _appendSingleChild(parentNode, newChild) {\n        if (newChild.parentNode) {\n            newChild.parentNode.removeChild(newChild);\n        }\n        newChild.parentNode = parentNode;\n        newChild.previousSibling = parentNode.lastChild;\n        newChild.nextSibling = null;\n        if (newChild.previousSibling) {\n            newChild.previousSibling.nextSibling = newChild;\n        } else {\n            parentNode.firstChild = newChild;\n        }\n        parentNode.lastChild = newChild;\n        _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);\n        return newChild;\n    }\n    Document.prototype = {\n        //implementation : null,\n        nodeName: '#document',\n        nodeType: DOCUMENT_NODE,\n        /**\n         * The DocumentType node of the document.\n         *\n         * @readonly\n         * @type DocumentType\n         */\n        doctype: null,\n        documentElement: null,\n        _inc: 1,\n        insertBefore: function (newChild, refChild) {\n            //raises\n            if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {\n                var child = newChild.firstChild;\n                while (child) {\n                    var next = child.nextSibling;\n                    this.insertBefore(child, refChild);\n                    child = next;\n                }\n                return newChild;\n            }\n            _insertBefore(this, newChild, refChild);\n            newChild.ownerDocument = this;\n            if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {\n                this.documentElement = newChild;\n            }\n            return newChild;\n        },\n        removeChild: function (oldChild) {\n            if (this.documentElement == oldChild) {\n                this.documentElement = null;\n            }\n            return _removeChild(this, oldChild);\n        },\n        replaceChild: function (newChild, oldChild) {\n            //raises\n            _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);\n            newChild.ownerDocument = this;\n            if (oldChild) {\n                this.removeChild(oldChild);\n            }\n            if (isElementNode(newChild)) {\n                this.documentElement = newChild;\n            }\n        },\n        // Introduced in DOM Level 2:\n        importNode: function (importedNode, deep) {\n            return importNode(this, importedNode, deep);\n        },\n        // Introduced in DOM Level 2:\n        getElementById: function (id) {\n            var rtv = null;\n            _visitNode(this.documentElement, function (node) {\n                if (node.nodeType == ELEMENT_NODE) {\n                    if (node.getAttribute('id') == id) {\n                        rtv = node;\n                        return true;\n                    }\n                }\n            });\n            return rtv;\n        },\n        /**\n         * The `getElementsByClassName` method of `Document` interface returns an array-like object\n         * of all child elements which have **all** of the given class name(s).\n         *\n         * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.\n         *\n         *\n         * Warning: This is a live LiveNodeList.\n         * Changes in the DOM will reflect in the array as the changes occur.\n         * If an element selected by this array no longer qualifies for the selector,\n         * it will automatically be removed. Be aware of this for iteration purposes.\n         *\n         * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace\n         *\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName\n         * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname\n         */\n        getElementsByClassName: function (classNames) {\n            var classNamesSet = toOrderedSet(classNames);\n            return new LiveNodeList(this, function (base) {\n                var ls = [];\n                if (classNamesSet.length > 0) {\n                    _visitNode(base.documentElement, function (node) {\n                        if (node !== base && node.nodeType === ELEMENT_NODE) {\n                            var nodeClassNames = node.getAttribute('class');\n                            // can be null if the attribute does not exist\n                            if (nodeClassNames) {\n                                // before splitting and iterating just compare them for the most common case\n                                var matches = classNames === nodeClassNames;\n                                if (!matches) {\n                                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);\n                                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));\n                                }\n                                if (matches) {\n                                    ls.push(node);\n                                }\n                            }\n                        }\n                    });\n                }\n                return ls;\n            });\n        },\n        //document factory method:\n        createElement: function (tagName) {\n            var node = new Element();\n            node.ownerDocument = this;\n            node.nodeName = tagName;\n            node.tagName = tagName;\n            node.localName = tagName;\n            node.childNodes = new NodeList();\n            var attrs = node.attributes = new NamedNodeMap();\n            attrs._ownerElement = node;\n            return node;\n        },\n        createDocumentFragment: function () {\n            var node = new DocumentFragment();\n            node.ownerDocument = this;\n            node.childNodes = new NodeList();\n            return node;\n        },\n        createTextNode: function (data) {\n            var node = new Text();\n            node.ownerDocument = this;\n            node.appendData(data);\n            return node;\n        },\n        createComment: function (data) {\n            var node = new Comment();\n            node.ownerDocument = this;\n            node.appendData(data);\n            return node;\n        },\n        createCDATASection: function (data) {\n            var node = new CDATASection();\n            node.ownerDocument = this;\n            node.appendData(data);\n            return node;\n        },\n        createProcessingInstruction: function (target, data) {\n            var node = new ProcessingInstruction();\n            node.ownerDocument = this;\n            node.tagName = node.target = target;\n            node.nodeValue = node.data = data;\n            return node;\n        },\n        createAttribute: function (name) {\n            var node = new Attr();\n            node.ownerDocument = this;\n            node.name = name;\n            node.nodeName = name;\n            node.localName = name;\n            node.specified = true;\n            return node;\n        },\n        createEntityReference: function (name) {\n            var node = new EntityReference();\n            node.ownerDocument = this;\n            node.nodeName = name;\n            return node;\n        },\n        // Introduced in DOM Level 2:\n        createElementNS: function (namespaceURI, qualifiedName) {\n            var node = new Element();\n            var pl = qualifiedName.split(':');\n            var attrs = node.attributes = new NamedNodeMap();\n            node.childNodes = new NodeList();\n            node.ownerDocument = this;\n            node.nodeName = qualifiedName;\n            node.tagName = qualifiedName;\n            node.namespaceURI = namespaceURI;\n            if (pl.length == 2) {\n                node.prefix = pl[0];\n                node.localName = pl[1];\n            } else {\n                //el.prefix = null;\n                node.localName = qualifiedName;\n            }\n            attrs._ownerElement = node;\n            return node;\n        },\n        // Introduced in DOM Level 2:\n        createAttributeNS: function (namespaceURI, qualifiedName) {\n            var node = new Attr();\n            var pl = qualifiedName.split(':');\n            node.ownerDocument = this;\n            node.nodeName = qualifiedName;\n            node.name = qualifiedName;\n            node.namespaceURI = namespaceURI;\n            node.specified = true;\n            if (pl.length == 2) {\n                node.prefix = pl[0];\n                node.localName = pl[1];\n            } else {\n                //el.prefix = null;\n                node.localName = qualifiedName;\n            }\n            return node;\n        }\n    };\n    _extends(Document, Node);\n    function Element() {\n        this._nsMap = {};\n    }\n    Element.prototype = {\n        nodeType: ELEMENT_NODE,\n        hasAttribute: function (name) {\n            return this.getAttributeNode(name) != null;\n        },\n        getAttribute: function (name) {\n            var attr = this.getAttributeNode(name);\n            return attr && attr.value || '';\n        },\n        getAttributeNode: function (name) {\n            return this.attributes.getNamedItem(name);\n        },\n        setAttribute: function (name, value) {\n            var attr = this.ownerDocument.createAttribute(name);\n            attr.value = attr.nodeValue = \"\" + value;\n            this.setAttributeNode(attr);\n        },\n        removeAttribute: function (name) {\n            var attr = this.getAttributeNode(name);\n            attr && this.removeAttributeNode(attr);\n        },\n        //four real opeartion method\n        appendChild: function (newChild) {\n            if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {\n                return this.insertBefore(newChild, null);\n            } else {\n                return _appendSingleChild(this, newChild);\n            }\n        },\n        setAttributeNode: function (newAttr) {\n            return this.attributes.setNamedItem(newAttr);\n        },\n        setAttributeNodeNS: function (newAttr) {\n            return this.attributes.setNamedItemNS(newAttr);\n        },\n        removeAttributeNode: function (oldAttr) {\n            //console.log(this == oldAttr.ownerElement)\n            return this.attributes.removeNamedItem(oldAttr.nodeName);\n        },\n        //get real attribute name,and remove it by removeAttributeNode\n        removeAttributeNS: function (namespaceURI, localName) {\n            var old = this.getAttributeNodeNS(namespaceURI, localName);\n            old && this.removeAttributeNode(old);\n        },\n        hasAttributeNS: function (namespaceURI, localName) {\n            return this.getAttributeNodeNS(namespaceURI, localName) != null;\n        },\n        getAttributeNS: function (namespaceURI, localName) {\n            var attr = this.getAttributeNodeNS(namespaceURI, localName);\n            return attr && attr.value || '';\n        },\n        setAttributeNS: function (namespaceURI, qualifiedName, value) {\n            var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);\n            attr.value = attr.nodeValue = \"\" + value;\n            this.setAttributeNode(attr);\n        },\n        getAttributeNodeNS: function (namespaceURI, localName) {\n            return this.attributes.getNamedItemNS(namespaceURI, localName);\n        },\n        getElementsByTagName: function (tagName) {\n            return new LiveNodeList(this, function (base) {\n                var ls = [];\n                _visitNode(base, function (node) {\n                    if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)) {\n                        ls.push(node);\n                    }\n                });\n                return ls;\n            });\n        },\n        getElementsByTagNameNS: function (namespaceURI, localName) {\n            return new LiveNodeList(this, function (base) {\n                var ls = [];\n                _visitNode(base, function (node) {\n                    if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)) {\n                        ls.push(node);\n                    }\n                });\n                return ls;\n            });\n        }\n    };\n    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;\n    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;\n    _extends(Element, Node);\n    function Attr() {}\n    Attr.prototype.nodeType = ATTRIBUTE_NODE;\n    _extends(Attr, Node);\n    function CharacterData() {}\n    CharacterData.prototype = {\n        data: '',\n        substringData: function (offset, count) {\n            return this.data.substring(offset, offset + count);\n        },\n        appendData: function (text) {\n            text = this.data + text;\n            this.nodeValue = this.data = text;\n            this.length = text.length;\n        },\n        insertData: function (offset, text) {\n            this.replaceData(offset, 0, text);\n        },\n        appendChild: function (newChild) {\n            throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);\n        },\n        deleteData: function (offset, count) {\n            this.replaceData(offset, count, \"\");\n        },\n        replaceData: function (offset, count, text) {\n            var start = this.data.substring(0, offset);\n            var end = this.data.substring(offset + count);\n            text = start + text + end;\n            this.nodeValue = this.data = text;\n            this.length = text.length;\n        }\n    };\n    _extends(CharacterData, Node);\n    function Text() {}\n    Text.prototype = {\n        nodeName: \"#text\",\n        nodeType: TEXT_NODE,\n        splitText: function (offset) {\n            var text = this.data;\n            var newText = text.substring(offset);\n            text = text.substring(0, offset);\n            this.data = this.nodeValue = text;\n            this.length = text.length;\n            var newNode = this.ownerDocument.createTextNode(newText);\n            if (this.parentNode) {\n                this.parentNode.insertBefore(newNode, this.nextSibling);\n            }\n            return newNode;\n        }\n    };\n    _extends(Text, CharacterData);\n    function Comment() {}\n    Comment.prototype = {\n        nodeName: \"#comment\",\n        nodeType: COMMENT_NODE\n    };\n    _extends(Comment, CharacterData);\n    function CDATASection() {}\n    CDATASection.prototype = {\n        nodeName: \"#cdata-section\",\n        nodeType: CDATA_SECTION_NODE\n    };\n    _extends(CDATASection, CharacterData);\n    function DocumentType() {}\n    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;\n    _extends(DocumentType, Node);\n    function Notation() {}\n    Notation.prototype.nodeType = NOTATION_NODE;\n    _extends(Notation, Node);\n    function Entity() {}\n    Entity.prototype.nodeType = ENTITY_NODE;\n    _extends(Entity, Node);\n    function EntityReference() {}\n    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;\n    _extends(EntityReference, Node);\n    function DocumentFragment() {}\n    DocumentFragment.prototype.nodeName = \"#document-fragment\";\n    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;\n    _extends(DocumentFragment, Node);\n    function ProcessingInstruction() {}\n    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;\n    _extends(ProcessingInstruction, Node);\n    function XMLSerializer() {}\n    XMLSerializer.prototype.serializeToString = function (node, isHtml, nodeFilter) {\n        return nodeSerializeToString.call(node, isHtml, nodeFilter);\n    };\n    Node.prototype.toString = nodeSerializeToString;\n    function nodeSerializeToString(isHtml, nodeFilter) {\n        var buf = [];\n        var refNode = this.nodeType == 9 && this.documentElement || this;\n        var prefix = refNode.prefix;\n        var uri = refNode.namespaceURI;\n        if (uri && prefix == null) {\n            //console.log(prefix)\n            var prefix = refNode.lookupPrefix(uri);\n            if (prefix == null) {\n                //isHTML = true;\n                var visibleNamespaces = [{\n                    namespace: uri,\n                    prefix: null\n                }\n                    //{namespace:uri,prefix:''}\n                ];\n            }\n        }\n\n        serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);\n        //console.log('###',this.nodeType,uri,prefix,buf.join(''))\n        return buf.join('');\n    }\n    function needNamespaceDefine(node, isHTML, visibleNamespaces) {\n        var prefix = node.prefix || '';\n        var uri = node.namespaceURI;\n        // According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,\n        // and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :\n        // > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.\n        // in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)\n        // and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :\n        // > [...] Furthermore, the attribute value [...] must not be an empty string.\n        // so serializing empty namespace value like xmlns:ds=\"\" would produce an invalid XML document.\n        if (!uri) {\n            return false;\n        }\n        if (prefix === \"xml\" && uri === NAMESPACE$2.XML || uri === NAMESPACE$2.XMLNS) {\n            return false;\n        }\n        var i = visibleNamespaces.length;\n        while (i--) {\n            var ns = visibleNamespaces[i];\n            // get namespace prefix\n            if (ns.prefix === prefix) {\n                return ns.namespace !== uri;\n            }\n        }\n        return true;\n    }\n    /**\n     * Well-formed constraint: No < in Attribute Values\n     * > The replacement text of any entity referred to directly or indirectly\n     * > in an attribute value must not contain a <.\n     * @see https://www.w3.org/TR/xml11/#CleanAttrVals\n     * @see https://www.w3.org/TR/xml11/#NT-AttValue\n     *\n     * Literal whitespace other than space that appear in attribute values\n     * are serialized as their entity references, so they will be preserved.\n     * (In contrast to whitespace literals in the input which are normalized to spaces)\n     * @see https://www.w3.org/TR/xml11/#AVNormalize\n     * @see https://w3c.github.io/DOM-Parsing/#serializing-an-element-s-attributes\n     */\n    function addSerializedAttribute(buf, qualifiedName, value) {\n        buf.push(' ', qualifiedName, '=\"', value.replace(/[<>&\"\\t\\n\\r]/g, _xmlEncoder), '\"');\n    }\n    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {\n        if (!visibleNamespaces) {\n            visibleNamespaces = [];\n        }\n        if (nodeFilter) {\n            node = nodeFilter(node);\n            if (node) {\n                if (typeof node == 'string') {\n                    buf.push(node);\n                    return;\n                }\n            } else {\n                return;\n            }\n            //buf.sort.apply(attrs, attributeSorter);\n        }\n\n        switch (node.nodeType) {\n            case ELEMENT_NODE:\n                var attrs = node.attributes;\n                var len = attrs.length;\n                var child = node.firstChild;\n                var nodeName = node.tagName;\n                isHTML = NAMESPACE$2.isHTML(node.namespaceURI) || isHTML;\n                var prefixedNodeName = nodeName;\n                if (!isHTML && !node.prefix && node.namespaceURI) {\n                    var defaultNS;\n                    // lookup current default ns from `xmlns` attribute\n                    for (var ai = 0; ai < attrs.length; ai++) {\n                        if (attrs.item(ai).name === 'xmlns') {\n                            defaultNS = attrs.item(ai).value;\n                            break;\n                        }\n                    }\n                    if (!defaultNS) {\n                        // lookup current default ns in visibleNamespaces\n                        for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {\n                            var namespace = visibleNamespaces[nsi];\n                            if (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {\n                                defaultNS = namespace.namespace;\n                                break;\n                            }\n                        }\n                    }\n                    if (defaultNS !== node.namespaceURI) {\n                        for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {\n                            var namespace = visibleNamespaces[nsi];\n                            if (namespace.namespace === node.namespaceURI) {\n                                if (namespace.prefix) {\n                                    prefixedNodeName = namespace.prefix + ':' + nodeName;\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n                buf.push('<', prefixedNodeName);\n                for (var i = 0; i < len; i++) {\n                    // add namespaces for attributes\n                    var attr = attrs.item(i);\n                    if (attr.prefix == 'xmlns') {\n                        visibleNamespaces.push({\n                            prefix: attr.localName,\n                            namespace: attr.value\n                        });\n                    } else if (attr.nodeName == 'xmlns') {\n                        visibleNamespaces.push({\n                            prefix: '',\n                            namespace: attr.value\n                        });\n                    }\n                }\n                for (var i = 0; i < len; i++) {\n                    var attr = attrs.item(i);\n                    if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {\n                        var prefix = attr.prefix || '';\n                        var uri = attr.namespaceURI;\n                        addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : \"xmlns\", uri);\n                        visibleNamespaces.push({\n                            prefix: prefix,\n                            namespace: uri\n                        });\n                    }\n                    serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);\n                }\n\n                // add namespace for current node\n                if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {\n                    var prefix = node.prefix || '';\n                    var uri = node.namespaceURI;\n                    addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : \"xmlns\", uri);\n                    visibleNamespaces.push({\n                        prefix: prefix,\n                        namespace: uri\n                    });\n                }\n                if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {\n                    buf.push('>');\n                    //if is cdata child node\n                    if (isHTML && /^script$/i.test(nodeName)) {\n                        while (child) {\n                            if (child.data) {\n                                buf.push(child.data);\n                            } else {\n                                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());\n                            }\n                            child = child.nextSibling;\n                        }\n                    } else {\n                        while (child) {\n                            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());\n                            child = child.nextSibling;\n                        }\n                    }\n                    buf.push('</', prefixedNodeName, '>');\n                } else {\n                    buf.push('/>');\n                }\n                // remove added visible namespaces\n                //visibleNamespaces.length = startVisibleNamespaces;\n                return;\n            case DOCUMENT_NODE:\n            case DOCUMENT_FRAGMENT_NODE:\n                var child = node.firstChild;\n                while (child) {\n                    serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());\n                    child = child.nextSibling;\n                }\n                return;\n            case ATTRIBUTE_NODE:\n                return addSerializedAttribute(buf, node.name, node.value);\n            case TEXT_NODE:\n                /**\n                 * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,\n                 * except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section.\n                 * If they are needed elsewhere, they must be escaped using either numeric character references or the strings\n                 * `&amp;` and `&lt;` respectively.\n                 * The right angle bracket (>) may be represented using the string \" &gt; \", and must, for compatibility,\n                 * be escaped using either `&gt;` or a character reference when it appears in the string `]]>` in content,\n                 * when that string is not marking the end of a CDATA section.\n                 *\n                 * In the content of elements, character data is any string of characters\n                 * which does not contain the start-delimiter of any markup\n                 * and does not include the CDATA-section-close delimiter, `]]>`.\n                 *\n                 * @see https://www.w3.org/TR/xml/#NT-CharData\n                 * @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node\n                 */\n                return buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));\n            case CDATA_SECTION_NODE:\n                return buf.push('<![CDATA[', node.data, ']]>');\n            case COMMENT_NODE:\n                return buf.push(\"<!--\", node.data, \"-->\");\n            case DOCUMENT_TYPE_NODE:\n                var pubid = node.publicId;\n                var sysid = node.systemId;\n                buf.push('<!DOCTYPE ', node.name);\n                if (pubid) {\n                    buf.push(' PUBLIC ', pubid);\n                    if (sysid && sysid != '.') {\n                        buf.push(' ', sysid);\n                    }\n                    buf.push('>');\n                } else if (sysid && sysid != '.') {\n                    buf.push(' SYSTEM ', sysid, '>');\n                } else {\n                    var sub = node.internalSubset;\n                    if (sub) {\n                        buf.push(\" [\", sub, \"]\");\n                    }\n                    buf.push(\">\");\n                }\n                return;\n            case PROCESSING_INSTRUCTION_NODE:\n                return buf.push(\"<?\", node.target, \" \", node.data, \"?>\");\n            case ENTITY_REFERENCE_NODE:\n                return buf.push('&', node.nodeName, ';');\n            //case ENTITY_NODE:\n            //case NOTATION_NODE:\n            default:\n                buf.push('??', node.nodeName);\n        }\n    }\n    function importNode(doc, node, deep) {\n        var node2;\n        switch (node.nodeType) {\n            case ELEMENT_NODE:\n                node2 = node.cloneNode(false);\n                node2.ownerDocument = doc;\n            //var attrs = node2.attributes;\n            //var len = attrs.length;\n            //for(var i=0;i<len;i++){\n            //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));\n            //}\n            case DOCUMENT_FRAGMENT_NODE:\n                break;\n            case ATTRIBUTE_NODE:\n                deep = true;\n                break;\n            //case ENTITY_REFERENCE_NODE:\n            //case PROCESSING_INSTRUCTION_NODE:\n            ////case TEXT_NODE:\n            //case CDATA_SECTION_NODE:\n            //case COMMENT_NODE:\n            //\tdeep = false;\n            //\tbreak;\n            //case DOCUMENT_NODE:\n            //case DOCUMENT_TYPE_NODE:\n            //cannot be imported.\n            //case ENTITY_NODE:\n            //case NOTATION_NODE：\n            //can not hit in level3\n            //default:throw e;\n        }\n\n        if (!node2) {\n            node2 = node.cloneNode(false); //false\n        }\n\n        node2.ownerDocument = doc;\n        node2.parentNode = null;\n        if (deep) {\n            var child = node.firstChild;\n            while (child) {\n                node2.appendChild(importNode(doc, child, deep));\n                child = child.nextSibling;\n            }\n        }\n        return node2;\n    }\n    //\n    //var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,\n    //\t\t\t\t\tattributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};\n    function cloneNode(doc, node, deep) {\n        var node2 = new node.constructor();\n        for (var n in node) {\n            if (Object.prototype.hasOwnProperty.call(node, n)) {\n                var v = node[n];\n                if (typeof v != \"object\") {\n                    if (v != node2[n]) {\n                        node2[n] = v;\n                    }\n                }\n            }\n        }\n        if (node.childNodes) {\n            node2.childNodes = new NodeList();\n        }\n        node2.ownerDocument = doc;\n        switch (node2.nodeType) {\n            case ELEMENT_NODE:\n                var attrs = node.attributes;\n                var attrs2 = node2.attributes = new NamedNodeMap();\n                var len = attrs.length;\n                attrs2._ownerElement = node2;\n                for (var i = 0; i < len; i++) {\n                    node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));\n                }\n                break;\n            case ATTRIBUTE_NODE:\n                deep = true;\n        }\n        if (deep) {\n            var child = node.firstChild;\n            while (child) {\n                node2.appendChild(cloneNode(doc, child, deep));\n                child = child.nextSibling;\n            }\n        }\n        return node2;\n    }\n    function __set__(object, key, value) {\n        object[key] = value;\n    }\n    //do dynamic\n    try {\n        if (Object.defineProperty) {\n            Object.defineProperty(LiveNodeList.prototype, 'length', {\n                get: function () {\n                    _updateLiveList(this);\n                    return this.$$length;\n                }\n            });\n            Object.defineProperty(Node.prototype, 'textContent', {\n                get: function () {\n                    return getTextContent(this);\n                },\n                set: function (data) {\n                    switch (this.nodeType) {\n                        case ELEMENT_NODE:\n                        case DOCUMENT_FRAGMENT_NODE:\n                            while (this.firstChild) {\n                                this.removeChild(this.firstChild);\n                            }\n                            if (data || String(data)) {\n                                this.appendChild(this.ownerDocument.createTextNode(data));\n                            }\n                            break;\n                        default:\n                            this.data = data;\n                            this.value = data;\n                            this.nodeValue = data;\n                    }\n                }\n            });\n            function getTextContent(node) {\n                switch (node.nodeType) {\n                    case ELEMENT_NODE:\n                    case DOCUMENT_FRAGMENT_NODE:\n                        var buf = [];\n                        node = node.firstChild;\n                        while (node) {\n                            if (node.nodeType !== 7 && node.nodeType !== 8) {\n                                buf.push(getTextContent(node));\n                            }\n                            node = node.nextSibling;\n                        }\n                        return buf.join('');\n                    default:\n                        return node.nodeValue;\n                }\n            }\n            __set__ = function (object, key, value) {\n                //console.log(value)\n                object['$$' + key] = value;\n            };\n        }\n    } catch (e) {//ie8\n    }\n\n    //if(typeof require == 'function'){\n    var DocumentType_1 = DocumentType;\n    var DOMException_1 = DOMException;\n    var DOMImplementation_1 = DOMImplementation$1;\n    var Element_1 = Element;\n    var Node_1 = Node;\n    var NodeList_1 = NodeList;\n    var XMLSerializer_1 = XMLSerializer;\n    //}\n\n    var dom = {\n        DocumentType: DocumentType_1,\n        DOMException: DOMException_1,\n        DOMImplementation: DOMImplementation_1,\n        Element: Element_1,\n        Node: Node_1,\n        NodeList: NodeList_1,\n        XMLSerializer: XMLSerializer_1\n    };\n\n    var entities = createCommonjsModule(function (module, exports) {\n        var freeze = conventions.freeze;\n\n        /**\n         * The entities that are predefined in every XML document.\n         *\n         * @see https://www.w3.org/TR/2006/REC-xml11-20060816/#sec-predefined-ent W3C XML 1.1\n         * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent W3C XML 1.0\n         * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML Wikipedia\n         */\n        exports.XML_ENTITIES = freeze({\n            amp: '&',\n            apos: \"'\",\n            gt: '>',\n            lt: '<',\n            quot: '\"'\n        });\n\n        /**\n         * A map of currently 241 entities that are detected in an HTML document.\n         * They contain all entries from `XML_ENTITIES`.\n         *\n         * @see XML_ENTITIES\n         * @see DOMParser.parseFromString\n         * @see DOMImplementation.prototype.createHTMLDocument\n         * @see https://html.spec.whatwg.org/#named-character-references WHATWG HTML(5) Spec\n         * @see https://www.w3.org/TR/xml-entity-names/ W3C XML Entity Names\n         * @see https://www.w3.org/TR/html4/sgml/entities.html W3C HTML4/SGML\n         * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML Wikipedia (HTML)\n         * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Entities_representing_special_characters_in_XHTML Wikpedia (XHTML)\n         */\n        exports.HTML_ENTITIES = freeze({\n            lt: '<',\n            gt: '>',\n            amp: '&',\n            quot: '\"',\n            apos: \"'\",\n            Agrave: \"À\",\n            Aacute: \"Á\",\n            Acirc: \"Â\",\n            Atilde: \"Ã\",\n            Auml: \"Ä\",\n            Aring: \"Å\",\n            AElig: \"Æ\",\n            Ccedil: \"Ç\",\n            Egrave: \"È\",\n            Eacute: \"É\",\n            Ecirc: \"Ê\",\n            Euml: \"Ë\",\n            Igrave: \"Ì\",\n            Iacute: \"Í\",\n            Icirc: \"Î\",\n            Iuml: \"Ï\",\n            ETH: \"Ð\",\n            Ntilde: \"Ñ\",\n            Ograve: \"Ò\",\n            Oacute: \"Ó\",\n            Ocirc: \"Ô\",\n            Otilde: \"Õ\",\n            Ouml: \"Ö\",\n            Oslash: \"Ø\",\n            Ugrave: \"Ù\",\n            Uacute: \"Ú\",\n            Ucirc: \"Û\",\n            Uuml: \"Ü\",\n            Yacute: \"Ý\",\n            THORN: \"Þ\",\n            szlig: \"ß\",\n            agrave: \"à\",\n            aacute: \"á\",\n            acirc: \"â\",\n            atilde: \"ã\",\n            auml: \"ä\",\n            aring: \"å\",\n            aelig: \"æ\",\n            ccedil: \"ç\",\n            egrave: \"è\",\n            eacute: \"é\",\n            ecirc: \"ê\",\n            euml: \"ë\",\n            igrave: \"ì\",\n            iacute: \"í\",\n            icirc: \"î\",\n            iuml: \"ï\",\n            eth: \"ð\",\n            ntilde: \"ñ\",\n            ograve: \"ò\",\n            oacute: \"ó\",\n            ocirc: \"ô\",\n            otilde: \"õ\",\n            ouml: \"ö\",\n            oslash: \"ø\",\n            ugrave: \"ù\",\n            uacute: \"ú\",\n            ucirc: \"û\",\n            uuml: \"ü\",\n            yacute: \"ý\",\n            thorn: \"þ\",\n            yuml: \"ÿ\",\n            nbsp: \"\\u00a0\",\n            iexcl: \"¡\",\n            cent: \"¢\",\n            pound: \"£\",\n            curren: \"¤\",\n            yen: \"¥\",\n            brvbar: \"¦\",\n            sect: \"§\",\n            uml: \"¨\",\n            copy: \"©\",\n            ordf: \"ª\",\n            laquo: \"«\",\n            not: \"¬\",\n            shy: \"­­\",\n            reg: \"®\",\n            macr: \"¯\",\n            deg: \"°\",\n            plusmn: \"±\",\n            sup2: \"²\",\n            sup3: \"³\",\n            acute: \"´\",\n            micro: \"µ\",\n            para: \"¶\",\n            middot: \"·\",\n            cedil: \"¸\",\n            sup1: \"¹\",\n            ordm: \"º\",\n            raquo: \"»\",\n            frac14: \"¼\",\n            frac12: \"½\",\n            frac34: \"¾\",\n            iquest: \"¿\",\n            times: \"×\",\n            divide: \"÷\",\n            forall: \"∀\",\n            part: \"∂\",\n            exist: \"∃\",\n            empty: \"∅\",\n            nabla: \"∇\",\n            isin: \"∈\",\n            notin: \"∉\",\n            ni: \"∋\",\n            prod: \"∏\",\n            sum: \"∑\",\n            minus: \"−\",\n            lowast: \"∗\",\n            radic: \"√\",\n            prop: \"∝\",\n            infin: \"∞\",\n            ang: \"∠\",\n            and: \"∧\",\n            or: \"∨\",\n            cap: \"∩\",\n            cup: \"∪\",\n            'int': \"∫\",\n            there4: \"∴\",\n            sim: \"∼\",\n            cong: \"≅\",\n            asymp: \"≈\",\n            ne: \"≠\",\n            equiv: \"≡\",\n            le: \"≤\",\n            ge: \"≥\",\n            sub: \"⊂\",\n            sup: \"⊃\",\n            nsub: \"⊄\",\n            sube: \"⊆\",\n            supe: \"⊇\",\n            oplus: \"⊕\",\n            otimes: \"⊗\",\n            perp: \"⊥\",\n            sdot: \"⋅\",\n            Alpha: \"Α\",\n            Beta: \"Β\",\n            Gamma: \"Γ\",\n            Delta: \"Δ\",\n            Epsilon: \"Ε\",\n            Zeta: \"Ζ\",\n            Eta: \"Η\",\n            Theta: \"Θ\",\n            Iota: \"Ι\",\n            Kappa: \"Κ\",\n            Lambda: \"Λ\",\n            Mu: \"Μ\",\n            Nu: \"Ν\",\n            Xi: \"Ξ\",\n            Omicron: \"Ο\",\n            Pi: \"Π\",\n            Rho: \"Ρ\",\n            Sigma: \"Σ\",\n            Tau: \"Τ\",\n            Upsilon: \"Υ\",\n            Phi: \"Φ\",\n            Chi: \"Χ\",\n            Psi: \"Ψ\",\n            Omega: \"Ω\",\n            alpha: \"α\",\n            beta: \"β\",\n            gamma: \"γ\",\n            delta: \"δ\",\n            epsilon: \"ε\",\n            zeta: \"ζ\",\n            eta: \"η\",\n            theta: \"θ\",\n            iota: \"ι\",\n            kappa: \"κ\",\n            lambda: \"λ\",\n            mu: \"μ\",\n            nu: \"ν\",\n            xi: \"ξ\",\n            omicron: \"ο\",\n            pi: \"π\",\n            rho: \"ρ\",\n            sigmaf: \"ς\",\n            sigma: \"σ\",\n            tau: \"τ\",\n            upsilon: \"υ\",\n            phi: \"φ\",\n            chi: \"χ\",\n            psi: \"ψ\",\n            omega: \"ω\",\n            thetasym: \"ϑ\",\n            upsih: \"ϒ\",\n            piv: \"ϖ\",\n            OElig: \"Œ\",\n            oelig: \"œ\",\n            Scaron: \"Š\",\n            scaron: \"š\",\n            Yuml: \"Ÿ\",\n            fnof: \"ƒ\",\n            circ: \"ˆ\",\n            tilde: \"˜\",\n            ensp: \" \",\n            emsp: \" \",\n            thinsp: \" \",\n            zwnj: \"‌\",\n            zwj: \"‍\",\n            lrm: \"‎\",\n            rlm: \"‏\",\n            ndash: \"–\",\n            mdash: \"—\",\n            lsquo: \"‘\",\n            rsquo: \"’\",\n            sbquo: \"‚\",\n            ldquo: \"“\",\n            rdquo: \"”\",\n            bdquo: \"„\",\n            dagger: \"†\",\n            Dagger: \"‡\",\n            bull: \"•\",\n            hellip: \"…\",\n            permil: \"‰\",\n            prime: \"′\",\n            Prime: \"″\",\n            lsaquo: \"‹\",\n            rsaquo: \"›\",\n            oline: \"‾\",\n            euro: \"€\",\n            trade: \"™\",\n            larr: \"←\",\n            uarr: \"↑\",\n            rarr: \"→\",\n            darr: \"↓\",\n            harr: \"↔\",\n            crarr: \"↵\",\n            lceil: \"⌈\",\n            rceil: \"⌉\",\n            lfloor: \"⌊\",\n            rfloor: \"⌋\",\n            loz: \"◊\",\n            spades: \"♠\",\n            clubs: \"♣\",\n            hearts: \"♥\",\n            diams: \"♦\"\n        });\n\n        /**\n         * @deprecated use `HTML_ENTITIES` instead\n         * @see HTML_ENTITIES\n         */\n        exports.entityMap = exports.HTML_ENTITIES;\n    });\n    entities.XML_ENTITIES;\n    entities.HTML_ENTITIES;\n    entities.entityMap;\n\n    var NAMESPACE$1 = conventions.NAMESPACE;\n\n    //[4]   \tNameStartChar\t   ::=   \t\":\" | [A-Z] | \"_\" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n    //[4a]   \tNameChar\t   ::=   \tNameStartChar | \"-\" | \".\" | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]\n    //[5]   \tName\t   ::=   \tNameStartChar (NameChar)*\n    var nameStartChar = /[A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/; //\\u10000-\\uEFFFF\n    var nameChar = new RegExp(\"[\\\\-\\\\.0-9\" + nameStartChar.source.slice(1, -1) + \"\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]\");\n    var tagNamePattern = new RegExp('^' + nameStartChar.source + nameChar.source + '*(?:\\:' + nameStartChar.source + nameChar.source + '*)?$');\n    //var tagNamePattern = /^[a-zA-Z_][\\w\\-\\.]*(?:\\:[a-zA-Z_][\\w\\-\\.]*)?$/\n    //var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')\n\n    //S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n    //S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\n    var S_TAG = 0; //tag name offerring\n    var S_ATTR = 1; //attr name offerring\n    var S_ATTR_SPACE = 2; //attr name end and space offer\n    var S_EQ = 3; //=space?\n    var S_ATTR_NOQUOT_VALUE = 4; //attr value(no quot value only)\n    var S_ATTR_END = 5; //attr value end and no space(quot end)\n    var S_TAG_SPACE = 6; //(attr value end || tag end ) && (space offer)\n    var S_TAG_CLOSE = 7; //closed el<el />\n\n    /**\n     * Creates an error that will not be caught by XMLReader aka the SAX parser.\n     *\n     * @param {string} message\n     * @param {any?} locator Optional, can provide details about the location in the source\n     * @constructor\n     */\n    function ParseError$1(message, locator) {\n        this.message = message;\n        this.locator = locator;\n        if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError$1);\n    }\n    ParseError$1.prototype = new Error();\n    ParseError$1.prototype.name = ParseError$1.name;\n    function XMLReader$1() {}\n    XMLReader$1.prototype = {\n        parse: function (source, defaultNSMap, entityMap) {\n            var domBuilder = this.domBuilder;\n            domBuilder.startDocument();\n            _copy(defaultNSMap, defaultNSMap = {});\n            parse$1(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);\n            domBuilder.endDocument();\n        }\n    };\n    function parse$1(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {\n        function fixedFromCharCode(code) {\n            // String.prototype.fromCharCode does not supports\n            // > 2 bytes unicode chars directly\n            if (code > 0xffff) {\n                code -= 0x10000;\n                var surrogate1 = 0xd800 + (code >> 10),\n                    surrogate2 = 0xdc00 + (code & 0x3ff);\n                return String.fromCharCode(surrogate1, surrogate2);\n            } else {\n                return String.fromCharCode(code);\n            }\n        }\n        function entityReplacer(a) {\n            var k = a.slice(1, -1);\n            if (Object.hasOwnProperty.call(entityMap, k)) {\n                return entityMap[k];\n            } else if (k.charAt(0) === '#') {\n                return fixedFromCharCode(parseInt(k.substr(1).replace('x', '0x')));\n            } else {\n                errorHandler.error('entity not found:' + a);\n                return a;\n            }\n        }\n        function appendText(end) {\n            //has some bugs\n            if (end > start) {\n                var xt = source.substring(start, end).replace(/&#?\\w+;/g, entityReplacer);\n                locator && position(start);\n                domBuilder.characters(xt, 0, end - start);\n                start = end;\n            }\n        }\n        function position(p, m) {\n            while (p >= lineEnd && (m = linePattern.exec(source))) {\n                lineStart = m.index;\n                lineEnd = lineStart + m[0].length;\n                locator.lineNumber++;\n                //console.log('line++:',locator,startPos,endPos)\n            }\n\n            locator.columnNumber = p - lineStart + 1;\n        }\n        var lineStart = 0;\n        var lineEnd = 0;\n        var linePattern = /.*(?:\\r\\n?|\\n)|.*$/g;\n        var locator = domBuilder.locator;\n        var parseStack = [{\n            currentNSMap: defaultNSMapCopy\n        }];\n        var closeMap = {};\n        var start = 0;\n        while (true) {\n            try {\n                var tagStart = source.indexOf('<', start);\n                if (tagStart < 0) {\n                    if (!source.substr(start).match(/^\\s*$/)) {\n                        var doc = domBuilder.doc;\n                        var text = doc.createTextNode(source.substr(start));\n                        doc.appendChild(text);\n                        domBuilder.currentElement = text;\n                    }\n                    return;\n                }\n                if (tagStart > start) {\n                    appendText(tagStart);\n                }\n                switch (source.charAt(tagStart + 1)) {\n                    case '/':\n                        var end = source.indexOf('>', tagStart + 3);\n                        var tagName = source.substring(tagStart + 2, end).replace(/[ \\t\\n\\r]+$/g, '');\n                        var config = parseStack.pop();\n                        if (end < 0) {\n                            tagName = source.substring(tagStart + 2).replace(/[\\s<].*/, '');\n                            errorHandler.error(\"end tag name: \" + tagName + ' is not complete:' + config.tagName);\n                            end = tagStart + 1 + tagName.length;\n                        } else if (tagName.match(/\\s</)) {\n                            tagName = tagName.replace(/[\\s<].*/, '');\n                            errorHandler.error(\"end tag name: \" + tagName + ' maybe not complete');\n                            end = tagStart + 1 + tagName.length;\n                        }\n                        var localNSMap = config.localNSMap;\n                        var endMatch = config.tagName == tagName;\n                        var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();\n                        if (endIgnoreCaseMach) {\n                            domBuilder.endElement(config.uri, config.localName, tagName);\n                            if (localNSMap) {\n                                for (var prefix in localNSMap) {\n                                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {\n                                        domBuilder.endPrefixMapping(prefix);\n                                    }\n                                }\n                            }\n                            if (!endMatch) {\n                                errorHandler.fatalError(\"end tag name: \" + tagName + ' is not match the current start tagName:' + config.tagName); // No known test case\n                            }\n                        } else {\n                            parseStack.push(config);\n                        }\n                        end++;\n                        break;\n                    // end elment\n                    case '?':\n                        // <?...?>\n                        locator && position(tagStart);\n                        end = parseInstruction(source, tagStart, domBuilder);\n                        break;\n                    case '!':\n                        // <!doctype,<![CDATA,<!--\n                        locator && position(tagStart);\n                        end = parseDCC(source, tagStart, domBuilder, errorHandler);\n                        break;\n                    default:\n                        locator && position(tagStart);\n                        var el = new ElementAttributes();\n                        var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;\n                        //elStartEnd\n                        var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);\n                        var len = el.length;\n                        if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {\n                            el.closed = true;\n                            if (!entityMap.nbsp) {\n                                errorHandler.warning('unclosed xml attribute');\n                            }\n                        }\n                        if (locator && len) {\n                            var locator2 = copyLocator(locator, {});\n                            //try{//attribute position fixed\n                            for (var i = 0; i < len; i++) {\n                                var a = el[i];\n                                position(a.offset);\n                                a.locator = copyLocator(locator, {});\n                            }\n                            domBuilder.locator = locator2;\n                            if (appendElement$1(el, domBuilder, currentNSMap)) {\n                                parseStack.push(el);\n                            }\n                            domBuilder.locator = locator;\n                        } else {\n                            if (appendElement$1(el, domBuilder, currentNSMap)) {\n                                parseStack.push(el);\n                            }\n                        }\n                        if (NAMESPACE$1.isHTML(el.uri) && !el.closed) {\n                            end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);\n                        } else {\n                            end++;\n                        }\n                }\n            } catch (e) {\n                if (e instanceof ParseError$1) {\n                    throw e;\n                }\n                errorHandler.error('element parse error: ' + e);\n                end = -1;\n            }\n            if (end > start) {\n                start = end;\n            } else {\n                //TODO: 这里有可能sax回退，有位置错误风险\n                appendText(Math.max(tagStart, start) + 1);\n            }\n        }\n    }\n    function copyLocator(f, t) {\n        t.lineNumber = f.lineNumber;\n        t.columnNumber = f.columnNumber;\n        return t;\n    }\n\n    /**\n     * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);\n     * @return end of the elementStartPart(end of elementEndPart for selfClosed el)\n     */\n    function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {\n        /**\n         * @param {string} qname\n         * @param {string} value\n         * @param {number} startIndex\n         */\n        function addAttribute(qname, value, startIndex) {\n            if (el.attributeNames.hasOwnProperty(qname)) {\n                errorHandler.fatalError('Attribute ' + qname + ' redefined');\n            }\n            el.addValue(qname,\n                // @see https://www.w3.org/TR/xml/#AVNormalize\n                // since the xmldom sax parser does not \"interpret\" DTD the following is not implemented:\n                // - recursive replacement of (DTD) entity references\n                // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA\n                value.replace(/[\\t\\n\\r]/g, ' ').replace(/&#?\\w+;/g, entityReplacer), startIndex);\n        }\n        var attrName;\n        var value;\n        var p = ++start;\n        var s = S_TAG; //status\n        while (true) {\n            var c = source.charAt(p);\n            switch (c) {\n                case '=':\n                    if (s === S_ATTR) {\n                        //attrName\n                        attrName = source.slice(start, p);\n                        s = S_EQ;\n                    } else if (s === S_ATTR_SPACE) {\n                        s = S_EQ;\n                    } else {\n                        //fatalError: equal must after attrName or space after attrName\n                        throw new Error('attribute equal must after attrName'); // No known test case\n                    }\n\n                    break;\n                case '\\'':\n                case '\"':\n                    if (s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE\n                    ) {\n                        //equal\n                        if (s === S_ATTR) {\n                            errorHandler.warning('attribute value must after \"=\"');\n                            attrName = source.slice(start, p);\n                        }\n                        start = p + 1;\n                        p = source.indexOf(c, start);\n                        if (p > 0) {\n                            value = source.slice(start, p);\n                            addAttribute(attrName, value, start - 1);\n                            s = S_ATTR_END;\n                        } else {\n                            //fatalError: no end quot match\n                            throw new Error('attribute value no end \\'' + c + '\\' match');\n                        }\n                    } else if (s == S_ATTR_NOQUOT_VALUE) {\n                        value = source.slice(start, p);\n                        addAttribute(attrName, value, start);\n                        errorHandler.warning('attribute \"' + attrName + '\" missed start quot(' + c + ')!!');\n                        start = p + 1;\n                        s = S_ATTR_END;\n                    } else {\n                        //fatalError: no equal before\n                        throw new Error('attribute value must after \"=\"'); // No known test case\n                    }\n\n                    break;\n                case '/':\n                    switch (s) {\n                        case S_TAG:\n                            el.setTagName(source.slice(start, p));\n                        case S_ATTR_END:\n                        case S_TAG_SPACE:\n                        case S_TAG_CLOSE:\n                            s = S_TAG_CLOSE;\n                            el.closed = true;\n                        case S_ATTR_NOQUOT_VALUE:\n                        case S_ATTR:\n                        case S_ATTR_SPACE:\n                            break;\n                        //case S_EQ:\n                        default:\n                            throw new Error(\"attribute invalid close char('/')\");\n                        // No known test case\n                    }\n\n                    break;\n                case '':\n                    //end document\n                    errorHandler.error('unexpected end of input');\n                    if (s == S_TAG) {\n                        el.setTagName(source.slice(start, p));\n                    }\n                    return p;\n                case '>':\n                    switch (s) {\n                        case S_TAG:\n                            el.setTagName(source.slice(start, p));\n                        case S_ATTR_END:\n                        case S_TAG_SPACE:\n                        case S_TAG_CLOSE:\n                            break;\n                        //normal\n                        case S_ATTR_NOQUOT_VALUE: //Compatible state\n                        case S_ATTR:\n                            value = source.slice(start, p);\n                            if (value.slice(-1) === '/') {\n                                el.closed = true;\n                                value = value.slice(0, -1);\n                            }\n                        case S_ATTR_SPACE:\n                            if (s === S_ATTR_SPACE) {\n                                value = attrName;\n                            }\n                            if (s == S_ATTR_NOQUOT_VALUE) {\n                                errorHandler.warning('attribute \"' + value + '\" missed quot(\")!');\n                                addAttribute(attrName, value, start);\n                            } else {\n                                if (!NAMESPACE$1.isHTML(currentNSMap['']) || !value.match(/^(?:disabled|checked|selected)$/i)) {\n                                    errorHandler.warning('attribute \"' + value + '\" missed value!! \"' + value + '\" instead!!');\n                                }\n                                addAttribute(value, value, start);\n                            }\n                            break;\n                        case S_EQ:\n                            throw new Error('attribute value missed!!');\n                    }\n                    //\t\t\tconsole.log(tagName,tagNamePattern,tagNamePattern.test(tagName))\n                    return p;\n                /*xml space '\\x20' | #x9 | #xD | #xA; */\n                case '\\u0080':\n                    c = ' ';\n                default:\n                    if (c <= ' ') {\n                        //space\n                        switch (s) {\n                            case S_TAG:\n                                el.setTagName(source.slice(start, p)); //tagName\n                                s = S_TAG_SPACE;\n                                break;\n                            case S_ATTR:\n                                attrName = source.slice(start, p);\n                                s = S_ATTR_SPACE;\n                                break;\n                            case S_ATTR_NOQUOT_VALUE:\n                                var value = source.slice(start, p);\n                                errorHandler.warning('attribute \"' + value + '\" missed quot(\")!!');\n                                addAttribute(attrName, value, start);\n                            case S_ATTR_END:\n                                s = S_TAG_SPACE;\n                                break;\n                            //case S_TAG_SPACE:\n                            //case S_EQ:\n                            //case S_ATTR_SPACE:\n                            //\tvoid();break;\n                            //case S_TAG_CLOSE:\n                            //ignore warning\n                        }\n                    } else {\n                        //not space\n                        //S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\n                        //S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\n                        switch (s) {\n                            //case S_TAG:void();break;\n                            //case S_ATTR:void();break;\n                            //case S_ATTR_NOQUOT_VALUE:void();break;\n                            case S_ATTR_SPACE:\n                                el.tagName;\n                                if (!NAMESPACE$1.isHTML(currentNSMap['']) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {\n                                    errorHandler.warning('attribute \"' + attrName + '\" missed value!! \"' + attrName + '\" instead2!!');\n                                }\n                                addAttribute(attrName, attrName, start);\n                                start = p;\n                                s = S_ATTR;\n                                break;\n                            case S_ATTR_END:\n                                errorHandler.warning('attribute space is required\"' + attrName + '\"!!');\n                            case S_TAG_SPACE:\n                                s = S_ATTR;\n                                start = p;\n                                break;\n                            case S_EQ:\n                                s = S_ATTR_NOQUOT_VALUE;\n                                start = p;\n                                break;\n                            case S_TAG_CLOSE:\n                                throw new Error(\"elements closed character '/' and '>' must be connected to\");\n                        }\n                    }\n            } //end outer switch\n            //console.log('p++',p)\n            p++;\n        }\n    }\n    /**\n     * @return true if has new namespace define\n     */\n    function appendElement$1(el, domBuilder, currentNSMap) {\n        var tagName = el.tagName;\n        var localNSMap = null;\n        //var currentNSMap = parseStack[parseStack.length-1].currentNSMap;\n        var i = el.length;\n        while (i--) {\n            var a = el[i];\n            var qName = a.qName;\n            var value = a.value;\n            var nsp = qName.indexOf(':');\n            if (nsp > 0) {\n                var prefix = a.prefix = qName.slice(0, nsp);\n                var localName = qName.slice(nsp + 1);\n                var nsPrefix = prefix === 'xmlns' && localName;\n            } else {\n                localName = qName;\n                prefix = null;\n                nsPrefix = qName === 'xmlns' && '';\n            }\n            //can not set prefix,because prefix !== ''\n            a.localName = localName;\n            //prefix == null for no ns prefix attribute\n            if (nsPrefix !== false) {\n                //hack!!\n                if (localNSMap == null) {\n                    localNSMap = {};\n                    //console.log(currentNSMap,0)\n                    _copy(currentNSMap, currentNSMap = {});\n                    //console.log(currentNSMap,1)\n                }\n\n                currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;\n                a.uri = NAMESPACE$1.XMLNS;\n                domBuilder.startPrefixMapping(nsPrefix, value);\n            }\n        }\n        var i = el.length;\n        while (i--) {\n            a = el[i];\n            var prefix = a.prefix;\n            if (prefix) {\n                //no prefix attribute has no namespace\n                if (prefix === 'xml') {\n                    a.uri = NAMESPACE$1.XML;\n                }\n                if (prefix !== 'xmlns') {\n                    a.uri = currentNSMap[prefix || ''];\n\n                    //{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}\n                }\n            }\n        }\n\n        var nsp = tagName.indexOf(':');\n        if (nsp > 0) {\n            prefix = el.prefix = tagName.slice(0, nsp);\n            localName = el.localName = tagName.slice(nsp + 1);\n        } else {\n            prefix = null; //important!!\n            localName = el.localName = tagName;\n        }\n        //no prefix element has default namespace\n        var ns = el.uri = currentNSMap[prefix || ''];\n        domBuilder.startElement(ns, localName, tagName, el);\n        //endPrefixMapping and startPrefixMapping have not any help for dom builder\n        //localNSMap = null\n        if (el.closed) {\n            domBuilder.endElement(ns, localName, tagName);\n            if (localNSMap) {\n                for (prefix in localNSMap) {\n                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {\n                        domBuilder.endPrefixMapping(prefix);\n                    }\n                }\n            }\n        } else {\n            el.currentNSMap = currentNSMap;\n            el.localNSMap = localNSMap;\n            //parseStack.push(el);\n            return true;\n        }\n    }\n    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {\n        if (/^(?:script|textarea)$/i.test(tagName)) {\n            var elEndStart = source.indexOf('</' + tagName + '>', elStartEnd);\n            var text = source.substring(elStartEnd + 1, elEndStart);\n            if (/[&<]/.test(text)) {\n                if (/^script$/i.test(tagName)) {\n                    //if(!/\\]\\]>/.test(text)){\n                    //lexHandler.startCDATA();\n                    domBuilder.characters(text, 0, text.length);\n                    //lexHandler.endCDATA();\n                    return elEndStart;\n                    //}\n                } //}else{//text area\n                text = text.replace(/&#?\\w+;/g, entityReplacer);\n                domBuilder.characters(text, 0, text.length);\n                return elEndStart;\n                //}\n            }\n        }\n\n        return elStartEnd + 1;\n    }\n    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {\n        //if(tagName in closeMap){\n        var pos = closeMap[tagName];\n        if (pos == null) {\n            //console.log(tagName)\n            pos = source.lastIndexOf('</' + tagName + '>');\n            if (pos < elStartEnd) {\n                //忘记闭合\n                pos = source.lastIndexOf('</' + tagName);\n            }\n            closeMap[tagName] = pos;\n        }\n        return pos < elStartEnd;\n        //}\n    }\n\n    function _copy(source, target) {\n        for (var n in source) {\n            if (Object.prototype.hasOwnProperty.call(source, n)) {\n                target[n] = source[n];\n            }\n        }\n    }\n    function parseDCC(source, start, domBuilder, errorHandler) {\n        //sure start with '<!'\n        var next = source.charAt(start + 2);\n        switch (next) {\n            case '-':\n                if (source.charAt(start + 3) === '-') {\n                    var end = source.indexOf('-->', start + 4);\n                    //append comment source.substring(4,end)//<!--\n                    if (end > start) {\n                        domBuilder.comment(source, start + 4, end - start - 4);\n                        return end + 3;\n                    } else {\n                        errorHandler.error(\"Unclosed comment\");\n                        return -1;\n                    }\n                } else {\n                    //error\n                    return -1;\n                }\n            default:\n                if (source.substr(start + 3, 6) == 'CDATA[') {\n                    var end = source.indexOf(']]>', start + 9);\n                    domBuilder.startCDATA();\n                    domBuilder.characters(source, start + 9, end - start - 9);\n                    domBuilder.endCDATA();\n                    return end + 3;\n                }\n                //<!DOCTYPE\n                //startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId)\n                var matchs = split(source, start);\n                var len = matchs.length;\n                if (len > 1 && /!doctype/i.test(matchs[0][0])) {\n                    var name = matchs[1][0];\n                    var pubid = false;\n                    var sysid = false;\n                    if (len > 3) {\n                        if (/^public$/i.test(matchs[2][0])) {\n                            pubid = matchs[3][0];\n                            sysid = len > 4 && matchs[4][0];\n                        } else if (/^system$/i.test(matchs[2][0])) {\n                            sysid = matchs[3][0];\n                        }\n                    }\n                    var lastMatch = matchs[len - 1];\n                    domBuilder.startDTD(name, pubid, sysid);\n                    domBuilder.endDTD();\n                    return lastMatch.index + lastMatch[0].length;\n                }\n        }\n        return -1;\n    }\n    function parseInstruction(source, start, domBuilder) {\n        var end = source.indexOf('?>', start);\n        if (end) {\n            var match = source.substring(start, end).match(/^<\\?(\\S*)\\s*([\\s\\S]*?)\\s*$/);\n            if (match) {\n                match[0].length;\n                domBuilder.processingInstruction(match[1], match[2]);\n                return end + 2;\n            } else {\n                //error\n                return -1;\n            }\n        }\n        return -1;\n    }\n    function ElementAttributes() {\n        this.attributeNames = {};\n    }\n    ElementAttributes.prototype = {\n        setTagName: function (tagName) {\n            if (!tagNamePattern.test(tagName)) {\n                throw new Error('invalid tagName:' + tagName);\n            }\n            this.tagName = tagName;\n        },\n        addValue: function (qName, value, offset) {\n            if (!tagNamePattern.test(qName)) {\n                throw new Error('invalid attribute:' + qName);\n            }\n            this.attributeNames[qName] = this.length;\n            this[this.length++] = {\n                qName: qName,\n                value: value,\n                offset: offset\n            };\n        },\n        length: 0,\n        getLocalName: function (i) {\n            return this[i].localName;\n        },\n        getLocator: function (i) {\n            return this[i].locator;\n        },\n        getQName: function (i) {\n            return this[i].qName;\n        },\n        getURI: function (i) {\n            return this[i].uri;\n        },\n        getValue: function (i) {\n            return this[i].value;\n        }\n        //\t,getIndex:function(uri, localName)){\n        //\t\tif(localName){\n        //\n        //\t\t}else{\n        //\t\t\tvar qName = uri\n        //\t\t}\n        //\t},\n        //\tgetValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},\n        //\tgetType:function(uri,localName){}\n        //\tgetType:function(i){},\n    };\n\n    function split(source, start) {\n        var match;\n        var buf = [];\n        var reg = /'[^']+'|\"[^\"]+\"|[^\\s<>\\/=]+=?|(\\/?\\s*>|<)/g;\n        reg.lastIndex = start;\n        reg.exec(source); //skip <\n        while (match = reg.exec(source)) {\n            buf.push(match);\n            if (match[1]) return buf;\n        }\n    }\n    var XMLReader_1 = XMLReader$1;\n    var ParseError_1 = ParseError$1;\n    var sax = {\n        XMLReader: XMLReader_1,\n        ParseError: ParseError_1\n    };\n\n    var DOMImplementation = dom.DOMImplementation;\n    var NAMESPACE = conventions.NAMESPACE;\n    var ParseError = sax.ParseError;\n    var XMLReader = sax.XMLReader;\n\n    /**\n     * Normalizes line ending according to https://www.w3.org/TR/xml11/#sec-line-ends:\n     *\n     * > XML parsed entities are often stored in computer files which,\n     * > for editing convenience, are organized into lines.\n     * > These lines are typically separated by some combination\n     * > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).\n     * >\n     * > To simplify the tasks of applications, the XML processor must behave\n     * > as if it normalized all line breaks in external parsed entities (including the document entity)\n     * > on input, before parsing, by translating all of the following to a single #xA character:\n     * >\n     * > 1. the two-character sequence #xD #xA\n     * > 2. the two-character sequence #xD #x85\n     * > 3. the single character #x85\n     * > 4. the single character #x2028\n     * > 5. any #xD character that is not immediately followed by #xA or #x85.\n     *\n     * @param {string} input\n     * @returns {string}\n     */\n    function normalizeLineEndings(input) {\n        return input.replace(/\\r[\\n\\u0085]/g, '\\n').replace(/[\\r\\u0085\\u2028]/g, '\\n');\n    }\n\n    /**\n     * @typedef Locator\n     * @property {number} [columnNumber]\n     * @property {number} [lineNumber]\n     */\n\n    /**\n     * @typedef DOMParserOptions\n     * @property {DOMHandler} [domBuilder]\n     * @property {Function} [errorHandler]\n     * @property {(string) => string} [normalizeLineEndings] used to replace line endings before parsing\n     * \t\t\t\t\t\tdefaults to `normalizeLineEndings`\n     * @property {Locator} [locator]\n     * @property {Record<string, string>} [xmlns]\n     *\n     * @see normalizeLineEndings\n     */\n\n    /**\n     * The DOMParser interface provides the ability to parse XML or HTML source code\n     * from a string into a DOM `Document`.\n     *\n     * _xmldom is different from the spec in that it allows an `options` parameter,\n     * to override the default behavior._\n     *\n     * @param {DOMParserOptions} [options]\n     * @constructor\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser\n     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization\n     */\n    function DOMParser$1(options) {\n        this.options = options || {\n            locator: {}\n        };\n    }\n    DOMParser$1.prototype.parseFromString = function (source, mimeType) {\n        var options = this.options;\n        var sax = new XMLReader();\n        var domBuilder = options.domBuilder || new DOMHandler(); //contentHandler and LexicalHandler\n        var errorHandler = options.errorHandler;\n        var locator = options.locator;\n        var defaultNSMap = options.xmlns || {};\n        var isHTML = /\\/x?html?$/.test(mimeType); //mimeType.toLowerCase().indexOf('html') > -1;\n        var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;\n        if (locator) {\n            domBuilder.setDocumentLocator(locator);\n        }\n        sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);\n        sax.domBuilder = options.domBuilder || domBuilder;\n        if (isHTML) {\n            defaultNSMap[''] = NAMESPACE.HTML;\n        }\n        defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;\n        var normalize = options.normalizeLineEndings || normalizeLineEndings;\n        if (source && typeof source === 'string') {\n            sax.parse(normalize(source), defaultNSMap, entityMap);\n        } else {\n            sax.errorHandler.error('invalid doc source');\n        }\n        return domBuilder.doc;\n    };\n    function buildErrorHandler(errorImpl, domBuilder, locator) {\n        if (!errorImpl) {\n            if (domBuilder instanceof DOMHandler) {\n                return domBuilder;\n            }\n            errorImpl = domBuilder;\n        }\n        var errorHandler = {};\n        var isCallback = errorImpl instanceof Function;\n        locator = locator || {};\n        function build(key) {\n            var fn = errorImpl[key];\n            if (!fn && isCallback) {\n                fn = errorImpl.length == 2 ? function (msg) {\n                    errorImpl(key, msg);\n                } : errorImpl;\n            }\n            errorHandler[key] = fn && function (msg) {\n                fn('[xmldom ' + key + ']\\t' + msg + _locator(locator));\n            } || function () {};\n        }\n        build('warning');\n        build('error');\n        build('fatalError');\n        return errorHandler;\n    }\n\n    //console.log('#\\n\\n\\n\\n\\n\\n\\n####')\n    /**\n     * +ContentHandler+ErrorHandler\n     * +LexicalHandler+EntityResolver2\n     * -DeclHandler-DTDHandler\n     *\n     * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler\n     * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2\n     * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html\n     */\n    function DOMHandler() {\n        this.cdata = false;\n    }\n    function position(locator, node) {\n        node.lineNumber = locator.lineNumber;\n        node.columnNumber = locator.columnNumber;\n    }\n    /**\n     * @see org.xml.sax.ContentHandler#startDocument\n     * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html\n     */\n    DOMHandler.prototype = {\n        startDocument: function () {\n            this.doc = new DOMImplementation().createDocument(null, null, null);\n            if (this.locator) {\n                this.doc.documentURI = this.locator.systemId;\n            }\n        },\n        startElement: function (namespaceURI, localName, qName, attrs) {\n            var doc = this.doc;\n            var el = doc.createElementNS(namespaceURI, qName || localName);\n            var len = attrs.length;\n            appendElement(this, el);\n            this.currentElement = el;\n            this.locator && position(this.locator, el);\n            for (var i = 0; i < len; i++) {\n                var namespaceURI = attrs.getURI(i);\n                var value = attrs.getValue(i);\n                var qName = attrs.getQName(i);\n                var attr = doc.createAttributeNS(namespaceURI, qName);\n                this.locator && position(attrs.getLocator(i), attr);\n                attr.value = attr.nodeValue = value;\n                el.setAttributeNode(attr);\n            }\n        },\n        endElement: function (namespaceURI, localName, qName) {\n            var current = this.currentElement;\n            current.tagName;\n            this.currentElement = current.parentNode;\n        },\n        startPrefixMapping: function (prefix, uri) {},\n        endPrefixMapping: function (prefix) {},\n        processingInstruction: function (target, data) {\n            var ins = this.doc.createProcessingInstruction(target, data);\n            this.locator && position(this.locator, ins);\n            appendElement(this, ins);\n        },\n        ignorableWhitespace: function (ch, start, length) {},\n        characters: function (chars, start, length) {\n            chars = _toString.apply(this, arguments);\n            //console.log(chars)\n            if (chars) {\n                if (this.cdata) {\n                    var charNode = this.doc.createCDATASection(chars);\n                } else {\n                    var charNode = this.doc.createTextNode(chars);\n                }\n                if (this.currentElement) {\n                    this.currentElement.appendChild(charNode);\n                } else if (/^\\s*$/.test(chars)) {\n                    this.doc.appendChild(charNode);\n                    //process xml\n                }\n\n                this.locator && position(this.locator, charNode);\n            }\n        },\n        skippedEntity: function (name) {},\n        endDocument: function () {\n            this.doc.normalize();\n        },\n        setDocumentLocator: function (locator) {\n            if (this.locator = locator) {\n                // && !('lineNumber' in locator)){\n                locator.lineNumber = 0;\n            }\n        },\n        //LexicalHandler\n        comment: function (chars, start, length) {\n            chars = _toString.apply(this, arguments);\n            var comm = this.doc.createComment(chars);\n            this.locator && position(this.locator, comm);\n            appendElement(this, comm);\n        },\n        startCDATA: function () {\n            //used in characters() methods\n            this.cdata = true;\n        },\n        endCDATA: function () {\n            this.cdata = false;\n        },\n        startDTD: function (name, publicId, systemId) {\n            var impl = this.doc.implementation;\n            if (impl && impl.createDocumentType) {\n                var dt = impl.createDocumentType(name, publicId, systemId);\n                this.locator && position(this.locator, dt);\n                appendElement(this, dt);\n                this.doc.doctype = dt;\n            }\n        },\n        /**\n         * @see org.xml.sax.ErrorHandler\n         * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html\n         */\n        warning: function (error) {\n            console.warn('[xmldom warning]\\t' + error, _locator(this.locator));\n        },\n        error: function (error) {\n            console.error('[xmldom error]\\t' + error, _locator(this.locator));\n        },\n        fatalError: function (error) {\n            throw new ParseError(error, this.locator);\n        }\n    };\n    function _locator(l) {\n        if (l) {\n            return '\\n@' + (l.systemId || '') + '#[line:' + l.lineNumber + ',col:' + l.columnNumber + ']';\n        }\n    }\n    function _toString(chars, start, length) {\n        if (typeof chars == 'string') {\n            return chars.substr(start, length);\n        } else {\n            //java sax connect width xmldom on rhino(what about: \"? && !(chars instanceof String)\")\n            if (chars.length >= start + length || start) {\n                return new java.lang.String(chars, start, length) + '';\n            }\n            return chars;\n        }\n    }\n\n    /*\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html\n   * used method of org.xml.sax.ext.LexicalHandler:\n   *  #comment(chars, start, length)\n   *  #startCDATA()\n   *  #endCDATA()\n   *  #startDTD(name, publicId, systemId)\n   *\n   *\n   * IGNORED method of org.xml.sax.ext.LexicalHandler:\n   *  #endDTD()\n   *  #startEntity(name)\n   *  #endEntity(name)\n   *\n   *\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html\n   * IGNORED method of org.xml.sax.ext.DeclHandler\n   * \t#attributeDecl(eName, aName, type, mode, value)\n   *  #elementDecl(name, model)\n   *  #externalEntityDecl(name, publicId, systemId)\n   *  #internalEntityDecl(name, value)\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html\n   * IGNORED method of org.xml.sax.EntityResolver2\n   *  #resolveEntity(String name,String publicId,String baseURI,String systemId)\n   *  #resolveEntity(publicId, systemId)\n   *  #getExternalSubset(name, baseURI)\n   * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html\n   * IGNORED method of org.xml.sax.DTDHandler\n   *  #notationDecl(name, publicId, systemId) {};\n   *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};\n   */\n    \"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl\".replace(/\\w+/g, function (key) {\n        DOMHandler.prototype[key] = function () {\n            return null;\n        };\n    });\n\n    /* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */\n    function appendElement(hander, node) {\n        if (!hander.currentElement) {\n            hander.doc.appendChild(node);\n        } else {\n            hander.currentElement.appendChild(node);\n        }\n    } //appendChild and setAttributeNS are preformance key\n\n    var __DOMHandler = DOMHandler;\n    var normalizeLineEndings_1 = normalizeLineEndings;\n    var DOMParser_1 = DOMParser$1;\n    var domParser = {\n        __DOMHandler: __DOMHandler,\n        normalizeLineEndings: normalizeLineEndings_1,\n        DOMParser: DOMParser_1\n    };\n\n    var DOMParser = domParser.DOMParser;\n\n    /*! @name mpd-parser @version 1.0.1 @license Apache-2.0 */\n    const isObject = obj => {\n        return !!obj && typeof obj === 'object';\n    };\n    const merge$1 = (...objects) => {\n        return objects.reduce((result, source) => {\n            if (typeof source !== 'object') {\n                return result;\n            }\n            Object.keys(source).forEach(key => {\n                if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n                    result[key] = result[key].concat(source[key]);\n                } else if (isObject(result[key]) && isObject(source[key])) {\n                    result[key] = merge$1(result[key], source[key]);\n                } else {\n                    result[key] = source[key];\n                }\n            });\n            return result;\n        }, {});\n    };\n    const values = o => Object.keys(o).map(k => o[k]);\n    const range = (start, end) => {\n        const result = [];\n        for (let i = start; i < end; i++) {\n            result.push(i);\n        }\n        return result;\n    };\n    const flatten = lists => lists.reduce((x, y) => x.concat(y), []);\n    const from = list => {\n        if (!list.length) {\n            return [];\n        }\n        const result = [];\n        for (let i = 0; i < list.length; i++) {\n            result.push(list[i]);\n        }\n        return result;\n    };\n    const findIndexes = (l, key) => l.reduce((a, e, i) => {\n        if (e[key]) {\n            a.push(i);\n        }\n        return a;\n    }, []);\n    /**\n     * Returns a union of the included lists provided each element can be identified by a key.\n     *\n     * @param {Array} list - list of lists to get the union of\n     * @param {Function} keyFunction - the function to use as a key for each element\n     *\n     * @return {Array} the union of the arrays\n     */\n\n    const union = (lists, keyFunction) => {\n        return values(lists.reduce((acc, list) => {\n            list.forEach(el => {\n                acc[keyFunction(el)] = el;\n            });\n            return acc;\n        }, {}));\n    };\n    var errors = {\n        INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\n        DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\n        DASH_INVALID_XML: 'DASH_INVALID_XML',\n        NO_BASE_URL: 'NO_BASE_URL',\n        MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\n        SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\n        UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\n    };\n\n    /**\n     * @typedef {Object} SingleUri\n     * @property {string} uri - relative location of segment\n     * @property {string} resolvedUri - resolved location of segment\n     * @property {Object} byterange - Object containing information on how to make byte range\n     *   requests following byte-range-spec per RFC2616.\n     * @property {String} byterange.length - length of range request\n     * @property {String} byterange.offset - byte offset of range request\n     *\n     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n     */\n\n    /**\n     * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n     * that conforms to how m3u8-parser is structured\n     *\n     * @see https://github.com/videojs/m3u8-parser\n     *\n     * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n     * @param {string} source - source url for segment\n     * @param {string} range - optional range used for range calls,\n     *   follows  RFC 2616, Clause 14.35.1\n     * @return {SingleUri} full segment information transformed into a format similar\n     *   to m3u8-parser\n     */\n\n    const urlTypeToSegment = ({\n                                  baseUrl = '',\n                                  source = '',\n                                  range = '',\n                                  indexRange = ''\n                              }) => {\n        const segment = {\n            uri: source,\n            resolvedUri: resolveUrl$1(baseUrl || '', source)\n        };\n        if (range || indexRange) {\n            const rangeStr = range ? range : indexRange;\n            const ranges = rangeStr.split('-'); // default to parsing this as a BigInt if possible\n\n            let startRange = window.BigInt ? window.BigInt(ranges[0]) : parseInt(ranges[0], 10);\n            let endRange = window.BigInt ? window.BigInt(ranges[1]) : parseInt(ranges[1], 10); // convert back to a number if less than MAX_SAFE_INTEGER\n\n            if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === 'bigint') {\n                startRange = Number(startRange);\n            }\n            if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === 'bigint') {\n                endRange = Number(endRange);\n            }\n            let length;\n            if (typeof endRange === 'bigint' || typeof startRange === 'bigint') {\n                length = window.BigInt(endRange) - window.BigInt(startRange) + window.BigInt(1);\n            } else {\n                length = endRange - startRange + 1;\n            }\n            if (typeof length === 'bigint' && length < Number.MAX_SAFE_INTEGER) {\n                length = Number(length);\n            } // byterange should be inclusive according to\n            // RFC 2616, Clause 14.35.1\n\n            segment.byterange = {\n                length,\n                offset: startRange\n            };\n        }\n        return segment;\n    };\n    const byteRangeToString = byterange => {\n        // `endRange` is one less than `offset + length` because the HTTP range\n        // header uses inclusive ranges\n        let endRange;\n        if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\n            endRange = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);\n        } else {\n            endRange = byterange.offset + byterange.length - 1;\n        }\n        return `${byterange.offset}-${endRange}`;\n    };\n\n    /**\n     * parse the end number attribue that can be a string\n     * number, or undefined.\n     *\n     * @param {string|number|undefined} endNumber\n     *        The end number attribute.\n     *\n     * @return {number|null}\n     *          The result of parsing the end number.\n     */\n\n    const parseEndNumber = endNumber => {\n        if (endNumber && typeof endNumber !== 'number') {\n            endNumber = parseInt(endNumber, 10);\n        }\n        if (isNaN(endNumber)) {\n            return null;\n        }\n        return endNumber;\n    };\n    /**\n     * Functions for calculating the range of available segments in static and dynamic\n     * manifests.\n     */\n\n    const segmentRange = {\n        /**\n         * Returns the entire range of available segments for a static MPD\n         *\n         * @param {Object} attributes\n         *        Inheritied MPD attributes\n         * @return {{ start: number, end: number }}\n         *         The start and end numbers for available segments\n         */\n        static(attributes) {\n            const {\n                duration,\n                timescale = 1,\n                sourceDuration,\n                periodDuration\n            } = attributes;\n            const endNumber = parseEndNumber(attributes.endNumber);\n            const segmentDuration = duration / timescale;\n            if (typeof endNumber === 'number') {\n                return {\n                    start: 0,\n                    end: endNumber\n                };\n            }\n            if (typeof periodDuration === 'number') {\n                return {\n                    start: 0,\n                    end: periodDuration / segmentDuration\n                };\n            }\n            return {\n                start: 0,\n                end: sourceDuration / segmentDuration\n            };\n        },\n        /**\n         * Returns the current live window range of available segments for a dynamic MPD\n         *\n         * @param {Object} attributes\n         *        Inheritied MPD attributes\n         * @return {{ start: number, end: number }}\n         *         The start and end numbers for available segments\n         */\n        dynamic(attributes) {\n            const {\n                NOW,\n                clientOffset,\n                availabilityStartTime,\n                timescale = 1,\n                duration,\n                periodStart = 0,\n                minimumUpdatePeriod = 0,\n                timeShiftBufferDepth = Infinity\n            } = attributes;\n            const endNumber = parseEndNumber(attributes.endNumber); // clientOffset is passed in at the top level of mpd-parser and is an offset calculated\n            // after retrieving UTC server time.\n\n            const now = (NOW + clientOffset) / 1000; // WC stands for Wall Clock.\n            // Convert the period start time to EPOCH.\n\n            const periodStartWC = availabilityStartTime + periodStart; // Period end in EPOCH is manifest's retrieval time + time until next update.\n\n            const periodEndWC = now + minimumUpdatePeriod;\n            const periodDuration = periodEndWC - periodStartWC;\n            const segmentCount = Math.ceil(periodDuration * timescale / duration);\n            const availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n            const availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n            return {\n                start: Math.max(0, availableStart),\n                end: typeof endNumber === 'number' ? endNumber : Math.min(segmentCount, availableEnd)\n            };\n        }\n    };\n    /**\n     * Maps a range of numbers to objects with information needed to build the corresponding\n     * segment list\n     *\n     * @name toSegmentsCallback\n     * @function\n     * @param {number} number\n     *        Number of the segment\n     * @param {number} index\n     *        Index of the number in the range list\n     * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n     *         Object with segment timing and duration info\n     */\n\n    /**\n     * Returns a callback for Array.prototype.map for mapping a range of numbers to\n     * information needed to build the segment list.\n     *\n     * @param {Object} attributes\n     *        Inherited MPD attributes\n     * @return {toSegmentsCallback}\n     *         Callback map function\n     */\n\n    const toSegments = attributes => number => {\n        const {\n            duration,\n            timescale = 1,\n            periodStart,\n            startNumber = 1\n        } = attributes;\n        return {\n            number: startNumber + number,\n            duration: duration / timescale,\n            timeline: periodStart,\n            time: number * duration\n        };\n    };\n    /**\n     * Returns a list of objects containing segment timing and duration info used for\n     * building the list of segments. This uses the @duration attribute specified\n     * in the MPD manifest to derive the range of segments.\n     *\n     * @param {Object} attributes\n     *        Inherited MPD attributes\n     * @return {{number: number, duration: number, time: number, timeline: number}[]}\n     *         List of Objects with segment timing and duration info\n     */\n\n    const parseByDuration = attributes => {\n        const {\n            type,\n            duration,\n            timescale = 1,\n            periodDuration,\n            sourceDuration\n        } = attributes;\n        const {\n            start,\n            end\n        } = segmentRange[type](attributes);\n        const segments = range(start, end).map(toSegments(attributes));\n        if (type === 'static') {\n            const index = segments.length - 1; // section is either a period or the full source\n\n            const sectionDuration = typeof periodDuration === 'number' ? periodDuration : sourceDuration; // final segment may be less than full segment duration\n\n            segments[index].duration = sectionDuration - duration / timescale * index;\n        }\n        return segments;\n    };\n\n    /**\n     * Translates SegmentBase into a set of segments.\n     * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n     * node should be translated into segment.\n     *\n     * @param {Object} attributes\n     *   Object containing all inherited attributes from parent elements with attribute\n     *   names as keys\n     * @return {Object.<Array>} list of segments\n     */\n\n    const segmentsFromBase = attributes => {\n        const {\n            baseUrl,\n            initialization = {},\n            sourceDuration,\n            indexRange = '',\n            periodStart,\n            presentationTime,\n            number = 0,\n            duration\n        } = attributes; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n\n        if (!baseUrl) {\n            throw new Error(errors.NO_BASE_URL);\n        }\n        const initSegment = urlTypeToSegment({\n            baseUrl,\n            source: initialization.sourceURL,\n            range: initialization.range\n        });\n        const segment = urlTypeToSegment({\n            baseUrl,\n            source: baseUrl,\n            indexRange\n        });\n        segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\n        // (since SegmentBase is only for one total segment)\n\n        if (duration) {\n            const segmentTimeInfo = parseByDuration(attributes);\n            if (segmentTimeInfo.length) {\n                segment.duration = segmentTimeInfo[0].duration;\n                segment.timeline = segmentTimeInfo[0].timeline;\n            }\n        } else if (sourceDuration) {\n            segment.duration = sourceDuration;\n            segment.timeline = periodStart;\n        } // If presentation time is provided, these segments are being generated by SIDX\n        // references, and should use the time provided. For the general case of SegmentBase,\n        // there should only be one segment in the period, so its presentation time is the same\n        // as its period start.\n\n        segment.presentationTime = presentationTime || periodStart;\n        segment.number = number;\n        return [segment];\n    };\n    /**\n     * Given a playlist, a sidx box, and a baseUrl, update the segment list of the playlist\n     * according to the sidx information given.\n     *\n     * playlist.sidx has metadadata about the sidx where-as the sidx param\n     * is the parsed sidx box itself.\n     *\n     * @param {Object} playlist the playlist to update the sidx information for\n     * @param {Object} sidx the parsed sidx box\n     * @return {Object} the playlist object with the updated sidx information\n     */\n\n    const addSidxSegmentsToPlaylist$1 = (playlist, sidx, baseUrl) => {\n        // Retain init segment information\n        const initSegment = playlist.sidx.map ? playlist.sidx.map : null; // Retain source duration from initial main manifest parsing\n\n        const sourceDuration = playlist.sidx.duration; // Retain source timeline\n\n        const timeline = playlist.timeline || 0;\n        const sidxByteRange = playlist.sidx.byterange;\n        const sidxEnd = sidxByteRange.offset + sidxByteRange.length; // Retain timescale of the parsed sidx\n\n        const timescale = sidx.timescale; // referenceType 1 refers to other sidx boxes\n\n        const mediaReferences = sidx.references.filter(r => r.referenceType !== 1);\n        const segments = [];\n        const type = playlist.endList ? 'static' : 'dynamic';\n        const periodStart = playlist.sidx.timeline;\n        let presentationTime = periodStart;\n        let number = playlist.mediaSequence || 0; // firstOffset is the offset from the end of the sidx box\n\n        let startIndex; // eslint-disable-next-line\n\n        if (typeof sidx.firstOffset === 'bigint') {\n            startIndex = window.BigInt(sidxEnd) + sidx.firstOffset;\n        } else {\n            startIndex = sidxEnd + sidx.firstOffset;\n        }\n        for (let i = 0; i < mediaReferences.length; i++) {\n            const reference = sidx.references[i]; // size of the referenced (sub)segment\n\n            const size = reference.referencedSize; // duration of the referenced (sub)segment, in  the  timescale\n            // this will be converted to seconds when generating segments\n\n            const duration = reference.subsegmentDuration; // should be an inclusive range\n\n            let endIndex; // eslint-disable-next-line\n\n            if (typeof startIndex === 'bigint') {\n                endIndex = startIndex + window.BigInt(size) - window.BigInt(1);\n            } else {\n                endIndex = startIndex + size - 1;\n            }\n            const indexRange = `${startIndex}-${endIndex}`;\n            const attributes = {\n                baseUrl,\n                timescale,\n                timeline,\n                periodStart,\n                presentationTime,\n                number,\n                duration,\n                sourceDuration,\n                indexRange,\n                type\n            };\n            const segment = segmentsFromBase(attributes)[0];\n            if (initSegment) {\n                segment.map = initSegment;\n            }\n            segments.push(segment);\n            if (typeof startIndex === 'bigint') {\n                startIndex += window.BigInt(size);\n            } else {\n                startIndex += size;\n            }\n            presentationTime += duration / timescale;\n            number++;\n        }\n        playlist.segments = segments;\n        return playlist;\n    };\n    const SUPPORTED_MEDIA_TYPES = ['AUDIO', 'SUBTITLES']; // allow one 60fps frame as leniency (arbitrarily chosen)\n\n    const TIME_FUDGE = 1 / 60;\n    /**\n     * Given a list of timelineStarts, combines, dedupes, and sorts them.\n     *\n     * @param {TimelineStart[]} timelineStarts - list of timeline starts\n     *\n     * @return {TimelineStart[]} the combined and deduped timeline starts\n     */\n\n    const getUniqueTimelineStarts = timelineStarts => {\n        return union(timelineStarts, ({\n                                          timeline\n                                      }) => timeline).sort((a, b) => a.timeline > b.timeline ? 1 : -1);\n    };\n    /**\n     * Finds the playlist with the matching NAME attribute.\n     *\n     * @param {Array} playlists - playlists to search through\n     * @param {string} name - the NAME attribute to search for\n     *\n     * @return {Object|null} the matching playlist object, or null\n     */\n\n    const findPlaylistWithName = (playlists, name) => {\n        for (let i = 0; i < playlists.length; i++) {\n            if (playlists[i].attributes.NAME === name) {\n                return playlists[i];\n            }\n        }\n        return null;\n    };\n    /**\n     * Gets a flattened array of media group playlists.\n     *\n     * @param {Object} manifest - the main manifest object\n     *\n     * @return {Array} the media group playlists\n     */\n\n    const getMediaGroupPlaylists = manifest => {\n        let mediaGroupPlaylists = [];\n        forEachMediaGroup$1(manifest, SUPPORTED_MEDIA_TYPES, (properties, type, group, label) => {\n            mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);\n        });\n        return mediaGroupPlaylists;\n    };\n    /**\n     * Updates the playlist's media sequence numbers.\n     *\n     * @param {Object} config - options object\n     * @param {Object} config.playlist - the playlist to update\n     * @param {number} config.mediaSequence - the mediaSequence number to start with\n     */\n\n    const updateMediaSequenceForPlaylist = ({\n                                                playlist,\n                                                mediaSequence\n                                            }) => {\n        playlist.mediaSequence = mediaSequence;\n        playlist.segments.forEach((segment, index) => {\n            segment.number = playlist.mediaSequence + index;\n        });\n    };\n    /**\n     * Updates the media and discontinuity sequence numbers of newPlaylists given oldPlaylists\n     * and a complete list of timeline starts.\n     *\n     * If no matching playlist is found, only the discontinuity sequence number of the playlist\n     * will be updated.\n     *\n     * Since early available timelines are not supported, at least one segment must be present.\n     *\n     * @param {Object} config - options object\n     * @param {Object[]} oldPlaylists - the old playlists to use as a reference\n     * @param {Object[]} newPlaylists - the new playlists to update\n     * @param {Object} timelineStarts - all timelineStarts seen in the stream to this point\n     */\n\n    const updateSequenceNumbers = ({\n                                       oldPlaylists,\n                                       newPlaylists,\n                                       timelineStarts\n                                   }) => {\n        newPlaylists.forEach(playlist => {\n            playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n                                                                                    timeline\n                                                                                }) {\n                return timeline === playlist.timeline;\n            }); // Playlists NAMEs come from DASH Representation IDs, which are mandatory\n            // (see ISO_23009-1-2012 5.3.5.2).\n            //\n            // If the same Representation existed in a prior Period, it will retain the same NAME.\n\n            const oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);\n            if (!oldPlaylist) {\n                // Since this is a new playlist, the media sequence values can start from 0 without\n                // consequence.\n                return;\n            } // TODO better support for live SIDX\n            //\n            // As of this writing, mpd-parser does not support multiperiod SIDX (in live or VOD).\n            // This is evident by a playlist only having a single SIDX reference. In a multiperiod\n            // playlist there would need to be multiple SIDX references. In addition, live SIDX is\n            // not supported when the SIDX properties change on refreshes.\n            //\n            // In the future, if support needs to be added, the merging logic here can be called\n            // after SIDX references are resolved. For now, exit early to prevent exceptions being\n            // thrown due to undefined references.\n\n            if (playlist.sidx) {\n                return;\n            } // Since we don't yet support early available timelines, we don't need to support\n            // playlists with no segments.\n\n            const firstNewSegment = playlist.segments[0];\n            const oldMatchingSegmentIndex = oldPlaylist.segments.findIndex(function (oldSegment) {\n                return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;\n            }); // No matching segment from the old playlist means the entire playlist was refreshed.\n            // In this case the media sequence should account for this update, and the new segments\n            // should be marked as discontinuous from the prior content, since the last prior\n            // timeline was removed.\n\n            if (oldMatchingSegmentIndex === -1) {\n                updateMediaSequenceForPlaylist({\n                    playlist,\n                    mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length\n                });\n                playlist.segments[0].discontinuity = true;\n                playlist.discontinuityStarts.unshift(0); // No matching segment does not necessarily mean there's missing content.\n                //\n                // If the new playlist's timeline is the same as the last seen segment's timeline,\n                // then a discontinuity can be added to identify that there's potentially missing\n                // content. If there's no missing content, the discontinuity should still be rather\n                // harmless. It's possible that if segment durations are accurate enough, that the\n                // existence of a gap can be determined using the presentation times and durations,\n                // but if the segment timing info is off, it may introduce more problems than simply\n                // adding the discontinuity.\n                //\n                // If the new playlist's timeline is different from the last seen segment's timeline,\n                // then a discontinuity can be added to identify that this is the first seen segment\n                // of a new timeline. However, the logic at the start of this function that\n                // determined the disconinuity sequence by timeline index is now off by one (the\n                // discontinuity of the newest timeline hasn't yet fallen off the manifest...since\n                // we added it), so the disconinuity sequence must be decremented.\n                //\n                // A period may also have a duration of zero, so the case of no segments is handled\n                // here even though we don't yet support early available periods.\n\n                if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {\n                    playlist.discontinuitySequence--;\n                }\n                return;\n            } // If the first segment matched with a prior segment on a discontinuity (it's matching\n            // on the first segment of a period), then the discontinuitySequence shouldn't be the\n            // timeline's matching one, but instead should be the one prior, and the first segment\n            // of the new manifest should be marked with a discontinuity.\n            //\n            // The reason for this special case is that discontinuity sequence shows how many\n            // discontinuities have fallen off of the playlist, and discontinuities are marked on\n            // the first segment of a new \"timeline.\" Because of this, while DASH will retain that\n            // Period while the \"timeline\" exists, HLS keeps track of it via the discontinuity\n            // sequence, and that first segment is an indicator, but can be removed before that\n            // timeline is gone.\n\n            const oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];\n            if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {\n                firstNewSegment.discontinuity = true;\n                playlist.discontinuityStarts.unshift(0);\n                playlist.discontinuitySequence--;\n            }\n            updateMediaSequenceForPlaylist({\n                playlist,\n                mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number\n            });\n        });\n    };\n    /**\n     * Given an old parsed manifest object and a new parsed manifest object, updates the\n     * sequence and timing values within the new manifest to ensure that it lines up with the\n     * old.\n     *\n     * @param {Array} oldManifest - the old main manifest object\n     * @param {Array} newManifest - the new main manifest object\n     *\n     * @return {Object} the updated new manifest object\n     */\n\n    const positionManifestOnTimeline = ({\n                                            oldManifest,\n                                            newManifest\n                                        }) => {\n        // Starting from v4.1.2 of the IOP, section 4.4.3.3 states:\n        //\n        // \"MPD@availabilityStartTime and Period@start shall not be changed over MPD updates.\"\n        //\n        // This was added from https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/160\n        //\n        // Because of this change, and the difficulty of supporting periods with changing start\n        // times, periods with changing start times are not supported. This makes the logic much\n        // simpler, since periods with the same start time can be considerred the same period\n        // across refreshes.\n        //\n        // To give an example as to the difficulty of handling periods where the start time may\n        // change, if a single period manifest is refreshed with another manifest with a single\n        // period, and both the start and end times are increased, then the only way to determine\n        // if it's a new period or an old one that has changed is to look through the segments of\n        // each playlist and determine the presentation time bounds to find a match. In addition,\n        // if the period start changed to exceed the old period end, then there would be no\n        // match, and it would not be possible to determine whether the refreshed period is a new\n        // one or the old one.\n        const oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));\n        const newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest)); // Save all seen timelineStarts to the new manifest. Although this potentially means that\n        // there's a \"memory leak\" in that it will never stop growing, in reality, only a couple\n        // of properties are saved for each seen Period. Even long running live streams won't\n        // generate too many Periods, unless the stream is watched for decades. In the future,\n        // this can be optimized by mapping to discontinuity sequence numbers for each timeline,\n        // but it may not become an issue, and the additional info can be useful for debugging.\n\n        newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);\n        updateSequenceNumbers({\n            oldPlaylists,\n            newPlaylists,\n            timelineStarts: newManifest.timelineStarts\n        });\n        return newManifest;\n    };\n    const generateSidxKey = sidx => sidx && sidx.uri + '-' + byteRangeToString(sidx.byterange);\n    const mergeDiscontiguousPlaylists = playlists => {\n        const mergedPlaylists = values(playlists.reduce((acc, playlist) => {\n            // assuming playlist IDs are the same across periods\n            // TODO: handle multiperiod where representation sets are not the same\n            // across periods\n            const name = playlist.attributes.id + (playlist.attributes.lang || '');\n            if (!acc[name]) {\n                // First Period\n                acc[name] = playlist;\n                acc[name].attributes.timelineStarts = [];\n            } else {\n                // Subsequent Periods\n                if (playlist.segments) {\n                    // first segment of subsequent periods signal a discontinuity\n                    if (playlist.segments[0]) {\n                        playlist.segments[0].discontinuity = true;\n                    }\n                    acc[name].segments.push(...playlist.segments);\n                } // bubble up contentProtection, this assumes all DRM content\n                // has the same contentProtection\n\n                if (playlist.attributes.contentProtection) {\n                    acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\n                }\n            }\n            acc[name].attributes.timelineStarts.push({\n                // Although they represent the same number, it's important to have both to make it\n                // compatible with HLS potentially having a similar attribute.\n                start: playlist.attributes.periodStart,\n                timeline: playlist.attributes.periodStart\n            });\n            return acc;\n        }, {}));\n        return mergedPlaylists.map(playlist => {\n            playlist.discontinuityStarts = findIndexes(playlist.segments || [], 'discontinuity');\n            return playlist;\n        });\n    };\n    const addSidxSegmentsToPlaylist = (playlist, sidxMapping) => {\n        const sidxKey = generateSidxKey(playlist.sidx);\n        const sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;\n        if (sidxMatch) {\n            addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);\n        }\n        return playlist;\n    };\n    const addSidxSegmentsToPlaylists = (playlists, sidxMapping = {}) => {\n        if (!Object.keys(sidxMapping).length) {\n            return playlists;\n        }\n        for (const i in playlists) {\n            playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);\n        }\n        return playlists;\n    };\n    const formatAudioPlaylist = ({\n                                     attributes,\n                                     segments,\n                                     sidx,\n                                     mediaSequence,\n                                     discontinuitySequence,\n                                     discontinuityStarts\n                                 }, isAudioOnly) => {\n        const playlist = {\n            attributes: {\n                NAME: attributes.id,\n                BANDWIDTH: attributes.bandwidth,\n                CODECS: attributes.codecs,\n                ['PROGRAM-ID']: 1\n            },\n            uri: '',\n            endList: attributes.type === 'static',\n            timeline: attributes.periodStart,\n            resolvedUri: '',\n            targetDuration: attributes.duration,\n            discontinuitySequence,\n            discontinuityStarts,\n            timelineStarts: attributes.timelineStarts,\n            mediaSequence,\n            segments\n        };\n        if (attributes.contentProtection) {\n            playlist.contentProtection = attributes.contentProtection;\n        }\n        if (sidx) {\n            playlist.sidx = sidx;\n        }\n        if (isAudioOnly) {\n            playlist.attributes.AUDIO = 'audio';\n            playlist.attributes.SUBTITLES = 'subs';\n        }\n        return playlist;\n    };\n    const formatVttPlaylist = ({\n                                   attributes,\n                                   segments,\n                                   mediaSequence,\n                                   discontinuityStarts,\n                                   discontinuitySequence\n                               }) => {\n        if (typeof segments === 'undefined') {\n            // vtt tracks may use single file in BaseURL\n            segments = [{\n                uri: attributes.baseUrl,\n                timeline: attributes.periodStart,\n                resolvedUri: attributes.baseUrl || '',\n                duration: attributes.sourceDuration,\n                number: 0\n            }]; // targetDuration should be the same duration as the only segment\n\n            attributes.duration = attributes.sourceDuration;\n        }\n        const m3u8Attributes = {\n            NAME: attributes.id,\n            BANDWIDTH: attributes.bandwidth,\n            ['PROGRAM-ID']: 1\n        };\n        if (attributes.codecs) {\n            m3u8Attributes.CODECS = attributes.codecs;\n        }\n        return {\n            attributes: m3u8Attributes,\n            uri: '',\n            endList: attributes.type === 'static',\n            timeline: attributes.periodStart,\n            resolvedUri: attributes.baseUrl || '',\n            targetDuration: attributes.duration,\n            timelineStarts: attributes.timelineStarts,\n            discontinuityStarts,\n            discontinuitySequence,\n            mediaSequence,\n            segments\n        };\n    };\n    const organizeAudioPlaylists = (playlists, sidxMapping = {}, isAudioOnly = false) => {\n        let mainPlaylist;\n        const formattedPlaylists = playlists.reduce((a, playlist) => {\n            const role = playlist.attributes.role && playlist.attributes.role.value || '';\n            const language = playlist.attributes.lang || '';\n            let label = playlist.attributes.label || 'main';\n            if (language && !playlist.attributes.label) {\n                const roleLabel = role ? ` (${role})` : '';\n                label = `${playlist.attributes.lang}${roleLabel}`;\n            }\n            if (!a[label]) {\n                a[label] = {\n                    language,\n                    autoselect: true,\n                    default: role === 'main',\n                    playlists: [],\n                    uri: ''\n                };\n            }\n            const formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);\n            a[label].playlists.push(formatted);\n            if (typeof mainPlaylist === 'undefined' && role === 'main') {\n                mainPlaylist = playlist;\n                mainPlaylist.default = true;\n            }\n            return a;\n        }, {}); // if no playlists have role \"main\", mark the first as main\n\n        if (!mainPlaylist) {\n            const firstLabel = Object.keys(formattedPlaylists)[0];\n            formattedPlaylists[firstLabel].default = true;\n        }\n        return formattedPlaylists;\n    };\n    const organizeVttPlaylists = (playlists, sidxMapping = {}) => {\n        return playlists.reduce((a, playlist) => {\n            const label = playlist.attributes.lang || 'text';\n            if (!a[label]) {\n                a[label] = {\n                    language: label,\n                    default: false,\n                    autoselect: false,\n                    playlists: [],\n                    uri: ''\n                };\n            }\n            a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));\n            return a;\n        }, {});\n    };\n    const organizeCaptionServices = captionServices => captionServices.reduce((svcObj, svc) => {\n        if (!svc) {\n            return svcObj;\n        }\n        svc.forEach(service => {\n            const {\n                channel,\n                language\n            } = service;\n            svcObj[language] = {\n                autoselect: false,\n                default: false,\n                instreamId: channel,\n                language\n            };\n            if (service.hasOwnProperty('aspectRatio')) {\n                svcObj[language].aspectRatio = service.aspectRatio;\n            }\n            if (service.hasOwnProperty('easyReader')) {\n                svcObj[language].easyReader = service.easyReader;\n            }\n            if (service.hasOwnProperty('3D')) {\n                svcObj[language]['3D'] = service['3D'];\n            }\n        });\n        return svcObj;\n    }, {});\n    const formatVideoPlaylist = ({\n                                     attributes,\n                                     segments,\n                                     sidx,\n                                     discontinuityStarts\n                                 }) => {\n        const playlist = {\n            attributes: {\n                NAME: attributes.id,\n                AUDIO: 'audio',\n                SUBTITLES: 'subs',\n                RESOLUTION: {\n                    width: attributes.width,\n                    height: attributes.height\n                },\n                CODECS: attributes.codecs,\n                BANDWIDTH: attributes.bandwidth,\n                ['PROGRAM-ID']: 1\n            },\n            uri: '',\n            endList: attributes.type === 'static',\n            timeline: attributes.periodStart,\n            resolvedUri: '',\n            targetDuration: attributes.duration,\n            discontinuityStarts,\n            timelineStarts: attributes.timelineStarts,\n            segments\n        };\n        if (attributes.frameRate) {\n            playlist.attributes['FRAME-RATE'] = attributes.frameRate;\n        }\n        if (attributes.contentProtection) {\n            playlist.contentProtection = attributes.contentProtection;\n        }\n        if (sidx) {\n            playlist.sidx = sidx;\n        }\n        return playlist;\n    };\n    const videoOnly = ({\n                           attributes\n                       }) => attributes.mimeType === 'video/mp4' || attributes.mimeType === 'video/webm' || attributes.contentType === 'video';\n    const audioOnly = ({\n                           attributes\n                       }) => attributes.mimeType === 'audio/mp4' || attributes.mimeType === 'audio/webm' || attributes.contentType === 'audio';\n    const vttOnly = ({\n                         attributes\n                     }) => attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\n    /**\n     * Contains start and timeline properties denoting a timeline start. For DASH, these will\n     * be the same number.\n     *\n     * @typedef {Object} TimelineStart\n     * @property {number} start - the start time of the timeline\n     * @property {number} timeline - the timeline number\n     */\n\n    /**\n     * Adds appropriate media and discontinuity sequence values to the segments and playlists.\n     *\n     * Throughout mpd-parser, the `number` attribute is used in relation to `startNumber`, a\n     * DASH specific attribute used in constructing segment URI's from templates. However, from\n     * an HLS perspective, the `number` attribute on a segment would be its `mediaSequence`\n     * value, which should start at the original media sequence value (or 0) and increment by 1\n     * for each segment thereafter. Since DASH's `startNumber` values are independent per\n     * period, it doesn't make sense to use it for `number`. Instead, assume everything starts\n     * from a 0 mediaSequence value and increment from there.\n     *\n     * Note that VHS currently doesn't use the `number` property, but it can be helpful for\n     * debugging and making sense of the manifest.\n     *\n     * For live playlists, to account for values increasing in manifests when periods are\n     * removed on refreshes, merging logic should be used to update the numbers to their\n     * appropriate values (to ensure they're sequential and increasing).\n     *\n     * @param {Object[]} playlists - the playlists to update\n     * @param {TimelineStart[]} timelineStarts - the timeline starts for the manifest\n     */\n\n    const addMediaSequenceValues = (playlists, timelineStarts) => {\n        // increment all segments sequentially\n        playlists.forEach(playlist => {\n            playlist.mediaSequence = 0;\n            playlist.discontinuitySequence = timelineStarts.findIndex(function ({\n                                                                                    timeline\n                                                                                }) {\n                return timeline === playlist.timeline;\n            });\n            if (!playlist.segments) {\n                return;\n            }\n            playlist.segments.forEach((segment, index) => {\n                segment.number = index;\n            });\n        });\n    };\n    /**\n     * Given a media group object, flattens all playlists within the media group into a single\n     * array.\n     *\n     * @param {Object} mediaGroupObject - the media group object\n     *\n     * @return {Object[]}\n     *         The media group playlists\n     */\n\n    const flattenMediaGroupPlaylists = mediaGroupObject => {\n        if (!mediaGroupObject) {\n            return [];\n        }\n        return Object.keys(mediaGroupObject).reduce((acc, label) => {\n            const labelContents = mediaGroupObject[label];\n            return acc.concat(labelContents.playlists);\n        }, []);\n    };\n    const toM3u8 = ({\n                        dashPlaylists,\n                        locations,\n                        sidxMapping = {},\n                        previousManifest\n                    }) => {\n        if (!dashPlaylists.length) {\n            return {};\n        } // grab all main manifest attributes\n\n        const {\n            sourceDuration: duration,\n            type,\n            suggestedPresentationDelay,\n            minimumUpdatePeriod\n        } = dashPlaylists[0].attributes;\n        const videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\n        const audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\n        const vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));\n        const captions = dashPlaylists.map(playlist => playlist.attributes.captionServices).filter(Boolean);\n        const manifest = {\n            allowCache: true,\n            discontinuityStarts: [],\n            segments: [],\n            endList: true,\n            mediaGroups: {\n                AUDIO: {},\n                VIDEO: {},\n                ['CLOSED-CAPTIONS']: {},\n                SUBTITLES: {}\n            },\n            uri: '',\n            duration,\n            playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)\n        };\n        if (minimumUpdatePeriod >= 0) {\n            manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1000;\n        }\n        if (locations) {\n            manifest.locations = locations;\n        }\n        if (type === 'dynamic') {\n            manifest.suggestedPresentationDelay = suggestedPresentationDelay;\n        }\n        const isAudioOnly = manifest.playlists.length === 0;\n        const organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;\n        const organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;\n        const formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));\n        const playlistTimelineStarts = formattedPlaylists.map(({\n                                                                   timelineStarts\n                                                               }) => timelineStarts);\n        manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);\n        addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);\n        if (organizedAudioGroup) {\n            manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;\n        }\n        if (organizedVttGroup) {\n            manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;\n        }\n        if (captions.length) {\n            manifest.mediaGroups['CLOSED-CAPTIONS'].cc = organizeCaptionServices(captions);\n        }\n        if (previousManifest) {\n            return positionManifestOnTimeline({\n                oldManifest: previousManifest,\n                newManifest: manifest\n            });\n        }\n        return manifest;\n    };\n\n    /**\n     * Calculates the R (repetition) value for a live stream (for the final segment\n     * in a manifest where the r value is negative 1)\n     *\n     * @param {Object} attributes\n     *        Object containing all inherited attributes from parent elements with attribute\n     *        names as keys\n     * @param {number} time\n     *        current time (typically the total time up until the final segment)\n     * @param {number} duration\n     *        duration property for the given <S />\n     *\n     * @return {number}\n     *        R value to reach the end of the given period\n     */\n    const getLiveRValue = (attributes, time, duration) => {\n        const {\n            NOW,\n            clientOffset,\n            availabilityStartTime,\n            timescale = 1,\n            periodStart = 0,\n            minimumUpdatePeriod = 0\n        } = attributes;\n        const now = (NOW + clientOffset) / 1000;\n        const periodStartWC = availabilityStartTime + periodStart;\n        const periodEndWC = now + minimumUpdatePeriod;\n        const periodDuration = periodEndWC - periodStartWC;\n        return Math.ceil((periodDuration * timescale - time) / duration);\n    };\n    /**\n     * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n     * timing and duration\n     *\n     * @param {Object} attributes\n     *        Object containing all inherited attributes from parent elements with attribute\n     *        names as keys\n     * @param {Object[]} segmentTimeline\n     *        List of objects representing the attributes of each S element contained within\n     *\n     * @return {{number: number, duration: number, time: number, timeline: number}[]}\n     *         List of Objects with segment timing and duration info\n     */\n\n    const parseByTimeline = (attributes, segmentTimeline) => {\n        const {\n            type,\n            minimumUpdatePeriod = 0,\n            media = '',\n            sourceDuration,\n            timescale = 1,\n            startNumber = 1,\n            periodStart: timeline\n        } = attributes;\n        const segments = [];\n        let time = -1;\n        for (let sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\n            const S = segmentTimeline[sIndex];\n            const duration = S.d;\n            const repeat = S.r || 0;\n            const segmentTime = S.t || 0;\n            if (time < 0) {\n                // first segment\n                time = segmentTime;\n            }\n            if (segmentTime && segmentTime > time) {\n                // discontinuity\n                // TODO: How to handle this type of discontinuity\n                // timeline++ here would treat it like HLS discontuity and content would\n                // get appended without gap\n                // E.G.\n                //  <S t=\"0\" d=\"1\" />\n                //  <S d=\"1\" />\n                //  <S d=\"1\" />\n                //  <S t=\"5\" d=\"1\" />\n                // would have $Time$ values of [0, 1, 2, 5]\n                // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n                // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n                // does the value of sourceDuration consider this when calculating arbitrary\n                // negative @r repeat value?\n                // E.G. Same elements as above with this added at the end\n                //  <S d=\"1\" r=\"-1\" />\n                //  with a sourceDuration of 10\n                // Would the 2 gaps be included in the time duration calculations resulting in\n                // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n                // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n                time = segmentTime;\n            }\n            let count;\n            if (repeat < 0) {\n                const nextS = sIndex + 1;\n                if (nextS === segmentTimeline.length) {\n                    // last segment\n                    if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\n                        count = getLiveRValue(attributes, time, duration);\n                    } else {\n                        // TODO: This may be incorrect depending on conclusion of TODO above\n                        count = (sourceDuration * timescale - time) / duration;\n                    }\n                } else {\n                    count = (segmentTimeline[nextS].t - time) / duration;\n                }\n            } else {\n                count = repeat + 1;\n            }\n            const end = startNumber + segments.length + count;\n            let number = startNumber + segments.length;\n            while (number < end) {\n                segments.push({\n                    number,\n                    duration: duration / timescale,\n                    time,\n                    timeline\n                });\n                time += duration;\n                number++;\n            }\n        }\n        return segments;\n    };\n    const identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n    /**\n     * Replaces template identifiers with corresponding values. To be used as the callback\n     * for String.prototype.replace\n     *\n     * @name replaceCallback\n     * @function\n     * @param {string} match\n     *        Entire match of identifier\n     * @param {string} identifier\n     *        Name of matched identifier\n     * @param {string} format\n     *        Format tag string. Its presence indicates that padding is expected\n     * @param {string} width\n     *        Desired length of the replaced value. Values less than this width shall be left\n     *        zero padded\n     * @return {string}\n     *         Replacement for the matched identifier\n     */\n\n    /**\n     * Returns a function to be used as a callback for String.prototype.replace to replace\n     * template identifiers\n     *\n     * @param {Obect} values\n     *        Object containing values that shall be used to replace known identifiers\n     * @param {number} values.RepresentationID\n     *        Value of the Representation@id attribute\n     * @param {number} values.Number\n     *        Number of the corresponding segment\n     * @param {number} values.Bandwidth\n     *        Value of the Representation@bandwidth attribute.\n     * @param {number} values.Time\n     *        Timestamp value of the corresponding segment\n     * @return {replaceCallback}\n     *         Callback to be used with String.prototype.replace to replace identifiers\n     */\n\n    const identifierReplacement = values => (match, identifier, format, width) => {\n        if (match === '$$') {\n            // escape sequence\n            return '$';\n        }\n        if (typeof values[identifier] === 'undefined') {\n            return match;\n        }\n        const value = '' + values[identifier];\n        if (identifier === 'RepresentationID') {\n            // Format tag shall not be present with RepresentationID\n            return value;\n        }\n        if (!format) {\n            width = 1;\n        } else {\n            width = parseInt(width, 10);\n        }\n        if (value.length >= width) {\n            return value;\n        }\n        return `${new Array(width - value.length + 1).join('0')}${value}`;\n    };\n    /**\n     * Constructs a segment url from a template string\n     *\n     * @param {string} url\n     *        Template string to construct url from\n     * @param {Obect} values\n     *        Object containing values that shall be used to replace known identifiers\n     * @param {number} values.RepresentationID\n     *        Value of the Representation@id attribute\n     * @param {number} values.Number\n     *        Number of the corresponding segment\n     * @param {number} values.Bandwidth\n     *        Value of the Representation@bandwidth attribute.\n     * @param {number} values.Time\n     *        Timestamp value of the corresponding segment\n     * @return {string}\n     *         Segment url with identifiers replaced\n     */\n\n    const constructTemplateUrl = (url, values) => url.replace(identifierPattern, identifierReplacement(values));\n    /**\n     * Generates a list of objects containing timing and duration information about each\n     * segment needed to generate segment uris and the complete segment object\n     *\n     * @param {Object} attributes\n     *        Object containing all inherited attributes from parent elements with attribute\n     *        names as keys\n     * @param {Object[]|undefined} segmentTimeline\n     *        List of objects representing the attributes of each S element contained within\n     *        the SegmentTimeline element\n     * @return {{number: number, duration: number, time: number, timeline: number}[]}\n     *         List of Objects with segment timing and duration info\n     */\n\n    const parseTemplateInfo = (attributes, segmentTimeline) => {\n        if (!attributes.duration && !segmentTimeline) {\n            // if neither @duration or SegmentTimeline are present, then there shall be exactly\n            // one media segment\n            return [{\n                number: attributes.startNumber || 1,\n                duration: attributes.sourceDuration,\n                time: 0,\n                timeline: attributes.periodStart\n            }];\n        }\n        if (attributes.duration) {\n            return parseByDuration(attributes);\n        }\n        return parseByTimeline(attributes, segmentTimeline);\n    };\n    /**\n     * Generates a list of segments using information provided by the SegmentTemplate element\n     *\n     * @param {Object} attributes\n     *        Object containing all inherited attributes from parent elements with attribute\n     *        names as keys\n     * @param {Object[]|undefined} segmentTimeline\n     *        List of objects representing the attributes of each S element contained within\n     *        the SegmentTimeline element\n     * @return {Object[]}\n     *         List of segment objects\n     */\n\n    const segmentsFromTemplate = (attributes, segmentTimeline) => {\n        const templateValues = {\n            RepresentationID: attributes.id,\n            Bandwidth: attributes.bandwidth || 0\n        };\n        const {\n            initialization = {\n                sourceURL: '',\n                range: ''\n            }\n        } = attributes;\n        const mapSegment = urlTypeToSegment({\n            baseUrl: attributes.baseUrl,\n            source: constructTemplateUrl(initialization.sourceURL, templateValues),\n            range: initialization.range\n        });\n        const segments = parseTemplateInfo(attributes, segmentTimeline);\n        return segments.map(segment => {\n            templateValues.Number = segment.number;\n            templateValues.Time = segment.time;\n            const uri = constructTemplateUrl(attributes.media || '', templateValues); // See DASH spec section 5.3.9.2.2\n            // - if timescale isn't present on any level, default to 1.\n\n            const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n            const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n            const presentationTime =\n                // Even if the @t attribute is not specified for the segment, segment.time is\n                // calculated in mpd-parser prior to this, so it's assumed to be available.\n                attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;\n            const map = {\n                uri,\n                timeline: segment.timeline,\n                duration: segment.duration,\n                resolvedUri: resolveUrl$1(attributes.baseUrl || '', uri),\n                map: mapSegment,\n                number: segment.number,\n                presentationTime\n            };\n            return map;\n        });\n    };\n\n    /**\n     * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n     * to an object that matches the output of a segment in videojs/mpd-parser\n     *\n     * @param {Object} attributes\n     *   Object containing all inherited attributes from parent elements with attribute\n     *   names as keys\n     * @param {Object} segmentUrl\n     *   <SegmentURL> node to translate into a segment object\n     * @return {Object} translated segment object\n     */\n\n    const SegmentURLToSegmentObject = (attributes, segmentUrl) => {\n        const {\n            baseUrl,\n            initialization = {}\n        } = attributes;\n        const initSegment = urlTypeToSegment({\n            baseUrl,\n            source: initialization.sourceURL,\n            range: initialization.range\n        });\n        const segment = urlTypeToSegment({\n            baseUrl,\n            source: segmentUrl.media,\n            range: segmentUrl.mediaRange\n        });\n        segment.map = initSegment;\n        return segment;\n    };\n    /**\n     * Generates a list of segments using information provided by the SegmentList element\n     * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n     * node should be translated into segment.\n     *\n     * @param {Object} attributes\n     *   Object containing all inherited attributes from parent elements with attribute\n     *   names as keys\n     * @param {Object[]|undefined} segmentTimeline\n     *        List of objects representing the attributes of each S element contained within\n     *        the SegmentTimeline element\n     * @return {Object.<Array>} list of segments\n     */\n\n    const segmentsFromList = (attributes, segmentTimeline) => {\n        const {\n            duration,\n            segmentUrls = [],\n            periodStart\n        } = attributes; // Per spec (5.3.9.2.1) no way to determine segment duration OR\n        // if both SegmentTimeline and @duration are defined, it is outside of spec.\n\n        if (!duration && !segmentTimeline || duration && segmentTimeline) {\n            throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n        }\n        const segmentUrlMap = segmentUrls.map(segmentUrlObject => SegmentURLToSegmentObject(attributes, segmentUrlObject));\n        let segmentTimeInfo;\n        if (duration) {\n            segmentTimeInfo = parseByDuration(attributes);\n        }\n        if (segmentTimeline) {\n            segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n        }\n        const segments = segmentTimeInfo.map((segmentTime, index) => {\n            if (segmentUrlMap[index]) {\n                const segment = segmentUrlMap[index]; // See DASH spec section 5.3.9.2.2\n                // - if timescale isn't present on any level, default to 1.\n\n                const timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n                const presentationTimeOffset = attributes.presentationTimeOffset || 0;\n                segment.timeline = segmentTime.timeline;\n                segment.duration = segmentTime.duration;\n                segment.number = segmentTime.number;\n                segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;\n                return segment;\n            } // Since we're mapping we should get rid of any blank segments (in case\n            // the given SegmentTimeline is handling for more elements than we have\n            // SegmentURLs for).\n        }).filter(segment => segment);\n        return segments;\n    };\n    const generateSegments = ({\n                                  attributes,\n                                  segmentInfo\n                              }) => {\n        let segmentAttributes;\n        let segmentsFn;\n        if (segmentInfo.template) {\n            segmentsFn = segmentsFromTemplate;\n            segmentAttributes = merge$1(attributes, segmentInfo.template);\n        } else if (segmentInfo.base) {\n            segmentsFn = segmentsFromBase;\n            segmentAttributes = merge$1(attributes, segmentInfo.base);\n        } else if (segmentInfo.list) {\n            segmentsFn = segmentsFromList;\n            segmentAttributes = merge$1(attributes, segmentInfo.list);\n        }\n        const segmentsInfo = {\n            attributes\n        };\n        if (!segmentsFn) {\n            return segmentsInfo;\n        }\n        const segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline); // The @duration attribute will be used to determin the playlist's targetDuration which\n        // must be in seconds. Since we've generated the segment list, we no longer need\n        // @duration to be in @timescale units, so we can convert it here.\n\n        if (segmentAttributes.duration) {\n            const {\n                duration,\n                timescale = 1\n            } = segmentAttributes;\n            segmentAttributes.duration = duration / timescale;\n        } else if (segments.length) {\n            // if there is no @duration attribute, use the largest segment duration as\n            // as target duration\n            segmentAttributes.duration = segments.reduce((max, segment) => {\n                return Math.max(max, Math.ceil(segment.duration));\n            }, 0);\n        } else {\n            segmentAttributes.duration = 0;\n        }\n        segmentsInfo.attributes = segmentAttributes;\n        segmentsInfo.segments = segments; // This is a sidx box without actual segment information\n\n        if (segmentInfo.base && segmentAttributes.indexRange) {\n            segmentsInfo.sidx = segments[0];\n            segmentsInfo.segments = [];\n        }\n        return segmentsInfo;\n    };\n    const toPlaylists = representations => representations.map(generateSegments);\n    const findChildren = (element, name) => from(element.childNodes).filter(({\n                                                                                 tagName\n                                                                             }) => tagName === name);\n    const getContent = element => element.textContent.trim();\n\n    /**\n     * Converts the provided string that may contain a division operation to a number.\n     *\n     * @param {string} value - the provided string value\n     *\n     * @return {number} the parsed string value\n     */\n    const parseDivisionValue = value => {\n        return parseFloat(value.split('/').reduce((prev, current) => prev / current));\n    };\n    const parseDuration = str => {\n        const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n        const SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n        const SECONDS_IN_DAY = 24 * 60 * 60;\n        const SECONDS_IN_HOUR = 60 * 60;\n        const SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\n\n        const durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n        const match = durationRegex.exec(str);\n        if (!match) {\n            return 0;\n        }\n        const [year, month, day, hour, minute, second] = match.slice(1);\n        return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n    };\n    const parseDate = str => {\n        // Date format without timezone according to ISO 8601\n        // YYY-MM-DDThh:mm:ss.ssssss\n        const dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n        // expressed by ending with 'Z'\n\n        if (dateRegex.test(str)) {\n            str += 'Z';\n        }\n        return Date.parse(str);\n    };\n    const parsers = {\n        /**\n         * Specifies the duration of the entire Media Presentation. Format is a duration string\n         * as specified in ISO 8601\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The duration in seconds\n         */\n        mediaPresentationDuration(value) {\n            return parseDuration(value);\n        },\n        /**\n         * Specifies the Segment availability start time for all Segments referred to in this\n         * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n         * time. Format is a date string as specified in ISO 8601\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The date as seconds from unix epoch\n         */\n        availabilityStartTime(value) {\n            return parseDate(value) / 1000;\n        },\n        /**\n         * Specifies the smallest period between potential changes to the MPD. Format is a\n         * duration string as specified in ISO 8601\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The duration in seconds\n         */\n        minimumUpdatePeriod(value) {\n            return parseDuration(value);\n        },\n        /**\n         * Specifies the suggested presentation delay. Format is a\n         * duration string as specified in ISO 8601\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The duration in seconds\n         */\n        suggestedPresentationDelay(value) {\n            return parseDuration(value);\n        },\n        /**\n         * specifices the type of mpd. Can be either \"static\" or \"dynamic\"\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         *\n         * @return {string}\n         *         The type as a string\n         */\n        type(value) {\n            return value;\n        },\n        /**\n         * Specifies the duration of the smallest time shifting buffer for any Representation\n         * in the MPD. Format is a duration string as specified in ISO 8601\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The duration in seconds\n         */\n        timeShiftBufferDepth(value) {\n            return parseDuration(value);\n        },\n        /**\n         * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n         * Format is a duration string as specified in ISO 8601\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The duration in seconds\n         */\n        start(value) {\n            return parseDuration(value);\n        },\n        /**\n         * Specifies the width of the visual presentation\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed width\n         */\n        width(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Specifies the height of the visual presentation\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed height\n         */\n        height(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Specifies the bitrate of the representation\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed bandwidth\n         */\n        bandwidth(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Specifies the frame rate of the representation\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed frame rate\n         */\n        frameRate(value) {\n            return parseDivisionValue(value);\n        },\n        /**\n         * Specifies the number of the first Media Segment in this Representation in the Period\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed number\n         */\n        startNumber(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Specifies the timescale in units per seconds\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed timescale\n         */\n        timescale(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Specifies the presentationTimeOffset.\n         *\n         * @param {string} value\n         *        value of the attribute as a string\n         *\n         * @return {number}\n         *         The parsed presentationTimeOffset\n         */\n        presentationTimeOffset(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Specifies the constant approximate Segment duration\n         * NOTE: The <Period> element also contains an @duration attribute. This duration\n         *       specifies the duration of the Period. This attribute is currently not\n         *       supported by the rest of the parser, however we still check for it to prevent\n         *       errors.\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed duration\n         */\n        duration(value) {\n            const parsedValue = parseInt(value, 10);\n            if (isNaN(parsedValue)) {\n                return parseDuration(value);\n            }\n            return parsedValue;\n        },\n        /**\n         * Specifies the Segment duration, in units of the value of the @timescale.\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed duration\n         */\n        d(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Specifies the MPD start time, in @timescale units, the first Segment in the series\n         * starts relative to the beginning of the Period\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed time\n         */\n        t(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Specifies the repeat count of the number of following contiguous Segments with the\n         * same duration expressed by the value of @d\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {number}\n         *         The parsed number\n         */\n        r(value) {\n            return parseInt(value, 10);\n        },\n        /**\n         * Default parser for all other attributes. Acts as a no-op and just returns the value\n         * as a string\n         *\n         * @param {string} value\n         *        value of attribute as a string\n         * @return {string}\n         *         Unparsed value\n         */\n        DEFAULT(value) {\n            return value;\n        }\n    };\n    /**\n     * Gets all the attributes and values of the provided node, parses attributes with known\n     * types, and returns an object with attribute names mapped to values.\n     *\n     * @param {Node} el\n     *        The node to parse attributes from\n     * @return {Object}\n     *         Object with all attributes of el parsed\n     */\n\n    const parseAttributes = el => {\n        if (!(el && el.attributes)) {\n            return {};\n        }\n        return from(el.attributes).reduce((a, e) => {\n            const parseFn = parsers[e.name] || parsers.DEFAULT;\n            a[e.name] = parseFn(e.value);\n            return a;\n        }, {});\n    };\n    const keySystemsMap = {\n        'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n        'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n        'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n        'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime'\n    };\n    /**\n     * Builds a list of urls that is the product of the reference urls and BaseURL values\n     *\n     * @param {string[]} referenceUrls\n     *        List of reference urls to resolve to\n     * @param {Node[]} baseUrlElements\n     *        List of BaseURL nodes from the mpd\n     * @return {string[]}\n     *         List of resolved urls\n     */\n\n    const buildBaseUrls = (referenceUrls, baseUrlElements) => {\n        if (!baseUrlElements.length) {\n            return referenceUrls;\n        }\n        return flatten(referenceUrls.map(function (reference) {\n            return baseUrlElements.map(function (baseUrlElement) {\n                return resolveUrl$1(reference, getContent(baseUrlElement));\n            });\n        }));\n    };\n    /**\n     * Contains all Segment information for its containing AdaptationSet\n     *\n     * @typedef {Object} SegmentInformation\n     * @property {Object|undefined} template\n     *           Contains the attributes for the SegmentTemplate node\n     * @property {Object[]|undefined} segmentTimeline\n     *           Contains a list of atrributes for each S node within the SegmentTimeline node\n     * @property {Object|undefined} list\n     *           Contains the attributes for the SegmentList node\n     * @property {Object|undefined} base\n     *           Contains the attributes for the SegmentBase node\n     */\n\n    /**\n     * Returns all available Segment information contained within the AdaptationSet node\n     *\n     * @param {Node} adaptationSet\n     *        The AdaptationSet node to get Segment information from\n     * @return {SegmentInformation}\n     *         The Segment information contained within the provided AdaptationSet\n     */\n\n    const getSegmentInformation = adaptationSet => {\n        const segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\n        const segmentList = findChildren(adaptationSet, 'SegmentList')[0];\n        const segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(s => merge$1({\n            tag: 'SegmentURL'\n        }, parseAttributes(s)));\n        const segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\n        const segmentTimelineParentNode = segmentList || segmentTemplate;\n        const segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\n        const segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n        const segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0]; // SegmentTemplate is handled slightly differently, since it can have both\n        // @initialization and an <Initialization> node.  @initialization can be templated,\n        // while the node can have a url and range specified.  If the <SegmentTemplate> has\n        // both @initialization and an <Initialization> subelement we opt to override with\n        // the node, as this interaction is not defined in the spec.\n\n        const template = segmentTemplate && parseAttributes(segmentTemplate);\n        if (template && segmentInitialization) {\n            template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n        } else if (template && template.initialization) {\n            // If it is @initialization we convert it to an object since this is the format that\n            // later functions will rely on for the initialization segment.  This is only valid\n            // for <SegmentTemplate>\n            template.initialization = {\n                sourceURL: template.initialization\n            };\n        }\n        const segmentInfo = {\n            template,\n            segmentTimeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(s => parseAttributes(s)),\n            list: segmentList && merge$1(parseAttributes(segmentList), {\n                segmentUrls,\n                initialization: parseAttributes(segmentInitialization)\n            }),\n            base: segmentBase && merge$1(parseAttributes(segmentBase), {\n                initialization: parseAttributes(segmentInitialization)\n            })\n        };\n        Object.keys(segmentInfo).forEach(key => {\n            if (!segmentInfo[key]) {\n                delete segmentInfo[key];\n            }\n        });\n        return segmentInfo;\n    };\n    /**\n     * Contains Segment information and attributes needed to construct a Playlist object\n     * from a Representation\n     *\n     * @typedef {Object} RepresentationInformation\n     * @property {SegmentInformation} segmentInfo\n     *           Segment information for this Representation\n     * @property {Object} attributes\n     *           Inherited attributes for this Representation\n     */\n\n    /**\n     * Maps a Representation node to an object containing Segment information and attributes\n     *\n     * @name inheritBaseUrlsCallback\n     * @function\n     * @param {Node} representation\n     *        Representation node from the mpd\n     * @return {RepresentationInformation}\n     *         Representation information needed to construct a Playlist object\n     */\n\n    /**\n     * Returns a callback for Array.prototype.map for mapping Representation nodes to\n     * Segment information and attributes using inherited BaseURL nodes.\n     *\n     * @param {Object} adaptationSetAttributes\n     *        Contains attributes inherited by the AdaptationSet\n     * @param {string[]} adaptationSetBaseUrls\n     *        Contains list of resolved base urls inherited by the AdaptationSet\n     * @param {SegmentInformation} adaptationSetSegmentInfo\n     *        Contains Segment information for the AdaptationSet\n     * @return {inheritBaseUrlsCallback}\n     *         Callback map function\n     */\n\n    const inheritBaseUrls = (adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) => representation => {\n        const repBaseUrlElements = findChildren(representation, 'BaseURL');\n        const repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n        const attributes = merge$1(adaptationSetAttributes, parseAttributes(representation));\n        const representationSegmentInfo = getSegmentInformation(representation);\n        return repBaseUrls.map(baseUrl => {\n            return {\n                segmentInfo: merge$1(adaptationSetSegmentInfo, representationSegmentInfo),\n                attributes: merge$1(attributes, {\n                    baseUrl\n                })\n            };\n        });\n    };\n    /**\n     * Tranforms a series of content protection nodes to\n     * an object containing pssh data by key system\n     *\n     * @param {Node[]} contentProtectionNodes\n     *        Content protection nodes\n     * @return {Object}\n     *        Object containing pssh data by key system\n     */\n\n    const generateKeySystemInformation = contentProtectionNodes => {\n        return contentProtectionNodes.reduce((acc, node) => {\n            const attributes = parseAttributes(node); // Although it could be argued that according to the UUID RFC spec the UUID string (a-f chars) should be generated\n            // as a lowercase string it also mentions it should be treated as case-insensitive on input. Since the key system\n            // UUIDs in the keySystemsMap are hardcoded as lowercase in the codebase there isn't any reason not to do\n            // .toLowerCase() on the input UUID string from the manifest (at least I could not think of one).\n\n            if (attributes.schemeIdUri) {\n                attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();\n            }\n            const keySystem = keySystemsMap[attributes.schemeIdUri];\n            if (keySystem) {\n                acc[keySystem] = {\n                    attributes\n                };\n                const psshNode = findChildren(node, 'cenc:pssh')[0];\n                if (psshNode) {\n                    const pssh = getContent(psshNode);\n                    acc[keySystem].pssh = pssh && decodeB64ToUint8Array(pssh);\n                }\n            }\n            return acc;\n        }, {});\n    }; // defined in ANSI_SCTE 214-1 2016\n\n    const parseCaptionServiceMetadata = service => {\n        // 608 captions\n        if (service.schemeIdUri === 'urn:scte:dash:cc:cea-608:2015') {\n            const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n            return values.map(value => {\n                let channel;\n                let language; // default language to value\n\n                language = value;\n                if (/^CC\\d=/.test(value)) {\n                    [channel, language] = value.split('=');\n                } else if (/^CC\\d$/.test(value)) {\n                    channel = value;\n                }\n                return {\n                    channel,\n                    language\n                };\n            });\n        } else if (service.schemeIdUri === 'urn:scte:dash:cc:cea-708:2015') {\n            const values = typeof service.value !== 'string' ? [] : service.value.split(';');\n            return values.map(value => {\n                const flags = {\n                    // service or channel number 1-63\n                    'channel': undefined,\n                    // language is a 3ALPHA per ISO 639.2/B\n                    // field is required\n                    'language': undefined,\n                    // BIT 1/0 or ?\n                    // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown\n                    'aspectRatio': 1,\n                    // BIT 1/0\n                    // easy reader flag indicated the text is tailed to the needs of beginning readers\n                    // default 0, or off\n                    'easyReader': 0,\n                    // BIT 1/0\n                    // If 3d metadata is present (CEA-708.1) then 1\n                    // default 0\n                    '3D': 0\n                };\n                if (/=/.test(value)) {\n                    const [channel, opts = ''] = value.split('=');\n                    flags.channel = channel;\n                    flags.language = value;\n                    opts.split(',').forEach(opt => {\n                        const [name, val] = opt.split(':');\n                        if (name === 'lang') {\n                            flags.language = val; // er for easyReadery\n                        } else if (name === 'er') {\n                            flags.easyReader = Number(val); // war for wide aspect ratio\n                        } else if (name === 'war') {\n                            flags.aspectRatio = Number(val);\n                        } else if (name === '3D') {\n                            flags['3D'] = Number(val);\n                        }\n                    });\n                } else {\n                    flags.language = value;\n                }\n                if (flags.channel) {\n                    flags.channel = 'SERVICE' + flags.channel;\n                }\n                return flags;\n            });\n        }\n    };\n    /**\n     * Maps an AdaptationSet node to a list of Representation information objects\n     *\n     * @name toRepresentationsCallback\n     * @function\n     * @param {Node} adaptationSet\n     *        AdaptationSet node from the mpd\n     * @return {RepresentationInformation[]}\n     *         List of objects containing Representaion information\n     */\n\n    /**\n     * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n     * Representation information objects\n     *\n     * @param {Object} periodAttributes\n     *        Contains attributes inherited by the Period\n     * @param {string[]} periodBaseUrls\n     *        Contains list of resolved base urls inherited by the Period\n     * @param {string[]} periodSegmentInfo\n     *        Contains Segment Information at the period level\n     * @return {toRepresentationsCallback}\n     *         Callback map function\n     */\n\n    const toRepresentations = (periodAttributes, periodBaseUrls, periodSegmentInfo) => adaptationSet => {\n        const adaptationSetAttributes = parseAttributes(adaptationSet);\n        const adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\n        const role = findChildren(adaptationSet, 'Role')[0];\n        const roleAttributes = {\n            role: parseAttributes(role)\n        };\n        let attrs = merge$1(periodAttributes, adaptationSetAttributes, roleAttributes);\n        const accessibility = findChildren(adaptationSet, 'Accessibility')[0];\n        const captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));\n        if (captionServices) {\n            attrs = merge$1(attrs, {\n                captionServices\n            });\n        }\n        const label = findChildren(adaptationSet, 'Label')[0];\n        if (label && label.childNodes.length) {\n            const labelVal = label.childNodes[0].nodeValue.trim();\n            attrs = merge$1(attrs, {\n                label: labelVal\n            });\n        }\n        const contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\n        if (Object.keys(contentProtection).length) {\n            attrs = merge$1(attrs, {\n                contentProtection\n            });\n        }\n        const segmentInfo = getSegmentInformation(adaptationSet);\n        const representations = findChildren(adaptationSet, 'Representation');\n        const adaptationSetSegmentInfo = merge$1(periodSegmentInfo, segmentInfo);\n        return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n    };\n    /**\n     * Contains all period information for mapping nodes onto adaptation sets.\n     *\n     * @typedef {Object} PeriodInformation\n     * @property {Node} period.node\n     *           Period node from the mpd\n     * @property {Object} period.attributes\n     *           Parsed period attributes from node plus any added\n     */\n\n    /**\n     * Maps a PeriodInformation object to a list of Representation information objects for all\n     * AdaptationSet nodes contained within the Period.\n     *\n     * @name toAdaptationSetsCallback\n     * @function\n     * @param {PeriodInformation} period\n     *        Period object containing necessary period information\n     * @param {number} periodStart\n     *        Start time of the Period within the mpd\n     * @return {RepresentationInformation[]}\n     *         List of objects containing Representaion information\n     */\n\n    /**\n     * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n     * Representation information objects\n     *\n     * @param {Object} mpdAttributes\n     *        Contains attributes inherited by the mpd\n     * @param {string[]} mpdBaseUrls\n     *        Contains list of resolved base urls inherited by the mpd\n     * @return {toAdaptationSetsCallback}\n     *         Callback map function\n     */\n\n    const toAdaptationSets = (mpdAttributes, mpdBaseUrls) => (period, index) => {\n        const periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, 'BaseURL'));\n        const periodAttributes = merge$1(mpdAttributes, {\n            periodStart: period.attributes.start\n        });\n        if (typeof period.attributes.duration === 'number') {\n            periodAttributes.periodDuration = period.attributes.duration;\n        }\n        const adaptationSets = findChildren(period.node, 'AdaptationSet');\n        const periodSegmentInfo = getSegmentInformation(period.node);\n        return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n    };\n    /**\n     * Gets Period@start property for a given period.\n     *\n     * @param {Object} options\n     *        Options object\n     * @param {Object} options.attributes\n     *        Period attributes\n     * @param {Object} [options.priorPeriodAttributes]\n     *        Prior period attributes (if prior period is available)\n     * @param {string} options.mpdType\n     *        The MPD@type these periods came from\n     * @return {number|null}\n     *         The period start, or null if it's an early available period or error\n     */\n\n    const getPeriodStart = ({\n                                attributes,\n                                priorPeriodAttributes,\n                                mpdType\n                            }) => {\n        // Summary of period start time calculation from DASH spec section 5.3.2.1\n        //\n        // A period's start is the first period's start + time elapsed after playing all\n        // prior periods to this one. Periods continue one after the other in time (without\n        // gaps) until the end of the presentation.\n        //\n        // The value of Period@start should be:\n        // 1. if Period@start is present: value of Period@start\n        // 2. if previous period exists and it has @duration: previous Period@start +\n        //    previous Period@duration\n        // 3. if this is first period and MPD@type is 'static': 0\n        // 4. in all other cases, consider the period an \"early available period\" (note: not\n        //    currently supported)\n        // (1)\n        if (typeof attributes.start === 'number') {\n            return attributes.start;\n        } // (2)\n\n        if (priorPeriodAttributes && typeof priorPeriodAttributes.start === 'number' && typeof priorPeriodAttributes.duration === 'number') {\n            return priorPeriodAttributes.start + priorPeriodAttributes.duration;\n        } // (3)\n\n        if (!priorPeriodAttributes && mpdType === 'static') {\n            return 0;\n        } // (4)\n        // There is currently no logic for calculating the Period@start value if there is\n        // no Period@start or prior Period@start and Period@duration available. This is not made\n        // explicit by the DASH interop guidelines or the DASH spec, however, since there's\n        // nothing about any other resolution strategies, it's implied. Thus, this case should\n        // be considered an early available period, or error, and null should suffice for both\n        // of those cases.\n\n        return null;\n    };\n    /**\n     * Traverses the mpd xml tree to generate a list of Representation information objects\n     * that have inherited attributes from parent nodes\n     *\n     * @param {Node} mpd\n     *        The root node of the mpd\n     * @param {Object} options\n     *        Available options for inheritAttributes\n     * @param {string} options.manifestUri\n     *        The uri source of the mpd\n     * @param {number} options.NOW\n     *        Current time per DASH IOP.  Default is current time in ms since epoch\n     * @param {number} options.clientOffset\n     *        Client time difference from NOW (in milliseconds)\n     * @return {RepresentationInformation[]}\n     *         List of objects containing Representation information\n     */\n\n    const inheritAttributes = (mpd, options = {}) => {\n        const {\n            manifestUri = '',\n            NOW = Date.now(),\n            clientOffset = 0\n        } = options;\n        const periodNodes = findChildren(mpd, 'Period');\n        if (!periodNodes.length) {\n            throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n        }\n        const locations = findChildren(mpd, 'Location');\n        const mpdAttributes = parseAttributes(mpd);\n        const mpdBaseUrls = buildBaseUrls([manifestUri], findChildren(mpd, 'BaseURL')); // See DASH spec section 5.3.1.2, Semantics of MPD element. Default type to 'static'.\n\n        mpdAttributes.type = mpdAttributes.type || 'static';\n        mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n        mpdAttributes.NOW = NOW;\n        mpdAttributes.clientOffset = clientOffset;\n        if (locations.length) {\n            mpdAttributes.locations = locations.map(getContent);\n        }\n        const periods = []; // Since toAdaptationSets acts on individual periods right now, the simplest approach to\n        // adding properties that require looking at prior periods is to parse attributes and add\n        // missing ones before toAdaptationSets is called. If more such properties are added, it\n        // may be better to refactor toAdaptationSets.\n\n        periodNodes.forEach((node, index) => {\n            const attributes = parseAttributes(node); // Use the last modified prior period, as it may contain added information necessary\n            // for this period.\n\n            const priorPeriod = periods[index - 1];\n            attributes.start = getPeriodStart({\n                attributes,\n                priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,\n                mpdType: mpdAttributes.type\n            });\n            periods.push({\n                node,\n                attributes\n            });\n        });\n        return {\n            locations: mpdAttributes.locations,\n            representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)))\n        };\n    };\n    const stringToMpdXml = manifestString => {\n        if (manifestString === '') {\n            throw new Error(errors.DASH_EMPTY_MANIFEST);\n        }\n        const parser = new DOMParser();\n        let xml;\n        let mpd;\n        try {\n            xml = parser.parseFromString(manifestString, 'application/xml');\n            mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\n        } catch (e) {// ie 11 throwsw on invalid xml\n        }\n        if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\n            throw new Error(errors.DASH_INVALID_XML);\n        }\n        return mpd;\n    };\n\n    /**\n     * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n     *\n     * @param {string} mpd\n     *        XML string of the MPD manifest\n     * @return {Object|null}\n     *         Attributes of UTCTiming node specified in the manifest. Null if none found\n     */\n\n    const parseUTCTimingScheme = mpd => {\n        const UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\n        if (!UTCTimingNode) {\n            return null;\n        }\n        const attributes = parseAttributes(UTCTimingNode);\n        switch (attributes.schemeIdUri) {\n            case 'urn:mpeg:dash:utc:http-head:2014':\n            case 'urn:mpeg:dash:utc:http-head:2012':\n                attributes.method = 'HEAD';\n                break;\n            case 'urn:mpeg:dash:utc:http-xsdate:2014':\n            case 'urn:mpeg:dash:utc:http-iso:2014':\n            case 'urn:mpeg:dash:utc:http-xsdate:2012':\n            case 'urn:mpeg:dash:utc:http-iso:2012':\n                attributes.method = 'GET';\n                break;\n            case 'urn:mpeg:dash:utc:direct:2014':\n            case 'urn:mpeg:dash:utc:direct:2012':\n                attributes.method = 'DIRECT';\n                attributes.value = Date.parse(attributes.value);\n                break;\n            case 'urn:mpeg:dash:utc:http-ntp:2014':\n            case 'urn:mpeg:dash:utc:ntp:2014':\n            case 'urn:mpeg:dash:utc:sntp:2014':\n            default:\n                throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n        }\n        return attributes;\n    };\n    /*\n   * Given a DASH manifest string and options, parses the DASH manifest into an object in the\n   * form outputed by m3u8-parser and accepted by videojs/http-streaming.\n   *\n   * For live DASH manifests, if `previousManifest` is provided in options, then the newly\n   * parsed DASH manifest will have its media sequence and discontinuity sequence values\n   * updated to reflect its position relative to the prior manifest.\n   *\n   * @param {string} manifestString - the DASH manifest as a string\n   * @param {options} [options] - any options\n   *\n   * @return {Object} the manifest object\n   */\n\n    const parse = (manifestString, options = {}) => {\n        const parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);\n        const playlists = toPlaylists(parsedManifestInfo.representationInfo);\n        return toM3u8({\n            dashPlaylists: playlists,\n            locations: parsedManifestInfo.locations,\n            sidxMapping: options.sidxMapping,\n            previousManifest: options.previousManifest\n        });\n    };\n    /**\n     * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n     *\n     * @param {string} manifestString\n     *        XML string of the MPD manifest\n     * @return {Object|null}\n     *         Attributes of UTCTiming node specified in the manifest. Null if none found\n     */\n\n    const parseUTCTiming = manifestString => parseUTCTimingScheme(stringToMpdXml(manifestString));\n\n    var MAX_UINT32 = Math.pow(2, 32);\n    var getUint64$1 = function (uint8) {\n        var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);\n        var value;\n        if (dv.getBigUint64) {\n            value = dv.getBigUint64(0);\n            if (value < Number.MAX_SAFE_INTEGER) {\n                return Number(value);\n            }\n            return value;\n        }\n        return dv.getUint32(0) * MAX_UINT32 + dv.getUint32(4);\n    };\n    var numbers = {\n        getUint64: getUint64$1,\n        MAX_UINT32: MAX_UINT32\n    };\n\n    var getUint64 = numbers.getUint64;\n    var parseSidx = function (data) {\n        var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n            result = {\n                version: data[0],\n                flags: new Uint8Array(data.subarray(1, 4)),\n                references: [],\n                referenceId: view.getUint32(4),\n                timescale: view.getUint32(8)\n            },\n            i = 12;\n        if (result.version === 0) {\n            result.earliestPresentationTime = view.getUint32(i);\n            result.firstOffset = view.getUint32(i + 4);\n            i += 8;\n        } else {\n            // read 64 bits\n            result.earliestPresentationTime = getUint64(data.subarray(i));\n            result.firstOffset = getUint64(data.subarray(i + 8));\n            i += 16;\n        }\n        i += 2; // reserved\n\n        var referenceCount = view.getUint16(i);\n        i += 2; // start of references\n\n        for (; referenceCount > 0; i += 12, referenceCount--) {\n            result.references.push({\n                referenceType: (data[i] & 0x80) >>> 7,\n                referencedSize: view.getUint32(i) & 0x7FFFFFFF,\n                subsegmentDuration: view.getUint32(i + 4),\n                startsWithSap: !!(data[i + 8] & 0x80),\n                sapType: (data[i + 8] & 0x70) >>> 4,\n                sapDeltaTime: view.getUint32(i + 8) & 0x0FFFFFFF\n            });\n        }\n        return result;\n    };\n    var parseSidx_1 = parseSidx;\n\n    var ID3 = toUint8([0x49, 0x44, 0x33]);\n    var getId3Size = function getId3Size(bytes, offset) {\n        if (offset === void 0) {\n            offset = 0;\n        }\n        bytes = toUint8(bytes);\n        var flags = bytes[offset + 5];\n        var returnSize = bytes[offset + 6] << 21 | bytes[offset + 7] << 14 | bytes[offset + 8] << 7 | bytes[offset + 9];\n        var footerPresent = (flags & 16) >> 4;\n        if (footerPresent) {\n            return returnSize + 20;\n        }\n        return returnSize + 10;\n    };\n    var getId3Offset = function getId3Offset(bytes, offset) {\n        if (offset === void 0) {\n            offset = 0;\n        }\n        bytes = toUint8(bytes);\n        if (bytes.length - offset < 10 || !bytesMatch(bytes, ID3, {\n            offset: offset\n        })) {\n            return offset;\n        }\n        offset += getId3Size(bytes, offset); // recursive check for id3 tags as some files\n        // have multiple ID3 tag sections even though\n        // they should not.\n\n        return getId3Offset(bytes, offset);\n    };\n\n    var normalizePath$1 = function normalizePath(path) {\n        if (typeof path === 'string') {\n            return stringToBytes(path);\n        }\n        if (typeof path === 'number') {\n            return path;\n        }\n        return path;\n    };\n    var normalizePaths$1 = function normalizePaths(paths) {\n        if (!Array.isArray(paths)) {\n            return [normalizePath$1(paths)];\n        }\n        return paths.map(function (p) {\n            return normalizePath$1(p);\n        });\n    };\n    /**\n     * find any number of boxes by name given a path to it in an iso bmff\n     * such as mp4.\n     *\n     * @param {TypedArray} bytes\n     *        bytes for the iso bmff to search for boxes in\n     *\n     * @param {Uint8Array[]|string[]|string|Uint8Array} name\n     *        An array of paths or a single path representing the name\n     *        of boxes to search through in bytes. Paths may be\n     *        uint8 (character codes) or strings.\n     *\n     * @param {boolean} [complete=false]\n     *        Should we search only for complete boxes on the final path.\n     *        This is very useful when you do not want to get back partial boxes\n     *        in the case of streaming files.\n     *\n     * @return {Uint8Array[]}\n     *         An array of the end paths that we found.\n     */\n\n    var findBox = function findBox(bytes, paths, complete) {\n        if (complete === void 0) {\n            complete = false;\n        }\n        paths = normalizePaths$1(paths);\n        bytes = toUint8(bytes);\n        var results = [];\n        if (!paths.length) {\n            // short-circuit the search for empty paths\n            return results;\n        }\n        var i = 0;\n        while (i < bytes.length) {\n            var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;\n            var type = bytes.subarray(i + 4, i + 8); // invalid box format.\n\n            if (size === 0) {\n                break;\n            }\n            var end = i + size;\n            if (end > bytes.length) {\n                // this box is bigger than the number of bytes we have\n                // and complete is set, we cannot find any more boxes.\n                if (complete) {\n                    break;\n                }\n                end = bytes.length;\n            }\n            var data = bytes.subarray(i + 8, end);\n            if (bytesMatch(type, paths[0])) {\n                if (paths.length === 1) {\n                    // this is the end of the path and we've found the box we were\n                    // looking for\n                    results.push(data);\n                } else {\n                    // recursively search for the next box along the path\n                    results.push.apply(results, findBox(data, paths.slice(1), complete));\n                }\n            }\n            i = end;\n        } // we've finished searching all of bytes\n\n        return results;\n    };\n\n    // https://matroska-org.github.io/libebml/specs.html\n    // https://www.matroska.org/technical/elements.html\n    // https://www.webmproject.org/docs/container/\n\n    var EBML_TAGS = {\n        EBML: toUint8([0x1A, 0x45, 0xDF, 0xA3]),\n        DocType: toUint8([0x42, 0x82]),\n        Segment: toUint8([0x18, 0x53, 0x80, 0x67]),\n        SegmentInfo: toUint8([0x15, 0x49, 0xA9, 0x66]),\n        Tracks: toUint8([0x16, 0x54, 0xAE, 0x6B]),\n        Track: toUint8([0xAE]),\n        TrackNumber: toUint8([0xd7]),\n        DefaultDuration: toUint8([0x23, 0xe3, 0x83]),\n        TrackEntry: toUint8([0xAE]),\n        TrackType: toUint8([0x83]),\n        FlagDefault: toUint8([0x88]),\n        CodecID: toUint8([0x86]),\n        CodecPrivate: toUint8([0x63, 0xA2]),\n        VideoTrack: toUint8([0xe0]),\n        AudioTrack: toUint8([0xe1]),\n        // Not used yet, but will be used for live webm/mkv\n        // see https://www.matroska.org/technical/basics.html#block-structure\n        // see https://www.matroska.org/technical/basics.html#simpleblock-structure\n        Cluster: toUint8([0x1F, 0x43, 0xB6, 0x75]),\n        Timestamp: toUint8([0xE7]),\n        TimestampScale: toUint8([0x2A, 0xD7, 0xB1]),\n        BlockGroup: toUint8([0xA0]),\n        BlockDuration: toUint8([0x9B]),\n        Block: toUint8([0xA1]),\n        SimpleBlock: toUint8([0xA3])\n    };\n    /**\n     * This is a simple table to determine the length\n     * of things in ebml. The length is one based (starts at 1,\n     * rather than zero) and for every zero bit before a one bit\n     * we add one to length. We also need this table because in some\n     * case we have to xor all the length bits from another value.\n     */\n\n    var LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];\n    var getLength = function getLength(byte) {\n        var len = 1;\n        for (var i = 0; i < LENGTH_TABLE.length; i++) {\n            if (byte & LENGTH_TABLE[i]) {\n                break;\n            }\n            len++;\n        }\n        return len;\n    }; // length in ebml is stored in the first 4 to 8 bits\n    // of the first byte. 4 for the id length and 8 for the\n    // data size length. Length is measured by converting the number to binary\n    // then 1 + the number of zeros before a 1 is encountered starting\n    // from the left.\n\n    var getvint = function getvint(bytes, offset, removeLength, signed) {\n        if (removeLength === void 0) {\n            removeLength = true;\n        }\n        if (signed === void 0) {\n            signed = false;\n        }\n        var length = getLength(bytes[offset]);\n        var valueBytes = bytes.subarray(offset, offset + length); // NOTE that we do **not** subarray here because we need to copy these bytes\n        // as they will be modified below to remove the dataSizeLen bits and we do not\n        // want to modify the original data. normally we could just call slice on\n        // uint8array but ie 11 does not support that...\n\n        if (removeLength) {\n            valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);\n            valueBytes[0] ^= LENGTH_TABLE[length - 1];\n        }\n        return {\n            length: length,\n            value: bytesToNumber(valueBytes, {\n                signed: signed\n            }),\n            bytes: valueBytes\n        };\n    };\n    var normalizePath = function normalizePath(path) {\n        if (typeof path === 'string') {\n            return path.match(/.{1,2}/g).map(function (p) {\n                return normalizePath(p);\n            });\n        }\n        if (typeof path === 'number') {\n            return numberToBytes(path);\n        }\n        return path;\n    };\n    var normalizePaths = function normalizePaths(paths) {\n        if (!Array.isArray(paths)) {\n            return [normalizePath(paths)];\n        }\n        return paths.map(function (p) {\n            return normalizePath(p);\n        });\n    };\n    var getInfinityDataSize = function getInfinityDataSize(id, bytes, offset) {\n        if (offset >= bytes.length) {\n            return bytes.length;\n        }\n        var innerid = getvint(bytes, offset, false);\n        if (bytesMatch(id.bytes, innerid.bytes)) {\n            return offset;\n        }\n        var dataHeader = getvint(bytes, offset + innerid.length);\n        return getInfinityDataSize(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);\n    };\n    /**\n     * Notes on the EBLM format.\n     *\n     * EBLM uses \"vints\" tags. Every vint tag contains\n     * two parts\n     *\n     * 1. The length from the first byte. You get this by\n     *    converting the byte to binary and counting the zeros\n     *    before a 1. Then you add 1 to that. Examples\n     *    00011111 = length 4 because there are 3 zeros before a 1.\n     *    00100000 = length 3 because there are 2 zeros before a 1.\n     *    00000011 = length 7 because there are 6 zeros before a 1.\n     *\n     * 2. The bits used for length are removed from the first byte\n     *    Then all the bytes are merged into a value. NOTE: this\n     *    is not the case for id ebml tags as there id includes\n     *    length bits.\n     *\n     */\n\n    var findEbml = function findEbml(bytes, paths) {\n        paths = normalizePaths(paths);\n        bytes = toUint8(bytes);\n        var results = [];\n        if (!paths.length) {\n            return results;\n        }\n        var i = 0;\n        while (i < bytes.length) {\n            var id = getvint(bytes, i, false);\n            var dataHeader = getvint(bytes, i + id.length);\n            var dataStart = i + id.length + dataHeader.length; // dataSize is unknown or this is a live stream\n\n            if (dataHeader.value === 0x7f) {\n                dataHeader.value = getInfinityDataSize(id, bytes, dataStart);\n                if (dataHeader.value !== bytes.length) {\n                    dataHeader.value -= dataStart;\n                }\n            }\n            var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;\n            var data = bytes.subarray(dataStart, dataEnd);\n            if (bytesMatch(paths[0], id.bytes)) {\n                if (paths.length === 1) {\n                    // this is the end of the paths and we've found the tag we were\n                    // looking for\n                    results.push(data);\n                } else {\n                    // recursively search for the next tag inside of the data\n                    // of this one\n                    results = results.concat(findEbml(data, paths.slice(1)));\n                }\n            }\n            var totalLength = id.length + dataHeader.length + data.length; // move past this tag entirely, we are not looking for it\n\n            i += totalLength;\n        }\n        return results;\n    }; // see https://www.matroska.org/technical/basics.html#block-structure\n\n    var NAL_TYPE_ONE = toUint8([0x00, 0x00, 0x00, 0x01]);\n    var NAL_TYPE_TWO = toUint8([0x00, 0x00, 0x01]);\n    var EMULATION_PREVENTION = toUint8([0x00, 0x00, 0x03]);\n    /**\n     * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n     * Sequence Payload\"\n     *\n     * @param data {Uint8Array} the bytes of a RBSP from a NAL\n     * unit\n     * @return {Uint8Array} the RBSP without any Emulation\n     * Prevention Bytes\n     */\n\n    var discardEmulationPreventionBytes = function discardEmulationPreventionBytes(bytes) {\n        var positions = [];\n        var i = 1; // Find all `Emulation Prevention Bytes`\n\n        while (i < bytes.length - 2) {\n            if (bytesMatch(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {\n                positions.push(i + 2);\n                i++;\n            }\n            i++;\n        } // If no Emulation Prevention Bytes were found just return the original\n        // array\n\n        if (positions.length === 0) {\n            return bytes;\n        } // Create a new array to hold the NAL unit data\n\n        var newLength = bytes.length - positions.length;\n        var newData = new Uint8Array(newLength);\n        var sourceIndex = 0;\n        for (i = 0; i < newLength; sourceIndex++, i++) {\n            if (sourceIndex === positions[0]) {\n                // Skip this byte\n                sourceIndex++; // Remove this position index\n\n                positions.shift();\n            }\n            newData[i] = bytes[sourceIndex];\n        }\n        return newData;\n    };\n    var findNal = function findNal(bytes, dataType, types, nalLimit) {\n        if (nalLimit === void 0) {\n            nalLimit = Infinity;\n        }\n        bytes = toUint8(bytes);\n        types = [].concat(types);\n        var i = 0;\n        var nalStart;\n        var nalsFound = 0; // keep searching until:\n        // we reach the end of bytes\n        // we reach the maximum number of nals they want to seach\n        // NOTE: that we disregard nalLimit when we have found the start\n        // of the nal we want so that we can find the end of the nal we want.\n\n        while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {\n            var nalOffset = void 0;\n            if (bytesMatch(bytes.subarray(i), NAL_TYPE_ONE)) {\n                nalOffset = 4;\n            } else if (bytesMatch(bytes.subarray(i), NAL_TYPE_TWO)) {\n                nalOffset = 3;\n            } // we are unsynced,\n            // find the next nal unit\n\n            if (!nalOffset) {\n                i++;\n                continue;\n            }\n            nalsFound++;\n            if (nalStart) {\n                return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));\n            }\n            var nalType = void 0;\n            if (dataType === 'h264') {\n                nalType = bytes[i + nalOffset] & 0x1f;\n            } else if (dataType === 'h265') {\n                nalType = bytes[i + nalOffset] >> 1 & 0x3f;\n            }\n            if (types.indexOf(nalType) !== -1) {\n                nalStart = i + nalOffset;\n            } // nal header is 1 length for h264, and 2 for h265\n\n            i += nalOffset + (dataType === 'h264' ? 1 : 2);\n        }\n        return bytes.subarray(0, 0);\n    };\n    var findH264Nal = function findH264Nal(bytes, type, nalLimit) {\n        return findNal(bytes, 'h264', type, nalLimit);\n    };\n    var findH265Nal = function findH265Nal(bytes, type, nalLimit) {\n        return findNal(bytes, 'h265', type, nalLimit);\n    };\n\n    var CONSTANTS = {\n        // \"webm\" string literal in hex\n        'webm': toUint8([0x77, 0x65, 0x62, 0x6d]),\n        // \"matroska\" string literal in hex\n        'matroska': toUint8([0x6d, 0x61, 0x74, 0x72, 0x6f, 0x73, 0x6b, 0x61]),\n        // \"fLaC\" string literal in hex\n        'flac': toUint8([0x66, 0x4c, 0x61, 0x43]),\n        // \"OggS\" string literal in hex\n        'ogg': toUint8([0x4f, 0x67, 0x67, 0x53]),\n        // ac-3 sync byte, also works for ec-3 as that is simply a codec\n        // of ac-3\n        'ac3': toUint8([0x0b, 0x77]),\n        // \"RIFF\" string literal in hex used for wav and avi\n        'riff': toUint8([0x52, 0x49, 0x46, 0x46]),\n        // \"AVI\" string literal in hex\n        'avi': toUint8([0x41, 0x56, 0x49]),\n        // \"WAVE\" string literal in hex\n        'wav': toUint8([0x57, 0x41, 0x56, 0x45]),\n        // \"ftyp3g\" string literal in hex\n        '3gp': toUint8([0x66, 0x74, 0x79, 0x70, 0x33, 0x67]),\n        // \"ftyp\" string literal in hex\n        'mp4': toUint8([0x66, 0x74, 0x79, 0x70]),\n        // \"styp\" string literal in hex\n        'fmp4': toUint8([0x73, 0x74, 0x79, 0x70]),\n        // \"ftypqt\" string literal in hex\n        'mov': toUint8([0x66, 0x74, 0x79, 0x70, 0x71, 0x74]),\n        // moov string literal in hex\n        'moov': toUint8([0x6D, 0x6F, 0x6F, 0x76]),\n        // moof string literal in hex\n        'moof': toUint8([0x6D, 0x6F, 0x6F, 0x66])\n    };\n    var _isLikely = {\n        aac: function aac(bytes) {\n            var offset = getId3Offset(bytes);\n            return bytesMatch(bytes, [0xFF, 0x10], {\n                offset: offset,\n                mask: [0xFF, 0x16]\n            });\n        },\n        mp3: function mp3(bytes) {\n            var offset = getId3Offset(bytes);\n            return bytesMatch(bytes, [0xFF, 0x02], {\n                offset: offset,\n                mask: [0xFF, 0x06]\n            });\n        },\n        webm: function webm(bytes) {\n            var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is webm\n\n            return bytesMatch(docType, CONSTANTS.webm);\n        },\n        mkv: function mkv(bytes) {\n            var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0]; // check if DocType EBML tag is matroska\n\n            return bytesMatch(docType, CONSTANTS.matroska);\n        },\n        mp4: function mp4(bytes) {\n            // if this file is another base media file format, it is not mp4\n            if (_isLikely['3gp'](bytes) || _isLikely.mov(bytes)) {\n                return false;\n            } // if this file starts with a ftyp or styp box its mp4\n\n            if (bytesMatch(bytes, CONSTANTS.mp4, {\n                offset: 4\n            }) || bytesMatch(bytes, CONSTANTS.fmp4, {\n                offset: 4\n            })) {\n                return true;\n            } // if this file starts with a moof/moov box its mp4\n\n            if (bytesMatch(bytes, CONSTANTS.moof, {\n                offset: 4\n            }) || bytesMatch(bytes, CONSTANTS.moov, {\n                offset: 4\n            })) {\n                return true;\n            }\n        },\n        mov: function mov(bytes) {\n            return bytesMatch(bytes, CONSTANTS.mov, {\n                offset: 4\n            });\n        },\n        '3gp': function gp(bytes) {\n            return bytesMatch(bytes, CONSTANTS['3gp'], {\n                offset: 4\n            });\n        },\n        ac3: function ac3(bytes) {\n            var offset = getId3Offset(bytes);\n            return bytesMatch(bytes, CONSTANTS.ac3, {\n                offset: offset\n            });\n        },\n        ts: function ts(bytes) {\n            if (bytes.length < 189 && bytes.length >= 1) {\n                return bytes[0] === 0x47;\n            }\n            var i = 0; // check the first 376 bytes for two matching sync bytes\n\n            while (i + 188 < bytes.length && i < 188) {\n                if (bytes[i] === 0x47 && bytes[i + 188] === 0x47) {\n                    return true;\n                }\n                i += 1;\n            }\n            return false;\n        },\n        flac: function flac(bytes) {\n            var offset = getId3Offset(bytes);\n            return bytesMatch(bytes, CONSTANTS.flac, {\n                offset: offset\n            });\n        },\n        ogg: function ogg(bytes) {\n            return bytesMatch(bytes, CONSTANTS.ogg);\n        },\n        avi: function avi(bytes) {\n            return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.avi, {\n                offset: 8\n            });\n        },\n        wav: function wav(bytes) {\n            return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.wav, {\n                offset: 8\n            });\n        },\n        'h264': function h264(bytes) {\n            // find seq_parameter_set_rbsp\n            return findH264Nal(bytes, 7, 3).length;\n        },\n        'h265': function h265(bytes) {\n            // find video_parameter_set_rbsp or seq_parameter_set_rbsp\n            return findH265Nal(bytes, [32, 33], 3).length;\n        }\n    }; // get all the isLikely functions\n    // but make sure 'ts' is above h264 and h265\n    // but below everything else as it is the least specific\n\n    var isLikelyTypes = Object.keys(_isLikely) // remove ts, h264, h265\n        .filter(function (t) {\n            return t !== 'ts' && t !== 'h264' && t !== 'h265';\n        }) // add it back to the bottom\n        .concat(['ts', 'h264', 'h265']); // make sure we are dealing with uint8 data.\n\n    isLikelyTypes.forEach(function (type) {\n        var isLikelyFn = _isLikely[type];\n        _isLikely[type] = function (bytes) {\n            return isLikelyFn(toUint8(bytes));\n        };\n    }); // export after wrapping\n\n    var isLikely = _isLikely; // A useful list of file signatures can be found here\n    // https://en.wikipedia.org/wiki/List_of_file_signatures\n\n    var detectContainerForBytes = function detectContainerForBytes(bytes) {\n        bytes = toUint8(bytes);\n        for (var i = 0; i < isLikelyTypes.length; i++) {\n            var type = isLikelyTypes[i];\n            if (isLikely[type](bytes)) {\n                return type;\n            }\n        }\n        return '';\n    }; // fmp4 is not a container\n\n    var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment(bytes) {\n        return findBox(bytes, ['moof']).length > 0;\n    };\n\n    /**\n     * mux.js\n     *\n     * Copyright (c) Brightcove\n     * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n     */\n    var ONE_SECOND_IN_TS = 90000,\n        // 90kHz clock\n        secondsToVideoTs,\n        secondsToAudioTs,\n        videoTsToSeconds,\n        audioTsToSeconds,\n        audioTsToVideoTs,\n        videoTsToAudioTs,\n        metadataTsToSeconds;\n    secondsToVideoTs = function (seconds) {\n        return seconds * ONE_SECOND_IN_TS;\n    };\n    secondsToAudioTs = function (seconds, sampleRate) {\n        return seconds * sampleRate;\n    };\n    videoTsToSeconds = function (timestamp) {\n        return timestamp / ONE_SECOND_IN_TS;\n    };\n    audioTsToSeconds = function (timestamp, sampleRate) {\n        return timestamp / sampleRate;\n    };\n    audioTsToVideoTs = function (timestamp, sampleRate) {\n        return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\n    };\n    videoTsToAudioTs = function (timestamp, sampleRate) {\n        return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\n    };\n\n    /**\n     * Adjust ID3 tag or caption timing information by the timeline pts values\n     * (if keepOriginalTimestamps is false) and convert to seconds\n     */\n    metadataTsToSeconds = function (timestamp, timelineStartPts, keepOriginalTimestamps) {\n        return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);\n    };\n    var clock = {\n        ONE_SECOND_IN_TS: ONE_SECOND_IN_TS,\n        secondsToVideoTs: secondsToVideoTs,\n        secondsToAudioTs: secondsToAudioTs,\n        videoTsToSeconds: videoTsToSeconds,\n        audioTsToSeconds: audioTsToSeconds,\n        audioTsToVideoTs: audioTsToVideoTs,\n        videoTsToAudioTs: videoTsToAudioTs,\n        metadataTsToSeconds: metadataTsToSeconds\n    };\n    var clock_1 = clock.ONE_SECOND_IN_TS;\n\n    /*! @name @videojs/http-streaming @version 3.0.2 @license Apache-2.0 */\n\n    /**\n     * @file resolve-url.js - Handling how URLs are resolved and manipulated\n     */\n    const resolveUrl = resolveUrl$2;\n    /**\n     * If the xhr request was redirected, return the responseURL, otherwise,\n     * return the original url.\n     *\n     * @api private\n     *\n     * @param  {string} url - an url being requested\n     * @param  {XMLHttpRequest} req - xhr request result\n     *\n     * @return {string}\n     */\n\n    const resolveManifestRedirect = (url, req) => {\n        // To understand how the responseURL below is set and generated:\n        // - https://fetch.spec.whatwg.org/#concept-response-url\n        // - https://fetch.spec.whatwg.org/#atomic-http-redirect-handling\n        if (req && req.responseURL && url !== req.responseURL) {\n            return req.responseURL;\n        }\n        return url;\n    };\n    const logger = source => {\n        if (videojs.log.debug) {\n            return videojs.log.debug.bind(videojs, 'VHS:', `${source} >`);\n        }\n        return function () {};\n    };\n\n    /**\n     * Provides a compatibility layer between Video.js 7 and 8 API changes for VHS.\n     */\n    /**\n     * Delegates to videojs.obj.merge (Video.js 8) or\n     * videojs.mergeOptions (Video.js 7).\n     */\n\n    function merge(...args) {\n        const context = videojs.obj || videojs;\n        const fn = context.merge || context.mergeOptions;\n        return fn.apply(context, args);\n    }\n    /**\n     * Delegates to videojs.time.createTimeRanges (Video.js 8) or\n     * videojs.createTimeRanges (Video.js 7).\n     */\n\n    function createTimeRanges(...args) {\n        const context = videojs.time || videojs;\n        const fn = context.createTimeRanges || context.createTimeRanges;\n        return fn.apply(context, args);\n    }\n\n    /**\n     * ranges\n     *\n     * Utilities for working with TimeRanges.\n     *\n     */\n\n    const TIME_FUDGE_FACTOR = 1 / 30; // Comparisons between time values such as current time and the end of the buffered range\n    // can be misleading because of precision differences or when the current media has poorly\n    // aligned audio and video, which can cause values to be slightly off from what you would\n    // expect. This value is what we consider to be safe to use in such comparisons to account\n    // for these scenarios.\n\n    const SAFE_TIME_DELTA = TIME_FUDGE_FACTOR * 3;\n    const filterRanges = function (timeRanges, predicate) {\n        const results = [];\n        let i;\n        if (timeRanges && timeRanges.length) {\n            // Search for ranges that match the predicate\n            for (i = 0; i < timeRanges.length; i++) {\n                if (predicate(timeRanges.start(i), timeRanges.end(i))) {\n                    results.push([timeRanges.start(i), timeRanges.end(i)]);\n                }\n            }\n        }\n        return createTimeRanges(results);\n    };\n    /**\n     * Attempts to find the buffered TimeRange that contains the specified\n     * time.\n     *\n     * @param {TimeRanges} buffered - the TimeRanges object to query\n     * @param {number} time  - the time to filter on.\n     * @return {TimeRanges} a new TimeRanges object\n     */\n\n    const findRange = function (buffered, time) {\n        return filterRanges(buffered, function (start, end) {\n            return start - SAFE_TIME_DELTA <= time && end + SAFE_TIME_DELTA >= time;\n        });\n    };\n    /**\n     * Returns the TimeRanges that begin later than the specified time.\n     *\n     * @param {TimeRanges} timeRanges - the TimeRanges object to query\n     * @param {number} time - the time to filter on.\n     * @return {TimeRanges} a new TimeRanges object.\n     */\n\n    const findNextRange = function (timeRanges, time) {\n        return filterRanges(timeRanges, function (start) {\n            return start - TIME_FUDGE_FACTOR >= time;\n        });\n    };\n    /**\n     * Returns gaps within a list of TimeRanges\n     *\n     * @param {TimeRanges} buffered - the TimeRanges object\n     * @return {TimeRanges} a TimeRanges object of gaps\n     */\n\n    const findGaps = function (buffered) {\n        if (buffered.length < 2) {\n            return createTimeRanges();\n        }\n        const ranges = [];\n        for (let i = 1; i < buffered.length; i++) {\n            const start = buffered.end(i - 1);\n            const end = buffered.start(i);\n            ranges.push([start, end]);\n        }\n        return createTimeRanges(ranges);\n    };\n    /**\n     * Calculate the intersection of two TimeRanges\n     *\n     * @param {TimeRanges} bufferA\n     * @param {TimeRanges} bufferB\n     * @return {TimeRanges} The interesection of `bufferA` with `bufferB`\n     */\n\n    const bufferIntersection = function (bufferA, bufferB) {\n        let start = null;\n        let end = null;\n        let arity = 0;\n        const extents = [];\n        const ranges = [];\n        if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) {\n            return createTimeRanges();\n        } // Handle the case where we have both buffers and create an\n        // intersection of the two\n\n        let count = bufferA.length; // A) Gather up all start and end times\n\n        while (count--) {\n            extents.push({\n                time: bufferA.start(count),\n                type: 'start'\n            });\n            extents.push({\n                time: bufferA.end(count),\n                type: 'end'\n            });\n        }\n        count = bufferB.length;\n        while (count--) {\n            extents.push({\n                time: bufferB.start(count),\n                type: 'start'\n            });\n            extents.push({\n                time: bufferB.end(count),\n                type: 'end'\n            });\n        } // B) Sort them by time\n\n        extents.sort(function (a, b) {\n            return a.time - b.time;\n        }); // C) Go along one by one incrementing arity for start and decrementing\n        //    arity for ends\n\n        for (count = 0; count < extents.length; count++) {\n            if (extents[count].type === 'start') {\n                arity++; // D) If arity is ever incremented to 2 we are entering an\n                //    overlapping range\n\n                if (arity === 2) {\n                    start = extents[count].time;\n                }\n            } else if (extents[count].type === 'end') {\n                arity--; // E) If arity is ever decremented to 1 we leaving an\n                //    overlapping range\n\n                if (arity === 1) {\n                    end = extents[count].time;\n                }\n            } // F) Record overlapping ranges\n\n            if (start !== null && end !== null) {\n                ranges.push([start, end]);\n                start = null;\n                end = null;\n            }\n        }\n        return createTimeRanges(ranges);\n    };\n    /**\n     * Gets a human readable string for a TimeRange\n     *\n     * @param {TimeRange} range\n     * @return {string} a human readable string\n     */\n\n    const printableRange = range => {\n        const strArr = [];\n        if (!range || !range.length) {\n            return '';\n        }\n        for (let i = 0; i < range.length; i++) {\n            strArr.push(range.start(i) + ' => ' + range.end(i));\n        }\n        return strArr.join(', ');\n    };\n    /**\n     * Calculates the amount of time left in seconds until the player hits the end of the\n     * buffer and causes a rebuffer\n     *\n     * @param {TimeRange} buffered\n     *        The state of the buffer\n     * @param {Numnber} currentTime\n     *        The current time of the player\n     * @param {number} playbackRate\n     *        The current playback rate of the player. Defaults to 1.\n     * @return {number}\n     *         Time until the player has to start rebuffering in seconds.\n     * @function timeUntilRebuffer\n     */\n\n    const timeUntilRebuffer = function (buffered, currentTime, playbackRate = 1) {\n        const bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;\n        return (bufferedEnd - currentTime) / playbackRate;\n    };\n    /**\n     * Converts a TimeRanges object into an array representation\n     *\n     * @param {TimeRanges} timeRanges\n     * @return {Array}\n     */\n\n    const timeRangesToArray = timeRanges => {\n        const timeRangesList = [];\n        for (let i = 0; i < timeRanges.length; i++) {\n            timeRangesList.push({\n                start: timeRanges.start(i),\n                end: timeRanges.end(i)\n            });\n        }\n        return timeRangesList;\n    };\n    /**\n     * Determines if two time range objects are different.\n     *\n     * @param {TimeRange} a\n     *        the first time range object to check\n     *\n     * @param {TimeRange} b\n     *        the second time range object to check\n     *\n     * @return {Boolean}\n     *         Whether the time range objects differ\n     */\n\n    const isRangeDifferent = function (a, b) {\n        // same object\n        if (a === b) {\n            return false;\n        } // one or the other is undefined\n\n        if (!a && b || !b && a) {\n            return true;\n        } // length is different\n\n        if (a.length !== b.length) {\n            return true;\n        } // see if any start/end pair is different\n\n        for (let i = 0; i < a.length; i++) {\n            if (a.start(i) !== b.start(i) || a.end(i) !== b.end(i)) {\n                return true;\n            }\n        } // if the length and every pair is the same\n        // this is the same time range\n\n        return false;\n    };\n    const lastBufferedEnd = function (a) {\n        if (!a || !a.length || !a.end) {\n            return;\n        }\n        return a.end(a.length - 1);\n    };\n    /**\n     * A utility function to add up the amount of time in a timeRange\n     * after a specified startTime.\n     * ie:[[0, 10], [20, 40], [50, 60]] with a startTime 0\n     *     would return 40 as there are 40s seconds after 0 in the timeRange\n     *\n     * @param {TimeRange} range\n     *        The range to check against\n     * @param {number} startTime\n     *        The time in the time range that you should start counting from\n     *\n     * @return {number}\n     *          The number of seconds in the buffer passed the specified time.\n     */\n\n    const timeAheadOf = function (range, startTime) {\n        let time = 0;\n        if (!range || !range.length) {\n            return time;\n        }\n        for (let i = 0; i < range.length; i++) {\n            const start = range.start(i);\n            const end = range.end(i); // startTime is after this range entirely\n\n            if (startTime > end) {\n                continue;\n            } // startTime is within this range\n\n            if (startTime > start && startTime <= end) {\n                time += end - startTime;\n                continue;\n            } // startTime is before this range.\n\n            time += end - start;\n        }\n        return time;\n    };\n\n    /**\n     * @file playlist.js\n     *\n     * Playlist related utilities.\n     */\n    /**\n     * Get the duration of a segment, with special cases for\n     * llhls segments that do not have a duration yet.\n     *\n     * @param {Object} playlist\n     *        the playlist that the segment belongs to.\n     * @param {Object} segment\n     *        the segment to get a duration for.\n     *\n     * @return {number}\n     *          the segment duration\n     */\n\n    const segmentDurationWithParts = (playlist, segment) => {\n        // if this isn't a preload segment\n        // then we will have a segment duration that is accurate.\n        if (!segment.preload) {\n            return segment.duration;\n        } // otherwise we have to add up parts and preload hints\n        // to get an up to date duration.\n\n        let result = 0;\n        (segment.parts || []).forEach(function (p) {\n            result += p.duration;\n        }); // for preload hints we have to use partTargetDuration\n        // as they won't even have a duration yet.\n\n        (segment.preloadHints || []).forEach(function (p) {\n            if (p.type === 'PART') {\n                result += playlist.partTargetDuration;\n            }\n        });\n        return result;\n    };\n    /**\n     * A function to get a combined list of parts and segments with durations\n     * and indexes.\n     *\n     * @param {Playlist} playlist the playlist to get the list for.\n     *\n     * @return {Array} The part/segment list.\n     */\n\n    const getPartsAndSegments = playlist => (playlist.segments || []).reduce((acc, segment, si) => {\n        if (segment.parts) {\n            segment.parts.forEach(function (part, pi) {\n                acc.push({\n                    duration: part.duration,\n                    segmentIndex: si,\n                    partIndex: pi,\n                    part,\n                    segment\n                });\n            });\n        } else {\n            acc.push({\n                duration: segment.duration,\n                segmentIndex: si,\n                partIndex: null,\n                segment,\n                part: null\n            });\n        }\n        return acc;\n    }, []);\n    const getLastParts = media => {\n        const lastSegment = media.segments && media.segments.length && media.segments[media.segments.length - 1];\n        return lastSegment && lastSegment.parts || [];\n    };\n    const getKnownPartCount = ({\n                                   preloadSegment\n                               }) => {\n        if (!preloadSegment) {\n            return;\n        }\n        const {\n            parts,\n            preloadHints\n        } = preloadSegment;\n        let partCount = (preloadHints || []).reduce((count, hint) => count + (hint.type === 'PART' ? 1 : 0), 0);\n        partCount += parts && parts.length ? parts.length : 0;\n        return partCount;\n    };\n    /**\n     * Get the number of seconds to delay from the end of a\n     * live playlist.\n     *\n     * @param {Playlist} main the main playlist\n     * @param {Playlist} media the media playlist\n     * @return {number} the hold back in seconds.\n     */\n\n    const liveEdgeDelay = (main, media) => {\n        if (media.endList) {\n            return 0;\n        } // dash suggestedPresentationDelay trumps everything\n\n        if (main && main.suggestedPresentationDelay) {\n            return main.suggestedPresentationDelay;\n        }\n        const hasParts = getLastParts(media).length > 0; // look for \"part\" delays from ll-hls first\n\n        if (hasParts && media.serverControl && media.serverControl.partHoldBack) {\n            return media.serverControl.partHoldBack;\n        } else if (hasParts && media.partTargetDuration) {\n            return media.partTargetDuration * 3; // finally look for full segment delays\n        } else if (media.serverControl && media.serverControl.holdBack) {\n            return media.serverControl.holdBack;\n        } else if (media.targetDuration) {\n            return media.targetDuration * 3;\n        }\n        return 0;\n    };\n    /**\n     * walk backward until we find a duration we can use\n     * or return a failure\n     *\n     * @param {Playlist} playlist the playlist to walk through\n     * @param {Number} endSequence the mediaSequence to stop walking on\n     */\n\n    const backwardDuration = function (playlist, endSequence) {\n        let result = 0;\n        let i = endSequence - playlist.mediaSequence; // if a start time is available for segment immediately following\n        // the interval, use it\n\n        let segment = playlist.segments[i]; // Walk backward until we find the latest segment with timeline\n        // information that is earlier than endSequence\n\n        if (segment) {\n            if (typeof segment.start !== 'undefined') {\n                return {\n                    result: segment.start,\n                    precise: true\n                };\n            }\n            if (typeof segment.end !== 'undefined') {\n                return {\n                    result: segment.end - segment.duration,\n                    precise: true\n                };\n            }\n        }\n        while (i--) {\n            segment = playlist.segments[i];\n            if (typeof segment.end !== 'undefined') {\n                return {\n                    result: result + segment.end,\n                    precise: true\n                };\n            }\n            result += segmentDurationWithParts(playlist, segment);\n            if (typeof segment.start !== 'undefined') {\n                return {\n                    result: result + segment.start,\n                    precise: true\n                };\n            }\n        }\n        return {\n            result,\n            precise: false\n        };\n    };\n    /**\n     * walk forward until we find a duration we can use\n     * or return a failure\n     *\n     * @param {Playlist} playlist the playlist to walk through\n     * @param {number} endSequence the mediaSequence to stop walking on\n     */\n\n    const forwardDuration = function (playlist, endSequence) {\n        let result = 0;\n        let segment;\n        let i = endSequence - playlist.mediaSequence; // Walk forward until we find the earliest segment with timeline\n        // information\n\n        for (; i < playlist.segments.length; i++) {\n            segment = playlist.segments[i];\n            if (typeof segment.start !== 'undefined') {\n                return {\n                    result: segment.start - result,\n                    precise: true\n                };\n            }\n            result += segmentDurationWithParts(playlist, segment);\n            if (typeof segment.end !== 'undefined') {\n                return {\n                    result: segment.end - result,\n                    precise: true\n                };\n            }\n        } // indicate we didn't find a useful duration estimate\n\n        return {\n            result: -1,\n            precise: false\n        };\n    };\n    /**\n     * Calculate the media duration from the segments associated with a\n     * playlist. The duration of a subinterval of the available segments\n     * may be calculated by specifying an end index.\n     *\n     * @param {Object} playlist a media playlist object\n     * @param {number=} endSequence an exclusive upper boundary\n     * for the playlist.  Defaults to playlist length.\n     * @param {number} expired the amount of time that has dropped\n     * off the front of the playlist in a live scenario\n     * @return {number} the duration between the first available segment\n     * and end index.\n     */\n\n    const intervalDuration = function (playlist, endSequence, expired) {\n        if (typeof endSequence === 'undefined') {\n            endSequence = playlist.mediaSequence + playlist.segments.length;\n        }\n        if (endSequence < playlist.mediaSequence) {\n            return 0;\n        } // do a backward walk to estimate the duration\n\n        const backward = backwardDuration(playlist, endSequence);\n        if (backward.precise) {\n            // if we were able to base our duration estimate on timing\n            // information provided directly from the Media Source, return\n            // it\n            return backward.result;\n        } // walk forward to see if a precise duration estimate can be made\n        // that way\n\n        const forward = forwardDuration(playlist, endSequence);\n        if (forward.precise) {\n            // we found a segment that has been buffered and so it's\n            // position is known precisely\n            return forward.result;\n        } // return the less-precise, playlist-based duration estimate\n\n        return backward.result + expired;\n    };\n    /**\n     * Calculates the duration of a playlist. If a start and end index\n     * are specified, the duration will be for the subset of the media\n     * timeline between those two indices. The total duration for live\n     * playlists is always Infinity.\n     *\n     * @param {Object} playlist a media playlist object\n     * @param {number=} endSequence an exclusive upper\n     * boundary for the playlist. Defaults to the playlist media\n     * sequence number plus its length.\n     * @param {number=} expired the amount of time that has\n     * dropped off the front of the playlist in a live scenario\n     * @return {number} the duration between the start index and end\n     * index.\n     */\n\n    const duration = function (playlist, endSequence, expired) {\n        if (!playlist) {\n            return 0;\n        }\n        if (typeof expired !== 'number') {\n            expired = 0;\n        } // if a slice of the total duration is not requested, use\n        // playlist-level duration indicators when they're present\n\n        if (typeof endSequence === 'undefined') {\n            // if present, use the duration specified in the playlist\n            if (playlist.totalDuration) {\n                return playlist.totalDuration;\n            } // duration should be Infinity for live playlists\n\n            if (!playlist.endList) {\n                return window.Infinity;\n            }\n        } // calculate the total duration based on the segment durations\n\n        return intervalDuration(playlist, endSequence, expired);\n    };\n    /**\n     * Calculate the time between two indexes in the current playlist\n     * neight the start- nor the end-index need to be within the current\n     * playlist in which case, the targetDuration of the playlist is used\n     * to approximate the durations of the segments\n     *\n     * @param {Array} options.durationList list to iterate over for durations.\n     * @param {number} options.defaultDuration duration to use for elements before or after the durationList\n     * @param {number} options.startIndex partsAndSegments index to start\n     * @param {number} options.endIndex partsAndSegments index to end.\n     * @return {number} the number of seconds between startIndex and endIndex\n     */\n\n    const sumDurations = function ({\n                                       defaultDuration,\n                                       durationList,\n                                       startIndex,\n                                       endIndex\n                                   }) {\n        let durations = 0;\n        if (startIndex > endIndex) {\n            [startIndex, endIndex] = [endIndex, startIndex];\n        }\n        if (startIndex < 0) {\n            for (let i = startIndex; i < Math.min(0, endIndex); i++) {\n                durations += defaultDuration;\n            }\n            startIndex = 0;\n        }\n        for (let i = startIndex; i < endIndex; i++) {\n            durations += durationList[i].duration;\n        }\n        return durations;\n    };\n    /**\n     * Calculates the playlist end time\n     *\n     * @param {Object} playlist a media playlist object\n     * @param {number=} expired the amount of time that has\n     *                  dropped off the front of the playlist in a live scenario\n     * @param {boolean|false} useSafeLiveEnd a boolean value indicating whether or not the\n     *                        playlist end calculation should consider the safe live end\n     *                        (truncate the playlist end by three segments). This is normally\n     *                        used for calculating the end of the playlist's seekable range.\n     *                        This takes into account the value of liveEdgePadding.\n     *                        Setting liveEdgePadding to 0 is equivalent to setting this to false.\n     * @param {number} liveEdgePadding a number indicating how far from the end of the playlist we should be in seconds.\n     *                 If this is provided, it is used in the safe live end calculation.\n     *                 Setting useSafeLiveEnd=false or liveEdgePadding=0 are equivalent.\n     *                 Corresponds to suggestedPresentationDelay in DASH manifests.\n     * @return {number} the end time of playlist\n     * @function playlistEnd\n     */\n\n    const playlistEnd = function (playlist, expired, useSafeLiveEnd, liveEdgePadding) {\n        if (!playlist || !playlist.segments) {\n            return null;\n        }\n        if (playlist.endList) {\n            return duration(playlist);\n        }\n        if (expired === null) {\n            return null;\n        }\n        expired = expired || 0;\n        let lastSegmentEndTime = intervalDuration(playlist, playlist.mediaSequence + playlist.segments.length, expired);\n        if (useSafeLiveEnd) {\n            liveEdgePadding = typeof liveEdgePadding === 'number' ? liveEdgePadding : liveEdgeDelay(null, playlist);\n            lastSegmentEndTime -= liveEdgePadding;\n        } // don't return a time less than zero\n\n        return Math.max(0, lastSegmentEndTime);\n    };\n    /**\n     * Calculates the interval of time that is currently seekable in a\n     * playlist. The returned time ranges are relative to the earliest\n     * moment in the specified playlist that is still available. A full\n     * seekable implementation for live streams would need to offset\n     * these values by the duration of content that has expired from the\n     * stream.\n     *\n     * @param {Object} playlist a media playlist object\n     * dropped off the front of the playlist in a live scenario\n     * @param {number=} expired the amount of time that has\n     * dropped off the front of the playlist in a live scenario\n     * @param {number} liveEdgePadding how far from the end of the playlist we should be in seconds.\n     *        Corresponds to suggestedPresentationDelay in DASH manifests.\n     * @return {TimeRanges} the periods of time that are valid targets\n     * for seeking\n     */\n\n    const seekable = function (playlist, expired, liveEdgePadding) {\n        const useSafeLiveEnd = true;\n        const seekableStart = expired || 0;\n        const seekableEnd = playlistEnd(playlist, expired, useSafeLiveEnd, liveEdgePadding);\n        if (seekableEnd === null) {\n            return createTimeRanges();\n        }\n        return createTimeRanges(seekableStart, seekableEnd);\n    };\n    /**\n     * Determine the index and estimated starting time of the segment that\n     * contains a specified playback position in a media playlist.\n     *\n     * @param {Object} options.playlist the media playlist to query\n     * @param {number} options.currentTime The number of seconds since the earliest\n     * possible position to determine the containing segment for\n     * @param {number} options.startTime the time when the segment/part starts\n     * @param {number} options.startingSegmentIndex the segment index to start looking at.\n     * @param {number?} [options.startingPartIndex] the part index to look at within the segment.\n     *\n     * @return {Object} an object with partIndex, segmentIndex, and startTime.\n     */\n\n    const getMediaInfoForTime = function ({\n                                              playlist,\n                                              currentTime,\n                                              startingSegmentIndex,\n                                              startingPartIndex,\n                                              startTime,\n                                              exactManifestTimings\n                                          }) {\n        let time = currentTime - startTime;\n        const partsAndSegments = getPartsAndSegments(playlist);\n        let startIndex = 0;\n        for (let i = 0; i < partsAndSegments.length; i++) {\n            const partAndSegment = partsAndSegments[i];\n            if (startingSegmentIndex !== partAndSegment.segmentIndex) {\n                continue;\n            } // skip this if part index does not match.\n\n            if (typeof startingPartIndex === 'number' && typeof partAndSegment.partIndex === 'number' && startingPartIndex !== partAndSegment.partIndex) {\n                continue;\n            }\n            startIndex = i;\n            break;\n        }\n        if (time < 0) {\n            // Walk backward from startIndex in the playlist, adding durations\n            // until we find a segment that contains `time` and return it\n            if (startIndex > 0) {\n                for (let i = startIndex - 1; i >= 0; i--) {\n                    const partAndSegment = partsAndSegments[i];\n                    time += partAndSegment.duration;\n                    if (exactManifestTimings) {\n                        if (time < 0) {\n                            continue;\n                        }\n                    } else if (time + TIME_FUDGE_FACTOR <= 0) {\n                        continue;\n                    }\n                    return {\n                        partIndex: partAndSegment.partIndex,\n                        segmentIndex: partAndSegment.segmentIndex,\n                        startTime: startTime - sumDurations({\n                            defaultDuration: playlist.targetDuration,\n                            durationList: partsAndSegments,\n                            startIndex,\n                            endIndex: i\n                        })\n                    };\n                }\n            } // We were unable to find a good segment within the playlist\n            // so select the first segment\n\n            return {\n                partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,\n                segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,\n                startTime: currentTime\n            };\n        } // When startIndex is negative, we first walk forward to first segment\n        // adding target durations. If we \"run out of time\" before getting to\n        // the first segment, return the first segment\n\n        if (startIndex < 0) {\n            for (let i = startIndex; i < 0; i++) {\n                time -= playlist.targetDuration;\n                if (time < 0) {\n                    return {\n                        partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,\n                        segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,\n                        startTime: currentTime\n                    };\n                }\n            }\n            startIndex = 0;\n        } // Walk forward from startIndex in the playlist, subtracting durations\n        // until we find a segment that contains `time` and return it\n\n        for (let i = startIndex; i < partsAndSegments.length; i++) {\n            const partAndSegment = partsAndSegments[i];\n            time -= partAndSegment.duration;\n            if (exactManifestTimings) {\n                if (time > 0) {\n                    continue;\n                }\n            } else if (time - TIME_FUDGE_FACTOR >= 0) {\n                continue;\n            }\n            return {\n                partIndex: partAndSegment.partIndex,\n                segmentIndex: partAndSegment.segmentIndex,\n                startTime: startTime + sumDurations({\n                    defaultDuration: playlist.targetDuration,\n                    durationList: partsAndSegments,\n                    startIndex,\n                    endIndex: i\n                })\n            };\n        } // We are out of possible candidates so load the last one...\n\n        return {\n            segmentIndex: partsAndSegments[partsAndSegments.length - 1].segmentIndex,\n            partIndex: partsAndSegments[partsAndSegments.length - 1].partIndex,\n            startTime: currentTime\n        };\n    };\n    /**\n     * Check whether the playlist is excluded or not.\n     *\n     * @param {Object} playlist the media playlist object\n     * @return {boolean} whether the playlist is excluded or not\n     * @function isExcluded\n     */\n\n    const isExcluded = function (playlist) {\n        return playlist.excludeUntil && playlist.excludeUntil > Date.now();\n    };\n    /**\n     * Check whether the playlist is compatible with current playback configuration or has\n     * been excluded permanently for being incompatible.\n     *\n     * @param {Object} playlist the media playlist object\n     * @return {boolean} whether the playlist is incompatible or not\n     * @function isIncompatible\n     */\n\n    const isIncompatible = function (playlist) {\n        return playlist.excludeUntil && playlist.excludeUntil === Infinity;\n    };\n    /**\n     * Check whether the playlist is enabled or not.\n     *\n     * @param {Object} playlist the media playlist object\n     * @return {boolean} whether the playlist is enabled or not\n     * @function isEnabled\n     */\n\n    const isEnabled = function (playlist) {\n        const excluded = isExcluded(playlist);\n        return !playlist.disabled && !excluded;\n    };\n    /**\n     * Check whether the playlist has been manually disabled through the representations api.\n     *\n     * @param {Object} playlist the media playlist object\n     * @return {boolean} whether the playlist is disabled manually or not\n     * @function isDisabled\n     */\n\n    const isDisabled = function (playlist) {\n        return playlist.disabled;\n    };\n    /**\n     * Returns whether the current playlist is an AES encrypted HLS stream\n     *\n     * @return {boolean} true if it's an AES encrypted HLS stream\n     */\n\n    const isAes = function (media) {\n        for (let i = 0; i < media.segments.length; i++) {\n            if (media.segments[i].key) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Checks if the playlist has a value for the specified attribute\n     *\n     * @param {string} attr\n     *        Attribute to check for\n     * @param {Object} playlist\n     *        The media playlist object\n     * @return {boolean}\n     *         Whether the playlist contains a value for the attribute or not\n     * @function hasAttribute\n     */\n\n    const hasAttribute = function (attr, playlist) {\n        return playlist.attributes && playlist.attributes[attr];\n    };\n    /**\n     * Estimates the time required to complete a segment download from the specified playlist\n     *\n     * @param {number} segmentDuration\n     *        Duration of requested segment\n     * @param {number} bandwidth\n     *        Current measured bandwidth of the player\n     * @param {Object} playlist\n     *        The media playlist object\n     * @param {number=} bytesReceived\n     *        Number of bytes already received for the request. Defaults to 0\n     * @return {number|NaN}\n     *         The estimated time to request the segment. NaN if bandwidth information for\n     *         the given playlist is unavailable\n     * @function estimateSegmentRequestTime\n     */\n\n    const estimateSegmentRequestTime = function (segmentDuration, bandwidth, playlist, bytesReceived = 0) {\n        if (!hasAttribute('BANDWIDTH', playlist)) {\n            return NaN;\n        }\n        const size = segmentDuration * playlist.attributes.BANDWIDTH;\n        return (size - bytesReceived * 8) / bandwidth;\n    };\n    /*\n   * Returns whether the current playlist is the lowest rendition\n   *\n   * @return {Boolean} true if on lowest rendition\n   */\n\n    const isLowestEnabledRendition = (main, media) => {\n        if (main.playlists.length === 1) {\n            return true;\n        }\n        const currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;\n        return main.playlists.filter(playlist => {\n            if (!isEnabled(playlist)) {\n                return false;\n            }\n            return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;\n        }).length === 0;\n    };\n    const playlistMatch = (a, b) => {\n        // both playlits are null\n        // or only one playlist is non-null\n        // no match\n        if (!a && !b || !a && b || a && !b) {\n            return false;\n        } // playlist objects are the same, match\n\n        if (a === b) {\n            return true;\n        } // first try to use id as it should be the most\n        // accurate\n\n        if (a.id && b.id && a.id === b.id) {\n            return true;\n        } // next try to use reslovedUri as it should be the\n        // second most accurate.\n\n        if (a.resolvedUri && b.resolvedUri && a.resolvedUri === b.resolvedUri) {\n            return true;\n        } // finally try to use uri as it should be accurate\n        // but might miss a few cases for relative uris\n\n        if (a.uri && b.uri && a.uri === b.uri) {\n            return true;\n        }\n        return false;\n    };\n    const someAudioVariant = function (main, callback) {\n        const AUDIO = main && main.mediaGroups && main.mediaGroups.AUDIO || {};\n        let found = false;\n        for (const groupName in AUDIO) {\n            for (const label in AUDIO[groupName]) {\n                found = callback(AUDIO[groupName][label]);\n                if (found) {\n                    break;\n                }\n            }\n            if (found) {\n                break;\n            }\n        }\n        return !!found;\n    };\n    const isAudioOnly = main => {\n        // we are audio only if we have no main playlists but do\n        // have media group playlists.\n        if (!main || !main.playlists || !main.playlists.length) {\n            // without audio variants or playlists this\n            // is not an audio only main.\n            const found = someAudioVariant(main, variant => variant.playlists && variant.playlists.length || variant.uri);\n            return found;\n        } // if every playlist has only an audio codec it is audio only\n\n        for (let i = 0; i < main.playlists.length; i++) {\n            const playlist = main.playlists[i];\n            const CODECS = playlist.attributes && playlist.attributes.CODECS; // all codecs are audio, this is an audio playlist.\n\n            if (CODECS && CODECS.split(',').every(c => isAudioCodec(c))) {\n                continue;\n            } // playlist is in an audio group it is audio only\n\n            const found = someAudioVariant(main, variant => playlistMatch(playlist, variant));\n            if (found) {\n                continue;\n            } // if we make it here this playlist isn't audio and we\n            // are not audio only\n\n            return false;\n        } // if we make it past every playlist without returning, then\n        // this is an audio only playlist.\n\n        return true;\n    }; // exports\n\n    var Playlist = {\n        liveEdgeDelay,\n        duration,\n        seekable,\n        getMediaInfoForTime,\n        isEnabled,\n        isDisabled,\n        isExcluded,\n        isIncompatible,\n        playlistEnd,\n        isAes,\n        hasAttribute,\n        estimateSegmentRequestTime,\n        isLowestEnabledRendition,\n        isAudioOnly,\n        playlistMatch,\n        segmentDurationWithParts\n    };\n    const {\n        log\n    } = videojs;\n    const createPlaylistID = (index, uri) => {\n        return `${index}-${uri}`;\n    }; // default function for creating a group id\n\n    const groupID = (type, group, label) => {\n        return `placeholder-uri-${type}-${group}-${label}`;\n    };\n    /**\n     * Parses a given m3u8 playlist\n     *\n     * @param {Function} [onwarn]\n     *        a function to call when the parser triggers a warning event.\n     * @param {Function} [oninfo]\n     *        a function to call when the parser triggers an info event.\n     * @param {string} manifestString\n     *        The downloaded manifest string\n     * @param {Object[]} [customTagParsers]\n     *        An array of custom tag parsers for the m3u8-parser instance\n     * @param {Object[]} [customTagMappers]\n     *        An array of custom tag mappers for the m3u8-parser instance\n     * @param {boolean} [llhls]\n     *        Whether to keep ll-hls features in the manifest after parsing.\n     * @return {Object}\n     *         The manifest object\n     */\n\n    const parseManifest = ({\n                               onwarn,\n                               oninfo,\n                               manifestString,\n                               customTagParsers = [],\n                               customTagMappers = [],\n                               llhls\n                           }) => {\n        const parser = new Parser();\n        if (onwarn) {\n            parser.on('warn', onwarn);\n        }\n        if (oninfo) {\n            parser.on('info', oninfo);\n        }\n        customTagParsers.forEach(customParser => parser.addParser(customParser));\n        customTagMappers.forEach(mapper => parser.addTagMapper(mapper));\n        parser.push(manifestString);\n        parser.end();\n        const manifest = parser.manifest; // remove llhls features from the parsed manifest\n        // if we don't want llhls support.\n\n        if (!llhls) {\n            ['preloadSegment', 'skip', 'serverControl', 'renditionReports', 'partInf', 'partTargetDuration'].forEach(function (k) {\n                if (manifest.hasOwnProperty(k)) {\n                    delete manifest[k];\n                }\n            });\n            if (manifest.segments) {\n                manifest.segments.forEach(function (segment) {\n                    ['parts', 'preloadHints'].forEach(function (k) {\n                        if (segment.hasOwnProperty(k)) {\n                            delete segment[k];\n                        }\n                    });\n                });\n            }\n        }\n        if (!manifest.targetDuration) {\n            let targetDuration = 10;\n            if (manifest.segments && manifest.segments.length) {\n                targetDuration = manifest.segments.reduce((acc, s) => Math.max(acc, s.duration), 0);\n            }\n            if (onwarn) {\n                onwarn(`manifest has no targetDuration defaulting to ${targetDuration}`);\n            }\n            manifest.targetDuration = targetDuration;\n        }\n        const parts = getLastParts(manifest);\n        if (parts.length && !manifest.partTargetDuration) {\n            const partTargetDuration = parts.reduce((acc, p) => Math.max(acc, p.duration), 0);\n            if (onwarn) {\n                onwarn(`manifest has no partTargetDuration defaulting to ${partTargetDuration}`);\n                log.error('LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.');\n            }\n            manifest.partTargetDuration = partTargetDuration;\n        }\n        return manifest;\n    };\n    /**\n     * Loops through all supported media groups in main and calls the provided\n     * callback for each group\n     *\n     * @param {Object} main\n     *        The parsed main manifest object\n     * @param {Function} callback\n     *        Callback to call for each media group\n     */\n\n    const forEachMediaGroup = (main, callback) => {\n        if (!main.mediaGroups) {\n            return;\n        }\n        ['AUDIO', 'SUBTITLES'].forEach(mediaType => {\n            if (!main.mediaGroups[mediaType]) {\n                return;\n            }\n            for (const groupKey in main.mediaGroups[mediaType]) {\n                for (const labelKey in main.mediaGroups[mediaType][groupKey]) {\n                    const mediaProperties = main.mediaGroups[mediaType][groupKey][labelKey];\n                    callback(mediaProperties, mediaType, groupKey, labelKey);\n                }\n            }\n        });\n    };\n    /**\n     * Adds properties and attributes to the playlist to keep consistent functionality for\n     * playlists throughout VHS.\n     *\n     * @param {Object} config\n     *        Arguments object\n     * @param {Object} config.playlist\n     *        The media playlist\n     * @param {string} [config.uri]\n     *        The uri to the media playlist (if media playlist is not from within a main\n     *        playlist)\n     * @param {string} id\n     *        ID to use for the playlist\n     */\n\n    const setupMediaPlaylist = ({\n                                    playlist,\n                                    uri,\n                                    id\n                                }) => {\n        playlist.id = id;\n        playlist.playlistErrors_ = 0;\n        if (uri) {\n            // For media playlists, m3u8-parser does not have access to a URI, as HLS media\n            // playlists do not contain their own source URI, but one is needed for consistency in\n            // VHS.\n            playlist.uri = uri;\n        } // For HLS main playlists, even though certain attributes MUST be defined, the\n        // stream may still be played without them.\n        // For HLS media playlists, m3u8-parser does not attach an attributes object to the\n        // manifest.\n        //\n        // To avoid undefined reference errors through the project, and make the code easier\n        // to write/read, add an empty attributes object for these cases.\n\n        playlist.attributes = playlist.attributes || {};\n    };\n    /**\n     * Adds ID, resolvedUri, and attributes properties to each playlist of the main, where\n     * necessary. In addition, creates playlist IDs for each playlist and adds playlist ID to\n     * playlist references to the playlists array.\n     *\n     * @param {Object} main\n     *        The main playlist\n     */\n\n    const setupMediaPlaylists = main => {\n        let i = main.playlists.length;\n        while (i--) {\n            const playlist = main.playlists[i];\n            setupMediaPlaylist({\n                playlist,\n                id: createPlaylistID(i, playlist.uri)\n            });\n            playlist.resolvedUri = resolveUrl(main.uri, playlist.uri);\n            main.playlists[playlist.id] = playlist; // URI reference added for backwards compatibility\n\n            main.playlists[playlist.uri] = playlist; // Although the spec states an #EXT-X-STREAM-INF tag MUST have a BANDWIDTH attribute,\n            // the stream can be played without it. Although an attributes property may have been\n            // added to the playlist to prevent undefined references, issue a warning to fix the\n            // manifest.\n\n            if (!playlist.attributes.BANDWIDTH) {\n                log.warn('Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.');\n            }\n        }\n    };\n    /**\n     * Adds resolvedUri properties to each media group.\n     *\n     * @param {Object} main\n     *        The main playlist\n     */\n\n    const resolveMediaGroupUris = main => {\n        forEachMediaGroup(main, properties => {\n            if (properties.uri) {\n                properties.resolvedUri = resolveUrl(main.uri, properties.uri);\n            }\n        });\n    };\n    /**\n     * Creates a main playlist wrapper to insert a sole media playlist into.\n     *\n     * @param {Object} media\n     *        Media playlist\n     * @param {string} uri\n     *        The media URI\n     *\n     * @return {Object}\n     *         main playlist\n     */\n\n    const mainForMedia = (media, uri) => {\n        const id = createPlaylistID(0, uri);\n        const main = {\n            mediaGroups: {\n                'AUDIO': {},\n                'VIDEO': {},\n                'CLOSED-CAPTIONS': {},\n                'SUBTITLES': {}\n            },\n            uri: window.location.href,\n            resolvedUri: window.location.href,\n            playlists: [{\n                uri,\n                id,\n                resolvedUri: uri,\n                // m3u8-parser does not attach an attributes property to media playlists so make\n                // sure that the property is attached to avoid undefined reference errors\n                attributes: {}\n            }]\n        }; // set up ID reference\n\n        main.playlists[id] = main.playlists[0]; // URI reference added for backwards compatibility\n\n        main.playlists[uri] = main.playlists[0];\n        return main;\n    };\n    /**\n     * Does an in-place update of the main manifest to add updated playlist URI references\n     * as well as other properties needed by VHS that aren't included by the parser.\n     *\n     * @param {Object} main\n     *        main manifest object\n     * @param {string} uri\n     *        The source URI\n     * @param {function} createGroupID\n     *        A function to determine how to create the groupID for mediaGroups\n     */\n\n    const addPropertiesToMain = (main, uri, createGroupID = groupID) => {\n        main.uri = uri;\n        for (let i = 0; i < main.playlists.length; i++) {\n            if (!main.playlists[i].uri) {\n                // Set up phony URIs for the playlists since playlists are referenced by their URIs\n                // throughout VHS, but some formats (e.g., DASH) don't have external URIs\n                // TODO: consider adding dummy URIs in mpd-parser\n                const phonyUri = `placeholder-uri-${i}`;\n                main.playlists[i].uri = phonyUri;\n            }\n        }\n        const audioOnlyMain = isAudioOnly(main);\n        forEachMediaGroup(main, (properties, mediaType, groupKey, labelKey) => {\n            // add a playlist array under properties\n            if (!properties.playlists || !properties.playlists.length) {\n                // If the manifest is audio only and this media group does not have a uri, check\n                // if the media group is located in the main list of playlists. If it is, don't add\n                // placeholder properties as it shouldn't be considered an alternate audio track.\n                if (audioOnlyMain && mediaType === 'AUDIO' && !properties.uri) {\n                    for (let i = 0; i < main.playlists.length; i++) {\n                        const p = main.playlists[i];\n                        if (p.attributes && p.attributes.AUDIO && p.attributes.AUDIO === groupKey) {\n                            return;\n                        }\n                    }\n                }\n                properties.playlists = [_extends$1({}, properties)];\n            }\n            properties.playlists.forEach(function (p, i) {\n                const groupId = createGroupID(mediaType, groupKey, labelKey, p);\n                const id = createPlaylistID(i, groupId);\n                if (p.uri) {\n                    p.resolvedUri = p.resolvedUri || resolveUrl(main.uri, p.uri);\n                } else {\n                    // DEPRECATED, this has been added to prevent a breaking change.\n                    // previously we only ever had a single media group playlist, so\n                    // we mark the first playlist uri without prepending the index as we used to\n                    // ideally we would do all of the playlists the same way.\n                    p.uri = i === 0 ? groupId : id; // don't resolve a placeholder uri to an absolute url, just use\n                    // the placeholder again\n\n                    p.resolvedUri = p.uri;\n                }\n                p.id = p.id || id; // add an empty attributes object, all playlists are\n                // expected to have this.\n\n                p.attributes = p.attributes || {}; // setup ID and URI references (URI for backwards compatibility)\n\n                main.playlists[p.id] = p;\n                main.playlists[p.uri] = p;\n            });\n        });\n        setupMediaPlaylists(main);\n        resolveMediaGroupUris(main);\n    };\n\n    /**\n     * @file playlist-loader.js\n     *\n     * A state machine that manages the loading, caching, and updating of\n     * M3U8 playlists.\n     *\n     */\n    const {\n        EventTarget: EventTarget$1\n    } = videojs;\n    const addLLHLSQueryDirectives = (uri, media) => {\n        if (media.endList || !media.serverControl) {\n            return uri;\n        }\n        const parameters = {};\n        if (media.serverControl.canBlockReload) {\n            const {\n                preloadSegment\n            } = media; // next msn is a zero based value, length is not.\n\n            let nextMSN = media.mediaSequence + media.segments.length; // If preload segment has parts then it is likely\n            // that we are going to request a part of that preload segment.\n            // the logic below is used to determine that.\n\n            if (preloadSegment) {\n                const parts = preloadSegment.parts || []; // _HLS_part is a zero based index\n\n                const nextPart = getKnownPartCount(media) - 1; // if nextPart is > -1 and not equal to just the\n                // length of parts, then we know we had part preload hints\n                // and we need to add the _HLS_part= query\n\n                if (nextPart > -1 && nextPart !== parts.length - 1) {\n                    // add existing parts to our preload hints\n                    // eslint-disable-next-line\n                    parameters._HLS_part = nextPart;\n                } // this if statement makes sure that we request the msn\n                // of the preload segment if:\n                // 1. the preload segment had parts (and was not yet a full segment)\n                //    but was added to our segments array\n                // 2. the preload segment had preload hints for parts that are not in\n                //    the manifest yet.\n                // in all other cases we want the segment after the preload segment\n                // which will be given by using media.segments.length because it is 1 based\n                // rather than 0 based.\n\n                if (nextPart > -1 || parts.length) {\n                    nextMSN--;\n                }\n            } // add _HLS_msn= in front of any _HLS_part query\n            // eslint-disable-next-line\n\n            parameters._HLS_msn = nextMSN;\n        }\n        if (media.serverControl && media.serverControl.canSkipUntil) {\n            // add _HLS_skip= infront of all other queries.\n            // eslint-disable-next-line\n            parameters._HLS_skip = media.serverControl.canSkipDateranges ? 'v2' : 'YES';\n        }\n        if (Object.keys(parameters).length) {\n            const parsedUri = new window.URL(uri);\n            ['_HLS_skip', '_HLS_msn', '_HLS_part'].forEach(function (name) {\n                if (!parameters.hasOwnProperty(name)) {\n                    return;\n                }\n                parsedUri.searchParams.set(name, parameters[name]);\n            });\n            uri = parsedUri.toString();\n        }\n        return uri;\n    };\n    /**\n     * Returns a new segment object with properties and\n     * the parts array merged.\n     *\n     * @param {Object} a the old segment\n     * @param {Object} b the new segment\n     *\n     * @return {Object} the merged segment\n     */\n\n    const updateSegment = (a, b) => {\n        if (!a) {\n            return b;\n        }\n        const result = merge(a, b); // if only the old segment has preload hints\n        // and the new one does not, remove preload hints.\n\n        if (a.preloadHints && !b.preloadHints) {\n            delete result.preloadHints;\n        } // if only the old segment has parts\n        // then the parts are no longer valid\n\n        if (a.parts && !b.parts) {\n            delete result.parts; // if both segments have parts\n            // copy part propeties from the old segment\n            // to the new one.\n        } else if (a.parts && b.parts) {\n            for (let i = 0; i < b.parts.length; i++) {\n                if (a.parts && a.parts[i]) {\n                    result.parts[i] = merge(a.parts[i], b.parts[i]);\n                }\n            }\n        } // set skipped to false for segments that have\n        // have had information merged from the old segment.\n\n        if (!a.skipped && b.skipped) {\n            result.skipped = false;\n        } // set preload to false for segments that have\n        // had information added in the new segment.\n\n        if (a.preload && !b.preload) {\n            result.preload = false;\n        }\n        return result;\n    };\n    /**\n     * Returns a new array of segments that is the result of merging\n     * properties from an older list of segments onto an updated\n     * list. No properties on the updated playlist will be ovewritten.\n     *\n     * @param {Array} original the outdated list of segments\n     * @param {Array} update the updated list of segments\n     * @param {number=} offset the index of the first update\n     * segment in the original segment list. For non-live playlists,\n     * this should always be zero and does not need to be\n     * specified. For live playlists, it should be the difference\n     * between the media sequence numbers in the original and updated\n     * playlists.\n     * @return {Array} a list of merged segment objects\n     */\n\n    const updateSegments = (original, update, offset) => {\n        const oldSegments = original.slice();\n        const newSegments = update.slice();\n        offset = offset || 0;\n        const result = [];\n        let currentMap;\n        for (let newIndex = 0; newIndex < newSegments.length; newIndex++) {\n            const oldSegment = oldSegments[newIndex + offset];\n            const newSegment = newSegments[newIndex];\n            if (oldSegment) {\n                currentMap = oldSegment.map || currentMap;\n                result.push(updateSegment(oldSegment, newSegment));\n            } else {\n                // carry over map to new segment if it is missing\n                if (currentMap && !newSegment.map) {\n                    newSegment.map = currentMap;\n                }\n                result.push(newSegment);\n            }\n        }\n        return result;\n    };\n    const resolveSegmentUris = (segment, baseUri) => {\n        // preloadSegment will not have a uri at all\n        // as the segment isn't actually in the manifest yet, only parts\n        if (!segment.resolvedUri && segment.uri) {\n            segment.resolvedUri = resolveUrl(baseUri, segment.uri);\n        }\n        if (segment.key && !segment.key.resolvedUri) {\n            segment.key.resolvedUri = resolveUrl(baseUri, segment.key.uri);\n        }\n        if (segment.map && !segment.map.resolvedUri) {\n            segment.map.resolvedUri = resolveUrl(baseUri, segment.map.uri);\n        }\n        if (segment.map && segment.map.key && !segment.map.key.resolvedUri) {\n            segment.map.key.resolvedUri = resolveUrl(baseUri, segment.map.key.uri);\n        }\n        if (segment.parts && segment.parts.length) {\n            segment.parts.forEach(p => {\n                if (p.resolvedUri) {\n                    return;\n                }\n                p.resolvedUri = resolveUrl(baseUri, p.uri);\n            });\n        }\n        if (segment.preloadHints && segment.preloadHints.length) {\n            segment.preloadHints.forEach(p => {\n                if (p.resolvedUri) {\n                    return;\n                }\n                p.resolvedUri = resolveUrl(baseUri, p.uri);\n            });\n        }\n    };\n    const getAllSegments = function (media) {\n        const segments = media.segments || [];\n        const preloadSegment = media.preloadSegment; // a preloadSegment with only preloadHints is not currently\n        // a usable segment, only include a preloadSegment that has\n        // parts.\n\n        if (preloadSegment && preloadSegment.parts && preloadSegment.parts.length) {\n            // if preloadHints has a MAP that means that the\n            // init segment is going to change. We cannot use any of the parts\n            // from this preload segment.\n            if (preloadSegment.preloadHints) {\n                for (let i = 0; i < preloadSegment.preloadHints.length; i++) {\n                    if (preloadSegment.preloadHints[i].type === 'MAP') {\n                        return segments;\n                    }\n                }\n            } // set the duration for our preload segment to target duration.\n\n            preloadSegment.duration = media.targetDuration;\n            preloadSegment.preload = true;\n            segments.push(preloadSegment);\n        }\n        return segments;\n    }; // consider the playlist unchanged if the playlist object is the same or\n    // the number of segments is equal, the media sequence number is unchanged,\n    // and this playlist hasn't become the end of the playlist\n\n    const isPlaylistUnchanged = (a, b) => a === b || a.segments && b.segments && a.segments.length === b.segments.length && a.endList === b.endList && a.mediaSequence === b.mediaSequence && a.preloadSegment === b.preloadSegment;\n    /**\n     * Returns a new main playlist that is the result of merging an\n     * updated media playlist into the original version. If the\n     * updated media playlist does not match any of the playlist\n     * entries in the original main playlist, null is returned.\n     *\n     * @param {Object} main a parsed main M3U8 object\n     * @param {Object} media a parsed media M3U8 object\n     * @return {Object} a new object that represents the original\n     * main playlist with the updated media playlist merged in, or\n     * null if the merge produced no change.\n     */\n\n    const updateMain$1 = (main, newMedia, unchangedCheck = isPlaylistUnchanged) => {\n        const result = merge(main, {});\n        const oldMedia = result.playlists[newMedia.id];\n        if (!oldMedia) {\n            return null;\n        }\n        if (unchangedCheck(oldMedia, newMedia)) {\n            return null;\n        }\n        newMedia.segments = getAllSegments(newMedia);\n        const mergedPlaylist = merge(oldMedia, newMedia); // always use the new media's preload segment\n\n        if (mergedPlaylist.preloadSegment && !newMedia.preloadSegment) {\n            delete mergedPlaylist.preloadSegment;\n        } // if the update could overlap existing segment information, merge the two segment lists\n\n        if (oldMedia.segments) {\n            if (newMedia.skip) {\n                newMedia.segments = newMedia.segments || []; // add back in objects for skipped segments, so that we merge\n                // old properties into the new segments\n\n                for (let i = 0; i < newMedia.skip.skippedSegments; i++) {\n                    newMedia.segments.unshift({\n                        skipped: true\n                    });\n                }\n            }\n            mergedPlaylist.segments = updateSegments(oldMedia.segments, newMedia.segments, newMedia.mediaSequence - oldMedia.mediaSequence);\n        } // resolve any segment URIs to prevent us from having to do it later\n\n        mergedPlaylist.segments.forEach(segment => {\n            resolveSegmentUris(segment, mergedPlaylist.resolvedUri);\n        }); // TODO Right now in the playlists array there are two references to each playlist, one\n        // that is referenced by index, and one by URI. The index reference may no longer be\n        // necessary.\n\n        for (let i = 0; i < result.playlists.length; i++) {\n            if (result.playlists[i].id === newMedia.id) {\n                result.playlists[i] = mergedPlaylist;\n            }\n        }\n        result.playlists[newMedia.id] = mergedPlaylist; // URI reference added for backwards compatibility\n\n        result.playlists[newMedia.uri] = mergedPlaylist; // update media group playlist references.\n\n        forEachMediaGroup(main, (properties, mediaType, groupKey, labelKey) => {\n            if (!properties.playlists) {\n                return;\n            }\n            for (let i = 0; i < properties.playlists.length; i++) {\n                if (newMedia.id === properties.playlists[i].id) {\n                    properties.playlists[i] = mergedPlaylist;\n                }\n            }\n        });\n        return result;\n    };\n    /**\n     * Calculates the time to wait before refreshing a live playlist\n     *\n     * @param {Object} media\n     *        The current media\n     * @param {boolean} update\n     *        True if there were any updates from the last refresh, false otherwise\n     * @return {number}\n     *         The time in ms to wait before refreshing the live playlist\n     */\n\n    const refreshDelay = (media, update) => {\n        const segments = media.segments || [];\n        const lastSegment = segments[segments.length - 1];\n        const lastPart = lastSegment && lastSegment.parts && lastSegment.parts[lastSegment.parts.length - 1];\n        const lastDuration = lastPart && lastPart.duration || lastSegment && lastSegment.duration;\n        if (update && lastDuration) {\n            return lastDuration * 1000;\n        } // if the playlist is unchanged since the last reload or last segment duration\n        // cannot be determined, try again after half the target duration\n\n        return (media.partTargetDuration || media.targetDuration || 10) * 500;\n    };\n    /**\n     * Load a playlist from a remote location\n     *\n     * @class PlaylistLoader\n     * @extends Stream\n     * @param {string|Object} src url or object of manifest\n     * @param {boolean} withCredentials the withCredentials xhr option\n     * @class\n     */\n\n    class PlaylistLoader extends EventTarget$1 {\n        constructor(src, vhs, options = {}) {\n            super();\n            if (!src) {\n                throw new Error('A non-empty playlist URL or object is required');\n            }\n            this.logger_ = logger('PlaylistLoader');\n            const {\n                withCredentials = false\n            } = options;\n            this.src = src;\n            this.vhs_ = vhs;\n            this.withCredentials = withCredentials;\n            const vhsOptions = vhs.options_;\n            this.customTagParsers = vhsOptions && vhsOptions.customTagParsers || [];\n            this.customTagMappers = vhsOptions && vhsOptions.customTagMappers || [];\n            this.llhls = vhsOptions && vhsOptions.llhls; // initialize the loader state\n\n            this.state = 'HAVE_NOTHING'; // live playlist staleness timeout\n\n            this.handleMediaupdatetimeout_ = this.handleMediaupdatetimeout_.bind(this);\n            this.on('mediaupdatetimeout', this.handleMediaupdatetimeout_);\n        }\n        handleMediaupdatetimeout_() {\n            if (this.state !== 'HAVE_METADATA') {\n                // only refresh the media playlist if no other activity is going on\n                return;\n            }\n            const media = this.media();\n            let uri = resolveUrl(this.main.uri, media.uri);\n            if (this.llhls) {\n                uri = addLLHLSQueryDirectives(uri, media);\n            }\n            this.state = 'HAVE_CURRENT_METADATA';\n            this.request = this.vhs_.xhr({\n                uri,\n                withCredentials: this.withCredentials\n            }, (error, req) => {\n                // disposed\n                if (!this.request) {\n                    return;\n                }\n                if (error) {\n                    return this.playlistRequestError(this.request, this.media(), 'HAVE_METADATA');\n                }\n                this.haveMetadata({\n                    playlistString: this.request.responseText,\n                    url: this.media().uri,\n                    id: this.media().id\n                });\n            });\n        }\n        playlistRequestError(xhr, playlist, startingState) {\n            const {\n                uri,\n                id\n            } = playlist; // any in-flight request is now finished\n\n            this.request = null;\n            if (startingState) {\n                this.state = startingState;\n            }\n            this.error = {\n                playlist: this.main.playlists[id],\n                status: xhr.status,\n                message: `HLS playlist request error at URL: ${uri}.`,\n                responseText: xhr.responseText,\n                code: xhr.status >= 500 ? 4 : 2\n            };\n            this.trigger('error');\n        }\n        parseManifest_({\n                           url,\n                           manifestString\n                       }) {\n            return parseManifest({\n                onwarn: ({\n                             message\n                         }) => this.logger_(`m3u8-parser warn for ${url}: ${message}`),\n                oninfo: ({\n                             message\n                         }) => this.logger_(`m3u8-parser info for ${url}: ${message}`),\n                manifestString,\n                customTagParsers: this.customTagParsers,\n                customTagMappers: this.customTagMappers,\n                llhls: this.llhls\n            });\n        }\n        /**\n         * Update the playlist loader's state in response to a new or updated playlist.\n         *\n         * @param {string} [playlistString]\n         *        Playlist string (if playlistObject is not provided)\n         * @param {Object} [playlistObject]\n         *        Playlist object (if playlistString is not provided)\n         * @param {string} url\n         *        URL of playlist\n         * @param {string} id\n         *        ID to use for playlist\n         */\n\n        haveMetadata({\n                         playlistString,\n                         playlistObject,\n                         url,\n                         id\n                     }) {\n            // any in-flight request is now finished\n            this.request = null;\n            this.state = 'HAVE_METADATA';\n            const playlist = playlistObject || this.parseManifest_({\n                url,\n                manifestString: playlistString\n            });\n            playlist.lastRequest = Date.now();\n            setupMediaPlaylist({\n                playlist,\n                uri: url,\n                id\n            }); // merge this playlist into the main manifest\n\n            const update = updateMain$1(this.main, playlist);\n            this.targetDuration = playlist.partTargetDuration || playlist.targetDuration;\n            this.pendingMedia_ = null;\n            if (update) {\n                this.main = update;\n                this.media_ = this.main.playlists[id];\n            } else {\n                this.trigger('playlistunchanged');\n            }\n            this.updateMediaUpdateTimeout_(refreshDelay(this.media(), !!update));\n            this.trigger('loadedplaylist');\n        }\n        /**\n         * Abort any outstanding work and clean up.\n         */\n\n        dispose() {\n            this.trigger('dispose');\n            this.stopRequest();\n            window.clearTimeout(this.mediaUpdateTimeout);\n            window.clearTimeout(this.finalRenditionTimeout);\n            this.off();\n        }\n        stopRequest() {\n            if (this.request) {\n                const oldRequest = this.request;\n                this.request = null;\n                oldRequest.onreadystatechange = null;\n                oldRequest.abort();\n            }\n        }\n        /**\n         * When called without any arguments, returns the currently\n         * active media playlist. When called with a single argument,\n         * triggers the playlist loader to asynchronously switch to the\n         * specified media playlist. Calling this method while the\n         * loader is in the HAVE_NOTHING causes an error to be emitted\n         * but otherwise has no effect.\n         *\n         * @param {Object=} playlist the parsed media playlist\n         * object to switch to\n         * @param {boolean=} shouldDelay whether we should delay the request by half target duration\n         *\n         * @return {Playlist} the current loaded media\n         */\n\n        media(playlist, shouldDelay) {\n            // getter\n            if (!playlist) {\n                return this.media_;\n            } // setter\n\n            if (this.state === 'HAVE_NOTHING') {\n                throw new Error('Cannot switch media playlist from ' + this.state);\n            } // find the playlist object if the target playlist has been\n            // specified by URI\n\n            if (typeof playlist === 'string') {\n                if (!this.main.playlists[playlist]) {\n                    throw new Error('Unknown playlist URI: ' + playlist);\n                }\n                playlist = this.main.playlists[playlist];\n            }\n            window.clearTimeout(this.finalRenditionTimeout);\n            if (shouldDelay) {\n                const delay = (playlist.partTargetDuration || playlist.targetDuration) / 2 * 1000 || 5 * 1000;\n                this.finalRenditionTimeout = window.setTimeout(this.media.bind(this, playlist, false), delay);\n                return;\n            }\n            const startingState = this.state;\n            const mediaChange = !this.media_ || playlist.id !== this.media_.id;\n            const mainPlaylistRef = this.main.playlists[playlist.id]; // switch to fully loaded playlists immediately\n\n            if (mainPlaylistRef && mainPlaylistRef.endList ||\n                // handle the case of a playlist object (e.g., if using vhs-json with a resolved\n                // media playlist or, for the case of demuxed audio, a resolved audio media group)\n                playlist.endList && playlist.segments.length) {\n                // abort outstanding playlist requests\n                if (this.request) {\n                    this.request.onreadystatechange = null;\n                    this.request.abort();\n                    this.request = null;\n                }\n                this.state = 'HAVE_METADATA';\n                this.media_ = playlist; // trigger media change if the active media has been updated\n\n                if (mediaChange) {\n                    this.trigger('mediachanging');\n                    if (startingState === 'HAVE_MAIN_MANIFEST') {\n                        // The initial playlist was a main manifest, and the first media selected was\n                        // also provided (in the form of a resolved playlist object) as part of the\n                        // source object (rather than just a URL). Therefore, since the media playlist\n                        // doesn't need to be requested, loadedmetadata won't trigger as part of the\n                        // normal flow, and needs an explicit trigger here.\n                        this.trigger('loadedmetadata');\n                    } else {\n                        this.trigger('mediachange');\n                    }\n                }\n                return;\n            } // We update/set the timeout here so that live playlists\n            // that are not a media change will \"start\" the loader as expected.\n            // We expect that this function will start the media update timeout\n            // cycle again. This also prevents a playlist switch failure from\n            // causing us to stall during live.\n\n            this.updateMediaUpdateTimeout_(refreshDelay(playlist, true)); // switching to the active playlist is a no-op\n\n            if (!mediaChange) {\n                return;\n            }\n            this.state = 'SWITCHING_MEDIA'; // there is already an outstanding playlist request\n\n            if (this.request) {\n                if (playlist.resolvedUri === this.request.url) {\n                    // requesting to switch to the same playlist multiple times\n                    // has no effect after the first\n                    return;\n                }\n                this.request.onreadystatechange = null;\n                this.request.abort();\n                this.request = null;\n            } // request the new playlist\n\n            if (this.media_) {\n                this.trigger('mediachanging');\n            }\n            this.pendingMedia_ = playlist;\n            this.request = this.vhs_.xhr({\n                uri: playlist.resolvedUri,\n                withCredentials: this.withCredentials\n            }, (error, req) => {\n                // disposed\n                if (!this.request) {\n                    return;\n                }\n                playlist.lastRequest = Date.now();\n                playlist.resolvedUri = resolveManifestRedirect(playlist.resolvedUri, req);\n                if (error) {\n                    return this.playlistRequestError(this.request, playlist, startingState);\n                }\n                this.haveMetadata({\n                    playlistString: req.responseText,\n                    url: playlist.uri,\n                    id: playlist.id\n                }); // fire loadedmetadata the first time a media playlist is loaded\n\n                if (startingState === 'HAVE_MAIN_MANIFEST') {\n                    this.trigger('loadedmetadata');\n                } else {\n                    this.trigger('mediachange');\n                }\n            });\n        }\n        /**\n         * pause loading of the playlist\n         */\n\n        pause() {\n            if (this.mediaUpdateTimeout) {\n                window.clearTimeout(this.mediaUpdateTimeout);\n                this.mediaUpdateTimeout = null;\n            }\n            this.stopRequest();\n            if (this.state === 'HAVE_NOTHING') {\n                // If we pause the loader before any data has been retrieved, its as if we never\n                // started, so reset to an unstarted state.\n                this.started = false;\n            } // Need to restore state now that no activity is happening\n\n            if (this.state === 'SWITCHING_MEDIA') {\n                // if the loader was in the process of switching media, it should either return to\n                // HAVE_MAIN_MANIFEST or HAVE_METADATA depending on if the loader has loaded a media\n                // playlist yet. This is determined by the existence of loader.media_\n                if (this.media_) {\n                    this.state = 'HAVE_METADATA';\n                } else {\n                    this.state = 'HAVE_MAIN_MANIFEST';\n                }\n            } else if (this.state === 'HAVE_CURRENT_METADATA') {\n                this.state = 'HAVE_METADATA';\n            }\n        }\n        /**\n         * start loading of the playlist\n         */\n\n        load(shouldDelay) {\n            if (this.mediaUpdateTimeout) {\n                window.clearTimeout(this.mediaUpdateTimeout);\n                this.mediaUpdateTimeout = null;\n            }\n            const media = this.media();\n            if (shouldDelay) {\n                const delay = media ? (media.partTargetDuration || media.targetDuration) / 2 * 1000 : 5 * 1000;\n                this.mediaUpdateTimeout = window.setTimeout(() => {\n                    this.mediaUpdateTimeout = null;\n                    this.load();\n                }, delay);\n                return;\n            }\n            if (!this.started) {\n                this.start();\n                return;\n            }\n            if (media && !media.endList) {\n                this.trigger('mediaupdatetimeout');\n            } else {\n                this.trigger('loadedplaylist');\n            }\n        }\n        updateMediaUpdateTimeout_(delay) {\n            if (this.mediaUpdateTimeout) {\n                window.clearTimeout(this.mediaUpdateTimeout);\n                this.mediaUpdateTimeout = null;\n            } // we only have use mediaupdatetimeout for live playlists.\n\n            if (!this.media() || this.media().endList) {\n                return;\n            }\n            this.mediaUpdateTimeout = window.setTimeout(() => {\n                this.mediaUpdateTimeout = null;\n                this.trigger('mediaupdatetimeout');\n                this.updateMediaUpdateTimeout_(delay);\n            }, delay);\n        }\n        /**\n         * start loading of the playlist\n         */\n\n        start() {\n            this.started = true;\n            if (typeof this.src === 'object') {\n                // in the case of an entirely constructed manifest object (meaning there's no actual\n                // manifest on a server), default the uri to the page's href\n                if (!this.src.uri) {\n                    this.src.uri = window.location.href;\n                } // resolvedUri is added on internally after the initial request. Since there's no\n                // request for pre-resolved manifests, add on resolvedUri here.\n\n                this.src.resolvedUri = this.src.uri; // Since a manifest object was passed in as the source (instead of a URL), the first\n                // request can be skipped (since the top level of the manifest, at a minimum, is\n                // already available as a parsed manifest object). However, if the manifest object\n                // represents a main playlist, some media playlists may need to be resolved before\n                // the starting segment list is available. Therefore, go directly to setup of the\n                // initial playlist, and let the normal flow continue from there.\n                //\n                // Note that the call to setup is asynchronous, as other sections of VHS may assume\n                // that the first request is asynchronous.\n\n                setTimeout(() => {\n                    this.setupInitialPlaylist(this.src);\n                }, 0);\n                return;\n            } // request the specified URL\n\n            this.request = this.vhs_.xhr({\n                uri: this.src,\n                withCredentials: this.withCredentials\n            }, (error, req) => {\n                // disposed\n                if (!this.request) {\n                    return;\n                } // clear the loader's request reference\n\n                this.request = null;\n                if (error) {\n                    this.error = {\n                        status: req.status,\n                        message: `HLS playlist request error at URL: ${this.src}.`,\n                        responseText: req.responseText,\n                        // MEDIA_ERR_NETWORK\n                        code: 2\n                    };\n                    if (this.state === 'HAVE_NOTHING') {\n                        this.started = false;\n                    }\n                    return this.trigger('error');\n                }\n                this.src = resolveManifestRedirect(this.src, req);\n                const manifest = this.parseManifest_({\n                    manifestString: req.responseText,\n                    url: this.src\n                });\n                this.setupInitialPlaylist(manifest);\n            });\n        }\n        srcUri() {\n            return typeof this.src === 'string' ? this.src : this.src.uri;\n        }\n        /**\n         * Given a manifest object that's either a main or media playlist, trigger the proper\n         * events and set the state of the playlist loader.\n         *\n         * If the manifest object represents a main playlist, `loadedplaylist` will be\n         * triggered to allow listeners to select a playlist. If none is selected, the loader\n         * will default to the first one in the playlists array.\n         *\n         * If the manifest object represents a media playlist, `loadedplaylist` will be\n         * triggered followed by `loadedmetadata`, as the only available playlist is loaded.\n         *\n         * In the case of a media playlist, a main playlist object wrapper with one playlist\n         * will be created so that all logic can handle playlists in the same fashion (as an\n         * assumed manifest object schema).\n         *\n         * @param {Object} manifest\n         *        The parsed manifest object\n         */\n\n        setupInitialPlaylist(manifest) {\n            this.state = 'HAVE_MAIN_MANIFEST';\n            if (manifest.playlists) {\n                this.main = manifest;\n                addPropertiesToMain(this.main, this.srcUri()); // If the initial main playlist has playlists wtih segments already resolved,\n                // then resolve URIs in advance, as they are usually done after a playlist request,\n                // which may not happen if the playlist is resolved.\n\n                manifest.playlists.forEach(playlist => {\n                    playlist.segments = getAllSegments(playlist);\n                    playlist.segments.forEach(segment => {\n                        resolveSegmentUris(segment, playlist.resolvedUri);\n                    });\n                });\n                this.trigger('loadedplaylist');\n                if (!this.request) {\n                    // no media playlist was specifically selected so start\n                    // from the first listed one\n                    this.media(this.main.playlists[0]);\n                }\n                return;\n            } // In order to support media playlists passed in as vhs-json, the case where the uri\n            // is not provided as part of the manifest should be considered, and an appropriate\n            // default used.\n\n            const uri = this.srcUri() || window.location.href;\n            this.main = mainForMedia(manifest, uri);\n            this.haveMetadata({\n                playlistObject: manifest,\n                url: uri,\n                id: this.main.playlists[0].id\n            });\n            this.trigger('loadedmetadata');\n        }\n    }\n\n    /**\n     * @file xhr.js\n     */\n    const {\n        xhr: videojsXHR\n    } = videojs;\n    const callbackWrapper = function (request, error, response, callback) {\n        const reqResponse = request.responseType === 'arraybuffer' ? request.response : request.responseText;\n        if (!error && reqResponse) {\n            request.responseTime = Date.now();\n            request.roundTripTime = request.responseTime - request.requestTime;\n            request.bytesReceived = reqResponse.byteLength || reqResponse.length;\n            if (!request.bandwidth) {\n                request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8 * 1000);\n            }\n        }\n        if (response.headers) {\n            request.responseHeaders = response.headers;\n        } // videojs.xhr now uses a specific code on the error\n        // object to signal that a request has timed out instead\n        // of setting a boolean on the request object\n\n        if (error && error.code === 'ETIMEDOUT') {\n            request.timedout = true;\n        } // videojs.xhr no longer considers status codes outside of 200 and 0\n        // (for file uris) to be errors, but the old XHR did, so emulate that\n        // behavior. Status 206 may be used in response to byterange requests.\n\n        if (!error && !request.aborted && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) {\n            error = new Error('XHR Failed with a response of: ' + (request && (reqResponse || request.responseText)));\n        }\n        callback(error, request);\n    };\n    const xhrFactory = function () {\n        const xhr = function XhrFunction(options, callback) {\n            // Add a default timeout\n            options = merge({\n                timeout: 45e3\n            }, options); // Allow an optional user-specified function to modify the option\n            // object before we construct the xhr request\n\n            const beforeRequest = XhrFunction.beforeRequest || videojs.Vhs.xhr.beforeRequest;\n            if (beforeRequest && typeof beforeRequest === 'function') {\n                const newOptions = beforeRequest(options);\n                if (newOptions) {\n                    options = newOptions;\n                }\n            } // Use the standard videojs.xhr() method unless `videojs.Vhs.xhr` has been overriden\n            // TODO: switch back to videojs.Vhs.xhr.name === 'XhrFunction' when we drop IE11\n\n            const xhrMethod = videojs.Vhs.xhr.original === true ? videojsXHR : videojs.Vhs.xhr;\n            const request = xhrMethod(options, function (error, response) {\n                return callbackWrapper(request, error, response, callback);\n            });\n            const originalAbort = request.abort;\n            request.abort = function () {\n                request.aborted = true;\n                return originalAbort.apply(request, arguments);\n            };\n            request.uri = options.uri;\n            request.requestTime = Date.now();\n            return request;\n        };\n        xhr.original = true;\n        return xhr;\n    };\n    /**\n     * Turns segment byterange into a string suitable for use in\n     * HTTP Range requests\n     *\n     * @param {Object} byterange - an object with two values defining the start and end\n     *                             of a byte-range\n     */\n\n    const byterangeStr = function (byterange) {\n        // `byterangeEnd` is one less than `offset + length` because the HTTP range\n        // header uses inclusive ranges\n        let byterangeEnd;\n        const byterangeStart = byterange.offset;\n        if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\n            byterangeEnd = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);\n        } else {\n            byterangeEnd = byterange.offset + byterange.length - 1;\n        }\n        return 'bytes=' + byterangeStart + '-' + byterangeEnd;\n    };\n    /**\n     * Defines headers for use in the xhr request for a particular segment.\n     *\n     * @param {Object} segment - a simplified copy of the segmentInfo object\n     *                           from SegmentLoader\n     */\n\n    const segmentXhrHeaders = function (segment) {\n        const headers = {};\n        if (segment.byterange) {\n            headers.Range = byterangeStr(segment.byterange);\n        }\n        return headers;\n    };\n\n    /**\n     * @file bin-utils.js\n     */\n\n    /**\n     * convert a TimeRange to text\n     *\n     * @param {TimeRange} range the timerange to use for conversion\n     * @param {number} i the iterator on the range to convert\n     * @return {string} the range in string format\n     */\n\n    const textRange = function (range, i) {\n        return range.start(i) + '-' + range.end(i);\n    };\n    /**\n     * format a number as hex string\n     *\n     * @param {number} e The number\n     * @param {number} i the iterator\n     * @return {string} the hex formatted number as a string\n     */\n\n    const formatHexString = function (e, i) {\n        const value = e.toString(16);\n        return '00'.substring(0, 2 - value.length) + value + (i % 2 ? ' ' : '');\n    };\n    const formatAsciiString = function (e) {\n        if (e >= 0x20 && e < 0x7e) {\n            return String.fromCharCode(e);\n        }\n        return '.';\n    };\n    /**\n     * Creates an object for sending to a web worker modifying properties that are TypedArrays\n     * into a new object with seperated properties for the buffer, byteOffset, and byteLength.\n     *\n     * @param {Object} message\n     *        Object of properties and values to send to the web worker\n     * @return {Object}\n     *         Modified message with TypedArray values expanded\n     * @function createTransferableMessage\n     */\n\n    const createTransferableMessage = function (message) {\n        const transferable = {};\n        Object.keys(message).forEach(key => {\n            const value = message[key];\n            if (isArrayBufferView(value)) {\n                transferable[key] = {\n                    bytes: value.buffer,\n                    byteOffset: value.byteOffset,\n                    byteLength: value.byteLength\n                };\n            } else {\n                transferable[key] = value;\n            }\n        });\n        return transferable;\n    };\n    /**\n     * Returns a unique string identifier for a media initialization\n     * segment.\n     *\n     * @param {Object} initSegment\n     *        the init segment object.\n     *\n     * @return {string} the generated init segment id\n     */\n\n    const initSegmentId = function (initSegment) {\n        const byterange = initSegment.byterange || {\n            length: Infinity,\n            offset: 0\n        };\n        return [byterange.length, byterange.offset, initSegment.resolvedUri].join(',');\n    };\n    /**\n     * Returns a unique string identifier for a media segment key.\n     *\n     * @param {Object} key the encryption key\n     * @return {string} the unique id for the media segment key.\n     */\n\n    const segmentKeyId = function (key) {\n        return key.resolvedUri;\n    };\n    /**\n     * utils to help dump binary data to the console\n     *\n     * @param {Array|TypedArray} data\n     *        data to dump to a string\n     *\n     * @return {string} the data as a hex string.\n     */\n\n    const hexDump = data => {\n        const bytes = Array.prototype.slice.call(data);\n        const step = 16;\n        let result = '';\n        let hex;\n        let ascii;\n        for (let j = 0; j < bytes.length / step; j++) {\n            hex = bytes.slice(j * step, j * step + step).map(formatHexString).join('');\n            ascii = bytes.slice(j * step, j * step + step).map(formatAsciiString).join('');\n            result += hex + ' ' + ascii + '\\n';\n        }\n        return result;\n    };\n    const tagDump = ({\n                         bytes\n                     }) => hexDump(bytes);\n    const textRanges = ranges => {\n        let result = '';\n        let i;\n        for (i = 0; i < ranges.length; i++) {\n            result += textRange(ranges, i) + ' ';\n        }\n        return result;\n    };\n    var utils = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        createTransferableMessage: createTransferableMessage,\n        initSegmentId: initSegmentId,\n        segmentKeyId: segmentKeyId,\n        hexDump: hexDump,\n        tagDump: tagDump,\n        textRanges: textRanges\n    });\n\n    // TODO handle fmp4 case where the timing info is accurate and doesn't involve transmux\n    // 25% was arbitrarily chosen, and may need to be refined over time.\n\n    const SEGMENT_END_FUDGE_PERCENT = 0.25;\n    /**\n     * Converts a player time (any time that can be gotten/set from player.currentTime(),\n     * e.g., any time within player.seekable().start(0) to player.seekable().end(0)) to a\n     * program time (any time referencing the real world (e.g., EXT-X-PROGRAM-DATE-TIME)).\n     *\n     * The containing segment is required as the EXT-X-PROGRAM-DATE-TIME serves as an \"anchor\n     * point\" (a point where we have a mapping from program time to player time, with player\n     * time being the post transmux start of the segment).\n     *\n     * For more details, see [this doc](../../docs/program-time-from-player-time.md).\n     *\n     * @param {number} playerTime the player time\n     * @param {Object} segment the segment which contains the player time\n     * @return {Date} program time\n     */\n\n    const playerTimeToProgramTime = (playerTime, segment) => {\n        if (!segment.dateTimeObject) {\n            // Can't convert without an \"anchor point\" for the program time (i.e., a time that can\n            // be used to map the start of a segment with a real world time).\n            return null;\n        }\n        const transmuxerPrependedSeconds = segment.videoTimingInfo.transmuxerPrependedSeconds;\n        const transmuxedStart = segment.videoTimingInfo.transmuxedPresentationStart; // get the start of the content from before old content is prepended\n\n        const startOfSegment = transmuxedStart + transmuxerPrependedSeconds;\n        const offsetFromSegmentStart = playerTime - startOfSegment;\n        return new Date(segment.dateTimeObject.getTime() + offsetFromSegmentStart * 1000);\n    };\n    const originalSegmentVideoDuration = videoTimingInfo => {\n        return videoTimingInfo.transmuxedPresentationEnd - videoTimingInfo.transmuxedPresentationStart - videoTimingInfo.transmuxerPrependedSeconds;\n    };\n    /**\n     * Finds a segment that contains the time requested given as an ISO-8601 string. The\n     * returned segment might be an estimate or an accurate match.\n     *\n     * @param {string} programTime The ISO-8601 programTime to find a match for\n     * @param {Object} playlist A playlist object to search within\n     */\n\n    const findSegmentForProgramTime = (programTime, playlist) => {\n        // Assumptions:\n        //  - verifyProgramDateTimeTags has already been run\n        //  - live streams have been started\n        let dateTimeObject;\n        try {\n            dateTimeObject = new Date(programTime);\n        } catch (e) {\n            return null;\n        }\n        if (!playlist || !playlist.segments || playlist.segments.length === 0) {\n            return null;\n        }\n        let segment = playlist.segments[0];\n        if (dateTimeObject < segment.dateTimeObject) {\n            // Requested time is before stream start.\n            return null;\n        }\n        for (let i = 0; i < playlist.segments.length - 1; i++) {\n            segment = playlist.segments[i];\n            const nextSegmentStart = playlist.segments[i + 1].dateTimeObject;\n            if (dateTimeObject < nextSegmentStart) {\n                break;\n            }\n        }\n        const lastSegment = playlist.segments[playlist.segments.length - 1];\n        const lastSegmentStart = lastSegment.dateTimeObject;\n        const lastSegmentDuration = lastSegment.videoTimingInfo ? originalSegmentVideoDuration(lastSegment.videoTimingInfo) : lastSegment.duration + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT;\n        const lastSegmentEnd = new Date(lastSegmentStart.getTime() + lastSegmentDuration * 1000);\n        if (dateTimeObject > lastSegmentEnd) {\n            // Beyond the end of the stream, or our best guess of the end of the stream.\n            return null;\n        }\n        if (dateTimeObject > lastSegmentStart) {\n            segment = lastSegment;\n        }\n        return {\n            segment,\n            estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : Playlist.duration(playlist, playlist.mediaSequence + playlist.segments.indexOf(segment)),\n            // Although, given that all segments have accurate date time objects, the segment\n            // selected should be accurate, unless the video has been transmuxed at some point\n            // (determined by the presence of the videoTimingInfo object), the segment's \"player\n            // time\" (the start time in the player) can't be considered accurate.\n            type: segment.videoTimingInfo ? 'accurate' : 'estimate'\n        };\n    };\n    /**\n     * Finds a segment that contains the given player time(in seconds).\n     *\n     * @param {number} time The player time to find a match for\n     * @param {Object} playlist A playlist object to search within\n     */\n\n    const findSegmentForPlayerTime = (time, playlist) => {\n        // Assumptions:\n        // - there will always be a segment.duration\n        // - we can start from zero\n        // - segments are in time order\n        if (!playlist || !playlist.segments || playlist.segments.length === 0) {\n            return null;\n        }\n        let segmentEnd = 0;\n        let segment;\n        for (let i = 0; i < playlist.segments.length; i++) {\n            segment = playlist.segments[i]; // videoTimingInfo is set after the segment is downloaded and transmuxed, and\n            // should contain the most accurate values we have for the segment's player times.\n            //\n            // Use the accurate transmuxedPresentationEnd value if it is available, otherwise fall\n            // back to an estimate based on the manifest derived (inaccurate) segment.duration, to\n            // calculate an end value.\n\n            segmentEnd = segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationEnd : segmentEnd + segment.duration;\n            if (time <= segmentEnd) {\n                break;\n            }\n        }\n        const lastSegment = playlist.segments[playlist.segments.length - 1];\n        if (lastSegment.videoTimingInfo && lastSegment.videoTimingInfo.transmuxedPresentationEnd < time) {\n            // The time requested is beyond the stream end.\n            return null;\n        }\n        if (time > segmentEnd) {\n            // The time is within or beyond the last segment.\n            //\n            // Check to see if the time is beyond a reasonable guess of the end of the stream.\n            if (time > segmentEnd + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT) {\n                // Technically, because the duration value is only an estimate, the time may still\n                // exist in the last segment, however, there isn't enough information to make even\n                // a reasonable estimate.\n                return null;\n            }\n            segment = lastSegment;\n        }\n        return {\n            segment,\n            estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : segmentEnd - segment.duration,\n            // Because videoTimingInfo is only set after transmux, it is the only way to get\n            // accurate timing values.\n            type: segment.videoTimingInfo ? 'accurate' : 'estimate'\n        };\n    };\n    /**\n     * Gives the offset of the comparisonTimestamp from the programTime timestamp in seconds.\n     * If the offset returned is positive, the programTime occurs after the\n     * comparisonTimestamp.\n     * If the offset is negative, the programTime occurs before the comparisonTimestamp.\n     *\n     * @param {string} comparisonTimeStamp An ISO-8601 timestamp to compare against\n     * @param {string} programTime The programTime as an ISO-8601 string\n     * @return {number} offset\n     */\n\n    const getOffsetFromTimestamp = (comparisonTimeStamp, programTime) => {\n        let segmentDateTime;\n        let programDateTime;\n        try {\n            segmentDateTime = new Date(comparisonTimeStamp);\n            programDateTime = new Date(programTime);\n        } catch (e) {// TODO handle error\n        }\n        const segmentTimeEpoch = segmentDateTime.getTime();\n        const programTimeEpoch = programDateTime.getTime();\n        return (programTimeEpoch - segmentTimeEpoch) / 1000;\n    };\n    /**\n     * Checks that all segments in this playlist have programDateTime tags.\n     *\n     * @param {Object} playlist A playlist object\n     */\n\n    const verifyProgramDateTimeTags = playlist => {\n        if (!playlist.segments || playlist.segments.length === 0) {\n            return false;\n        }\n        for (let i = 0; i < playlist.segments.length; i++) {\n            const segment = playlist.segments[i];\n            if (!segment.dateTimeObject) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Returns the programTime of the media given a playlist and a playerTime.\n     * The playlist must have programDateTime tags for a programDateTime tag to be returned.\n     * If the segments containing the time requested have not been buffered yet, an estimate\n     * may be returned to the callback.\n     *\n     * @param {Object} args\n     * @param {Object} args.playlist A playlist object to search within\n     * @param {number} time A playerTime in seconds\n     * @param {Function} callback(err, programTime)\n     * @return {string} err.message A detailed error message\n     * @return {Object} programTime\n     * @return {number} programTime.mediaSeconds The streamTime in seconds\n     * @return {string} programTime.programDateTime The programTime as an ISO-8601 String\n     */\n\n    const getProgramTime = ({\n                                playlist,\n                                time = undefined,\n                                callback\n                            }) => {\n        if (!callback) {\n            throw new Error('getProgramTime: callback must be provided');\n        }\n        if (!playlist || time === undefined) {\n            return callback({\n                message: 'getProgramTime: playlist and time must be provided'\n            });\n        }\n        const matchedSegment = findSegmentForPlayerTime(time, playlist);\n        if (!matchedSegment) {\n            return callback({\n                message: 'valid programTime was not found'\n            });\n        }\n        if (matchedSegment.type === 'estimate') {\n            return callback({\n                message: 'Accurate programTime could not be determined.' + ' Please seek to e.seekTime and try again',\n                seekTime: matchedSegment.estimatedStart\n            });\n        }\n        const programTimeObject = {\n            mediaSeconds: time\n        };\n        const programTime = playerTimeToProgramTime(time, matchedSegment.segment);\n        if (programTime) {\n            programTimeObject.programDateTime = programTime.toISOString();\n        }\n        return callback(null, programTimeObject);\n    };\n    /**\n     * Seeks in the player to a time that matches the given programTime ISO-8601 string.\n     *\n     * @param {Object} args\n     * @param {string} args.programTime A programTime to seek to as an ISO-8601 String\n     * @param {Object} args.playlist A playlist to look within\n     * @param {number} args.retryCount The number of times to try for an accurate seek. Default is 2.\n     * @param {Function} args.seekTo A method to perform a seek\n     * @param {boolean} args.pauseAfterSeek Whether to end in a paused state after seeking. Default is true.\n     * @param {Object} args.tech The tech to seek on\n     * @param {Function} args.callback(err, newTime) A callback to return the new time to\n     * @return {string} err.message A detailed error message\n     * @return {number} newTime The exact time that was seeked to in seconds\n     */\n\n    const seekToProgramTime = ({\n                                   programTime,\n                                   playlist,\n                                   retryCount = 2,\n                                   seekTo,\n                                   pauseAfterSeek = true,\n                                   tech,\n                                   callback\n                               }) => {\n        if (!callback) {\n            throw new Error('seekToProgramTime: callback must be provided');\n        }\n        if (typeof programTime === 'undefined' || !playlist || !seekTo) {\n            return callback({\n                message: 'seekToProgramTime: programTime, seekTo and playlist must be provided'\n            });\n        }\n        if (!playlist.endList && !tech.hasStarted_) {\n            return callback({\n                message: 'player must be playing a live stream to start buffering'\n            });\n        }\n        if (!verifyProgramDateTimeTags(playlist)) {\n            return callback({\n                message: 'programDateTime tags must be provided in the manifest ' + playlist.resolvedUri\n            });\n        }\n        const matchedSegment = findSegmentForProgramTime(programTime, playlist); // no match\n\n        if (!matchedSegment) {\n            return callback({\n                message: `${programTime} was not found in the stream`\n            });\n        }\n        const segment = matchedSegment.segment;\n        const mediaOffset = getOffsetFromTimestamp(segment.dateTimeObject, programTime);\n        if (matchedSegment.type === 'estimate') {\n            // we've run out of retries\n            if (retryCount === 0) {\n                return callback({\n                    message: `${programTime} is not buffered yet. Try again`\n                });\n            }\n            seekTo(matchedSegment.estimatedStart + mediaOffset);\n            tech.one('seeked', () => {\n                seekToProgramTime({\n                    programTime,\n                    playlist,\n                    retryCount: retryCount - 1,\n                    seekTo,\n                    pauseAfterSeek,\n                    tech,\n                    callback\n                });\n            });\n            return;\n        } // Since the segment.start value is determined from the buffered end or ending time\n        // of the prior segment, the seekToTime doesn't need to account for any transmuxer\n        // modifications.\n\n        const seekToTime = segment.start + mediaOffset;\n        const seekedCallback = () => {\n            return callback(null, tech.currentTime());\n        }; // listen for seeked event\n\n        tech.one('seeked', seekedCallback); // pause before seeking as video.js will restore this state\n\n        if (pauseAfterSeek) {\n            tech.pause();\n        }\n        seekTo(seekToTime);\n    };\n\n    // which will only happen if the request is complete.\n\n    const callbackOnCompleted = (request, cb) => {\n        if (request.readyState === 4) {\n            return cb();\n        }\n        return;\n    };\n    const containerRequest = (uri, xhr, cb) => {\n        let bytes = [];\n        let id3Offset;\n        let finished = false;\n        const endRequestAndCallback = function (err, req, type, _bytes) {\n            req.abort();\n            finished = true;\n            return cb(err, req, type, _bytes);\n        };\n        const progressListener = function (error, request) {\n            if (finished) {\n                return;\n            }\n            if (error) {\n                return endRequestAndCallback(error, request, '', bytes);\n            } // grap the new part of content that was just downloaded\n\n            const newPart = request.responseText.substring(bytes && bytes.byteLength || 0, request.responseText.length); // add that onto bytes\n\n            bytes = concatTypedArrays(bytes, stringToBytes(newPart, true));\n            id3Offset = id3Offset || getId3Offset(bytes); // we need at least 10 bytes to determine a type\n            // or we need at least two bytes after an id3Offset\n\n            if (bytes.length < 10 || id3Offset && bytes.length < id3Offset + 2) {\n                return callbackOnCompleted(request, () => endRequestAndCallback(error, request, '', bytes));\n            }\n            const type = detectContainerForBytes(bytes); // if this looks like a ts segment but we don't have enough data\n            // to see the second sync byte, wait until we have enough data\n            // before declaring it ts\n\n            if (type === 'ts' && bytes.length < 188) {\n                return callbackOnCompleted(request, () => endRequestAndCallback(error, request, '', bytes));\n            } // this may be an unsynced ts segment\n            // wait for 376 bytes before detecting no container\n\n            if (!type && bytes.length < 376) {\n                return callbackOnCompleted(request, () => endRequestAndCallback(error, request, '', bytes));\n            }\n            return endRequestAndCallback(null, request, type, bytes);\n        };\n        const options = {\n            uri,\n            beforeSend(request) {\n                // this forces the browser to pass the bytes to us unprocessed\n                request.overrideMimeType('text/plain; charset=x-user-defined');\n                request.addEventListener('progress', function ({\n                                                                   total,\n                                                                   loaded\n                                                               }) {\n                    return callbackWrapper(request, null, {\n                        statusCode: request.status\n                    }, progressListener);\n                });\n            }\n        };\n        const request = xhr(options, function (error, response) {\n            return callbackWrapper(request, error, response, progressListener);\n        });\n        return request;\n    };\n    const {\n        EventTarget\n    } = videojs;\n    const dashPlaylistUnchanged = function (a, b) {\n        if (!isPlaylistUnchanged(a, b)) {\n            return false;\n        } // for dash the above check will often return true in scenarios where\n        // the playlist actually has changed because mediaSequence isn't a\n        // dash thing, and we often set it to 1. So if the playlists have the same amount\n        // of segments we return true.\n        // So for dash we need to make sure that the underlying segments are different.\n        // if sidx changed then the playlists are different.\n\n        if (a.sidx && b.sidx && (a.sidx.offset !== b.sidx.offset || a.sidx.length !== b.sidx.length)) {\n            return false;\n        } else if (!a.sidx && b.sidx || a.sidx && !b.sidx) {\n            return false;\n        } // one or the other does not have segments\n        // there was a change.\n\n        if (a.segments && !b.segments || !a.segments && b.segments) {\n            return false;\n        } // neither has segments nothing changed\n\n        if (!a.segments && !b.segments) {\n            return true;\n        } // check segments themselves\n\n        for (let i = 0; i < a.segments.length; i++) {\n            const aSegment = a.segments[i];\n            const bSegment = b.segments[i]; // if uris are different between segments there was a change\n\n            if (aSegment.uri !== bSegment.uri) {\n                return false;\n            } // neither segment has a byterange, there will be no byterange change.\n\n            if (!aSegment.byterange && !bSegment.byterange) {\n                continue;\n            }\n            const aByterange = aSegment.byterange;\n            const bByterange = bSegment.byterange; // if byterange only exists on one of the segments, there was a change.\n\n            if (aByterange && !bByterange || !aByterange && bByterange) {\n                return false;\n            } // if both segments have byterange with different offsets, there was a change.\n\n            if (aByterange.offset !== bByterange.offset || aByterange.length !== bByterange.length) {\n                return false;\n            }\n        } // if everything was the same with segments, this is the same playlist.\n\n        return true;\n    };\n    /**\n     * Use the representation IDs from the mpd object to create groupIDs, the NAME is set to mandatory representation\n     * ID in the parser. This allows for continuous playout across periods with the same representation IDs\n     * (continuous periods as defined in DASH-IF 3.2.12). This is assumed in the mpd-parser as well. If we want to support\n     * periods without continuous playback this function may need modification as well as the parser.\n     */\n\n    const dashGroupId = (type, group, label, playlist) => {\n        // If the manifest somehow does not have an ID (non-dash compliant), use the label.\n        const playlistId = playlist.attributes.NAME || label;\n        return `placeholder-uri-${type}-${group}-${playlistId}`;\n    };\n    /**\n     * Parses the main XML string and updates playlist URI references.\n     *\n     * @param {Object} config\n     *        Object of arguments\n     * @param {string} config.mainXml\n     *        The mpd XML\n     * @param {string} config.srcUrl\n     *        The mpd URL\n     * @param {Date} config.clientOffset\n     *         A time difference between server and client\n     * @param {Object} config.sidxMapping\n     *        SIDX mappings for moof/mdat URIs and byte ranges\n     * @return {Object}\n     *         The parsed mpd manifest object\n     */\n\n    const parseMainXml = ({\n                              mainXml,\n                              srcUrl,\n                              clientOffset,\n                              sidxMapping,\n                              previousManifest\n                          }) => {\n        const manifest = parse(mainXml, {\n            manifestUri: srcUrl,\n            clientOffset,\n            sidxMapping,\n            previousManifest\n        });\n        addPropertiesToMain(manifest, srcUrl, dashGroupId);\n        return manifest;\n    };\n    /**\n     * Removes any mediaGroup labels that no longer exist in the newMain\n     *\n     * @param {Object} update\n     *         The previous mpd object being updated\n     * @param {Object} newMain\n     *         The new mpd object\n     */\n\n    const removeOldMediaGroupLabels = (update, newMain) => {\n        forEachMediaGroup(update, (properties, type, group, label) => {\n            if (!(label in newMain.mediaGroups[type][group])) {\n                delete update.mediaGroups[type][group][label];\n            }\n        });\n    };\n    /**\n     * Returns a new main manifest that is the result of merging an updated main manifest\n     * into the original version.\n     *\n     * @param {Object} oldMain\n     *        The old parsed mpd object\n     * @param {Object} newMain\n     *        The updated parsed mpd object\n     * @return {Object}\n     *         A new object representing the original main manifest with the updated media\n     *         playlists merged in\n     */\n\n    const updateMain = (oldMain, newMain, sidxMapping) => {\n        let noChanges = true;\n        let update = merge(oldMain, {\n            // These are top level properties that can be updated\n            duration: newMain.duration,\n            minimumUpdatePeriod: newMain.minimumUpdatePeriod,\n            timelineStarts: newMain.timelineStarts\n        }); // First update the playlists in playlist list\n\n        for (let i = 0; i < newMain.playlists.length; i++) {\n            const playlist = newMain.playlists[i];\n            if (playlist.sidx) {\n                const sidxKey = generateSidxKey(playlist.sidx); // add sidx segments to the playlist if we have all the sidx info already\n\n                if (sidxMapping && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx) {\n                    addSidxSegmentsToPlaylist$1(playlist, sidxMapping[sidxKey].sidx, playlist.sidx.resolvedUri);\n                }\n            }\n            const playlistUpdate = updateMain$1(update, playlist, dashPlaylistUnchanged);\n            if (playlistUpdate) {\n                update = playlistUpdate;\n                noChanges = false;\n            }\n        } // Then update media group playlists\n\n        forEachMediaGroup(newMain, (properties, type, group, label) => {\n            if (properties.playlists && properties.playlists.length) {\n                const id = properties.playlists[0].id;\n                const playlistUpdate = updateMain$1(update, properties.playlists[0], dashPlaylistUnchanged);\n                if (playlistUpdate) {\n                    update = playlistUpdate; // add new mediaGroup label if it doesn't exist and assign the new mediaGroup.\n\n                    if (!(label in update.mediaGroups[type][group])) {\n                        update.mediaGroups[type][group][label] = properties;\n                    } // update the playlist reference within media groups\n\n                    update.mediaGroups[type][group][label].playlists[0] = update.playlists[id];\n                    noChanges = false;\n                }\n            }\n        }); // remove mediaGroup labels and references that no longer exist in the newMain\n\n        removeOldMediaGroupLabels(update, newMain);\n        if (newMain.minimumUpdatePeriod !== oldMain.minimumUpdatePeriod) {\n            noChanges = false;\n        }\n        if (noChanges) {\n            return null;\n        }\n        return update;\n    }; // SIDX should be equivalent if the URI and byteranges of the SIDX match.\n    // If the SIDXs have maps, the two maps should match,\n    // both `a` and `b` missing SIDXs is considered matching.\n    // If `a` or `b` but not both have a map, they aren't matching.\n\n    const equivalentSidx = (a, b) => {\n        const neitherMap = Boolean(!a.map && !b.map);\n        const equivalentMap = neitherMap || Boolean(a.map && b.map && a.map.byterange.offset === b.map.byterange.offset && a.map.byterange.length === b.map.byterange.length);\n        return equivalentMap && a.uri === b.uri && a.byterange.offset === b.byterange.offset && a.byterange.length === b.byterange.length;\n    }; // exported for testing\n\n    const compareSidxEntry = (playlists, oldSidxMapping) => {\n        const newSidxMapping = {};\n        for (const id in playlists) {\n            const playlist = playlists[id];\n            const currentSidxInfo = playlist.sidx;\n            if (currentSidxInfo) {\n                const key = generateSidxKey(currentSidxInfo);\n                if (!oldSidxMapping[key]) {\n                    break;\n                }\n                const savedSidxInfo = oldSidxMapping[key].sidxInfo;\n                if (equivalentSidx(savedSidxInfo, currentSidxInfo)) {\n                    newSidxMapping[key] = oldSidxMapping[key];\n                }\n            }\n        }\n        return newSidxMapping;\n    };\n    /**\n     *  A function that filters out changed items as they need to be requested separately.\n     *\n     *  The method is exported for testing\n     *\n     *  @param {Object} main the parsed mpd XML returned via mpd-parser\n     *  @param {Object} oldSidxMapping the SIDX to compare against\n     */\n\n    const filterChangedSidxMappings = (main, oldSidxMapping) => {\n        const videoSidx = compareSidxEntry(main.playlists, oldSidxMapping);\n        let mediaGroupSidx = videoSidx;\n        forEachMediaGroup(main, (properties, mediaType, groupKey, labelKey) => {\n            if (properties.playlists && properties.playlists.length) {\n                const playlists = properties.playlists;\n                mediaGroupSidx = merge(mediaGroupSidx, compareSidxEntry(playlists, oldSidxMapping));\n            }\n        });\n        return mediaGroupSidx;\n    };\n    class DashPlaylistLoader extends EventTarget {\n        // DashPlaylistLoader must accept either a src url or a playlist because subsequent\n        // playlist loader setups from media groups will expect to be able to pass a playlist\n        // (since there aren't external URLs to media playlists with DASH)\n        constructor(srcUrlOrPlaylist, vhs, options = {}, mainPlaylistLoader) {\n            super();\n            this.mainPlaylistLoader_ = mainPlaylistLoader || this;\n            if (!mainPlaylistLoader) {\n                this.isMain_ = true;\n            }\n            const {\n                withCredentials = false\n            } = options;\n            this.vhs_ = vhs;\n            this.withCredentials = withCredentials;\n            if (!srcUrlOrPlaylist) {\n                throw new Error('A non-empty playlist URL or object is required');\n            } // event naming?\n\n            this.on('minimumUpdatePeriod', () => {\n                this.refreshXml_();\n            }); // live playlist staleness timeout\n\n            this.on('mediaupdatetimeout', () => {\n                this.refreshMedia_(this.media().id);\n            });\n            this.state = 'HAVE_NOTHING';\n            this.loadedPlaylists_ = {};\n            this.logger_ = logger('DashPlaylistLoader'); // initialize the loader state\n            // The mainPlaylistLoader will be created with a string\n\n            if (this.isMain_) {\n                this.mainPlaylistLoader_.srcUrl = srcUrlOrPlaylist; // TODO: reset sidxMapping between period changes\n                // once multi-period is refactored\n\n                this.mainPlaylistLoader_.sidxMapping_ = {};\n            } else {\n                this.childPlaylist_ = srcUrlOrPlaylist;\n            }\n        }\n        requestErrored_(err, request, startingState) {\n            // disposed\n            if (!this.request) {\n                return true;\n            } // pending request is cleared\n\n            this.request = null;\n            if (err) {\n                // use the provided error object or create one\n                // based on the request/response\n                this.error = typeof err === 'object' && !(err instanceof Error) ? err : {\n                    status: request.status,\n                    message: 'DASH request error at URL: ' + request.uri,\n                    response: request.response,\n                    // MEDIA_ERR_NETWORK\n                    code: 2\n                };\n                if (startingState) {\n                    this.state = startingState;\n                }\n                this.trigger('error');\n                return true;\n            }\n        }\n        /**\n         * Verify that the container of the sidx segment can be parsed\n         * and if it can, get and parse that segment.\n         */\n\n        addSidxSegments_(playlist, startingState, cb) {\n            const sidxKey = playlist.sidx && generateSidxKey(playlist.sidx); // playlist lacks sidx or sidx segments were added to this playlist already.\n\n            if (!playlist.sidx || !sidxKey || this.mainPlaylistLoader_.sidxMapping_[sidxKey]) {\n                // keep this function async\n                this.mediaRequest_ = window.setTimeout(() => cb(false), 0);\n                return;\n            } // resolve the segment URL relative to the playlist\n\n            const uri = resolveManifestRedirect(playlist.sidx.resolvedUri);\n            const fin = (err, request) => {\n                if (this.requestErrored_(err, request, startingState)) {\n                    return;\n                }\n                const sidxMapping = this.mainPlaylistLoader_.sidxMapping_;\n                let sidx;\n                try {\n                    sidx = parseSidx_1(toUint8(request.response).subarray(8));\n                } catch (e) {\n                    // sidx parsing failed.\n                    this.requestErrored_(e, request, startingState);\n                    return;\n                }\n                sidxMapping[sidxKey] = {\n                    sidxInfo: playlist.sidx,\n                    sidx\n                };\n                addSidxSegmentsToPlaylist$1(playlist, sidx, playlist.sidx.resolvedUri);\n                return cb(true);\n            };\n            this.request = containerRequest(uri, this.vhs_.xhr, (err, request, container, bytes) => {\n                if (err) {\n                    return fin(err, request);\n                }\n                if (!container || container !== 'mp4') {\n                    return fin({\n                        status: request.status,\n                        message: `Unsupported ${container || 'unknown'} container type for sidx segment at URL: ${uri}`,\n                        // response is just bytes in this case\n                        // but we really don't want to return that.\n                        response: '',\n                        playlist,\n                        internal: true,\n                        playlistExclusionDuration: Infinity,\n                        // MEDIA_ERR_NETWORK\n                        code: 2\n                    }, request);\n                } // if we already downloaded the sidx bytes in the container request, use them\n\n                const {\n                    offset,\n                    length\n                } = playlist.sidx.byterange;\n                if (bytes.length >= length + offset) {\n                    return fin(err, {\n                        response: bytes.subarray(offset, offset + length),\n                        status: request.status,\n                        uri: request.uri\n                    });\n                } // otherwise request sidx bytes\n\n                this.request = this.vhs_.xhr({\n                    uri,\n                    responseType: 'arraybuffer',\n                    headers: segmentXhrHeaders({\n                        byterange: playlist.sidx.byterange\n                    })\n                }, fin);\n            });\n        }\n        dispose() {\n            this.trigger('dispose');\n            this.stopRequest();\n            this.loadedPlaylists_ = {};\n            window.clearTimeout(this.minimumUpdatePeriodTimeout_);\n            window.clearTimeout(this.mediaRequest_);\n            window.clearTimeout(this.mediaUpdateTimeout);\n            this.mediaUpdateTimeout = null;\n            this.mediaRequest_ = null;\n            this.minimumUpdatePeriodTimeout_ = null;\n            if (this.mainPlaylistLoader_.createMupOnMedia_) {\n                this.off('loadedmetadata', this.mainPlaylistLoader_.createMupOnMedia_);\n                this.mainPlaylistLoader_.createMupOnMedia_ = null;\n            }\n            this.off();\n        }\n        hasPendingRequest() {\n            return this.request || this.mediaRequest_;\n        }\n        stopRequest() {\n            if (this.request) {\n                const oldRequest = this.request;\n                this.request = null;\n                oldRequest.onreadystatechange = null;\n                oldRequest.abort();\n            }\n        }\n        media(playlist) {\n            // getter\n            if (!playlist) {\n                return this.media_;\n            } // setter\n\n            if (this.state === 'HAVE_NOTHING') {\n                throw new Error('Cannot switch media playlist from ' + this.state);\n            }\n            const startingState = this.state; // find the playlist object if the target playlist has been specified by URI\n\n            if (typeof playlist === 'string') {\n                if (!this.mainPlaylistLoader_.main.playlists[playlist]) {\n                    throw new Error('Unknown playlist URI: ' + playlist);\n                }\n                playlist = this.mainPlaylistLoader_.main.playlists[playlist];\n            }\n            const mediaChange = !this.media_ || playlist.id !== this.media_.id; // switch to previously loaded playlists immediately\n\n            if (mediaChange && this.loadedPlaylists_[playlist.id] && this.loadedPlaylists_[playlist.id].endList) {\n                this.state = 'HAVE_METADATA';\n                this.media_ = playlist; // trigger media change if the active media has been updated\n\n                if (mediaChange) {\n                    this.trigger('mediachanging');\n                    this.trigger('mediachange');\n                }\n                return;\n            } // switching to the active playlist is a no-op\n\n            if (!mediaChange) {\n                return;\n            } // switching from an already loaded playlist\n\n            if (this.media_) {\n                this.trigger('mediachanging');\n            }\n            this.addSidxSegments_(playlist, startingState, sidxChanged => {\n                // everything is ready just continue to haveMetadata\n                this.haveMetadata({\n                    startingState,\n                    playlist\n                });\n            });\n        }\n        haveMetadata({\n                         startingState,\n                         playlist\n                     }) {\n            this.state = 'HAVE_METADATA';\n            this.loadedPlaylists_[playlist.id] = playlist;\n            this.mediaRequest_ = null; // This will trigger loadedplaylist\n\n            this.refreshMedia_(playlist.id); // fire loadedmetadata the first time a media playlist is loaded\n            // to resolve setup of media groups\n\n            if (startingState === 'HAVE_MAIN_MANIFEST') {\n                this.trigger('loadedmetadata');\n            } else {\n                // trigger media change if the active media has been updated\n                this.trigger('mediachange');\n            }\n        }\n        pause() {\n            if (this.mainPlaylistLoader_.createMupOnMedia_) {\n                this.off('loadedmetadata', this.mainPlaylistLoader_.createMupOnMedia_);\n                this.mainPlaylistLoader_.createMupOnMedia_ = null;\n            }\n            this.stopRequest();\n            window.clearTimeout(this.mediaUpdateTimeout);\n            this.mediaUpdateTimeout = null;\n            if (this.isMain_) {\n                window.clearTimeout(this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_);\n                this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_ = null;\n            }\n            if (this.state === 'HAVE_NOTHING') {\n                // If we pause the loader before any data has been retrieved, its as if we never\n                // started, so reset to an unstarted state.\n                this.started = false;\n            }\n        }\n        load(isFinalRendition) {\n            window.clearTimeout(this.mediaUpdateTimeout);\n            this.mediaUpdateTimeout = null;\n            const media = this.media();\n            if (isFinalRendition) {\n                const delay = media ? media.targetDuration / 2 * 1000 : 5 * 1000;\n                this.mediaUpdateTimeout = window.setTimeout(() => this.load(), delay);\n                return;\n            } // because the playlists are internal to the manifest, load should either load the\n            // main manifest, or do nothing but trigger an event\n\n            if (!this.started) {\n                this.start();\n                return;\n            }\n            if (media && !media.endList) {\n                // Check to see if this is the main loader and the MUP was cleared (this happens\n                // when the loader was paused). `media` should be set at this point since one is always\n                // set during `start()`.\n                if (this.isMain_ && !this.minimumUpdatePeriodTimeout_) {\n                    // Trigger minimumUpdatePeriod to refresh the main manifest\n                    this.trigger('minimumUpdatePeriod'); // Since there was no prior minimumUpdatePeriodTimeout it should be recreated\n\n                    this.updateMinimumUpdatePeriodTimeout_();\n                }\n                this.trigger('mediaupdatetimeout');\n            } else {\n                this.trigger('loadedplaylist');\n            }\n        }\n        start() {\n            this.started = true; // We don't need to request the main manifest again\n            // Call this asynchronously to match the xhr request behavior below\n\n            if (!this.isMain_) {\n                this.mediaRequest_ = window.setTimeout(() => this.haveMain_(), 0);\n                return;\n            }\n            this.requestMain_((req, mainChanged) => {\n                this.haveMain_();\n                if (!this.hasPendingRequest() && !this.media_) {\n                    this.media(this.mainPlaylistLoader_.main.playlists[0]);\n                }\n            });\n        }\n        requestMain_(cb) {\n            this.request = this.vhs_.xhr({\n                uri: this.mainPlaylistLoader_.srcUrl,\n                withCredentials: this.withCredentials\n            }, (error, req) => {\n                if (this.requestErrored_(error, req)) {\n                    if (this.state === 'HAVE_NOTHING') {\n                        this.started = false;\n                    }\n                    return;\n                }\n                const mainChanged = req.responseText !== this.mainPlaylistLoader_.mainXml_;\n                this.mainPlaylistLoader_.mainXml_ = req.responseText;\n                if (req.responseHeaders && req.responseHeaders.date) {\n                    this.mainLoaded_ = Date.parse(req.responseHeaders.date);\n                } else {\n                    this.mainLoaded_ = Date.now();\n                }\n                this.mainPlaylistLoader_.srcUrl = resolveManifestRedirect(this.mainPlaylistLoader_.srcUrl, req);\n                if (mainChanged) {\n                    this.handleMain_();\n                    this.syncClientServerClock_(() => {\n                        return cb(req, mainChanged);\n                    });\n                    return;\n                }\n                return cb(req, mainChanged);\n            });\n        }\n        /**\n         * Parses the main xml for UTCTiming node to sync the client clock to the server\n         * clock. If the UTCTiming node requires a HEAD or GET request, that request is made.\n         *\n         * @param {Function} done\n         *        Function to call when clock sync has completed\n         */\n\n        syncClientServerClock_(done) {\n            const utcTiming = parseUTCTiming(this.mainPlaylistLoader_.mainXml_); // No UTCTiming element found in the mpd. Use Date header from mpd request as the\n            // server clock\n\n            if (utcTiming === null) {\n                this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now();\n                return done();\n            }\n            if (utcTiming.method === 'DIRECT') {\n                this.mainPlaylistLoader_.clientOffset_ = utcTiming.value - Date.now();\n                return done();\n            }\n            this.request = this.vhs_.xhr({\n                uri: resolveUrl(this.mainPlaylistLoader_.srcUrl, utcTiming.value),\n                method: utcTiming.method,\n                withCredentials: this.withCredentials\n            }, (error, req) => {\n                // disposed\n                if (!this.request) {\n                    return;\n                }\n                if (error) {\n                    // sync request failed, fall back to using date header from mpd\n                    // TODO: log warning\n                    this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now();\n                    return done();\n                }\n                let serverTime;\n                if (utcTiming.method === 'HEAD') {\n                    if (!req.responseHeaders || !req.responseHeaders.date) {\n                        // expected date header not preset, fall back to using date header from mpd\n                        // TODO: log warning\n                        serverTime = this.mainLoaded_;\n                    } else {\n                        serverTime = Date.parse(req.responseHeaders.date);\n                    }\n                } else {\n                    serverTime = Date.parse(req.responseText);\n                }\n                this.mainPlaylistLoader_.clientOffset_ = serverTime - Date.now();\n                done();\n            });\n        }\n        haveMain_() {\n            this.state = 'HAVE_MAIN_MANIFEST';\n            if (this.isMain_) {\n                // We have the main playlist at this point, so\n                // trigger this to allow PlaylistController\n                // to make an initial playlist selection\n                this.trigger('loadedplaylist');\n            } else if (!this.media_) {\n                // no media playlist was specifically selected so select\n                // the one the child playlist loader was created with\n                this.media(this.childPlaylist_);\n            }\n        }\n        handleMain_() {\n            // clear media request\n            this.mediaRequest_ = null;\n            const oldMain = this.mainPlaylistLoader_.main;\n            let newMain = parseMainXml({\n                mainXml: this.mainPlaylistLoader_.mainXml_,\n                srcUrl: this.mainPlaylistLoader_.srcUrl,\n                clientOffset: this.mainPlaylistLoader_.clientOffset_,\n                sidxMapping: this.mainPlaylistLoader_.sidxMapping_,\n                previousManifest: oldMain\n            }); // if we have an old main to compare the new main against\n\n            if (oldMain) {\n                newMain = updateMain(oldMain, newMain, this.mainPlaylistLoader_.sidxMapping_);\n            } // only update main if we have a new main\n\n            this.mainPlaylistLoader_.main = newMain ? newMain : oldMain;\n            const location = this.mainPlaylistLoader_.main.locations && this.mainPlaylistLoader_.main.locations[0];\n            if (location && location !== this.mainPlaylistLoader_.srcUrl) {\n                this.mainPlaylistLoader_.srcUrl = location;\n            }\n            if (!oldMain || newMain && newMain.minimumUpdatePeriod !== oldMain.minimumUpdatePeriod) {\n                this.updateMinimumUpdatePeriodTimeout_();\n            }\n            return Boolean(newMain);\n        }\n        updateMinimumUpdatePeriodTimeout_() {\n            const mpl = this.mainPlaylistLoader_; // cancel any pending creation of mup on media\n            // a new one will be added if needed.\n\n            if (mpl.createMupOnMedia_) {\n                mpl.off('loadedmetadata', mpl.createMupOnMedia_);\n                mpl.createMupOnMedia_ = null;\n            } // clear any pending timeouts\n\n            if (mpl.minimumUpdatePeriodTimeout_) {\n                window.clearTimeout(mpl.minimumUpdatePeriodTimeout_);\n                mpl.minimumUpdatePeriodTimeout_ = null;\n            }\n            let mup = mpl.main && mpl.main.minimumUpdatePeriod; // If the minimumUpdatePeriod has a value of 0, that indicates that the current\n            // MPD has no future validity, so a new one will need to be acquired when new\n            // media segments are to be made available. Thus, we use the target duration\n            // in this case\n\n            if (mup === 0) {\n                if (mpl.media()) {\n                    mup = mpl.media().targetDuration * 1000;\n                } else {\n                    mpl.createMupOnMedia_ = mpl.updateMinimumUpdatePeriodTimeout_;\n                    mpl.one('loadedmetadata', mpl.createMupOnMedia_);\n                }\n            } // if minimumUpdatePeriod is invalid or <= zero, which\n            // can happen when a live video becomes VOD. skip timeout\n            // creation.\n\n            if (typeof mup !== 'number' || mup <= 0) {\n                if (mup < 0) {\n                    this.logger_(`found invalid minimumUpdatePeriod of ${mup}, not setting a timeout`);\n                }\n                return;\n            }\n            this.createMUPTimeout_(mup);\n        }\n        createMUPTimeout_(mup) {\n            const mpl = this.mainPlaylistLoader_;\n            mpl.minimumUpdatePeriodTimeout_ = window.setTimeout(() => {\n                mpl.minimumUpdatePeriodTimeout_ = null;\n                mpl.trigger('minimumUpdatePeriod');\n                mpl.createMUPTimeout_(mup);\n            }, mup);\n        }\n        /**\n         * Sends request to refresh the main xml and updates the parsed main manifest\n         */\n\n        refreshXml_() {\n            this.requestMain_((req, mainChanged) => {\n                if (!mainChanged) {\n                    return;\n                }\n                if (this.media_) {\n                    this.media_ = this.mainPlaylistLoader_.main.playlists[this.media_.id];\n                } // This will filter out updated sidx info from the mapping\n\n                this.mainPlaylistLoader_.sidxMapping_ = filterChangedSidxMappings(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.sidxMapping_);\n                this.addSidxSegments_(this.media(), this.state, sidxChanged => {\n                    // TODO: do we need to reload the current playlist?\n                    this.refreshMedia_(this.media().id);\n                });\n            });\n        }\n        /**\n         * Refreshes the media playlist by re-parsing the main xml and updating playlist\n         * references. If this is an alternate loader, the updated parsed manifest is retrieved\n         * from the main loader.\n         */\n\n        refreshMedia_(mediaID) {\n            if (!mediaID) {\n                throw new Error('refreshMedia_ must take a media id');\n            } // for main we have to reparse the main xml\n            // to re-create segments based on current timing values\n            // which may change media. We only skip updating the main manifest\n            // if this is the first time this.media_ is being set.\n            // as main was just parsed in that case.\n\n            if (this.media_ && this.isMain_) {\n                this.handleMain_();\n            }\n            const playlists = this.mainPlaylistLoader_.main.playlists;\n            const mediaChanged = !this.media_ || this.media_ !== playlists[mediaID];\n            if (mediaChanged) {\n                this.media_ = playlists[mediaID];\n            } else {\n                this.trigger('playlistunchanged');\n            }\n            if (!this.mediaUpdateTimeout) {\n                const createMediaUpdateTimeout = () => {\n                    if (this.media().endList) {\n                        return;\n                    }\n                    this.mediaUpdateTimeout = window.setTimeout(() => {\n                        this.trigger('mediaupdatetimeout');\n                        createMediaUpdateTimeout();\n                    }, refreshDelay(this.media(), Boolean(mediaChanged)));\n                };\n                createMediaUpdateTimeout();\n            }\n            this.trigger('loadedplaylist');\n        }\n    }\n    var Config = {\n        GOAL_BUFFER_LENGTH: 30,\n        MAX_GOAL_BUFFER_LENGTH: 60,\n        BACK_BUFFER_LENGTH: 30,\n        GOAL_BUFFER_LENGTH_RATE: 1,\n        // 0.5 MB/s\n        INITIAL_BANDWIDTH: 4194304,\n        // A fudge factor to apply to advertised playlist bitrates to account for\n        // temporary flucations in client bandwidth\n        BANDWIDTH_VARIANCE: 1.2,\n        // How much of the buffer must be filled before we consider upswitching\n        BUFFER_LOW_WATER_LINE: 0,\n        MAX_BUFFER_LOW_WATER_LINE: 30,\n        // TODO: Remove this when experimentalBufferBasedABR is removed\n        EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,\n        BUFFER_LOW_WATER_LINE_RATE: 1,\n        // If the buffer is greater than the high water line, we won't switch down\n        BUFFER_HIGH_WATER_LINE: 30\n    };\n    const stringToArrayBuffer = string => {\n        const view = new Uint8Array(new ArrayBuffer(string.length));\n        for (let i = 0; i < string.length; i++) {\n            view[i] = string.charCodeAt(i);\n        }\n        return view.buffer;\n    };\n\n    /* global Blob, BlobBuilder, Worker */\n    // unify worker interface\n    const browserWorkerPolyFill = function (workerObj) {\n        // node only supports on/off\n        workerObj.on = workerObj.addEventListener;\n        workerObj.off = workerObj.removeEventListener;\n        return workerObj;\n    };\n    const createObjectURL = function (str) {\n        try {\n            return URL.createObjectURL(new Blob([str], {\n                type: 'application/javascript'\n            }));\n        } catch (e) {\n            const blob = new BlobBuilder();\n            blob.append(str);\n            return URL.createObjectURL(blob.getBlob());\n        }\n    };\n    const factory = function (code) {\n        return function () {\n            const objectUrl = createObjectURL(code);\n            const worker = browserWorkerPolyFill(new Worker(objectUrl));\n            worker.objURL = objectUrl;\n            const terminate = worker.terminate;\n            worker.on = worker.addEventListener;\n            worker.off = worker.removeEventListener;\n            worker.terminate = function () {\n                URL.revokeObjectURL(objectUrl);\n                return terminate.call(this);\n            };\n            return worker;\n        };\n    };\n    const transform = function (code) {\n        return `var browserWorkerPolyFill = ${browserWorkerPolyFill.toString()};\\n` + 'browserWorkerPolyFill(self);\\n' + code;\n    };\n    const getWorkerString = function (fn) {\n        return fn.toString().replace(/^function.+?{/, '').slice(0, -1);\n    };\n\n    /* rollup-plugin-worker-factory start for worker!/Users/ddashkevich/projects/http-streaming/src/transmuxer-worker.js */\n    const workerCode$1 = transform(getWorkerString(function () {\n        var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * A lightweight readable stream implemention that handles event dispatching.\n         * Objects that inherit from streams should call init in their constructors.\n         */\n\n        var Stream$8 = function () {\n            this.init = function () {\n                var listeners = {};\n                /**\n                 * Add a listener for a specified event type.\n                 * @param type {string} the event name\n                 * @param listener {function} the callback to be invoked when an event of\n                 * the specified type occurs\n                 */\n\n                this.on = function (type, listener) {\n                    if (!listeners[type]) {\n                        listeners[type] = [];\n                    }\n                    listeners[type] = listeners[type].concat(listener);\n                };\n                /**\n                 * Remove a listener for a specified event type.\n                 * @param type {string} the event name\n                 * @param listener {function} a function previously registered for this\n                 * type of event through `on`\n                 */\n\n                this.off = function (type, listener) {\n                    var index;\n                    if (!listeners[type]) {\n                        return false;\n                    }\n                    index = listeners[type].indexOf(listener);\n                    listeners[type] = listeners[type].slice();\n                    listeners[type].splice(index, 1);\n                    return index > -1;\n                };\n                /**\n                 * Trigger an event of the specified type on this stream. Any additional\n                 * arguments to this function are passed as parameters to event listeners.\n                 * @param type {string} the event name\n                 */\n\n                this.trigger = function (type) {\n                    var callbacks, i, length, args;\n                    callbacks = listeners[type];\n                    if (!callbacks) {\n                        return;\n                    } // Slicing the arguments on every invocation of this method\n                    // can add a significant amount of overhead. Avoid the\n                    // intermediate object creation for the common case of a\n                    // single callback argument\n\n                    if (arguments.length === 2) {\n                        length = callbacks.length;\n                        for (i = 0; i < length; ++i) {\n                            callbacks[i].call(this, arguments[1]);\n                        }\n                    } else {\n                        args = [];\n                        i = arguments.length;\n                        for (i = 1; i < arguments.length; ++i) {\n                            args.push(arguments[i]);\n                        }\n                        length = callbacks.length;\n                        for (i = 0; i < length; ++i) {\n                            callbacks[i].apply(this, args);\n                        }\n                    }\n                };\n                /**\n                 * Destroys the stream and cleans up.\n                 */\n\n                this.dispose = function () {\n                    listeners = {};\n                };\n            };\n        };\n        /**\n         * Forwards all `data` events on this stream to the destination stream. The\n         * destination stream should provide a method `push` to receive the data\n         * events as they arrive.\n         * @param destination {stream} the stream that will receive all `data` events\n         * @param autoFlush {boolean} if false, we will not call `flush` on the destination\n         *                            when the current stream emits a 'done' event\n         * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n         */\n\n        Stream$8.prototype.pipe = function (destination) {\n            this.on('data', function (data) {\n                destination.push(data);\n            });\n            this.on('done', function (flushSource) {\n                destination.flush(flushSource);\n            });\n            this.on('partialdone', function (flushSource) {\n                destination.partialFlush(flushSource);\n            });\n            this.on('endedtimeline', function (flushSource) {\n                destination.endTimeline(flushSource);\n            });\n            this.on('reset', function (flushSource) {\n                destination.reset(flushSource);\n            });\n            return destination;\n        }; // Default stream functions that are expected to be overridden to perform\n        // actual work. These are provided by the prototype as a sort of no-op\n        // implementation so that we don't have to check for their existence in the\n        // `pipe` function above.\n\n        Stream$8.prototype.push = function (data) {\n            this.trigger('data', data);\n        };\n        Stream$8.prototype.flush = function (flushSource) {\n            this.trigger('done', flushSource);\n        };\n        Stream$8.prototype.partialFlush = function (flushSource) {\n            this.trigger('partialdone', flushSource);\n        };\n        Stream$8.prototype.endTimeline = function (flushSource) {\n            this.trigger('endedtimeline', flushSource);\n        };\n        Stream$8.prototype.reset = function (flushSource) {\n            this.trigger('reset', flushSource);\n        };\n        var stream = Stream$8;\n        var MAX_UINT32$1 = Math.pow(2, 32);\n        var getUint64$3 = function (uint8) {\n            var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);\n            var value;\n            if (dv.getBigUint64) {\n                value = dv.getBigUint64(0);\n                if (value < Number.MAX_SAFE_INTEGER) {\n                    return Number(value);\n                }\n                return value;\n            }\n            return dv.getUint32(0) * MAX_UINT32$1 + dv.getUint32(4);\n        };\n        var numbers = {\n            getUint64: getUint64$3,\n            MAX_UINT32: MAX_UINT32$1\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Functions that generate fragmented MP4s suitable for use with Media\n         * Source Extensions.\n         */\n\n        var MAX_UINT32 = numbers.MAX_UINT32;\n        var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun$1, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS; // pre-calculate constants\n\n        (function () {\n            var i;\n            types = {\n                avc1: [],\n                // codingname\n                avcC: [],\n                btrt: [],\n                dinf: [],\n                dref: [],\n                esds: [],\n                ftyp: [],\n                hdlr: [],\n                mdat: [],\n                mdhd: [],\n                mdia: [],\n                mfhd: [],\n                minf: [],\n                moof: [],\n                moov: [],\n                mp4a: [],\n                // codingname\n                mvex: [],\n                mvhd: [],\n                pasp: [],\n                sdtp: [],\n                smhd: [],\n                stbl: [],\n                stco: [],\n                stsc: [],\n                stsd: [],\n                stsz: [],\n                stts: [],\n                styp: [],\n                tfdt: [],\n                tfhd: [],\n                traf: [],\n                trak: [],\n                trun: [],\n                trex: [],\n                tkhd: [],\n                vmhd: []\n            }; // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\n            // don't throw an error\n\n            if (typeof Uint8Array === 'undefined') {\n                return;\n            }\n            for (i in types) {\n                if (types.hasOwnProperty(i)) {\n                    types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n                }\n            }\n            MAJOR_BRAND = new Uint8Array(['i'.charCodeAt(0), 's'.charCodeAt(0), 'o'.charCodeAt(0), 'm'.charCodeAt(0)]);\n            AVC1_BRAND = new Uint8Array(['a'.charCodeAt(0), 'v'.charCodeAt(0), 'c'.charCodeAt(0), '1'.charCodeAt(0)]);\n            MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\n            VIDEO_HDLR = new Uint8Array([0x00,\n                // version 0\n                0x00, 0x00, 0x00,\n                // flags\n                0x00, 0x00, 0x00, 0x00,\n                // pre_defined\n                0x76, 0x69, 0x64, 0x65,\n                // handler_type: 'vide'\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n            ]);\n\n            AUDIO_HDLR = new Uint8Array([0x00,\n                // version 0\n                0x00, 0x00, 0x00,\n                // flags\n                0x00, 0x00, 0x00, 0x00,\n                // pre_defined\n                0x73, 0x6f, 0x75, 0x6e,\n                // handler_type: 'soun'\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n            ]);\n\n            HDLR_TYPES = {\n                video: VIDEO_HDLR,\n                audio: AUDIO_HDLR\n            };\n            DREF = new Uint8Array([0x00,\n                // version 0\n                0x00, 0x00, 0x00,\n                // flags\n                0x00, 0x00, 0x00, 0x01,\n                // entry_count\n                0x00, 0x00, 0x00, 0x0c,\n                // entry_size\n                0x75, 0x72, 0x6c, 0x20,\n                // 'url' type\n                0x00,\n                // version 0\n                0x00, 0x00, 0x01 // entry_flags\n            ]);\n\n            SMHD = new Uint8Array([0x00,\n                // version\n                0x00, 0x00, 0x00,\n                // flags\n                0x00, 0x00,\n                // balance, 0 means centered\n                0x00, 0x00 // reserved\n            ]);\n\n            STCO = new Uint8Array([0x00,\n                // version\n                0x00, 0x00, 0x00,\n                // flags\n                0x00, 0x00, 0x00, 0x00 // entry_count\n            ]);\n\n            STSC = STCO;\n            STSZ = new Uint8Array([0x00,\n                // version\n                0x00, 0x00, 0x00,\n                // flags\n                0x00, 0x00, 0x00, 0x00,\n                // sample_size\n                0x00, 0x00, 0x00, 0x00 // sample_count\n            ]);\n\n            STTS = STCO;\n            VMHD = new Uint8Array([0x00,\n                // version\n                0x00, 0x00, 0x01,\n                // flags\n                0x00, 0x00,\n                // graphicsmode\n                0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n            ]);\n        })();\n\n        box = function (type) {\n            var payload = [],\n                size = 0,\n                i,\n                result,\n                view;\n            for (i = 1; i < arguments.length; i++) {\n                payload.push(arguments[i]);\n            }\n            i = payload.length; // calculate the total size we need to allocate\n\n            while (i--) {\n                size += payload[i].byteLength;\n            }\n            result = new Uint8Array(size + 8);\n            view = new DataView(result.buffer, result.byteOffset, result.byteLength);\n            view.setUint32(0, result.byteLength);\n            result.set(type, 4); // copy the payload into the result\n\n            for (i = 0, size = 8; i < payload.length; i++) {\n                result.set(payload[i], size);\n                size += payload[i].byteLength;\n            }\n            return result;\n        };\n        dinf = function () {\n            return box(types.dinf, box(types.dref, DREF));\n        };\n        esds = function (track) {\n            return box(types.esds, new Uint8Array([0x00,\n                // version\n                0x00, 0x00, 0x00,\n                // flags\n                // ES_Descriptor\n                0x03,\n                // tag, ES_DescrTag\n                0x19,\n                // length\n                0x00, 0x00,\n                // ES_ID\n                0x00,\n                // streamDependenceFlag, URL_flag, reserved, streamPriority\n                // DecoderConfigDescriptor\n                0x04,\n                // tag, DecoderConfigDescrTag\n                0x11,\n                // length\n                0x40,\n                // object type\n                0x15,\n                // streamType\n                0x00, 0x06, 0x00,\n                // bufferSizeDB\n                0x00, 0x00, 0xda, 0xc0,\n                // maxBitrate\n                0x00, 0x00, 0xda, 0xc0,\n                // avgBitrate\n                // DecoderSpecificInfo\n                0x05,\n                // tag, DecoderSpecificInfoTag\n                0x02,\n                // length\n                // ISO/IEC 14496-3, AudioSpecificConfig\n                // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\n                track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1, track.samplingfrequencyindex << 7 | track.channelcount << 3, 0x06, 0x01, 0x02 // GASpecificConfig\n            ]));\n        };\n\n        ftyp = function () {\n            return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\n        };\n        hdlr = function (type) {\n            return box(types.hdlr, HDLR_TYPES[type]);\n        };\n        mdat = function (data) {\n            return box(types.mdat, data);\n        };\n        mdhd = function (track) {\n            var result = new Uint8Array([0x00,\n                // version 0\n                0x00, 0x00, 0x00,\n                // flags\n                0x00, 0x00, 0x00, 0x02,\n                // creation_time\n                0x00, 0x00, 0x00, 0x03,\n                // modification_time\n                0x00, 0x01, 0x5f, 0x90,\n                // timescale, 90,000 \"ticks\" per second\n                track.duration >>> 24 & 0xFF, track.duration >>> 16 & 0xFF, track.duration >>> 8 & 0xFF, track.duration & 0xFF,\n                // duration\n                0x55, 0xc4,\n                // 'und' language (undetermined)\n                0x00, 0x00]); // Use the sample rate from the track metadata, when it is\n            // defined. The sample rate can be parsed out of an ADTS header, for\n            // instance.\n\n            if (track.samplerate) {\n                result[12] = track.samplerate >>> 24 & 0xFF;\n                result[13] = track.samplerate >>> 16 & 0xFF;\n                result[14] = track.samplerate >>> 8 & 0xFF;\n                result[15] = track.samplerate & 0xFF;\n            }\n            return box(types.mdhd, result);\n        };\n        mdia = function (track) {\n            return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\n        };\n        mfhd = function (sequenceNumber) {\n            return box(types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00,\n                // flags\n                (sequenceNumber & 0xFF000000) >> 24, (sequenceNumber & 0xFF0000) >> 16, (sequenceNumber & 0xFF00) >> 8, sequenceNumber & 0xFF // sequence_number\n            ]));\n        };\n\n        minf = function (track) {\n            return box(types.minf, track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));\n        };\n        moof = function (sequenceNumber, tracks) {\n            var trackFragments = [],\n                i = tracks.length; // build traf boxes for each track fragment\n\n            while (i--) {\n                trackFragments[i] = traf(tracks[i]);\n            }\n            return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));\n        };\n        /**\n         * Returns a movie box.\n         * @param tracks {array} the tracks associated with this movie\n         * @see ISO/IEC 14496-12:2012(E), section 8.2.1\n         */\n\n        moov = function (tracks) {\n            var i = tracks.length,\n                boxes = [];\n            while (i--) {\n                boxes[i] = trak(tracks[i]);\n            }\n            return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\n        };\n        mvex = function (tracks) {\n            var i = tracks.length,\n                boxes = [];\n            while (i--) {\n                boxes[i] = trex(tracks[i]);\n            }\n            return box.apply(null, [types.mvex].concat(boxes));\n        };\n        mvhd = function (duration) {\n            var bytes = new Uint8Array([0x00,\n                // version 0\n                0x00, 0x00, 0x00,\n                // flags\n                0x00, 0x00, 0x00, 0x01,\n                // creation_time\n                0x00, 0x00, 0x00, 0x02,\n                // modification_time\n                0x00, 0x01, 0x5f, 0x90,\n                // timescale, 90,000 \"ticks\" per second\n                (duration & 0xFF000000) >> 24, (duration & 0xFF0000) >> 16, (duration & 0xFF00) >> 8, duration & 0xFF,\n                // duration\n                0x00, 0x01, 0x00, 0x00,\n                // 1.0 rate\n                0x01, 0x00,\n                // 1.0 volume\n                0x00, 0x00,\n                // reserved\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n                // transformation: unity matrix\n                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                // pre_defined\n                0xff, 0xff, 0xff, 0xff // next_track_ID\n            ]);\n\n            return box(types.mvhd, bytes);\n        };\n        sdtp = function (track) {\n            var samples = track.samples || [],\n                bytes = new Uint8Array(4 + samples.length),\n                flags,\n                i; // leave the full box header (4 bytes) all zero\n            // write the sample table\n\n            for (i = 0; i < samples.length; i++) {\n                flags = samples[i].flags;\n                bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n            }\n            return box(types.sdtp, bytes);\n        };\n        stbl = function (track) {\n            return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));\n        };\n        (function () {\n            var videoSample, audioSample;\n            stsd = function (track) {\n                return box(types.stsd, new Uint8Array([0x00,\n                    // version 0\n                    0x00, 0x00, 0x00,\n                    // flags\n                    0x00, 0x00, 0x00, 0x01]), track.type === 'video' ? videoSample(track) : audioSample(track));\n            };\n            videoSample = function (track) {\n                var sps = track.sps || [],\n                    pps = track.pps || [],\n                    sequenceParameterSets = [],\n                    pictureParameterSets = [],\n                    i,\n                    avc1Box; // assemble the SPSs\n\n                for (i = 0; i < sps.length; i++) {\n                    sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\n                    sequenceParameterSets.push(sps[i].byteLength & 0xFF); // sequenceParameterSetLength\n\n                    sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\n                } // assemble the PPSs\n\n                for (i = 0; i < pps.length; i++) {\n                    pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\n                    pictureParameterSets.push(pps[i].byteLength & 0xFF);\n                    pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\n                }\n                avc1Box = [types.avc1, new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    // reserved\n                    0x00, 0x01,\n                    // data_reference_index\n                    0x00, 0x00,\n                    // pre_defined\n                    0x00, 0x00,\n                    // reserved\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    // pre_defined\n                    (track.width & 0xff00) >> 8, track.width & 0xff,\n                    // width\n                    (track.height & 0xff00) >> 8, track.height & 0xff,\n                    // height\n                    0x00, 0x48, 0x00, 0x00,\n                    // horizresolution\n                    0x00, 0x48, 0x00, 0x00,\n                    // vertresolution\n                    0x00, 0x00, 0x00, 0x00,\n                    // reserved\n                    0x00, 0x01,\n                    // frame_count\n                    0x13, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x6a, 0x73, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62, 0x2d, 0x68, 0x6c, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    // compressorname\n                    0x00, 0x18,\n                    // depth = 24\n                    0x11, 0x11 // pre_defined = -1\n                ]), box(types.avcC, new Uint8Array([0x01,\n                    // configurationVersion\n                    track.profileIdc,\n                    // AVCProfileIndication\n                    track.profileCompatibility,\n                    // profile_compatibility\n                    track.levelIdc,\n                    // AVCLevelIndication\n                    0xff // lengthSizeMinusOne, hard-coded to 4 bytes\n                ].concat([sps.length],\n                    // numOfSequenceParameterSets\n                    sequenceParameterSets,\n                    // \"SPS\"\n                    [pps.length],\n                    // numOfPictureParameterSets\n                    pictureParameterSets // \"PPS\"\n                ))), box(types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n                    // bufferSizeDB\n                    0x00, 0x2d, 0xc6, 0xc0,\n                    // maxBitrate\n                    0x00, 0x2d, 0xc6, 0xc0 // avgBitrate\n                ]))];\n\n                if (track.sarRatio) {\n                    var hSpacing = track.sarRatio[0],\n                        vSpacing = track.sarRatio[1];\n                    avc1Box.push(box(types.pasp, new Uint8Array([(hSpacing & 0xFF000000) >> 24, (hSpacing & 0xFF0000) >> 16, (hSpacing & 0xFF00) >> 8, hSpacing & 0xFF, (vSpacing & 0xFF000000) >> 24, (vSpacing & 0xFF0000) >> 16, (vSpacing & 0xFF00) >> 8, vSpacing & 0xFF])));\n                }\n                return box.apply(null, avc1Box);\n            };\n            audioSample = function (track) {\n                return box(types.mp4a, new Uint8Array([\n                    // SampleEntry, ISO/IEC 14496-12\n                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                    // reserved\n                    0x00, 0x01,\n                    // data_reference_index\n                    // AudioSampleEntry, ISO/IEC 14496-12\n                    0x00, 0x00, 0x00, 0x00,\n                    // reserved\n                    0x00, 0x00, 0x00, 0x00,\n                    // reserved\n                    (track.channelcount & 0xff00) >> 8, track.channelcount & 0xff,\n                    // channelcount\n                    (track.samplesize & 0xff00) >> 8, track.samplesize & 0xff,\n                    // samplesize\n                    0x00, 0x00,\n                    // pre_defined\n                    0x00, 0x00,\n                    // reserved\n                    (track.samplerate & 0xff00) >> 8, track.samplerate & 0xff, 0x00, 0x00 // samplerate, 16.16\n                    // MP4AudioSampleEntry, ISO/IEC 14496-14\n                ]), esds(track));\n            };\n        })();\n        tkhd = function (track) {\n            var result = new Uint8Array([0x00,\n                // version 0\n                0x00, 0x00, 0x07,\n                // flags\n                0x00, 0x00, 0x00, 0x00,\n                // creation_time\n                0x00, 0x00, 0x00, 0x00,\n                // modification_time\n                (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF,\n                // track_ID\n                0x00, 0x00, 0x00, 0x00,\n                // reserved\n                (track.duration & 0xFF000000) >> 24, (track.duration & 0xFF0000) >> 16, (track.duration & 0xFF00) >> 8, track.duration & 0xFF,\n                // duration\n                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                // reserved\n                0x00, 0x00,\n                // layer\n                0x00, 0x00,\n                // alternate_group\n                0x01, 0x00,\n                // non-audio track volume\n                0x00, 0x00,\n                // reserved\n                0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n                // transformation: unity matrix\n                (track.width & 0xFF00) >> 8, track.width & 0xFF, 0x00, 0x00,\n                // width\n                (track.height & 0xFF00) >> 8, track.height & 0xFF, 0x00, 0x00 // height\n            ]);\n\n            return box(types.tkhd, result);\n        };\n        /**\n         * Generate a track fragment (traf) box. A traf box collects metadata\n         * about tracks in a movie fragment (moof) box.\n         */\n\n        traf = function (track) {\n            var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;\n            trackFragmentHeader = box(types.tfhd, new Uint8Array([0x00,\n                // version 0\n                0x00, 0x00, 0x3a,\n                // flags\n                (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF,\n                // track_ID\n                0x00, 0x00, 0x00, 0x01,\n                // sample_description_index\n                0x00, 0x00, 0x00, 0x00,\n                // default_sample_duration\n                0x00, 0x00, 0x00, 0x00,\n                // default_sample_size\n                0x00, 0x00, 0x00, 0x00 // default_sample_flags\n            ]));\n\n            upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / MAX_UINT32);\n            lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % MAX_UINT32);\n            trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([0x01,\n                // version 1\n                0x00, 0x00, 0x00,\n                // flags\n                // baseMediaDecodeTime\n                upperWordBaseMediaDecodeTime >>> 24 & 0xFF, upperWordBaseMediaDecodeTime >>> 16 & 0xFF, upperWordBaseMediaDecodeTime >>> 8 & 0xFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >>> 24 & 0xFF, lowerWordBaseMediaDecodeTime >>> 16 & 0xFF, lowerWordBaseMediaDecodeTime >>> 8 & 0xFF, lowerWordBaseMediaDecodeTime & 0xFF])); // the data offset specifies the number of bytes from the start of\n            // the containing moof to the first payload byte of the associated\n            // mdat\n\n            dataOffset = 32 +\n                // tfhd\n                20 +\n                // tfdt\n                8 +\n                // traf header\n                16 +\n                // mfhd\n                8 +\n                // moof header\n                8; // mdat header\n            // audio tracks require less metadata\n\n            if (track.type === 'audio') {\n                trackFragmentRun = trun$1(track, dataOffset);\n                return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);\n            } // video tracks should contain an independent and disposable samples\n            // box (sdtp)\n            // generate one and adjust offsets to match\n\n            sampleDependencyTable = sdtp(track);\n            trackFragmentRun = trun$1(track, sampleDependencyTable.length + dataOffset);\n            return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);\n        };\n        /**\n         * Generate a track box.\n         * @param track {object} a track definition\n         * @return {Uint8Array} the track box\n         */\n\n        trak = function (track) {\n            track.duration = track.duration || 0xffffffff;\n            return box(types.trak, tkhd(track), mdia(track));\n        };\n        trex = function (track) {\n            var result = new Uint8Array([0x00,\n                // version 0\n                0x00, 0x00, 0x00,\n                // flags\n                (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF,\n                // track_ID\n                0x00, 0x00, 0x00, 0x01,\n                // default_sample_description_index\n                0x00, 0x00, 0x00, 0x00,\n                // default_sample_duration\n                0x00, 0x00, 0x00, 0x00,\n                // default_sample_size\n                0x00, 0x01, 0x00, 0x01 // default_sample_flags\n            ]); // the last two bytes of default_sample_flags is the sample\n            // degradation priority, a hint about the importance of this sample\n            // relative to others. Lower the degradation priority for all sample\n            // types other than video.\n\n            if (track.type !== 'video') {\n                result[result.length - 1] = 0x00;\n            }\n            return box(types.trex, result);\n        };\n        (function () {\n            var audioTrun, videoTrun, trunHeader; // This method assumes all samples are uniform. That is, if a\n            // duration is present for the first sample, it will be present for\n            // all subsequent samples.\n            // see ISO/IEC 14496-12:2012, Section 8.8.8.1\n\n            trunHeader = function (samples, offset) {\n                var durationPresent = 0,\n                    sizePresent = 0,\n                    flagsPresent = 0,\n                    compositionTimeOffset = 0; // trun flag constants\n\n                if (samples.length) {\n                    if (samples[0].duration !== undefined) {\n                        durationPresent = 0x1;\n                    }\n                    if (samples[0].size !== undefined) {\n                        sizePresent = 0x2;\n                    }\n                    if (samples[0].flags !== undefined) {\n                        flagsPresent = 0x4;\n                    }\n                    if (samples[0].compositionTimeOffset !== undefined) {\n                        compositionTimeOffset = 0x8;\n                    }\n                }\n                return [0x00,\n                    // version 0\n                    0x00, durationPresent | sizePresent | flagsPresent | compositionTimeOffset, 0x01,\n                    // flags\n                    (samples.length & 0xFF000000) >>> 24, (samples.length & 0xFF0000) >>> 16, (samples.length & 0xFF00) >>> 8, samples.length & 0xFF,\n                    // sample_count\n                    (offset & 0xFF000000) >>> 24, (offset & 0xFF0000) >>> 16, (offset & 0xFF00) >>> 8, offset & 0xFF // data_offset\n                ];\n            };\n\n            videoTrun = function (track, offset) {\n                var bytesOffest, bytes, header, samples, sample, i;\n                samples = track.samples || [];\n                offset += 8 + 12 + 16 * samples.length;\n                header = trunHeader(samples, offset);\n                bytes = new Uint8Array(header.length + samples.length * 16);\n                bytes.set(header);\n                bytesOffest = header.length;\n                for (i = 0; i < samples.length; i++) {\n                    sample = samples[i];\n                    bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\n                    bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\n                    bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\n                    bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\n\n                    bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\n                    bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\n                    bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\n                    bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\n\n                    bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;\n                    bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;\n                    bytes[bytesOffest++] = sample.flags.degradationPriority & 0xF0 << 8;\n                    bytes[bytesOffest++] = sample.flags.degradationPriority & 0x0F; // sample_flags\n\n                    bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF000000) >>> 24;\n                    bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF0000) >>> 16;\n                    bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF00) >>> 8;\n                    bytes[bytesOffest++] = sample.compositionTimeOffset & 0xFF; // sample_composition_time_offset\n                }\n\n                return box(types.trun, bytes);\n            };\n            audioTrun = function (track, offset) {\n                var bytes, bytesOffest, header, samples, sample, i;\n                samples = track.samples || [];\n                offset += 8 + 12 + 8 * samples.length;\n                header = trunHeader(samples, offset);\n                bytes = new Uint8Array(header.length + samples.length * 8);\n                bytes.set(header);\n                bytesOffest = header.length;\n                for (i = 0; i < samples.length; i++) {\n                    sample = samples[i];\n                    bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\n                    bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\n                    bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\n                    bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\n\n                    bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\n                    bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\n                    bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\n                    bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\n                }\n\n                return box(types.trun, bytes);\n            };\n            trun$1 = function (track, offset) {\n                if (track.type === 'audio') {\n                    return audioTrun(track, offset);\n                }\n                return videoTrun(track, offset);\n            };\n        })();\n        var mp4Generator = {\n            ftyp: ftyp,\n            mdat: mdat,\n            moof: moof,\n            moov: moov,\n            initSegment: function (tracks) {\n                var fileType = ftyp(),\n                    movie = moov(tracks),\n                    result;\n                result = new Uint8Array(fileType.byteLength + movie.byteLength);\n                result.set(fileType);\n                result.set(movie, fileType.byteLength);\n                return result;\n            }\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n            // composed of the nal units that make up that frame\n            // Also keep track of cummulative data about the frame from the nal units such\n            // as the frame duration, starting pts, etc.\n\n        var groupNalsIntoFrames = function (nalUnits) {\n                var i,\n                    currentNal,\n                    currentFrame = [],\n                    frames = []; // TODO added for LHLS, make sure this is OK\n\n                frames.byteLength = 0;\n                frames.nalCount = 0;\n                frames.duration = 0;\n                currentFrame.byteLength = 0;\n                for (i = 0; i < nalUnits.length; i++) {\n                    currentNal = nalUnits[i]; // Split on 'aud'-type nal units\n\n                    if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n                        // Since the very first nal unit is expected to be an AUD\n                        // only push to the frames array when currentFrame is not empty\n                        if (currentFrame.length) {\n                            currentFrame.duration = currentNal.dts - currentFrame.dts; // TODO added for LHLS, make sure this is OK\n\n                            frames.byteLength += currentFrame.byteLength;\n                            frames.nalCount += currentFrame.length;\n                            frames.duration += currentFrame.duration;\n                            frames.push(currentFrame);\n                        }\n                        currentFrame = [currentNal];\n                        currentFrame.byteLength = currentNal.data.byteLength;\n                        currentFrame.pts = currentNal.pts;\n                        currentFrame.dts = currentNal.dts;\n                    } else {\n                        // Specifically flag key frames for ease of use later\n                        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n                            currentFrame.keyFrame = true;\n                        }\n                        currentFrame.duration = currentNal.dts - currentFrame.dts;\n                        currentFrame.byteLength += currentNal.data.byteLength;\n                        currentFrame.push(currentNal);\n                    }\n                } // For the last frame, use the duration of the previous frame if we\n                // have nothing better to go on\n\n                if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {\n                    currentFrame.duration = frames[frames.length - 1].duration;\n                } // Push the final frame\n                // TODO added for LHLS, make sure this is OK\n\n                frames.byteLength += currentFrame.byteLength;\n                frames.nalCount += currentFrame.length;\n                frames.duration += currentFrame.duration;\n                frames.push(currentFrame);\n                return frames;\n            }; // Convert an array of frames into an array of Gop with each Gop being composed\n        // of the frames that make up that Gop\n        // Also keep track of cummulative data about the Gop from the frames such as the\n        // Gop duration, starting pts, etc.\n\n        var groupFramesIntoGops = function (frames) {\n            var i,\n                currentFrame,\n                currentGop = [],\n                gops = []; // We must pre-set some of the values on the Gop since we\n            // keep running totals of these values\n\n            currentGop.byteLength = 0;\n            currentGop.nalCount = 0;\n            currentGop.duration = 0;\n            currentGop.pts = frames[0].pts;\n            currentGop.dts = frames[0].dts; // store some metadata about all the Gops\n\n            gops.byteLength = 0;\n            gops.nalCount = 0;\n            gops.duration = 0;\n            gops.pts = frames[0].pts;\n            gops.dts = frames[0].dts;\n            for (i = 0; i < frames.length; i++) {\n                currentFrame = frames[i];\n                if (currentFrame.keyFrame) {\n                    // Since the very first frame is expected to be an keyframe\n                    // only push to the gops array when currentGop is not empty\n                    if (currentGop.length) {\n                        gops.push(currentGop);\n                        gops.byteLength += currentGop.byteLength;\n                        gops.nalCount += currentGop.nalCount;\n                        gops.duration += currentGop.duration;\n                    }\n                    currentGop = [currentFrame];\n                    currentGop.nalCount = currentFrame.length;\n                    currentGop.byteLength = currentFrame.byteLength;\n                    currentGop.pts = currentFrame.pts;\n                    currentGop.dts = currentFrame.dts;\n                    currentGop.duration = currentFrame.duration;\n                } else {\n                    currentGop.duration += currentFrame.duration;\n                    currentGop.nalCount += currentFrame.length;\n                    currentGop.byteLength += currentFrame.byteLength;\n                    currentGop.push(currentFrame);\n                }\n            }\n            if (gops.length && currentGop.duration <= 0) {\n                currentGop.duration = gops[gops.length - 1].duration;\n            }\n            gops.byteLength += currentGop.byteLength;\n            gops.nalCount += currentGop.nalCount;\n            gops.duration += currentGop.duration; // push the final Gop\n\n            gops.push(currentGop);\n            return gops;\n        };\n        /*\n     * Search for the first keyframe in the GOPs and throw away all frames\n     * until that keyframe. Then extend the duration of the pulled keyframe\n     * and pull the PTS and DTS of the keyframe so that it covers the time\n     * range of the frames that were disposed.\n     *\n     * @param {Array} gops video GOPs\n     * @returns {Array} modified video GOPs\n     */\n\n        var extendFirstKeyFrame = function (gops) {\n            var currentGop;\n            if (!gops[0][0].keyFrame && gops.length > 1) {\n                // Remove the first GOP\n                currentGop = gops.shift();\n                gops.byteLength -= currentGop.byteLength;\n                gops.nalCount -= currentGop.nalCount; // Extend the first frame of what is now the\n                // first gop to cover the time period of the\n                // frames we just removed\n\n                gops[0][0].dts = currentGop.dts;\n                gops[0][0].pts = currentGop.pts;\n                gops[0][0].duration += currentGop.duration;\n            }\n            return gops;\n        };\n        /**\n         * Default sample object\n         * see ISO/IEC 14496-12:2012, section 8.6.4.3\n         */\n\n        var createDefaultSample = function () {\n            return {\n                size: 0,\n                flags: {\n                    isLeading: 0,\n                    dependsOn: 1,\n                    isDependedOn: 0,\n                    hasRedundancy: 0,\n                    degradationPriority: 0,\n                    isNonSyncSample: 1\n                }\n            };\n        };\n        /*\n     * Collates information from a video frame into an object for eventual\n     * entry into an MP4 sample table.\n     *\n     * @param {Object} frame the video frame\n     * @param {Number} dataOffset the byte offset to position the sample\n     * @return {Object} object containing sample table info for a frame\n     */\n\n        var sampleForFrame = function (frame, dataOffset) {\n            var sample = createDefaultSample();\n            sample.dataOffset = dataOffset;\n            sample.compositionTimeOffset = frame.pts - frame.dts;\n            sample.duration = frame.duration;\n            sample.size = 4 * frame.length; // Space for nal unit size\n\n            sample.size += frame.byteLength;\n            if (frame.keyFrame) {\n                sample.flags.dependsOn = 2;\n                sample.flags.isNonSyncSample = 0;\n            }\n            return sample;\n        }; // generate the track's sample table from an array of gops\n\n        var generateSampleTable$1 = function (gops, baseDataOffset) {\n            var h,\n                i,\n                sample,\n                currentGop,\n                currentFrame,\n                dataOffset = baseDataOffset || 0,\n                samples = [];\n            for (h = 0; h < gops.length; h++) {\n                currentGop = gops[h];\n                for (i = 0; i < currentGop.length; i++) {\n                    currentFrame = currentGop[i];\n                    sample = sampleForFrame(currentFrame, dataOffset);\n                    dataOffset += sample.size;\n                    samples.push(sample);\n                }\n            }\n            return samples;\n        }; // generate the track's raw mdat data from an array of gops\n\n        var concatenateNalData = function (gops) {\n            var h,\n                i,\n                j,\n                currentGop,\n                currentFrame,\n                currentNal,\n                dataOffset = 0,\n                nalsByteLength = gops.byteLength,\n                numberOfNals = gops.nalCount,\n                totalByteLength = nalsByteLength + 4 * numberOfNals,\n                data = new Uint8Array(totalByteLength),\n                view = new DataView(data.buffer); // For each Gop..\n\n            for (h = 0; h < gops.length; h++) {\n                currentGop = gops[h]; // For each Frame..\n\n                for (i = 0; i < currentGop.length; i++) {\n                    currentFrame = currentGop[i]; // For each NAL..\n\n                    for (j = 0; j < currentFrame.length; j++) {\n                        currentNal = currentFrame[j];\n                        view.setUint32(dataOffset, currentNal.data.byteLength);\n                        dataOffset += 4;\n                        data.set(currentNal.data, dataOffset);\n                        dataOffset += currentNal.data.byteLength;\n                    }\n                }\n            }\n            return data;\n        }; // generate the track's sample table from a frame\n\n        var generateSampleTableForFrame = function (frame, baseDataOffset) {\n            var sample,\n                dataOffset = baseDataOffset || 0,\n                samples = [];\n            sample = sampleForFrame(frame, dataOffset);\n            samples.push(sample);\n            return samples;\n        }; // generate the track's raw mdat data from a frame\n\n        var concatenateNalDataForFrame = function (frame) {\n            var i,\n                currentNal,\n                dataOffset = 0,\n                nalsByteLength = frame.byteLength,\n                numberOfNals = frame.length,\n                totalByteLength = nalsByteLength + 4 * numberOfNals,\n                data = new Uint8Array(totalByteLength),\n                view = new DataView(data.buffer); // For each NAL..\n\n            for (i = 0; i < frame.length; i++) {\n                currentNal = frame[i];\n                view.setUint32(dataOffset, currentNal.data.byteLength);\n                dataOffset += 4;\n                data.set(currentNal.data, dataOffset);\n                dataOffset += currentNal.data.byteLength;\n            }\n            return data;\n        };\n        var frameUtils$1 = {\n            groupNalsIntoFrames: groupNalsIntoFrames,\n            groupFramesIntoGops: groupFramesIntoGops,\n            extendFirstKeyFrame: extendFirstKeyFrame,\n            generateSampleTable: generateSampleTable$1,\n            concatenateNalData: concatenateNalData,\n            generateSampleTableForFrame: generateSampleTableForFrame,\n            concatenateNalDataForFrame: concatenateNalDataForFrame\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var highPrefix = [33, 16, 5, 32, 164, 27];\n        var lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];\n        var zeroFill = function (count) {\n            var a = [];\n            while (count--) {\n                a.push(0);\n            }\n            return a;\n        };\n        var makeTable = function (metaTable) {\n            return Object.keys(metaTable).reduce(function (obj, key) {\n                obj[key] = new Uint8Array(metaTable[key].reduce(function (arr, part) {\n                    return arr.concat(part);\n                }, []));\n                return obj;\n            }, {});\n        };\n        var silence;\n        var silence_1 = function () {\n            if (!silence) {\n                // Frames-of-silence to use for filling in missing AAC frames\n                var coneOfSilence = {\n                    96000: [highPrefix, [227, 64], zeroFill(154), [56]],\n                    88200: [highPrefix, [231], zeroFill(170), [56]],\n                    64000: [highPrefix, [248, 192], zeroFill(240), [56]],\n                    48000: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],\n                    44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],\n                    32000: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],\n                    24000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],\n                    16000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],\n                    12000: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],\n                    11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],\n                    8000: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]\n                };\n                silence = makeTable(coneOfSilence);\n            }\n            return silence;\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var ONE_SECOND_IN_TS$4 = 90000,\n            // 90kHz clock\n            secondsToVideoTs,\n            secondsToAudioTs,\n            videoTsToSeconds,\n            audioTsToSeconds,\n            audioTsToVideoTs,\n            videoTsToAudioTs,\n            metadataTsToSeconds;\n        secondsToVideoTs = function (seconds) {\n            return seconds * ONE_SECOND_IN_TS$4;\n        };\n        secondsToAudioTs = function (seconds, sampleRate) {\n            return seconds * sampleRate;\n        };\n        videoTsToSeconds = function (timestamp) {\n            return timestamp / ONE_SECOND_IN_TS$4;\n        };\n        audioTsToSeconds = function (timestamp, sampleRate) {\n            return timestamp / sampleRate;\n        };\n        audioTsToVideoTs = function (timestamp, sampleRate) {\n            return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\n        };\n        videoTsToAudioTs = function (timestamp, sampleRate) {\n            return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\n        };\n        /**\n         * Adjust ID3 tag or caption timing information by the timeline pts values\n         * (if keepOriginalTimestamps is false) and convert to seconds\n         */\n\n        metadataTsToSeconds = function (timestamp, timelineStartPts, keepOriginalTimestamps) {\n            return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);\n        };\n        var clock$2 = {\n            ONE_SECOND_IN_TS: ONE_SECOND_IN_TS$4,\n            secondsToVideoTs: secondsToVideoTs,\n            secondsToAudioTs: secondsToAudioTs,\n            videoTsToSeconds: videoTsToSeconds,\n            audioTsToSeconds: audioTsToSeconds,\n            audioTsToVideoTs: audioTsToVideoTs,\n            videoTsToAudioTs: videoTsToAudioTs,\n            metadataTsToSeconds: metadataTsToSeconds\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var coneOfSilence = silence_1;\n        var clock$1 = clock$2;\n        /**\n         * Sum the `byteLength` properties of the data in each AAC frame\n         */\n\n        var sumFrameByteLengths = function (array) {\n            var i,\n                currentObj,\n                sum = 0; // sum the byteLength's all each nal unit in the frame\n\n            for (i = 0; i < array.length; i++) {\n                currentObj = array[i];\n                sum += currentObj.data.byteLength;\n            }\n            return sum;\n        }; // Possibly pad (prefix) the audio track with silence if appending this track\n        // would lead to the introduction of a gap in the audio buffer\n\n        var prefixWithSilence = function (track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {\n            var baseMediaDecodeTimeTs,\n                frameDuration = 0,\n                audioGapDuration = 0,\n                audioFillFrameCount = 0,\n                audioFillDuration = 0,\n                silentFrame,\n                i,\n                firstFrame;\n            if (!frames.length) {\n                return;\n            }\n            baseMediaDecodeTimeTs = clock$1.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate); // determine frame clock duration based on sample rate, round up to avoid overfills\n\n            frameDuration = Math.ceil(clock$1.ONE_SECOND_IN_TS / (track.samplerate / 1024));\n            if (audioAppendStartTs && videoBaseMediaDecodeTime) {\n                // insert the shortest possible amount (audio gap or audio to video gap)\n                audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime); // number of full frames in the audio gap\n\n                audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);\n                audioFillDuration = audioFillFrameCount * frameDuration;\n            } // don't attempt to fill gaps smaller than a single frame or larger\n            // than a half second\n\n            if (audioFillFrameCount < 1 || audioFillDuration > clock$1.ONE_SECOND_IN_TS / 2) {\n                return;\n            }\n            silentFrame = coneOfSilence()[track.samplerate];\n            if (!silentFrame) {\n                // we don't have a silent frame pregenerated for the sample rate, so use a frame\n                // from the content instead\n                silentFrame = frames[0].data;\n            }\n            for (i = 0; i < audioFillFrameCount; i++) {\n                firstFrame = frames[0];\n                frames.splice(0, 0, {\n                    data: silentFrame,\n                    dts: firstFrame.dts - frameDuration,\n                    pts: firstFrame.pts - frameDuration\n                });\n            }\n            track.baseMediaDecodeTime -= Math.floor(clock$1.videoTsToAudioTs(audioFillDuration, track.samplerate));\n            return audioFillDuration;\n        }; // If the audio segment extends before the earliest allowed dts\n        // value, remove AAC frames until starts at or after the earliest\n        // allowed DTS so that we don't end up with a negative baseMedia-\n        // DecodeTime for the audio track\n\n        var trimAdtsFramesByEarliestDts = function (adtsFrames, track, earliestAllowedDts) {\n            if (track.minSegmentDts >= earliestAllowedDts) {\n                return adtsFrames;\n            } // We will need to recalculate the earliest segment Dts\n\n            track.minSegmentDts = Infinity;\n            return adtsFrames.filter(function (currentFrame) {\n                // If this is an allowed frame, keep it and record it's Dts\n                if (currentFrame.dts >= earliestAllowedDts) {\n                    track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\n                    track.minSegmentPts = track.minSegmentDts;\n                    return true;\n                } // Otherwise, discard it\n\n                return false;\n            });\n        }; // generate the track's raw mdat data from an array of frames\n\n        var generateSampleTable = function (frames) {\n            var i,\n                currentFrame,\n                samples = [];\n            for (i = 0; i < frames.length; i++) {\n                currentFrame = frames[i];\n                samples.push({\n                    size: currentFrame.data.byteLength,\n                    duration: 1024 // For AAC audio, all samples contain 1024 samples\n                });\n            }\n\n            return samples;\n        }; // generate the track's sample table from an array of frames\n\n        var concatenateFrameData = function (frames) {\n            var i,\n                currentFrame,\n                dataOffset = 0,\n                data = new Uint8Array(sumFrameByteLengths(frames));\n            for (i = 0; i < frames.length; i++) {\n                currentFrame = frames[i];\n                data.set(currentFrame.data, dataOffset);\n                dataOffset += currentFrame.data.byteLength;\n            }\n            return data;\n        };\n        var audioFrameUtils$1 = {\n            prefixWithSilence: prefixWithSilence,\n            trimAdtsFramesByEarliestDts: trimAdtsFramesByEarliestDts,\n            generateSampleTable: generateSampleTable,\n            concatenateFrameData: concatenateFrameData\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var ONE_SECOND_IN_TS$3 = clock$2.ONE_SECOND_IN_TS;\n        /**\n         * Store information about the start and end of the track and the\n         * duration for each frame/sample we process in order to calculate\n         * the baseMediaDecodeTime\n         */\n\n        var collectDtsInfo = function (track, data) {\n            if (typeof data.pts === 'number') {\n                if (track.timelineStartInfo.pts === undefined) {\n                    track.timelineStartInfo.pts = data.pts;\n                }\n                if (track.minSegmentPts === undefined) {\n                    track.minSegmentPts = data.pts;\n                } else {\n                    track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\n                }\n                if (track.maxSegmentPts === undefined) {\n                    track.maxSegmentPts = data.pts;\n                } else {\n                    track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\n                }\n            }\n            if (typeof data.dts === 'number') {\n                if (track.timelineStartInfo.dts === undefined) {\n                    track.timelineStartInfo.dts = data.dts;\n                }\n                if (track.minSegmentDts === undefined) {\n                    track.minSegmentDts = data.dts;\n                } else {\n                    track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\n                }\n                if (track.maxSegmentDts === undefined) {\n                    track.maxSegmentDts = data.dts;\n                } else {\n                    track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\n                }\n            }\n        };\n        /**\n         * Clear values used to calculate the baseMediaDecodeTime between\n         * tracks\n         */\n\n        var clearDtsInfo = function (track) {\n            delete track.minSegmentDts;\n            delete track.maxSegmentDts;\n            delete track.minSegmentPts;\n            delete track.maxSegmentPts;\n        };\n        /**\n         * Calculate the track's baseMediaDecodeTime based on the earliest\n         * DTS the transmuxer has ever seen and the minimum DTS for the\n         * current track\n         * @param track {object} track metadata configuration\n         * @param keepOriginalTimestamps {boolean} If true, keep the timestamps\n         *        in the source; false to adjust the first segment to start at 0.\n         */\n\n        var calculateTrackBaseMediaDecodeTime = function (track, keepOriginalTimestamps) {\n            var baseMediaDecodeTime,\n                scale,\n                minSegmentDts = track.minSegmentDts; // Optionally adjust the time so the first segment starts at zero.\n\n            if (!keepOriginalTimestamps) {\n                minSegmentDts -= track.timelineStartInfo.dts;\n            } // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\n            // we want the start of the first segment to be placed\n\n            baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime; // Add to that the distance this segment is from the very first\n\n            baseMediaDecodeTime += minSegmentDts; // baseMediaDecodeTime must not become negative\n\n            baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);\n            if (track.type === 'audio') {\n                // Audio has a different clock equal to the sampling_rate so we need to\n                // scale the PTS values into the clock rate of the track\n                scale = track.samplerate / ONE_SECOND_IN_TS$3;\n                baseMediaDecodeTime *= scale;\n                baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);\n            }\n            return baseMediaDecodeTime;\n        };\n        var trackDecodeInfo$1 = {\n            clearDtsInfo: clearDtsInfo,\n            calculateTrackBaseMediaDecodeTime: calculateTrackBaseMediaDecodeTime,\n            collectDtsInfo: collectDtsInfo\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Reads in-band caption information from a video elementary\n         * stream. Captions must follow the CEA-708 standard for injection\n         * into an MPEG-2 transport streams.\n         * @see https://en.wikipedia.org/wiki/CEA-708\n         * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n         */\n            // payload type field to indicate how they are to be\n            // interpreted. CEAS-708 caption content is always transmitted with\n            // payload type 0x04.\n\n        var USER_DATA_REGISTERED_ITU_T_T35 = 4,\n            RBSP_TRAILING_BITS = 128;\n        /**\n         * Parse a supplemental enhancement information (SEI) NAL unit.\n         * Stops parsing once a message of type ITU T T35 has been found.\n         *\n         * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n         * @return {object} the parsed SEI payload\n         * @see Rec. ITU-T H.264, 7.3.2.3.1\n         */\n\n        var parseSei = function (bytes) {\n            var i = 0,\n                result = {\n                    payloadType: -1,\n                    payloadSize: 0\n                },\n                payloadType = 0,\n                payloadSize = 0; // go through the sei_rbsp parsing each each individual sei_message\n\n            while (i < bytes.byteLength) {\n                // stop once we have hit the end of the sei_rbsp\n                if (bytes[i] === RBSP_TRAILING_BITS) {\n                    break;\n                } // Parse payload type\n\n                while (bytes[i] === 0xFF) {\n                    payloadType += 255;\n                    i++;\n                }\n                payloadType += bytes[i++]; // Parse payload size\n\n                while (bytes[i] === 0xFF) {\n                    payloadSize += 255;\n                    i++;\n                }\n                payloadSize += bytes[i++]; // this sei_message is a 608/708 caption so save it and break\n                // there can only ever be one caption message in a frame's sei\n\n                if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n                    var userIdentifier = String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6]);\n                    if (userIdentifier === 'GA94') {\n                        result.payloadType = payloadType;\n                        result.payloadSize = payloadSize;\n                        result.payload = bytes.subarray(i, i + payloadSize);\n                        break;\n                    } else {\n                        result.payload = void 0;\n                    }\n                } // skip the payload and parse the next message\n\n                i += payloadSize;\n                payloadType = 0;\n                payloadSize = 0;\n            }\n            return result;\n        }; // see ANSI/SCTE 128-1 (2013), section 8.1\n\n        var parseUserData = function (sei) {\n            // itu_t_t35_contry_code must be 181 (United States) for\n            // captions\n            if (sei.payload[0] !== 181) {\n                return null;\n            } // itu_t_t35_provider_code should be 49 (ATSC) for captions\n\n            if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {\n                return null;\n            } // the user_identifier should be \"GA94\" to indicate ATSC1 data\n\n            if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== 'GA94') {\n                return null;\n            } // finally, user_data_type_code should be 0x03 for caption data\n\n            if (sei.payload[7] !== 0x03) {\n                return null;\n            } // return the user_data_type_structure and strip the trailing\n            // marker bits\n\n            return sei.payload.subarray(8, sei.payload.length - 1);\n        }; // see CEA-708-D, section 4.4\n\n        var parseCaptionPackets = function (pts, userData) {\n            var results = [],\n                i,\n                count,\n                offset,\n                data; // if this is just filler, return immediately\n\n            if (!(userData[0] & 0x40)) {\n                return results;\n            } // parse out the cc_data_1 and cc_data_2 fields\n\n            count = userData[0] & 0x1f;\n            for (i = 0; i < count; i++) {\n                offset = i * 3;\n                data = {\n                    type: userData[offset + 2] & 0x03,\n                    pts: pts\n                }; // capture cc data when cc_valid is 1\n\n                if (userData[offset + 2] & 0x04) {\n                    data.ccData = userData[offset + 3] << 8 | userData[offset + 4];\n                    results.push(data);\n                }\n            }\n            return results;\n        };\n        var discardEmulationPreventionBytes$1 = function (data) {\n            var length = data.byteLength,\n                emulationPreventionBytesPositions = [],\n                i = 1,\n                newLength,\n                newData; // Find all `Emulation Prevention Bytes`\n\n            while (i < length - 2) {\n                if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n                    emulationPreventionBytesPositions.push(i + 2);\n                    i += 2;\n                } else {\n                    i++;\n                }\n            } // If no Emulation Prevention Bytes were found just return the original\n            // array\n\n            if (emulationPreventionBytesPositions.length === 0) {\n                return data;\n            } // Create a new array to hold the NAL unit data\n\n            newLength = length - emulationPreventionBytesPositions.length;\n            newData = new Uint8Array(newLength);\n            var sourceIndex = 0;\n            for (i = 0; i < newLength; sourceIndex++, i++) {\n                if (sourceIndex === emulationPreventionBytesPositions[0]) {\n                    // Skip this byte\n                    sourceIndex++; // Remove this position index\n\n                    emulationPreventionBytesPositions.shift();\n                }\n                newData[i] = data[sourceIndex];\n            }\n            return newData;\n        }; // exports\n\n        var captionPacketParser = {\n            parseSei: parseSei,\n            parseUserData: parseUserData,\n            parseCaptionPackets: parseCaptionPackets,\n            discardEmulationPreventionBytes: discardEmulationPreventionBytes$1,\n            USER_DATA_REGISTERED_ITU_T_T35: USER_DATA_REGISTERED_ITU_T_T35\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Reads in-band caption information from a video elementary\n         * stream. Captions must follow the CEA-708 standard for injection\n         * into an MPEG-2 transport streams.\n         * @see https://en.wikipedia.org/wiki/CEA-708\n         * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n         */\n            // Link To Transport\n            // -----------------\n\n        var Stream$7 = stream;\n        var cea708Parser = captionPacketParser;\n        var CaptionStream$2 = function (options) {\n            options = options || {};\n            CaptionStream$2.prototype.init.call(this); // parse708captions flag, default to true\n\n            this.parse708captions_ = typeof options.parse708captions === 'boolean' ? options.parse708captions : true;\n            this.captionPackets_ = [];\n            this.ccStreams_ = [new Cea608Stream(0, 0),\n                // eslint-disable-line no-use-before-define\n                new Cea608Stream(0, 1),\n                // eslint-disable-line no-use-before-define\n                new Cea608Stream(1, 0),\n                // eslint-disable-line no-use-before-define\n                new Cea608Stream(1, 1) // eslint-disable-line no-use-before-define\n            ];\n\n            if (this.parse708captions_) {\n                this.cc708Stream_ = new Cea708Stream({\n                    captionServices: options.captionServices\n                }); // eslint-disable-line no-use-before-define\n            }\n\n            this.reset(); // forward data and done events from CCs to this CaptionStream\n\n            this.ccStreams_.forEach(function (cc) {\n                cc.on('data', this.trigger.bind(this, 'data'));\n                cc.on('partialdone', this.trigger.bind(this, 'partialdone'));\n                cc.on('done', this.trigger.bind(this, 'done'));\n            }, this);\n            if (this.parse708captions_) {\n                this.cc708Stream_.on('data', this.trigger.bind(this, 'data'));\n                this.cc708Stream_.on('partialdone', this.trigger.bind(this, 'partialdone'));\n                this.cc708Stream_.on('done', this.trigger.bind(this, 'done'));\n            }\n        };\n        CaptionStream$2.prototype = new Stream$7();\n        CaptionStream$2.prototype.push = function (event) {\n            var sei, userData, newCaptionPackets; // only examine SEI NALs\n\n            if (event.nalUnitType !== 'sei_rbsp') {\n                return;\n            } // parse the sei\n\n            sei = cea708Parser.parseSei(event.escapedRBSP); // no payload data, skip\n\n            if (!sei.payload) {\n                return;\n            } // ignore everything but user_data_registered_itu_t_t35\n\n            if (sei.payloadType !== cea708Parser.USER_DATA_REGISTERED_ITU_T_T35) {\n                return;\n            } // parse out the user data payload\n\n            userData = cea708Parser.parseUserData(sei); // ignore unrecognized userData\n\n            if (!userData) {\n                return;\n            } // Sometimes, the same segment # will be downloaded twice. To stop the\n            // caption data from being processed twice, we track the latest dts we've\n            // received and ignore everything with a dts before that. However, since\n            // data for a specific dts can be split across packets on either side of\n            // a segment boundary, we need to make sure we *don't* ignore the packets\n            // from the *next* segment that have dts === this.latestDts_. By constantly\n            // tracking the number of packets received with dts === this.latestDts_, we\n            // know how many should be ignored once we start receiving duplicates.\n\n            if (event.dts < this.latestDts_) {\n                // We've started getting older data, so set the flag.\n                this.ignoreNextEqualDts_ = true;\n                return;\n            } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {\n                this.numSameDts_--;\n                if (!this.numSameDts_) {\n                    // We've received the last duplicate packet, time to start processing again\n                    this.ignoreNextEqualDts_ = false;\n                }\n                return;\n            } // parse out CC data packets and save them for later\n\n            newCaptionPackets = cea708Parser.parseCaptionPackets(event.pts, userData);\n            this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);\n            if (this.latestDts_ !== event.dts) {\n                this.numSameDts_ = 0;\n            }\n            this.numSameDts_++;\n            this.latestDts_ = event.dts;\n        };\n        CaptionStream$2.prototype.flushCCStreams = function (flushType) {\n            this.ccStreams_.forEach(function (cc) {\n                return flushType === 'flush' ? cc.flush() : cc.partialFlush();\n            }, this);\n        };\n        CaptionStream$2.prototype.flushStream = function (flushType) {\n            // make sure we actually parsed captions before proceeding\n            if (!this.captionPackets_.length) {\n                this.flushCCStreams(flushType);\n                return;\n            } // In Chrome, the Array#sort function is not stable so add a\n            // presortIndex that we can use to ensure we get a stable-sort\n\n            this.captionPackets_.forEach(function (elem, idx) {\n                elem.presortIndex = idx;\n            }); // sort caption byte-pairs based on their PTS values\n\n            this.captionPackets_.sort(function (a, b) {\n                if (a.pts === b.pts) {\n                    return a.presortIndex - b.presortIndex;\n                }\n                return a.pts - b.pts;\n            });\n            this.captionPackets_.forEach(function (packet) {\n                if (packet.type < 2) {\n                    // Dispatch packet to the right Cea608Stream\n                    this.dispatchCea608Packet(packet);\n                } else {\n                    // Dispatch packet to the Cea708Stream\n                    this.dispatchCea708Packet(packet);\n                }\n            }, this);\n            this.captionPackets_.length = 0;\n            this.flushCCStreams(flushType);\n        };\n        CaptionStream$2.prototype.flush = function () {\n            return this.flushStream('flush');\n        }; // Only called if handling partial data\n\n        CaptionStream$2.prototype.partialFlush = function () {\n            return this.flushStream('partialFlush');\n        };\n        CaptionStream$2.prototype.reset = function () {\n            this.latestDts_ = null;\n            this.ignoreNextEqualDts_ = false;\n            this.numSameDts_ = 0;\n            this.activeCea608Channel_ = [null, null];\n            this.ccStreams_.forEach(function (ccStream) {\n                ccStream.reset();\n            });\n        }; // From the CEA-608 spec:\n\n        /*\n     * When XDS sub-packets are interleaved with other services, the end of each sub-packet shall be followed\n     * by a control pair to change to a different service. When any of the control codes from 0x10 to 0x1F is\n     * used to begin a control code pair, it indicates the return to captioning or Text data. The control code pair\n     * and subsequent data should then be processed according to the FCC rules. It may be necessary for the\n     * line 21 data encoder to automatically insert a control code pair (i.e. RCL, RU2, RU3, RU4, RDC, or RTD)\n     * to switch to captioning or Text.\n    */\n        // With that in mind, we ignore any data between an XDS control code and a\n        // subsequent closed-captioning control code.\n\n        CaptionStream$2.prototype.dispatchCea608Packet = function (packet) {\n            // NOTE: packet.type is the CEA608 field\n            if (this.setsTextOrXDSActive(packet)) {\n                this.activeCea608Channel_[packet.type] = null;\n            } else if (this.setsChannel1Active(packet)) {\n                this.activeCea608Channel_[packet.type] = 0;\n            } else if (this.setsChannel2Active(packet)) {\n                this.activeCea608Channel_[packet.type] = 1;\n            }\n            if (this.activeCea608Channel_[packet.type] === null) {\n                // If we haven't received anything to set the active channel, or the\n                // packets are Text/XDS data, discard the data; we don't want jumbled\n                // captions\n                return;\n            }\n            this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);\n        };\n        CaptionStream$2.prototype.setsChannel1Active = function (packet) {\n            return (packet.ccData & 0x7800) === 0x1000;\n        };\n        CaptionStream$2.prototype.setsChannel2Active = function (packet) {\n            return (packet.ccData & 0x7800) === 0x1800;\n        };\n        CaptionStream$2.prototype.setsTextOrXDSActive = function (packet) {\n            return (packet.ccData & 0x7100) === 0x0100 || (packet.ccData & 0x78fe) === 0x102a || (packet.ccData & 0x78fe) === 0x182a;\n        };\n        CaptionStream$2.prototype.dispatchCea708Packet = function (packet) {\n            if (this.parse708captions_) {\n                this.cc708Stream_.push(packet);\n            }\n        }; // ----------------------\n        // Session to Application\n        // ----------------------\n        // This hash maps special and extended character codes to their\n        // proper Unicode equivalent. The first one-byte key is just a\n        // non-standard character code. The two-byte keys that follow are\n        // the extended CEA708 character codes, along with the preceding\n        // 0x10 extended character byte to distinguish these codes from\n        // non-extended character codes. Every CEA708 character code that\n        // is not in this object maps directly to a standard unicode\n        // character code.\n        // The transparent space and non-breaking transparent space are\n        // technically not fully supported since there is no code to\n        // make them transparent, so they have normal non-transparent\n        // stand-ins.\n        // The special closed caption (CC) character isn't a standard\n        // unicode character, so a fairly similar unicode character was\n        // chosen in it's place.\n\n        var CHARACTER_TRANSLATION_708 = {\n            0x7f: 0x266a,\n            // ♪\n            0x1020: 0x20,\n            // Transparent Space\n            0x1021: 0xa0,\n            // Nob-breaking Transparent Space\n            0x1025: 0x2026,\n            // …\n            0x102a: 0x0160,\n            // Š\n            0x102c: 0x0152,\n            // Œ\n            0x1030: 0x2588,\n            // █\n            0x1031: 0x2018,\n            // ‘\n            0x1032: 0x2019,\n            // ’\n            0x1033: 0x201c,\n            // “\n            0x1034: 0x201d,\n            // ”\n            0x1035: 0x2022,\n            // •\n            0x1039: 0x2122,\n            // ™\n            0x103a: 0x0161,\n            // š\n            0x103c: 0x0153,\n            // œ\n            0x103d: 0x2120,\n            // ℠\n            0x103f: 0x0178,\n            // Ÿ\n            0x1076: 0x215b,\n            // ⅛\n            0x1077: 0x215c,\n            // ⅜\n            0x1078: 0x215d,\n            // ⅝\n            0x1079: 0x215e,\n            // ⅞\n            0x107a: 0x23d0,\n            // ⏐\n            0x107b: 0x23a4,\n            // ⎤\n            0x107c: 0x23a3,\n            // ⎣\n            0x107d: 0x23af,\n            // ⎯\n            0x107e: 0x23a6,\n            // ⎦\n            0x107f: 0x23a1,\n            // ⎡\n            0x10a0: 0x3138 // ㄸ (CC char)\n        };\n\n        var get708CharFromCode = function (code) {\n            var newCode = CHARACTER_TRANSLATION_708[code] || code;\n            if (code & 0x1000 && code === newCode) {\n                // Invalid extended code\n                return '';\n            }\n            return String.fromCharCode(newCode);\n        };\n        var within708TextBlock = function (b) {\n            return 0x20 <= b && b <= 0x7f || 0xa0 <= b && b <= 0xff;\n        };\n        var Cea708Window = function (windowNum) {\n            this.windowNum = windowNum;\n            this.reset();\n        };\n        Cea708Window.prototype.reset = function () {\n            this.clearText();\n            this.pendingNewLine = false;\n            this.winAttr = {};\n            this.penAttr = {};\n            this.penLoc = {};\n            this.penColor = {}; // These default values are arbitrary,\n            // defineWindow will usually override them\n\n            this.visible = 0;\n            this.rowLock = 0;\n            this.columnLock = 0;\n            this.priority = 0;\n            this.relativePositioning = 0;\n            this.anchorVertical = 0;\n            this.anchorHorizontal = 0;\n            this.anchorPoint = 0;\n            this.rowCount = 1;\n            this.virtualRowCount = this.rowCount + 1;\n            this.columnCount = 41;\n            this.windowStyle = 0;\n            this.penStyle = 0;\n        };\n        Cea708Window.prototype.getText = function () {\n            return this.rows.join('\\n');\n        };\n        Cea708Window.prototype.clearText = function () {\n            this.rows = [''];\n            this.rowIdx = 0;\n        };\n        Cea708Window.prototype.newLine = function (pts) {\n            if (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow === 'function') {\n                this.beforeRowOverflow(pts);\n            }\n            if (this.rows.length > 0) {\n                this.rows.push('');\n                this.rowIdx++;\n            } // Show all virtual rows since there's no visible scrolling\n\n            while (this.rows.length > this.virtualRowCount) {\n                this.rows.shift();\n                this.rowIdx--;\n            }\n        };\n        Cea708Window.prototype.isEmpty = function () {\n            if (this.rows.length === 0) {\n                return true;\n            } else if (this.rows.length === 1) {\n                return this.rows[0] === '';\n            }\n            return false;\n        };\n        Cea708Window.prototype.addText = function (text) {\n            this.rows[this.rowIdx] += text;\n        };\n        Cea708Window.prototype.backspace = function () {\n            if (!this.isEmpty()) {\n                var row = this.rows[this.rowIdx];\n                this.rows[this.rowIdx] = row.substr(0, row.length - 1);\n            }\n        };\n        var Cea708Service = function (serviceNum, encoding, stream) {\n            this.serviceNum = serviceNum;\n            this.text = '';\n            this.currentWindow = new Cea708Window(-1);\n            this.windows = [];\n            this.stream = stream; // Try to setup a TextDecoder if an `encoding` value was provided\n\n            if (typeof encoding === 'string') {\n                this.createTextDecoder(encoding);\n            }\n        };\n        /**\n         * Initialize service windows\n         * Must be run before service use\n         *\n         * @param  {Integer}  pts               PTS value\n         * @param  {Function} beforeRowOverflow Function to execute before row overflow of a window\n         */\n\n        Cea708Service.prototype.init = function (pts, beforeRowOverflow) {\n            this.startPts = pts;\n            for (var win = 0; win < 8; win++) {\n                this.windows[win] = new Cea708Window(win);\n                if (typeof beforeRowOverflow === 'function') {\n                    this.windows[win].beforeRowOverflow = beforeRowOverflow;\n                }\n            }\n        };\n        /**\n         * Set current window of service to be affected by commands\n         *\n         * @param  {Integer} windowNum Window number\n         */\n\n        Cea708Service.prototype.setCurrentWindow = function (windowNum) {\n            this.currentWindow = this.windows[windowNum];\n        };\n        /**\n         * Try to create a TextDecoder if it is natively supported\n         */\n\n        Cea708Service.prototype.createTextDecoder = function (encoding) {\n            if (typeof TextDecoder === 'undefined') {\n                this.stream.trigger('log', {\n                    level: 'warn',\n                    message: 'The `encoding` option is unsupported without TextDecoder support'\n                });\n            } else {\n                try {\n                    this.textDecoder_ = new TextDecoder(encoding);\n                } catch (error) {\n                    this.stream.trigger('log', {\n                        level: 'warn',\n                        message: 'TextDecoder could not be created with ' + encoding + ' encoding. ' + error\n                    });\n                }\n            }\n        };\n        var Cea708Stream = function (options) {\n            options = options || {};\n            Cea708Stream.prototype.init.call(this);\n            var self = this;\n            var captionServices = options.captionServices || {};\n            var captionServiceEncodings = {};\n            var serviceProps; // Get service encodings from captionServices option block\n\n            Object.keys(captionServices).forEach(serviceName => {\n                serviceProps = captionServices[serviceName];\n                if (/^SERVICE/.test(serviceName)) {\n                    captionServiceEncodings[serviceName] = serviceProps.encoding;\n                }\n            });\n            this.serviceEncodings = captionServiceEncodings;\n            this.current708Packet = null;\n            this.services = {};\n            this.push = function (packet) {\n                if (packet.type === 3) {\n                    // 708 packet start\n                    self.new708Packet();\n                    self.add708Bytes(packet);\n                } else {\n                    if (self.current708Packet === null) {\n                        // This should only happen at the start of a file if there's no packet start.\n                        self.new708Packet();\n                    }\n                    self.add708Bytes(packet);\n                }\n            };\n        };\n        Cea708Stream.prototype = new Stream$7();\n        /**\n         * Push current 708 packet, create new 708 packet.\n         */\n\n        Cea708Stream.prototype.new708Packet = function () {\n            if (this.current708Packet !== null) {\n                this.push708Packet();\n            }\n            this.current708Packet = {\n                data: [],\n                ptsVals: []\n            };\n        };\n        /**\n         * Add pts and both bytes from packet into current 708 packet.\n         */\n\n        Cea708Stream.prototype.add708Bytes = function (packet) {\n            var data = packet.ccData;\n            var byte0 = data >>> 8;\n            var byte1 = data & 0xff; // I would just keep a list of packets instead of bytes, but it isn't clear in the spec\n            // that service blocks will always line up with byte pairs.\n\n            this.current708Packet.ptsVals.push(packet.pts);\n            this.current708Packet.data.push(byte0);\n            this.current708Packet.data.push(byte1);\n        };\n        /**\n         * Parse completed 708 packet into service blocks and push each service block.\n         */\n\n        Cea708Stream.prototype.push708Packet = function () {\n            var packet708 = this.current708Packet;\n            var packetData = packet708.data;\n            var serviceNum = null;\n            var blockSize = null;\n            var i = 0;\n            var b = packetData[i++];\n            packet708.seq = b >> 6;\n            packet708.sizeCode = b & 0x3f; // 0b00111111;\n\n            for (; i < packetData.length; i++) {\n                b = packetData[i++];\n                serviceNum = b >> 5;\n                blockSize = b & 0x1f; // 0b00011111\n\n                if (serviceNum === 7 && blockSize > 0) {\n                    // Extended service num\n                    b = packetData[i++];\n                    serviceNum = b;\n                }\n                this.pushServiceBlock(serviceNum, i, blockSize);\n                if (blockSize > 0) {\n                    i += blockSize - 1;\n                }\n            }\n        };\n        /**\n         * Parse service block, execute commands, read text.\n         *\n         * Note: While many of these commands serve important purposes,\n         * many others just parse out the parameters or attributes, but\n         * nothing is done with them because this is not a full and complete\n         * implementation of the entire 708 spec.\n         *\n         * @param  {Integer} serviceNum Service number\n         * @param  {Integer} start      Start index of the 708 packet data\n         * @param  {Integer} size       Block size\n         */\n\n        Cea708Stream.prototype.pushServiceBlock = function (serviceNum, start, size) {\n            var b;\n            var i = start;\n            var packetData = this.current708Packet.data;\n            var service = this.services[serviceNum];\n            if (!service) {\n                service = this.initService(serviceNum, i);\n            }\n            for (; i < start + size && i < packetData.length; i++) {\n                b = packetData[i];\n                if (within708TextBlock(b)) {\n                    i = this.handleText(i, service);\n                } else if (b === 0x18) {\n                    i = this.multiByteCharacter(i, service);\n                } else if (b === 0x10) {\n                    i = this.extendedCommands(i, service);\n                } else if (0x80 <= b && b <= 0x87) {\n                    i = this.setCurrentWindow(i, service);\n                } else if (0x98 <= b && b <= 0x9f) {\n                    i = this.defineWindow(i, service);\n                } else if (b === 0x88) {\n                    i = this.clearWindows(i, service);\n                } else if (b === 0x8c) {\n                    i = this.deleteWindows(i, service);\n                } else if (b === 0x89) {\n                    i = this.displayWindows(i, service);\n                } else if (b === 0x8a) {\n                    i = this.hideWindows(i, service);\n                } else if (b === 0x8b) {\n                    i = this.toggleWindows(i, service);\n                } else if (b === 0x97) {\n                    i = this.setWindowAttributes(i, service);\n                } else if (b === 0x90) {\n                    i = this.setPenAttributes(i, service);\n                } else if (b === 0x91) {\n                    i = this.setPenColor(i, service);\n                } else if (b === 0x92) {\n                    i = this.setPenLocation(i, service);\n                } else if (b === 0x8f) {\n                    service = this.reset(i, service);\n                } else if (b === 0x08) {\n                    // BS: Backspace\n                    service.currentWindow.backspace();\n                } else if (b === 0x0c) {\n                    // FF: Form feed\n                    service.currentWindow.clearText();\n                } else if (b === 0x0d) {\n                    // CR: Carriage return\n                    service.currentWindow.pendingNewLine = true;\n                } else if (b === 0x0e) {\n                    // HCR: Horizontal carriage return\n                    service.currentWindow.clearText();\n                } else if (b === 0x8d) {\n                    // DLY: Delay, nothing to do\n                    i++;\n                } else ;\n            }\n        };\n        /**\n         * Execute an extended command\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.extendedCommands = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[++i];\n            if (within708TextBlock(b)) {\n                i = this.handleText(i, service, {\n                    isExtended: true\n                });\n            }\n            return i;\n        };\n        /**\n         * Get PTS value of a given byte index\n         *\n         * @param  {Integer} byteIndex  Index of the byte\n         * @return {Integer}            PTS\n         */\n\n        Cea708Stream.prototype.getPts = function (byteIndex) {\n            // There's 1 pts value per 2 bytes\n            return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];\n        };\n        /**\n         * Initializes a service\n         *\n         * @param  {Integer} serviceNum Service number\n         * @return {Service}            Initialized service object\n         */\n\n        Cea708Stream.prototype.initService = function (serviceNum, i) {\n            var serviceName = 'SERVICE' + serviceNum;\n            var self = this;\n            var serviceName;\n            var encoding;\n            if (serviceName in this.serviceEncodings) {\n                encoding = this.serviceEncodings[serviceName];\n            }\n            this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self);\n            this.services[serviceNum].init(this.getPts(i), function (pts) {\n                self.flushDisplayed(pts, self.services[serviceNum]);\n            });\n            return this.services[serviceNum];\n        };\n        /**\n         * Execute text writing to current window\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.handleText = function (i, service, options) {\n            var isExtended = options && options.isExtended;\n            var isMultiByte = options && options.isMultiByte;\n            var packetData = this.current708Packet.data;\n            var extended = isExtended ? 0x1000 : 0x0000;\n            var currentByte = packetData[i];\n            var nextByte = packetData[i + 1];\n            var win = service.currentWindow;\n            var char;\n            var charCodeArray; // Use the TextDecoder if one was created for this service\n\n            if (service.textDecoder_ && !isExtended) {\n                if (isMultiByte) {\n                    charCodeArray = [currentByte, nextByte];\n                    i++;\n                } else {\n                    charCodeArray = [currentByte];\n                }\n                char = service.textDecoder_.decode(new Uint8Array(charCodeArray));\n            } else {\n                char = get708CharFromCode(extended | currentByte);\n            }\n            if (win.pendingNewLine && !win.isEmpty()) {\n                win.newLine(this.getPts(i));\n            }\n            win.pendingNewLine = false;\n            win.addText(char);\n            return i;\n        };\n        /**\n         * Handle decoding of multibyte character\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.multiByteCharacter = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var firstByte = packetData[i + 1];\n            var secondByte = packetData[i + 2];\n            if (within708TextBlock(firstByte) && within708TextBlock(secondByte)) {\n                i = this.handleText(++i, service, {\n                    isMultiByte: true\n                });\n            }\n            return i;\n        };\n        /**\n         * Parse and execute the CW# command.\n         *\n         * Set the current window.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.setCurrentWindow = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[i];\n            var windowNum = b & 0x07;\n            service.setCurrentWindow(windowNum);\n            return i;\n        };\n        /**\n         * Parse and execute the DF# command.\n         *\n         * Define a window and set it as the current window.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.defineWindow = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[i];\n            var windowNum = b & 0x07;\n            service.setCurrentWindow(windowNum);\n            var win = service.currentWindow;\n            b = packetData[++i];\n            win.visible = (b & 0x20) >> 5; // v\n\n            win.rowLock = (b & 0x10) >> 4; // rl\n\n            win.columnLock = (b & 0x08) >> 3; // cl\n\n            win.priority = b & 0x07; // p\n\n            b = packetData[++i];\n            win.relativePositioning = (b & 0x80) >> 7; // rp\n\n            win.anchorVertical = b & 0x7f; // av\n\n            b = packetData[++i];\n            win.anchorHorizontal = b; // ah\n\n            b = packetData[++i];\n            win.anchorPoint = (b & 0xf0) >> 4; // ap\n\n            win.rowCount = b & 0x0f; // rc\n\n            b = packetData[++i];\n            win.columnCount = b & 0x3f; // cc\n\n            b = packetData[++i];\n            win.windowStyle = (b & 0x38) >> 3; // ws\n\n            win.penStyle = b & 0x07; // ps\n            // The spec says there are (rowCount+1) \"virtual rows\"\n\n            win.virtualRowCount = win.rowCount + 1;\n            return i;\n        };\n        /**\n         * Parse and execute the SWA command.\n         *\n         * Set attributes of the current window.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.setWindowAttributes = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[i];\n            var winAttr = service.currentWindow.winAttr;\n            b = packetData[++i];\n            winAttr.fillOpacity = (b & 0xc0) >> 6; // fo\n\n            winAttr.fillRed = (b & 0x30) >> 4; // fr\n\n            winAttr.fillGreen = (b & 0x0c) >> 2; // fg\n\n            winAttr.fillBlue = b & 0x03; // fb\n\n            b = packetData[++i];\n            winAttr.borderType = (b & 0xc0) >> 6; // bt\n\n            winAttr.borderRed = (b & 0x30) >> 4; // br\n\n            winAttr.borderGreen = (b & 0x0c) >> 2; // bg\n\n            winAttr.borderBlue = b & 0x03; // bb\n\n            b = packetData[++i];\n            winAttr.borderType += (b & 0x80) >> 5; // bt\n\n            winAttr.wordWrap = (b & 0x40) >> 6; // ww\n\n            winAttr.printDirection = (b & 0x30) >> 4; // pd\n\n            winAttr.scrollDirection = (b & 0x0c) >> 2; // sd\n\n            winAttr.justify = b & 0x03; // j\n\n            b = packetData[++i];\n            winAttr.effectSpeed = (b & 0xf0) >> 4; // es\n\n            winAttr.effectDirection = (b & 0x0c) >> 2; // ed\n\n            winAttr.displayEffect = b & 0x03; // de\n\n            return i;\n        };\n        /**\n         * Gather text from all displayed windows and push a caption to output.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         */\n\n        Cea708Stream.prototype.flushDisplayed = function (pts, service) {\n            var displayedText = []; // TODO: Positioning not supported, displaying multiple windows will not necessarily\n            // display text in the correct order, but sample files so far have not shown any issue.\n\n            for (var winId = 0; winId < 8; winId++) {\n                if (service.windows[winId].visible && !service.windows[winId].isEmpty()) {\n                    displayedText.push(service.windows[winId].getText());\n                }\n            }\n            service.endPts = pts;\n            service.text = displayedText.join('\\n\\n');\n            this.pushCaption(service);\n            service.startPts = pts;\n        };\n        /**\n         * Push a caption to output if the caption contains text.\n         *\n         * @param  {Service} service  The service object to be affected\n         */\n\n        Cea708Stream.prototype.pushCaption = function (service) {\n            if (service.text !== '') {\n                this.trigger('data', {\n                    startPts: service.startPts,\n                    endPts: service.endPts,\n                    text: service.text,\n                    stream: 'cc708_' + service.serviceNum\n                });\n                service.text = '';\n                service.startPts = service.endPts;\n            }\n        };\n        /**\n         * Parse and execute the DSW command.\n         *\n         * Set visible property of windows based on the parsed bitmask.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.displayWindows = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[++i];\n            var pts = this.getPts(i);\n            this.flushDisplayed(pts, service);\n            for (var winId = 0; winId < 8; winId++) {\n                if (b & 0x01 << winId) {\n                    service.windows[winId].visible = 1;\n                }\n            }\n            return i;\n        };\n        /**\n         * Parse and execute the HDW command.\n         *\n         * Set visible property of windows based on the parsed bitmask.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.hideWindows = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[++i];\n            var pts = this.getPts(i);\n            this.flushDisplayed(pts, service);\n            for (var winId = 0; winId < 8; winId++) {\n                if (b & 0x01 << winId) {\n                    service.windows[winId].visible = 0;\n                }\n            }\n            return i;\n        };\n        /**\n         * Parse and execute the TGW command.\n         *\n         * Set visible property of windows based on the parsed bitmask.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.toggleWindows = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[++i];\n            var pts = this.getPts(i);\n            this.flushDisplayed(pts, service);\n            for (var winId = 0; winId < 8; winId++) {\n                if (b & 0x01 << winId) {\n                    service.windows[winId].visible ^= 1;\n                }\n            }\n            return i;\n        };\n        /**\n         * Parse and execute the CLW command.\n         *\n         * Clear text of windows based on the parsed bitmask.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.clearWindows = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[++i];\n            var pts = this.getPts(i);\n            this.flushDisplayed(pts, service);\n            for (var winId = 0; winId < 8; winId++) {\n                if (b & 0x01 << winId) {\n                    service.windows[winId].clearText();\n                }\n            }\n            return i;\n        };\n        /**\n         * Parse and execute the DLW command.\n         *\n         * Re-initialize windows based on the parsed bitmask.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.deleteWindows = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[++i];\n            var pts = this.getPts(i);\n            this.flushDisplayed(pts, service);\n            for (var winId = 0; winId < 8; winId++) {\n                if (b & 0x01 << winId) {\n                    service.windows[winId].reset();\n                }\n            }\n            return i;\n        };\n        /**\n         * Parse and execute the SPA command.\n         *\n         * Set pen attributes of the current window.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.setPenAttributes = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[i];\n            var penAttr = service.currentWindow.penAttr;\n            b = packetData[++i];\n            penAttr.textTag = (b & 0xf0) >> 4; // tt\n\n            penAttr.offset = (b & 0x0c) >> 2; // o\n\n            penAttr.penSize = b & 0x03; // s\n\n            b = packetData[++i];\n            penAttr.italics = (b & 0x80) >> 7; // i\n\n            penAttr.underline = (b & 0x40) >> 6; // u\n\n            penAttr.edgeType = (b & 0x38) >> 3; // et\n\n            penAttr.fontStyle = b & 0x07; // fs\n\n            return i;\n        };\n        /**\n         * Parse and execute the SPC command.\n         *\n         * Set pen color of the current window.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.setPenColor = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[i];\n            var penColor = service.currentWindow.penColor;\n            b = packetData[++i];\n            penColor.fgOpacity = (b & 0xc0) >> 6; // fo\n\n            penColor.fgRed = (b & 0x30) >> 4; // fr\n\n            penColor.fgGreen = (b & 0x0c) >> 2; // fg\n\n            penColor.fgBlue = b & 0x03; // fb\n\n            b = packetData[++i];\n            penColor.bgOpacity = (b & 0xc0) >> 6; // bo\n\n            penColor.bgRed = (b & 0x30) >> 4; // br\n\n            penColor.bgGreen = (b & 0x0c) >> 2; // bg\n\n            penColor.bgBlue = b & 0x03; // bb\n\n            b = packetData[++i];\n            penColor.edgeRed = (b & 0x30) >> 4; // er\n\n            penColor.edgeGreen = (b & 0x0c) >> 2; // eg\n\n            penColor.edgeBlue = b & 0x03; // eb\n\n            return i;\n        };\n        /**\n         * Parse and execute the SPL command.\n         *\n         * Set pen location of the current window.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Integer}          New index after parsing\n         */\n\n        Cea708Stream.prototype.setPenLocation = function (i, service) {\n            var packetData = this.current708Packet.data;\n            var b = packetData[i];\n            var penLoc = service.currentWindow.penLoc; // Positioning isn't really supported at the moment, so this essentially just inserts a linebreak\n\n            service.currentWindow.pendingNewLine = true;\n            b = packetData[++i];\n            penLoc.row = b & 0x0f; // r\n\n            b = packetData[++i];\n            penLoc.column = b & 0x3f; // c\n\n            return i;\n        };\n        /**\n         * Execute the RST command.\n         *\n         * Reset service to a clean slate. Re-initialize.\n         *\n         * @param  {Integer} i        Current index in the 708 packet\n         * @param  {Service} service  The service object to be affected\n         * @return {Service}          Re-initialized service\n         */\n\n        Cea708Stream.prototype.reset = function (i, service) {\n            var pts = this.getPts(i);\n            this.flushDisplayed(pts, service);\n            return this.initService(service.serviceNum, i);\n        }; // This hash maps non-ASCII, special, and extended character codes to their\n        // proper Unicode equivalent. The first keys that are only a single byte\n        // are the non-standard ASCII characters, which simply map the CEA608 byte\n        // to the standard ASCII/Unicode. The two-byte keys that follow are the CEA608\n        // character codes, but have their MSB bitmasked with 0x03 so that a lookup\n        // can be performed regardless of the field and data channel on which the\n        // character code was received.\n\n        var CHARACTER_TRANSLATION = {\n            0x2a: 0xe1,\n            // á\n            0x5c: 0xe9,\n            // é\n            0x5e: 0xed,\n            // í\n            0x5f: 0xf3,\n            // ó\n            0x60: 0xfa,\n            // ú\n            0x7b: 0xe7,\n            // ç\n            0x7c: 0xf7,\n            // ÷\n            0x7d: 0xd1,\n            // Ñ\n            0x7e: 0xf1,\n            // ñ\n            0x7f: 0x2588,\n            // █\n            0x0130: 0xae,\n            // ®\n            0x0131: 0xb0,\n            // °\n            0x0132: 0xbd,\n            // ½\n            0x0133: 0xbf,\n            // ¿\n            0x0134: 0x2122,\n            // ™\n            0x0135: 0xa2,\n            // ¢\n            0x0136: 0xa3,\n            // £\n            0x0137: 0x266a,\n            // ♪\n            0x0138: 0xe0,\n            // à\n            0x0139: 0xa0,\n            //\n            0x013a: 0xe8,\n            // è\n            0x013b: 0xe2,\n            // â\n            0x013c: 0xea,\n            // ê\n            0x013d: 0xee,\n            // î\n            0x013e: 0xf4,\n            // ô\n            0x013f: 0xfb,\n            // û\n            0x0220: 0xc1,\n            // Á\n            0x0221: 0xc9,\n            // É\n            0x0222: 0xd3,\n            // Ó\n            0x0223: 0xda,\n            // Ú\n            0x0224: 0xdc,\n            // Ü\n            0x0225: 0xfc,\n            // ü\n            0x0226: 0x2018,\n            // ‘\n            0x0227: 0xa1,\n            // ¡\n            0x0228: 0x2a,\n            // *\n            0x0229: 0x27,\n            // '\n            0x022a: 0x2014,\n            // —\n            0x022b: 0xa9,\n            // ©\n            0x022c: 0x2120,\n            // ℠\n            0x022d: 0x2022,\n            // •\n            0x022e: 0x201c,\n            // “\n            0x022f: 0x201d,\n            // ”\n            0x0230: 0xc0,\n            // À\n            0x0231: 0xc2,\n            // Â\n            0x0232: 0xc7,\n            // Ç\n            0x0233: 0xc8,\n            // È\n            0x0234: 0xca,\n            // Ê\n            0x0235: 0xcb,\n            // Ë\n            0x0236: 0xeb,\n            // ë\n            0x0237: 0xce,\n            // Î\n            0x0238: 0xcf,\n            // Ï\n            0x0239: 0xef,\n            // ï\n            0x023a: 0xd4,\n            // Ô\n            0x023b: 0xd9,\n            // Ù\n            0x023c: 0xf9,\n            // ù\n            0x023d: 0xdb,\n            // Û\n            0x023e: 0xab,\n            // «\n            0x023f: 0xbb,\n            // »\n            0x0320: 0xc3,\n            // Ã\n            0x0321: 0xe3,\n            // ã\n            0x0322: 0xcd,\n            // Í\n            0x0323: 0xcc,\n            // Ì\n            0x0324: 0xec,\n            // ì\n            0x0325: 0xd2,\n            // Ò\n            0x0326: 0xf2,\n            // ò\n            0x0327: 0xd5,\n            // Õ\n            0x0328: 0xf5,\n            // õ\n            0x0329: 0x7b,\n            // {\n            0x032a: 0x7d,\n            // }\n            0x032b: 0x5c,\n            // \\\n            0x032c: 0x5e,\n            // ^\n            0x032d: 0x5f,\n            // _\n            0x032e: 0x7c,\n            // |\n            0x032f: 0x7e,\n            // ~\n            0x0330: 0xc4,\n            // Ä\n            0x0331: 0xe4,\n            // ä\n            0x0332: 0xd6,\n            // Ö\n            0x0333: 0xf6,\n            // ö\n            0x0334: 0xdf,\n            // ß\n            0x0335: 0xa5,\n            // ¥\n            0x0336: 0xa4,\n            // ¤\n            0x0337: 0x2502,\n            // │\n            0x0338: 0xc5,\n            // Å\n            0x0339: 0xe5,\n            // å\n            0x033a: 0xd8,\n            // Ø\n            0x033b: 0xf8,\n            // ø\n            0x033c: 0x250c,\n            // ┌\n            0x033d: 0x2510,\n            // ┐\n            0x033e: 0x2514,\n            // └\n            0x033f: 0x2518 // ┘\n        };\n\n        var getCharFromCode = function (code) {\n            if (code === null) {\n                return '';\n            }\n            code = CHARACTER_TRANSLATION[code] || code;\n            return String.fromCharCode(code);\n        }; // the index of the last row in a CEA-608 display buffer\n\n        var BOTTOM_ROW = 14; // This array is used for mapping PACs -> row #, since there's no way of\n        // getting it through bit logic.\n\n        var ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620, 0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420]; // CEA-608 captions are rendered onto a 34x15 matrix of character\n        // cells. The \"bottom\" row is the last element in the outer array.\n\n        var createDisplayBuffer = function () {\n            var result = [],\n                i = BOTTOM_ROW + 1;\n            while (i--) {\n                result.push('');\n            }\n            return result;\n        };\n        var Cea608Stream = function (field, dataChannel) {\n            Cea608Stream.prototype.init.call(this);\n            this.field_ = field || 0;\n            this.dataChannel_ = dataChannel || 0;\n            this.name_ = 'CC' + ((this.field_ << 1 | this.dataChannel_) + 1);\n            this.setConstants();\n            this.reset();\n            this.push = function (packet) {\n                var data, swap, char0, char1, text; // remove the parity bits\n\n                data = packet.ccData & 0x7f7f; // ignore duplicate control codes; the spec demands they're sent twice\n\n                if (data === this.lastControlCode_) {\n                    this.lastControlCode_ = null;\n                    return;\n                } // Store control codes\n\n                if ((data & 0xf000) === 0x1000) {\n                    this.lastControlCode_ = data;\n                } else if (data !== this.PADDING_) {\n                    this.lastControlCode_ = null;\n                }\n                char0 = data >>> 8;\n                char1 = data & 0xff;\n                if (data === this.PADDING_) {\n                    return;\n                } else if (data === this.RESUME_CAPTION_LOADING_) {\n                    this.mode_ = 'popOn';\n                } else if (data === this.END_OF_CAPTION_) {\n                    // If an EOC is received while in paint-on mode, the displayed caption\n                    // text should be swapped to non-displayed memory as if it was a pop-on\n                    // caption. Because of that, we should explicitly switch back to pop-on\n                    // mode\n                    this.mode_ = 'popOn';\n                    this.clearFormatting(packet.pts); // if a caption was being displayed, it's gone now\n\n                    this.flushDisplayed(packet.pts); // flip memory\n\n                    swap = this.displayed_;\n                    this.displayed_ = this.nonDisplayed_;\n                    this.nonDisplayed_ = swap; // start measuring the time to display the caption\n\n                    this.startPts_ = packet.pts;\n                } else if (data === this.ROLL_UP_2_ROWS_) {\n                    this.rollUpRows_ = 2;\n                    this.setRollUp(packet.pts);\n                } else if (data === this.ROLL_UP_3_ROWS_) {\n                    this.rollUpRows_ = 3;\n                    this.setRollUp(packet.pts);\n                } else if (data === this.ROLL_UP_4_ROWS_) {\n                    this.rollUpRows_ = 4;\n                    this.setRollUp(packet.pts);\n                } else if (data === this.CARRIAGE_RETURN_) {\n                    this.clearFormatting(packet.pts);\n                    this.flushDisplayed(packet.pts);\n                    this.shiftRowsUp_();\n                    this.startPts_ = packet.pts;\n                } else if (data === this.BACKSPACE_) {\n                    if (this.mode_ === 'popOn') {\n                        this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n                    } else {\n                        this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n                    }\n                } else if (data === this.ERASE_DISPLAYED_MEMORY_) {\n                    this.flushDisplayed(packet.pts);\n                    this.displayed_ = createDisplayBuffer();\n                } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {\n                    this.nonDisplayed_ = createDisplayBuffer();\n                } else if (data === this.RESUME_DIRECT_CAPTIONING_) {\n                    if (this.mode_ !== 'paintOn') {\n                        // NOTE: This should be removed when proper caption positioning is\n                        // implemented\n                        this.flushDisplayed(packet.pts);\n                        this.displayed_ = createDisplayBuffer();\n                    }\n                    this.mode_ = 'paintOn';\n                    this.startPts_ = packet.pts; // Append special characters to caption text\n                } else if (this.isSpecialCharacter(char0, char1)) {\n                    // Bitmask char0 so that we can apply character transformations\n                    // regardless of field and data channel.\n                    // Then byte-shift to the left and OR with char1 so we can pass the\n                    // entire character code to `getCharFromCode`.\n                    char0 = (char0 & 0x03) << 8;\n                    text = getCharFromCode(char0 | char1);\n                    this[this.mode_](packet.pts, text);\n                    this.column_++; // Append extended characters to caption text\n                } else if (this.isExtCharacter(char0, char1)) {\n                    // Extended characters always follow their \"non-extended\" equivalents.\n                    // IE if a \"è\" is desired, you'll always receive \"eè\"; non-compliant\n                    // decoders are supposed to drop the \"è\", while compliant decoders\n                    // backspace the \"e\" and insert \"è\".\n                    // Delete the previous character\n                    if (this.mode_ === 'popOn') {\n                        this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n                    } else {\n                        this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n                    } // Bitmask char0 so that we can apply character transformations\n                    // regardless of field and data channel.\n                    // Then byte-shift to the left and OR with char1 so we can pass the\n                    // entire character code to `getCharFromCode`.\n\n                    char0 = (char0 & 0x03) << 8;\n                    text = getCharFromCode(char0 | char1);\n                    this[this.mode_](packet.pts, text);\n                    this.column_++; // Process mid-row codes\n                } else if (this.isMidRowCode(char0, char1)) {\n                    // Attributes are not additive, so clear all formatting\n                    this.clearFormatting(packet.pts); // According to the standard, mid-row codes\n                    // should be replaced with spaces, so add one now\n\n                    this[this.mode_](packet.pts, ' ');\n                    this.column_++;\n                    if ((char1 & 0xe) === 0xe) {\n                        this.addFormatting(packet.pts, ['i']);\n                    }\n                    if ((char1 & 0x1) === 0x1) {\n                        this.addFormatting(packet.pts, ['u']);\n                    } // Detect offset control codes and adjust cursor\n                } else if (this.isOffsetControlCode(char0, char1)) {\n                    // Cursor position is set by indent PAC (see below) in 4-column\n                    // increments, with an additional offset code of 1-3 to reach any\n                    // of the 32 columns specified by CEA-608. So all we need to do\n                    // here is increment the column cursor by the given offset.\n                    this.column_ += char1 & 0x03; // Detect PACs (Preamble Address Codes)\n                } else if (this.isPAC(char0, char1)) {\n                    // There's no logic for PAC -> row mapping, so we have to just\n                    // find the row code in an array and use its index :(\n                    var row = ROWS.indexOf(data & 0x1f20); // Configure the caption window if we're in roll-up mode\n\n                    if (this.mode_ === 'rollUp') {\n                        // This implies that the base row is incorrectly set.\n                        // As per the recommendation in CEA-608(Base Row Implementation), defer to the number\n                        // of roll-up rows set.\n                        if (row - this.rollUpRows_ + 1 < 0) {\n                            row = this.rollUpRows_ - 1;\n                        }\n                        this.setRollUp(packet.pts, row);\n                    }\n                    if (row !== this.row_) {\n                        // formatting is only persistent for current row\n                        this.clearFormatting(packet.pts);\n                        this.row_ = row;\n                    } // All PACs can apply underline, so detect and apply\n                    // (All odd-numbered second bytes set underline)\n\n                    if (char1 & 0x1 && this.formatting_.indexOf('u') === -1) {\n                        this.addFormatting(packet.pts, ['u']);\n                    }\n                    if ((data & 0x10) === 0x10) {\n                        // We've got an indent level code. Each successive even number\n                        // increments the column cursor by 4, so we can get the desired\n                        // column position by bit-shifting to the right (to get n/2)\n                        // and multiplying by 4.\n                        this.column_ = ((data & 0xe) >> 1) * 4;\n                    }\n                    if (this.isColorPAC(char1)) {\n                        // it's a color code, though we only support white, which\n                        // can be either normal or italicized. white italics can be\n                        // either 0x4e or 0x6e depending on the row, so we just\n                        // bitwise-and with 0xe to see if italics should be turned on\n                        if ((char1 & 0xe) === 0xe) {\n                            this.addFormatting(packet.pts, ['i']);\n                        }\n                    } // We have a normal character in char0, and possibly one in char1\n                } else if (this.isNormalChar(char0)) {\n                    if (char1 === 0x00) {\n                        char1 = null;\n                    }\n                    text = getCharFromCode(char0);\n                    text += getCharFromCode(char1);\n                    this[this.mode_](packet.pts, text);\n                    this.column_ += text.length;\n                } // finish data processing\n            };\n        };\n\n        Cea608Stream.prototype = new Stream$7(); // Trigger a cue point that captures the current state of the\n        // display buffer\n\n        Cea608Stream.prototype.flushDisplayed = function (pts) {\n            var content = this.displayed_ // remove spaces from the start and end of the string\n                .map(function (row, index) {\n                    try {\n                        return row.trim();\n                    } catch (e) {\n                        // Ordinarily, this shouldn't happen. However, caption\n                        // parsing errors should not throw exceptions and\n                        // break playback.\n                        this.trigger('log', {\n                            level: 'warn',\n                            message: 'Skipping a malformed 608 caption at index ' + index + '.'\n                        });\n                        return '';\n                    }\n                }, this) // combine all text rows to display in one cue\n                .join('\\n') // and remove blank rows from the start and end, but not the middle\n                .replace(/^\\n+|\\n+$/g, '');\n            if (content.length) {\n                this.trigger('data', {\n                    startPts: this.startPts_,\n                    endPts: pts,\n                    text: content,\n                    stream: this.name_\n                });\n            }\n        };\n        /**\n         * Zero out the data, used for startup and on seek\n         */\n\n        Cea608Stream.prototype.reset = function () {\n            this.mode_ = 'popOn'; // When in roll-up mode, the index of the last row that will\n            // actually display captions. If a caption is shifted to a row\n            // with a lower index than this, it is cleared from the display\n            // buffer\n\n            this.topRow_ = 0;\n            this.startPts_ = 0;\n            this.displayed_ = createDisplayBuffer();\n            this.nonDisplayed_ = createDisplayBuffer();\n            this.lastControlCode_ = null; // Track row and column for proper line-breaking and spacing\n\n            this.column_ = 0;\n            this.row_ = BOTTOM_ROW;\n            this.rollUpRows_ = 2; // This variable holds currently-applied formatting\n\n            this.formatting_ = [];\n        };\n        /**\n         * Sets up control code and related constants for this instance\n         */\n\n        Cea608Stream.prototype.setConstants = function () {\n            // The following attributes have these uses:\n            // ext_ :    char0 for mid-row codes, and the base for extended\n            //           chars (ext_+0, ext_+1, and ext_+2 are char0s for\n            //           extended codes)\n            // control_: char0 for control codes, except byte-shifted to the\n            //           left so that we can do this.control_ | CONTROL_CODE\n            // offset_:  char0 for tab offset codes\n            //\n            // It's also worth noting that control codes, and _only_ control codes,\n            // differ between field 1 and field2. Field 2 control codes are always\n            // their field 1 value plus 1. That's why there's the \"| field\" on the\n            // control value.\n            if (this.dataChannel_ === 0) {\n                this.BASE_ = 0x10;\n                this.EXT_ = 0x11;\n                this.CONTROL_ = (0x14 | this.field_) << 8;\n                this.OFFSET_ = 0x17;\n            } else if (this.dataChannel_ === 1) {\n                this.BASE_ = 0x18;\n                this.EXT_ = 0x19;\n                this.CONTROL_ = (0x1c | this.field_) << 8;\n                this.OFFSET_ = 0x1f;\n            } // Constants for the LSByte command codes recognized by Cea608Stream. This\n            // list is not exhaustive. For a more comprehensive listing and semantics see\n            // http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\n            // Padding\n\n            this.PADDING_ = 0x0000; // Pop-on Mode\n\n            this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 0x20;\n            this.END_OF_CAPTION_ = this.CONTROL_ | 0x2f; // Roll-up Mode\n\n            this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 0x25;\n            this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 0x26;\n            this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 0x27;\n            this.CARRIAGE_RETURN_ = this.CONTROL_ | 0x2d; // paint-on mode\n\n            this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 0x29; // Erasure\n\n            this.BACKSPACE_ = this.CONTROL_ | 0x21;\n            this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2c;\n            this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;\n        };\n        /**\n         * Detects if the 2-byte packet data is a special character\n         *\n         * Special characters have a second byte in the range 0x30 to 0x3f,\n         * with the first byte being 0x11 (for data channel 1) or 0x19 (for\n         * data channel 2).\n         *\n         * @param  {Integer} char0 The first byte\n         * @param  {Integer} char1 The second byte\n         * @return {Boolean}       Whether the 2 bytes are an special character\n         */\n\n        Cea608Stream.prototype.isSpecialCharacter = function (char0, char1) {\n            return char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f;\n        };\n        /**\n         * Detects if the 2-byte packet data is an extended character\n         *\n         * Extended characters have a second byte in the range 0x20 to 0x3f,\n         * with the first byte being 0x12 or 0x13 (for data channel 1) or\n         * 0x1a or 0x1b (for data channel 2).\n         *\n         * @param  {Integer} char0 The first byte\n         * @param  {Integer} char1 The second byte\n         * @return {Boolean}       Whether the 2 bytes are an extended character\n         */\n\n        Cea608Stream.prototype.isExtCharacter = function (char0, char1) {\n            return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 0x20 && char1 <= 0x3f;\n        };\n        /**\n         * Detects if the 2-byte packet is a mid-row code\n         *\n         * Mid-row codes have a second byte in the range 0x20 to 0x2f, with\n         * the first byte being 0x11 (for data channel 1) or 0x19 (for data\n         * channel 2).\n         *\n         * @param  {Integer} char0 The first byte\n         * @param  {Integer} char1 The second byte\n         * @return {Boolean}       Whether the 2 bytes are a mid-row code\n         */\n\n        Cea608Stream.prototype.isMidRowCode = function (char0, char1) {\n            return char0 === this.EXT_ && char1 >= 0x20 && char1 <= 0x2f;\n        };\n        /**\n         * Detects if the 2-byte packet is an offset control code\n         *\n         * Offset control codes have a second byte in the range 0x21 to 0x23,\n         * with the first byte being 0x17 (for data channel 1) or 0x1f (for\n         * data channel 2).\n         *\n         * @param  {Integer} char0 The first byte\n         * @param  {Integer} char1 The second byte\n         * @return {Boolean}       Whether the 2 bytes are an offset control code\n         */\n\n        Cea608Stream.prototype.isOffsetControlCode = function (char0, char1) {\n            return char0 === this.OFFSET_ && char1 >= 0x21 && char1 <= 0x23;\n        };\n        /**\n         * Detects if the 2-byte packet is a Preamble Address Code\n         *\n         * PACs have a first byte in the range 0x10 to 0x17 (for data channel 1)\n         * or 0x18 to 0x1f (for data channel 2), with the second byte in the\n         * range 0x40 to 0x7f.\n         *\n         * @param  {Integer} char0 The first byte\n         * @param  {Integer} char1 The second byte\n         * @return {Boolean}       Whether the 2 bytes are a PAC\n         */\n\n        Cea608Stream.prototype.isPAC = function (char0, char1) {\n            return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 0x40 && char1 <= 0x7f;\n        };\n        /**\n         * Detects if a packet's second byte is in the range of a PAC color code\n         *\n         * PAC color codes have the second byte be in the range 0x40 to 0x4f, or\n         * 0x60 to 0x6f.\n         *\n         * @param  {Integer} char1 The second byte\n         * @return {Boolean}       Whether the byte is a color PAC\n         */\n\n        Cea608Stream.prototype.isColorPAC = function (char1) {\n            return char1 >= 0x40 && char1 <= 0x4f || char1 >= 0x60 && char1 <= 0x7f;\n        };\n        /**\n         * Detects if a single byte is in the range of a normal character\n         *\n         * Normal text bytes are in the range 0x20 to 0x7f.\n         *\n         * @param  {Integer} char  The byte\n         * @return {Boolean}       Whether the byte is a normal character\n         */\n\n        Cea608Stream.prototype.isNormalChar = function (char) {\n            return char >= 0x20 && char <= 0x7f;\n        };\n        /**\n         * Configures roll-up\n         *\n         * @param  {Integer} pts         Current PTS\n         * @param  {Integer} newBaseRow  Used by PACs to slide the current window to\n         *                               a new position\n         */\n\n        Cea608Stream.prototype.setRollUp = function (pts, newBaseRow) {\n            // Reset the base row to the bottom row when switching modes\n            if (this.mode_ !== 'rollUp') {\n                this.row_ = BOTTOM_ROW;\n                this.mode_ = 'rollUp'; // Spec says to wipe memories when switching to roll-up\n\n                this.flushDisplayed(pts);\n                this.nonDisplayed_ = createDisplayBuffer();\n                this.displayed_ = createDisplayBuffer();\n            }\n            if (newBaseRow !== undefined && newBaseRow !== this.row_) {\n                // move currently displayed captions (up or down) to the new base row\n                for (var i = 0; i < this.rollUpRows_; i++) {\n                    this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];\n                    this.displayed_[this.row_ - i] = '';\n                }\n            }\n            if (newBaseRow === undefined) {\n                newBaseRow = this.row_;\n            }\n            this.topRow_ = newBaseRow - this.rollUpRows_ + 1;\n        }; // Adds the opening HTML tag for the passed character to the caption text,\n        // and keeps track of it for later closing\n\n        Cea608Stream.prototype.addFormatting = function (pts, format) {\n            this.formatting_ = this.formatting_.concat(format);\n            var text = format.reduce(function (text, format) {\n                return text + '<' + format + '>';\n            }, '');\n            this[this.mode_](pts, text);\n        }; // Adds HTML closing tags for current formatting to caption text and\n        // clears remembered formatting\n\n        Cea608Stream.prototype.clearFormatting = function (pts) {\n            if (!this.formatting_.length) {\n                return;\n            }\n            var text = this.formatting_.reverse().reduce(function (text, format) {\n                return text + '</' + format + '>';\n            }, '');\n            this.formatting_ = [];\n            this[this.mode_](pts, text);\n        }; // Mode Implementations\n\n        Cea608Stream.prototype.popOn = function (pts, text) {\n            var baseRow = this.nonDisplayed_[this.row_]; // buffer characters\n\n            baseRow += text;\n            this.nonDisplayed_[this.row_] = baseRow;\n        };\n        Cea608Stream.prototype.rollUp = function (pts, text) {\n            var baseRow = this.displayed_[this.row_];\n            baseRow += text;\n            this.displayed_[this.row_] = baseRow;\n        };\n        Cea608Stream.prototype.shiftRowsUp_ = function () {\n            var i; // clear out inactive rows\n\n            for (i = 0; i < this.topRow_; i++) {\n                this.displayed_[i] = '';\n            }\n            for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {\n                this.displayed_[i] = '';\n            } // shift displayed rows up\n\n            for (i = this.topRow_; i < this.row_; i++) {\n                this.displayed_[i] = this.displayed_[i + 1];\n            } // clear out the bottom row\n\n            this.displayed_[this.row_] = '';\n        };\n        Cea608Stream.prototype.paintOn = function (pts, text) {\n            var baseRow = this.displayed_[this.row_];\n            baseRow += text;\n            this.displayed_[this.row_] = baseRow;\n        }; // exports\n\n        var captionStream = {\n            CaptionStream: CaptionStream$2,\n            Cea608Stream: Cea608Stream,\n            Cea708Stream: Cea708Stream\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var streamTypes = {\n            H264_STREAM_TYPE: 0x1B,\n            ADTS_STREAM_TYPE: 0x0F,\n            METADATA_STREAM_TYPE: 0x15\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Accepts program elementary stream (PES) data events and corrects\n         * decode and presentation time stamps to account for a rollover\n         * of the 33 bit value.\n         */\n\n        var Stream$6 = stream;\n        var MAX_TS = 8589934592;\n        var RO_THRESH = 4294967296;\n        var TYPE_SHARED = 'shared';\n        var handleRollover$1 = function (value, reference) {\n            var direction = 1;\n            if (value > reference) {\n                // If the current timestamp value is greater than our reference timestamp and we detect a\n                // timestamp rollover, this means the roll over is happening in the opposite direction.\n                // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\n                // point will be set to a small number, e.g. 1. The user then seeks backwards over the\n                // rollover point. In loading this segment, the timestamp values will be very large,\n                // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\n                // the time stamp to be `value - 2^33`.\n                direction = -1;\n            } // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\n            // cause an incorrect adjustment.\n\n            while (Math.abs(reference - value) > RO_THRESH) {\n                value += direction * MAX_TS;\n            }\n            return value;\n        };\n        var TimestampRolloverStream$1 = function (type) {\n            var lastDTS, referenceDTS;\n            TimestampRolloverStream$1.prototype.init.call(this); // The \"shared\" type is used in cases where a stream will contain muxed\n            // video and audio. We could use `undefined` here, but having a string\n            // makes debugging a little clearer.\n\n            this.type_ = type || TYPE_SHARED;\n            this.push = function (data) {\n                // Any \"shared\" rollover streams will accept _all_ data. Otherwise,\n                // streams will only accept data that matches their type.\n                if (this.type_ !== TYPE_SHARED && data.type !== this.type_) {\n                    return;\n                }\n                if (referenceDTS === undefined) {\n                    referenceDTS = data.dts;\n                }\n                data.dts = handleRollover$1(data.dts, referenceDTS);\n                data.pts = handleRollover$1(data.pts, referenceDTS);\n                lastDTS = data.dts;\n                this.trigger('data', data);\n            };\n            this.flush = function () {\n                referenceDTS = lastDTS;\n                this.trigger('done');\n            };\n            this.endTimeline = function () {\n                this.flush();\n                this.trigger('endedtimeline');\n            };\n            this.discontinuity = function () {\n                referenceDTS = void 0;\n                lastDTS = void 0;\n            };\n            this.reset = function () {\n                this.discontinuity();\n                this.trigger('reset');\n            };\n        };\n        TimestampRolloverStream$1.prototype = new Stream$6();\n        var timestampRolloverStream = {\n            TimestampRolloverStream: TimestampRolloverStream$1,\n            handleRollover: handleRollover$1\n        }; // Once IE11 support is dropped, this function should be removed.\n\n        var typedArrayIndexOf$1 = (typedArray, element, fromIndex) => {\n            if (!typedArray) {\n                return -1;\n            }\n            var currentIndex = fromIndex;\n            for (; currentIndex < typedArray.length; currentIndex++) {\n                if (typedArray[currentIndex] === element) {\n                    return currentIndex;\n                }\n            }\n            return -1;\n        };\n        var typedArray = {\n            typedArrayIndexOf: typedArrayIndexOf$1\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Tools for parsing ID3 frame data\n         * @see http://id3.org/id3v2.3.0\n         */\n\n        var typedArrayIndexOf = typedArray.typedArrayIndexOf,\n            // Frames that allow different types of text encoding contain a text\n            // encoding description byte [ID3v2.4.0 section 4.]\n            textEncodingDescriptionByte = {\n                Iso88591: 0x00,\n                // ISO-8859-1, terminated with \\0.\n                Utf16: 0x01,\n                // UTF-16 encoded Unicode BOM, terminated with \\0\\0\n                Utf16be: 0x02,\n                // UTF-16BE encoded Unicode, without BOM, terminated with \\0\\0\n                Utf8: 0x03 // UTF-8 encoded Unicode, terminated with \\0\n            },\n            // return a percent-encoded representation of the specified byte range\n            // @see http://en.wikipedia.org/wiki/Percent-encoding\n            percentEncode$1 = function (bytes, start, end) {\n                var i,\n                    result = '';\n                for (i = start; i < end; i++) {\n                    result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n                }\n                return result;\n            },\n            // return the string representation of the specified byte range,\n            // interpreted as UTf-8.\n            parseUtf8 = function (bytes, start, end) {\n                return decodeURIComponent(percentEncode$1(bytes, start, end));\n            },\n            // return the string representation of the specified byte range,\n            // interpreted as ISO-8859-1.\n            parseIso88591$1 = function (bytes, start, end) {\n                return unescape(percentEncode$1(bytes, start, end)); // jshint ignore:line\n            },\n            parseSyncSafeInteger$1 = function (data) {\n                return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n            },\n            frameParsers = {\n                'APIC': function (frame) {\n                    var i = 1,\n                        mimeTypeEndIndex,\n                        descriptionEndIndex,\n                        LINK_MIME_TYPE = '-->';\n                    if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {\n                        // ignore frames with unrecognized character encodings\n                        return;\n                    } // parsing fields [ID3v2.4.0 section 4.14.]\n\n                    mimeTypeEndIndex = typedArrayIndexOf(frame.data, 0, i);\n                    if (mimeTypeEndIndex < 0) {\n                        // malformed frame\n                        return;\n                    } // parsing Mime type field (terminated with \\0)\n\n                    frame.mimeType = parseIso88591$1(frame.data, i, mimeTypeEndIndex);\n                    i = mimeTypeEndIndex + 1; // parsing 1-byte Picture Type field\n\n                    frame.pictureType = frame.data[i];\n                    i++;\n                    descriptionEndIndex = typedArrayIndexOf(frame.data, 0, i);\n                    if (descriptionEndIndex < 0) {\n                        // malformed frame\n                        return;\n                    } // parsing Description field (terminated with \\0)\n\n                    frame.description = parseUtf8(frame.data, i, descriptionEndIndex);\n                    i = descriptionEndIndex + 1;\n                    if (frame.mimeType === LINK_MIME_TYPE) {\n                        // parsing Picture Data field as URL (always represented as ISO-8859-1 [ID3v2.4.0 section 4.])\n                        frame.url = parseIso88591$1(frame.data, i, frame.data.length);\n                    } else {\n                        // parsing Picture Data field as binary data\n                        frame.pictureData = frame.data.subarray(i, frame.data.length);\n                    }\n                },\n                'T*': function (frame) {\n                    if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {\n                        // ignore frames with unrecognized character encodings\n                        return;\n                    } // parse text field, do not include null terminator in the frame value\n                    // frames that allow different types of encoding contain terminated text [ID3v2.4.0 section 4.]\n\n                    frame.value = parseUtf8(frame.data, 1, frame.data.length).replace(/\\0*$/, ''); // text information frames supports multiple strings, stored as a terminator separated list [ID3v2.4.0 section 4.2.]\n\n                    frame.values = frame.value.split('\\0');\n                },\n                'TXXX': function (frame) {\n                    var descriptionEndIndex;\n                    if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {\n                        // ignore frames with unrecognized character encodings\n                        return;\n                    }\n                    descriptionEndIndex = typedArrayIndexOf(frame.data, 0, 1);\n                    if (descriptionEndIndex === -1) {\n                        return;\n                    } // parse the text fields\n\n                    frame.description = parseUtf8(frame.data, 1, descriptionEndIndex); // do not include the null terminator in the tag value\n                    // frames that allow different types of encoding contain terminated text\n                    // [ID3v2.4.0 section 4.]\n\n                    frame.value = parseUtf8(frame.data, descriptionEndIndex + 1, frame.data.length).replace(/\\0*$/, '');\n                    frame.data = frame.value;\n                },\n                'W*': function (frame) {\n                    // parse URL field; URL fields are always represented as ISO-8859-1 [ID3v2.4.0 section 4.]\n                    // if the value is followed by a string termination all the following information should be ignored [ID3v2.4.0 section 4.3]\n                    frame.url = parseIso88591$1(frame.data, 0, frame.data.length).replace(/\\0.*$/, '');\n                },\n                'WXXX': function (frame) {\n                    var descriptionEndIndex;\n                    if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {\n                        // ignore frames with unrecognized character encodings\n                        return;\n                    }\n                    descriptionEndIndex = typedArrayIndexOf(frame.data, 0, 1);\n                    if (descriptionEndIndex === -1) {\n                        return;\n                    } // parse the description and URL fields\n\n                    frame.description = parseUtf8(frame.data, 1, descriptionEndIndex); // URL fields are always represented as ISO-8859-1 [ID3v2.4.0 section 4.]\n                    // if the value is followed by a string termination all the following information\n                    // should be ignored [ID3v2.4.0 section 4.3]\n\n                    frame.url = parseIso88591$1(frame.data, descriptionEndIndex + 1, frame.data.length).replace(/\\0.*$/, '');\n                },\n                'PRIV': function (frame) {\n                    var i;\n                    for (i = 0; i < frame.data.length; i++) {\n                        if (frame.data[i] === 0) {\n                            // parse the description and URL fields\n                            frame.owner = parseIso88591$1(frame.data, 0, i);\n                            break;\n                        }\n                    }\n                    frame.privateData = frame.data.subarray(i + 1);\n                    frame.data = frame.privateData;\n                }\n            };\n        var parseId3Frames$1 = function (data) {\n            var frameSize,\n                frameHeader,\n                frameStart = 10,\n                tagSize = 0,\n                frames = []; // If we don't have enough data for a header, 10 bytes,\n            // or 'ID3' in the first 3 bytes this is not a valid ID3 tag.\n\n            if (data.length < 10 || data[0] !== 'I'.charCodeAt(0) || data[1] !== 'D'.charCodeAt(0) || data[2] !== '3'.charCodeAt(0)) {\n                return;\n            } // the frame size is transmitted as a 28-bit integer in the\n            // last four bytes of the ID3 header.\n            // The most significant bit of each byte is dropped and the\n            // results concatenated to recover the actual value.\n\n            tagSize = parseSyncSafeInteger$1(data.subarray(6, 10)); // ID3 reports the tag size excluding the header but it's more\n            // convenient for our comparisons to include it\n\n            tagSize += 10; // check bit 6 of byte 5 for the extended header flag.\n\n            var hasExtendedHeader = data[5] & 0x40;\n            if (hasExtendedHeader) {\n                // advance the frame start past the extended header\n                frameStart += 4; // header size field\n\n                frameStart += parseSyncSafeInteger$1(data.subarray(10, 14));\n                tagSize -= parseSyncSafeInteger$1(data.subarray(16, 20)); // clip any padding off the end\n            } // parse one or more ID3 frames\n            // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n            do {\n                // determine the number of bytes in this frame\n                frameSize = parseSyncSafeInteger$1(data.subarray(frameStart + 4, frameStart + 8));\n                if (frameSize < 1) {\n                    break;\n                }\n                frameHeader = String.fromCharCode(data[frameStart], data[frameStart + 1], data[frameStart + 2], data[frameStart + 3]);\n                var frame = {\n                    id: frameHeader,\n                    data: data.subarray(frameStart + 10, frameStart + frameSize + 10)\n                };\n                frame.key = frame.id; // parse frame values\n\n                if (frameParsers[frame.id]) {\n                    // use frame specific parser\n                    frameParsers[frame.id](frame);\n                } else if (frame.id[0] === 'T') {\n                    // use text frame generic parser\n                    frameParsers['T*'](frame);\n                } else if (frame.id[0] === 'W') {\n                    // use URL link frame generic parser\n                    frameParsers['W*'](frame);\n                }\n                frames.push(frame);\n                frameStart += 10; // advance past the frame header\n\n                frameStart += frameSize; // advance past the frame body\n            } while (frameStart < tagSize);\n            return frames;\n        };\n        var parseId3 = {\n            parseId3Frames: parseId3Frames$1,\n            parseSyncSafeInteger: parseSyncSafeInteger$1,\n            frameParsers: frameParsers\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Accepts program elementary stream (PES) data events and parses out\n         * ID3 metadata from them, if present.\n         * @see http://id3.org/id3v2.3.0\n         */\n\n        var Stream$5 = stream,\n            StreamTypes$3 = streamTypes,\n            id3 = parseId3,\n            MetadataStream;\n        MetadataStream = function (options) {\n            var settings = {\n                    // the bytes of the program-level descriptor field in MP2T\n                    // see ISO/IEC 13818-1:2013 (E), section 2.6 \"Program and\n                    // program element descriptors\"\n                    descriptor: options && options.descriptor\n                },\n                // the total size in bytes of the ID3 tag being parsed\n                tagSize = 0,\n                // tag data that is not complete enough to be parsed\n                buffer = [],\n                // the total number of bytes currently in the buffer\n                bufferSize = 0,\n                i;\n            MetadataStream.prototype.init.call(this); // calculate the text track in-band metadata track dispatch type\n            // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\n\n            this.dispatchType = StreamTypes$3.METADATA_STREAM_TYPE.toString(16);\n            if (settings.descriptor) {\n                for (i = 0; i < settings.descriptor.length; i++) {\n                    this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\n                }\n            }\n            this.push = function (chunk) {\n                var tag, frameStart, frameSize, frame, i, frameHeader;\n                if (chunk.type !== 'timed-metadata') {\n                    return;\n                } // if data_alignment_indicator is set in the PES header,\n                // we must have the start of a new ID3 tag. Assume anything\n                // remaining in the buffer was malformed and throw it out\n\n                if (chunk.dataAlignmentIndicator) {\n                    bufferSize = 0;\n                    buffer.length = 0;\n                } // ignore events that don't look like ID3 data\n\n                if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== 'I'.charCodeAt(0) || chunk.data[1] !== 'D'.charCodeAt(0) || chunk.data[2] !== '3'.charCodeAt(0))) {\n                    this.trigger('log', {\n                        level: 'warn',\n                        message: 'Skipping unrecognized metadata packet'\n                    });\n                    return;\n                } // add this chunk to the data we've collected so far\n\n                buffer.push(chunk);\n                bufferSize += chunk.data.byteLength; // grab the size of the entire frame from the ID3 header\n\n                if (buffer.length === 1) {\n                    // the frame size is transmitted as a 28-bit integer in the\n                    // last four bytes of the ID3 header.\n                    // The most significant bit of each byte is dropped and the\n                    // results concatenated to recover the actual value.\n                    tagSize = id3.parseSyncSafeInteger(chunk.data.subarray(6, 10)); // ID3 reports the tag size excluding the header but it's more\n                    // convenient for our comparisons to include it\n\n                    tagSize += 10;\n                } // if the entire frame has not arrived, wait for more data\n\n                if (bufferSize < tagSize) {\n                    return;\n                } // collect the entire frame so it can be parsed\n\n                tag = {\n                    data: new Uint8Array(tagSize),\n                    frames: [],\n                    pts: buffer[0].pts,\n                    dts: buffer[0].dts\n                };\n                for (i = 0; i < tagSize;) {\n                    tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\n                    i += buffer[0].data.byteLength;\n                    bufferSize -= buffer[0].data.byteLength;\n                    buffer.shift();\n                } // find the start of the first frame and the end of the tag\n\n                frameStart = 10;\n                if (tag.data[5] & 0x40) {\n                    // advance the frame start past the extended header\n                    frameStart += 4; // header size field\n\n                    frameStart += id3.parseSyncSafeInteger(tag.data.subarray(10, 14)); // clip any padding off the end\n\n                    tagSize -= id3.parseSyncSafeInteger(tag.data.subarray(16, 20));\n                } // parse one or more ID3 frames\n                // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n                do {\n                    // determine the number of bytes in this frame\n                    frameSize = id3.parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));\n                    if (frameSize < 1) {\n                        this.trigger('log', {\n                            level: 'warn',\n                            message: 'Malformed ID3 frame encountered. Skipping remaining metadata parsing.'\n                        }); // If the frame is malformed, don't parse any further frames but allow previous valid parsed frames\n                        // to be sent along.\n\n                        break;\n                    }\n                    frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);\n                    frame = {\n                        id: frameHeader,\n                        data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\n                    };\n                    frame.key = frame.id; // parse frame values\n\n                    if (id3.frameParsers[frame.id]) {\n                        // use frame specific parser\n                        id3.frameParsers[frame.id](frame);\n                    } else if (frame.id[0] === 'T') {\n                        // use text frame generic parser\n                        id3.frameParsers['T*'](frame);\n                    } else if (frame.id[0] === 'W') {\n                        // use URL link frame generic parser\n                        id3.frameParsers['W*'](frame);\n                    } // handle the special PRIV frame used to indicate the start\n                    // time for raw AAC data\n\n                    if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\n                        var d = frame.data,\n                            size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n                        size *= 4;\n                        size += d[7] & 0x03;\n                        frame.timeStamp = size; // in raw AAC, all subsequent data will be timestamped based\n                        // on the value of this frame\n                        // we couldn't have known the appropriate pts and dts before\n                        // parsing this ID3 tag so set those values now\n\n                        if (tag.pts === undefined && tag.dts === undefined) {\n                            tag.pts = frame.timeStamp;\n                            tag.dts = frame.timeStamp;\n                        }\n                        this.trigger('timestamp', frame);\n                    }\n                    tag.frames.push(frame);\n                    frameStart += 10; // advance past the frame header\n\n                    frameStart += frameSize; // advance past the frame body\n                } while (frameStart < tagSize);\n                this.trigger('data', tag);\n            };\n        };\n        MetadataStream.prototype = new Stream$5();\n        var metadataStream = MetadataStream;\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * A stream-based mp2t to mp4 converter. This utility can be used to\n         * deliver mp4s to a SourceBuffer on platforms that support native\n         * Media Source Extensions.\n         */\n\n        var Stream$4 = stream,\n            CaptionStream$1 = captionStream,\n            StreamTypes$2 = streamTypes,\n            TimestampRolloverStream = timestampRolloverStream.TimestampRolloverStream; // object types\n\n        var TransportPacketStream, TransportParseStream, ElementaryStream; // constants\n\n        var MP2T_PACKET_LENGTH$1 = 188,\n            // bytes\n            SYNC_BYTE$1 = 0x47;\n        /**\n         * Splits an incoming stream of binary data into MPEG-2 Transport\n         * Stream packets.\n         */\n\n        TransportPacketStream = function () {\n            var buffer = new Uint8Array(MP2T_PACKET_LENGTH$1),\n                bytesInBuffer = 0;\n            TransportPacketStream.prototype.init.call(this); // Deliver new bytes to the stream.\n\n            /**\n             * Split a stream of data into M2TS packets\n             **/\n\n            this.push = function (bytes) {\n                var startIndex = 0,\n                    endIndex = MP2T_PACKET_LENGTH$1,\n                    everything; // If there are bytes remaining from the last segment, prepend them to the\n                // bytes that were pushed in\n\n                if (bytesInBuffer) {\n                    everything = new Uint8Array(bytes.byteLength + bytesInBuffer);\n                    everything.set(buffer.subarray(0, bytesInBuffer));\n                    everything.set(bytes, bytesInBuffer);\n                    bytesInBuffer = 0;\n                } else {\n                    everything = bytes;\n                } // While we have enough data for a packet\n\n                while (endIndex < everything.byteLength) {\n                    // Look for a pair of start and end sync bytes in the data..\n                    if (everything[startIndex] === SYNC_BYTE$1 && everything[endIndex] === SYNC_BYTE$1) {\n                        // We found a packet so emit it and jump one whole packet forward in\n                        // the stream\n                        this.trigger('data', everything.subarray(startIndex, endIndex));\n                        startIndex += MP2T_PACKET_LENGTH$1;\n                        endIndex += MP2T_PACKET_LENGTH$1;\n                        continue;\n                    } // If we get here, we have somehow become de-synchronized and we need to step\n                    // forward one byte at a time until we find a pair of sync bytes that denote\n                    // a packet\n\n                    startIndex++;\n                    endIndex++;\n                } // If there was some data left over at the end of the segment that couldn't\n                // possibly be a whole packet, keep it because it might be the start of a packet\n                // that continues in the next segment\n\n                if (startIndex < everything.byteLength) {\n                    buffer.set(everything.subarray(startIndex), 0);\n                    bytesInBuffer = everything.byteLength - startIndex;\n                }\n            };\n            /**\n             * Passes identified M2TS packets to the TransportParseStream to be parsed\n             **/\n\n            this.flush = function () {\n                // If the buffer contains a whole packet when we are being flushed, emit it\n                // and empty the buffer. Otherwise hold onto the data because it may be\n                // important for decoding the next segment\n                if (bytesInBuffer === MP2T_PACKET_LENGTH$1 && buffer[0] === SYNC_BYTE$1) {\n                    this.trigger('data', buffer);\n                    bytesInBuffer = 0;\n                }\n                this.trigger('done');\n            };\n            this.endTimeline = function () {\n                this.flush();\n                this.trigger('endedtimeline');\n            };\n            this.reset = function () {\n                bytesInBuffer = 0;\n                this.trigger('reset');\n            };\n        };\n        TransportPacketStream.prototype = new Stream$4();\n        /**\n         * Accepts an MP2T TransportPacketStream and emits data events with parsed\n         * forms of the individual transport stream packets.\n         */\n\n        TransportParseStream = function () {\n            var parsePsi, parsePat, parsePmt, self;\n            TransportParseStream.prototype.init.call(this);\n            self = this;\n            this.packetsWaitingForPmt = [];\n            this.programMapTable = undefined;\n            parsePsi = function (payload, psi) {\n                var offset = 0; // PSI packets may be split into multiple sections and those\n                // sections may be split into multiple packets. If a PSI\n                // section starts in this packet, the payload_unit_start_indicator\n                // will be true and the first byte of the payload will indicate\n                // the offset from the current position to the start of the\n                // section.\n\n                if (psi.payloadUnitStartIndicator) {\n                    offset += payload[offset] + 1;\n                }\n                if (psi.type === 'pat') {\n                    parsePat(payload.subarray(offset), psi);\n                } else {\n                    parsePmt(payload.subarray(offset), psi);\n                }\n            };\n            parsePat = function (payload, pat) {\n                pat.section_number = payload[7]; // eslint-disable-line camelcase\n\n                pat.last_section_number = payload[8]; // eslint-disable-line camelcase\n                // skip the PSI header and parse the first PMT entry\n\n                self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];\n                pat.pmtPid = self.pmtPid;\n            };\n            /**\n             * Parse out the relevant fields of a Program Map Table (PMT).\n             * @param payload {Uint8Array} the PMT-specific portion of an MP2T\n             * packet. The first byte in this array should be the table_id\n             * field.\n             * @param pmt {object} the object that should be decorated with\n             * fields parsed from the PMT.\n             */\n\n            parsePmt = function (payload, pmt) {\n                var sectionLength, tableEnd, programInfoLength, offset; // PMTs can be sent ahead of the time when they should actually\n                // take effect. We don't believe this should ever be the case\n                // for HLS but we'll ignore \"forward\" PMT declarations if we see\n                // them. Future PMT declarations have the current_next_indicator\n                // set to zero.\n\n                if (!(payload[5] & 0x01)) {\n                    return;\n                } // overwrite any existing program map table\n\n                self.programMapTable = {\n                    video: null,\n                    audio: null,\n                    'timed-metadata': {}\n                }; // the mapping table ends at the end of the current section\n\n                sectionLength = (payload[1] & 0x0f) << 8 | payload[2];\n                tableEnd = 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\n                // long the program info descriptors are\n\n                programInfoLength = (payload[10] & 0x0f) << 8 | payload[11]; // advance the offset to the first entry in the mapping table\n\n                offset = 12 + programInfoLength;\n                while (offset < tableEnd) {\n                    var streamType = payload[offset];\n                    var pid = (payload[offset + 1] & 0x1F) << 8 | payload[offset + 2]; // only map a single elementary_pid for audio and video stream types\n                    // TODO: should this be done for metadata too? for now maintain behavior of\n                    //       multiple metadata streams\n\n                    if (streamType === StreamTypes$2.H264_STREAM_TYPE && self.programMapTable.video === null) {\n                        self.programMapTable.video = pid;\n                    } else if (streamType === StreamTypes$2.ADTS_STREAM_TYPE && self.programMapTable.audio === null) {\n                        self.programMapTable.audio = pid;\n                    } else if (streamType === StreamTypes$2.METADATA_STREAM_TYPE) {\n                        // map pid to stream type for metadata streams\n                        self.programMapTable['timed-metadata'][pid] = streamType;\n                    } // move to the next table entry\n                    // skip past the elementary stream descriptors, if present\n\n                    offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;\n                } // record the map on the packet as well\n\n                pmt.programMapTable = self.programMapTable;\n            };\n            /**\n             * Deliver a new MP2T packet to the next stream in the pipeline.\n             */\n\n            this.push = function (packet) {\n                var result = {},\n                    offset = 4;\n                result.payloadUnitStartIndicator = !!(packet[1] & 0x40); // pid is a 13-bit field starting at the last bit of packet[1]\n\n                result.pid = packet[1] & 0x1f;\n                result.pid <<= 8;\n                result.pid |= packet[2]; // if an adaption field is present, its length is specified by the\n                // fifth byte of the TS packet header. The adaptation field is\n                // used to add stuffing to PES packets that don't fill a complete\n                // TS packet, and to specify some forms of timing and control data\n                // that we do not currently use.\n\n                if ((packet[3] & 0x30) >>> 4 > 0x01) {\n                    offset += packet[offset] + 1;\n                } // parse the rest of the packet based on the type\n\n                if (result.pid === 0) {\n                    result.type = 'pat';\n                    parsePsi(packet.subarray(offset), result);\n                    this.trigger('data', result);\n                } else if (result.pid === this.pmtPid) {\n                    result.type = 'pmt';\n                    parsePsi(packet.subarray(offset), result);\n                    this.trigger('data', result); // if there are any packets waiting for a PMT to be found, process them now\n\n                    while (this.packetsWaitingForPmt.length) {\n                        this.processPes_.apply(this, this.packetsWaitingForPmt.shift());\n                    }\n                } else if (this.programMapTable === undefined) {\n                    // When we have not seen a PMT yet, defer further processing of\n                    // PES packets until one has been parsed\n                    this.packetsWaitingForPmt.push([packet, offset, result]);\n                } else {\n                    this.processPes_(packet, offset, result);\n                }\n            };\n            this.processPes_ = function (packet, offset, result) {\n                // set the appropriate stream type\n                if (result.pid === this.programMapTable.video) {\n                    result.streamType = StreamTypes$2.H264_STREAM_TYPE;\n                } else if (result.pid === this.programMapTable.audio) {\n                    result.streamType = StreamTypes$2.ADTS_STREAM_TYPE;\n                } else {\n                    // if not video or audio, it is timed-metadata or unknown\n                    // if unknown, streamType will be undefined\n                    result.streamType = this.programMapTable['timed-metadata'][result.pid];\n                }\n                result.type = 'pes';\n                result.data = packet.subarray(offset);\n                this.trigger('data', result);\n            };\n        };\n        TransportParseStream.prototype = new Stream$4();\n        TransportParseStream.STREAM_TYPES = {\n            h264: 0x1b,\n            adts: 0x0f\n        };\n        /**\n         * Reconsistutes program elementary stream (PES) packets from parsed\n         * transport stream packets. That is, if you pipe an\n         * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output\n         * events will be events which capture the bytes for individual PES\n         * packets plus relevant metadata that has been extracted from the\n         * container.\n         */\n\n        ElementaryStream = function () {\n            var self = this,\n                segmentHadPmt = false,\n                // PES packet fragments\n                video = {\n                    data: [],\n                    size: 0\n                },\n                audio = {\n                    data: [],\n                    size: 0\n                },\n                timedMetadata = {\n                    data: [],\n                    size: 0\n                },\n                programMapTable,\n                parsePes = function (payload, pes) {\n                    var ptsDtsFlags;\n                    const startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2]; // default to an empty array\n\n                    pes.data = new Uint8Array(); // In certain live streams, the start of a TS fragment has ts packets\n                    // that are frame data that is continuing from the previous fragment. This\n                    // is to check that the pes data is the start of a new pes payload\n\n                    if (startPrefix !== 1) {\n                        return;\n                    } // get the packet length, this will be 0 for video\n\n                    pes.packetLength = 6 + (payload[4] << 8 | payload[5]); // find out if this packets starts a new keyframe\n\n                    pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0; // PES packets may be annotated with a PTS value, or a PTS value\n                    // and a DTS value. Determine what combination of values is\n                    // available to work with.\n\n                    ptsDtsFlags = payload[7]; // PTS and DTS are normally stored as a 33-bit number.  Javascript\n                    // performs all bitwise operations on 32-bit integers but javascript\n                    // supports a much greater range (52-bits) of integer using standard\n                    // mathematical operations.\n                    // We construct a 31-bit value using bitwise operators over the 31\n                    // most significant bits and then multiply by 4 (equal to a left-shift\n                    // of 2) before we add the final 2 least significant bits of the\n                    // timestamp (equal to an OR.)\n\n                    if (ptsDtsFlags & 0xC0) {\n                        // the PTS and DTS are not written out directly. For information\n                        // on how they are encoded, see\n                        // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n                        pes.pts = (payload[9] & 0x0E) << 27 | (payload[10] & 0xFF) << 20 | (payload[11] & 0xFE) << 12 | (payload[12] & 0xFF) << 5 | (payload[13] & 0xFE) >>> 3;\n                        pes.pts *= 4; // Left shift by 2\n\n                        pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs\n\n                        pes.dts = pes.pts;\n                        if (ptsDtsFlags & 0x40) {\n                            pes.dts = (payload[14] & 0x0E) << 27 | (payload[15] & 0xFF) << 20 | (payload[16] & 0xFE) << 12 | (payload[17] & 0xFF) << 5 | (payload[18] & 0xFE) >>> 3;\n                            pes.dts *= 4; // Left shift by 2\n\n                            pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs\n                        }\n                    } // the data section starts immediately after the PES header.\n                    // pes_header_data_length specifies the number of header bytes\n                    // that follow the last byte of the field.\n\n                    pes.data = payload.subarray(9 + payload[8]);\n                },\n                /**\n                 * Pass completely parsed PES packets to the next stream in the pipeline\n                 **/\n                flushStream = function (stream, type, forceFlush) {\n                    var packetData = new Uint8Array(stream.size),\n                        event = {\n                            type: type\n                        },\n                        i = 0,\n                        offset = 0,\n                        packetFlushable = false,\n                        fragment; // do nothing if there is not enough buffered data for a complete\n                    // PES header\n\n                    if (!stream.data.length || stream.size < 9) {\n                        return;\n                    }\n                    event.trackId = stream.data[0].pid; // reassemble the packet\n\n                    for (i = 0; i < stream.data.length; i++) {\n                        fragment = stream.data[i];\n                        packetData.set(fragment.data, offset);\n                        offset += fragment.data.byteLength;\n                    } // parse assembled packet's PES header\n\n                    parsePes(packetData, event); // non-video PES packets MUST have a non-zero PES_packet_length\n                    // check that there is enough stream data to fill the packet\n\n                    packetFlushable = type === 'video' || event.packetLength <= stream.size; // flush pending packets if the conditions are right\n\n                    if (forceFlush || packetFlushable) {\n                        stream.size = 0;\n                        stream.data.length = 0;\n                    } // only emit packets that are complete. this is to avoid assembling\n                    // incomplete PES packets due to poor segmentation\n\n                    if (packetFlushable) {\n                        self.trigger('data', event);\n                    }\n                };\n            ElementaryStream.prototype.init.call(this);\n            /**\n             * Identifies M2TS packet types and parses PES packets using metadata\n             * parsed from the PMT\n             **/\n\n            this.push = function (data) {\n                ({\n                    pat: function () {// we have to wait for the PMT to arrive as well before we\n                        // have any meaningful metadata\n                    },\n                    pes: function () {\n                        var stream, streamType;\n                        switch (data.streamType) {\n                            case StreamTypes$2.H264_STREAM_TYPE:\n                                stream = video;\n                                streamType = 'video';\n                                break;\n                            case StreamTypes$2.ADTS_STREAM_TYPE:\n                                stream = audio;\n                                streamType = 'audio';\n                                break;\n                            case StreamTypes$2.METADATA_STREAM_TYPE:\n                                stream = timedMetadata;\n                                streamType = 'timed-metadata';\n                                break;\n                            default:\n                                // ignore unknown stream types\n                                return;\n                        } // if a new packet is starting, we can flush the completed\n                        // packet\n\n                        if (data.payloadUnitStartIndicator) {\n                            flushStream(stream, streamType, true);\n                        } // buffer this fragment until we are sure we've received the\n                        // complete payload\n\n                        stream.data.push(data);\n                        stream.size += data.data.byteLength;\n                    },\n                    pmt: function () {\n                        var event = {\n                            type: 'metadata',\n                            tracks: []\n                        };\n                        programMapTable = data.programMapTable; // translate audio and video streams to tracks\n\n                        if (programMapTable.video !== null) {\n                            event.tracks.push({\n                                timelineStartInfo: {\n                                    baseMediaDecodeTime: 0\n                                },\n                                id: +programMapTable.video,\n                                codec: 'avc',\n                                type: 'video'\n                            });\n                        }\n                        if (programMapTable.audio !== null) {\n                            event.tracks.push({\n                                timelineStartInfo: {\n                                    baseMediaDecodeTime: 0\n                                },\n                                id: +programMapTable.audio,\n                                codec: 'adts',\n                                type: 'audio'\n                            });\n                        }\n                        segmentHadPmt = true;\n                        self.trigger('data', event);\n                    }\n                })[data.type]();\n            };\n            this.reset = function () {\n                video.size = 0;\n                video.data.length = 0;\n                audio.size = 0;\n                audio.data.length = 0;\n                this.trigger('reset');\n            };\n            /**\n             * Flush any remaining input. Video PES packets may be of variable\n             * length. Normally, the start of a new video packet can trigger the\n             * finalization of the previous packet. That is not possible if no\n             * more video is forthcoming, however. In that case, some other\n             * mechanism (like the end of the file) has to be employed. When it is\n             * clear that no additional data is forthcoming, calling this method\n             * will flush the buffered packets.\n             */\n\n            this.flushStreams_ = function () {\n                // !!THIS ORDER IS IMPORTANT!!\n                // video first then audio\n                flushStream(video, 'video');\n                flushStream(audio, 'audio');\n                flushStream(timedMetadata, 'timed-metadata');\n            };\n            this.flush = function () {\n                // if on flush we haven't had a pmt emitted\n                // and we have a pmt to emit. emit the pmt\n                // so that we trigger a trackinfo downstream.\n                if (!segmentHadPmt && programMapTable) {\n                    var pmt = {\n                        type: 'metadata',\n                        tracks: []\n                    }; // translate audio and video streams to tracks\n\n                    if (programMapTable.video !== null) {\n                        pmt.tracks.push({\n                            timelineStartInfo: {\n                                baseMediaDecodeTime: 0\n                            },\n                            id: +programMapTable.video,\n                            codec: 'avc',\n                            type: 'video'\n                        });\n                    }\n                    if (programMapTable.audio !== null) {\n                        pmt.tracks.push({\n                            timelineStartInfo: {\n                                baseMediaDecodeTime: 0\n                            },\n                            id: +programMapTable.audio,\n                            codec: 'adts',\n                            type: 'audio'\n                        });\n                    }\n                    self.trigger('data', pmt);\n                }\n                segmentHadPmt = false;\n                this.flushStreams_();\n                this.trigger('done');\n            };\n        };\n        ElementaryStream.prototype = new Stream$4();\n        var m2ts$1 = {\n            PAT_PID: 0x0000,\n            MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH$1,\n            TransportPacketStream: TransportPacketStream,\n            TransportParseStream: TransportParseStream,\n            ElementaryStream: ElementaryStream,\n            TimestampRolloverStream: TimestampRolloverStream,\n            CaptionStream: CaptionStream$1.CaptionStream,\n            Cea608Stream: CaptionStream$1.Cea608Stream,\n            Cea708Stream: CaptionStream$1.Cea708Stream,\n            MetadataStream: metadataStream\n        };\n        for (var type in StreamTypes$2) {\n            if (StreamTypes$2.hasOwnProperty(type)) {\n                m2ts$1[type] = StreamTypes$2[type];\n            }\n        }\n        var m2ts_1 = m2ts$1;\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var Stream$3 = stream;\n        var ONE_SECOND_IN_TS$2 = clock$2.ONE_SECOND_IN_TS;\n        var AdtsStream$1;\n        var ADTS_SAMPLING_FREQUENCIES$1 = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n        /*\n     * Accepts a ElementaryStream and emits data events with parsed\n     * AAC Audio Frames of the individual packets. Input audio in ADTS\n     * format is unpacked and re-emitted as AAC frames.\n     *\n     * @see http://wiki.multimedia.cx/index.php?title=ADTS\n     * @see http://wiki.multimedia.cx/?title=Understanding_AAC\n     */\n\n        AdtsStream$1 = function (handlePartialSegments) {\n            var buffer,\n                frameNum = 0;\n            AdtsStream$1.prototype.init.call(this);\n            this.skipWarn_ = function (start, end) {\n                this.trigger('log', {\n                    level: 'warn',\n                    message: `adts skiping bytes ${start} to ${end} in frame ${frameNum} outside syncword`\n                });\n            };\n            this.push = function (packet) {\n                var i = 0,\n                    frameLength,\n                    protectionSkipBytes,\n                    oldBuffer,\n                    sampleCount,\n                    adtsFrameDuration;\n                if (!handlePartialSegments) {\n                    frameNum = 0;\n                }\n                if (packet.type !== 'audio') {\n                    // ignore non-audio data\n                    return;\n                } // Prepend any data in the buffer to the input data so that we can parse\n                // aac frames the cross a PES packet boundary\n\n                if (buffer && buffer.length) {\n                    oldBuffer = buffer;\n                    buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);\n                    buffer.set(oldBuffer);\n                    buffer.set(packet.data, oldBuffer.byteLength);\n                } else {\n                    buffer = packet.data;\n                } // unpack any ADTS frames which have been fully received\n                // for details on the ADTS header, see http://wiki.multimedia.cx/index.php?title=ADTS\n\n                var skip; // We use i + 7 here because we want to be able to parse the entire header.\n                // If we don't have enough bytes to do that, then we definitely won't have a full frame.\n\n                while (i + 7 < buffer.length) {\n                    // Look for the start of an ADTS header..\n                    if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {\n                        if (typeof skip !== 'number') {\n                            skip = i;\n                        } // If a valid header was not found,  jump one forward and attempt to\n                        // find a valid ADTS header starting at the next byte\n\n                        i++;\n                        continue;\n                    }\n                    if (typeof skip === 'number') {\n                        this.skipWarn_(skip, i);\n                        skip = null;\n                    } // The protection skip bit tells us if we have 2 bytes of CRC data at the\n                    // end of the ADTS header\n\n                    protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2; // Frame length is a 13 bit integer starting 16 bits from the\n                    // end of the sync sequence\n                    // NOTE: frame length includes the size of the header\n\n                    frameLength = (buffer[i + 3] & 0x03) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 0xe0) >> 5;\n                    sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;\n                    adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS$2 / ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 0x3c) >>> 2]; // If we don't have enough data to actually finish this ADTS frame,\n                    // then we have to wait for more data\n\n                    if (buffer.byteLength - i < frameLength) {\n                        break;\n                    } // Otherwise, deliver the complete AAC frame\n\n                    this.trigger('data', {\n                        pts: packet.pts + frameNum * adtsFrameDuration,\n                        dts: packet.dts + frameNum * adtsFrameDuration,\n                        sampleCount: sampleCount,\n                        audioobjecttype: (buffer[i + 2] >>> 6 & 0x03) + 1,\n                        channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 0xc0) >>> 6,\n                        samplerate: ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 0x3c) >>> 2],\n                        samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,\n                        // assume ISO/IEC 14496-12 AudioSampleEntry default of 16\n                        samplesize: 16,\n                        // data is the frame without it's header\n                        data: buffer.subarray(i + 7 + protectionSkipBytes, i + frameLength)\n                    });\n                    frameNum++;\n                    i += frameLength;\n                }\n                if (typeof skip === 'number') {\n                    this.skipWarn_(skip, i);\n                    skip = null;\n                } // remove processed bytes from the buffer.\n\n                buffer = buffer.subarray(i);\n            };\n            this.flush = function () {\n                frameNum = 0;\n                this.trigger('done');\n            };\n            this.reset = function () {\n                buffer = void 0;\n                this.trigger('reset');\n            };\n            this.endTimeline = function () {\n                buffer = void 0;\n                this.trigger('endedtimeline');\n            };\n        };\n        AdtsStream$1.prototype = new Stream$3();\n        var adts = AdtsStream$1;\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var ExpGolomb$1;\n        /**\n         * Parser for exponential Golomb codes, a variable-bitwidth number encoding\n         * scheme used by h264.\n         */\n\n        ExpGolomb$1 = function (workingData) {\n            var\n                // the number of bytes left to examine in workingData\n                workingBytesAvailable = workingData.byteLength,\n                // the current word being examined\n                workingWord = 0,\n                // :uint\n                // the number of bits left to examine in the current word\n                workingBitsAvailable = 0; // :uint;\n            // ():uint\n\n            this.length = function () {\n                return 8 * workingBytesAvailable;\n            }; // ():uint\n\n            this.bitsAvailable = function () {\n                return 8 * workingBytesAvailable + workingBitsAvailable;\n            }; // ():void\n\n            this.loadWord = function () {\n                var position = workingData.byteLength - workingBytesAvailable,\n                    workingBytes = new Uint8Array(4),\n                    availableBytes = Math.min(4, workingBytesAvailable);\n                if (availableBytes === 0) {\n                    throw new Error('no bytes available');\n                }\n                workingBytes.set(workingData.subarray(position, position + availableBytes));\n                workingWord = new DataView(workingBytes.buffer).getUint32(0); // track the amount of workingData that has been processed\n\n                workingBitsAvailable = availableBytes * 8;\n                workingBytesAvailable -= availableBytes;\n            }; // (count:int):void\n\n            this.skipBits = function (count) {\n                var skipBytes; // :int\n\n                if (workingBitsAvailable > count) {\n                    workingWord <<= count;\n                    workingBitsAvailable -= count;\n                } else {\n                    count -= workingBitsAvailable;\n                    skipBytes = Math.floor(count / 8);\n                    count -= skipBytes * 8;\n                    workingBytesAvailable -= skipBytes;\n                    this.loadWord();\n                    workingWord <<= count;\n                    workingBitsAvailable -= count;\n                }\n            }; // (size:int):uint\n\n            this.readBits = function (size) {\n                var bits = Math.min(workingBitsAvailable, size),\n                    // :uint\n                    valu = workingWord >>> 32 - bits; // :uint\n                // if size > 31, handle error\n\n                workingBitsAvailable -= bits;\n                if (workingBitsAvailable > 0) {\n                    workingWord <<= bits;\n                } else if (workingBytesAvailable > 0) {\n                    this.loadWord();\n                }\n                bits = size - bits;\n                if (bits > 0) {\n                    return valu << bits | this.readBits(bits);\n                }\n                return valu;\n            }; // ():uint\n\n            this.skipLeadingZeros = function () {\n                var leadingZeroCount; // :uint\n\n                for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\n                    if ((workingWord & 0x80000000 >>> leadingZeroCount) !== 0) {\n                        // the first bit of working word is 1\n                        workingWord <<= leadingZeroCount;\n                        workingBitsAvailable -= leadingZeroCount;\n                        return leadingZeroCount;\n                    }\n                } // we exhausted workingWord and still have not found a 1\n\n                this.loadWord();\n                return leadingZeroCount + this.skipLeadingZeros();\n            }; // ():void\n\n            this.skipUnsignedExpGolomb = function () {\n                this.skipBits(1 + this.skipLeadingZeros());\n            }; // ():void\n\n            this.skipExpGolomb = function () {\n                this.skipBits(1 + this.skipLeadingZeros());\n            }; // ():uint\n\n            this.readUnsignedExpGolomb = function () {\n                var clz = this.skipLeadingZeros(); // :uint\n\n                return this.readBits(clz + 1) - 1;\n            }; // ():int\n\n            this.readExpGolomb = function () {\n                var valu = this.readUnsignedExpGolomb(); // :int\n\n                if (0x01 & valu) {\n                    // the number is odd if the low order bit is set\n                    return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n                }\n\n                return -1 * (valu >>> 1); // divide by two then make it negative\n            }; // Some convenience functions\n            // :Boolean\n\n            this.readBoolean = function () {\n                return this.readBits(1) === 1;\n            }; // ():int\n\n            this.readUnsignedByte = function () {\n                return this.readBits(8);\n            };\n            this.loadWord();\n        };\n        var expGolomb = ExpGolomb$1;\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var Stream$2 = stream;\n        var ExpGolomb = expGolomb;\n        var H264Stream$1, NalByteStream;\n        var PROFILES_WITH_OPTIONAL_SPS_DATA;\n        /**\n         * Accepts a NAL unit byte stream and unpacks the embedded NAL units.\n         */\n\n        NalByteStream = function () {\n            var syncPoint = 0,\n                i,\n                buffer;\n            NalByteStream.prototype.init.call(this);\n            /*\n       * Scans a byte stream and triggers a data event with the NAL units found.\n       * @param {Object} data Event received from H264Stream\n       * @param {Uint8Array} data.data The h264 byte stream to be scanned\n       *\n       * @see H264Stream.push\n       */\n\n            this.push = function (data) {\n                var swapBuffer;\n                if (!buffer) {\n                    buffer = data.data;\n                } else {\n                    swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);\n                    swapBuffer.set(buffer);\n                    swapBuffer.set(data.data, buffer.byteLength);\n                    buffer = swapBuffer;\n                }\n                var len = buffer.byteLength; // Rec. ITU-T H.264, Annex B\n                // scan for NAL unit boundaries\n                // a match looks like this:\n                // 0 0 1 .. NAL .. 0 0 1\n                // ^ sync point        ^ i\n                // or this:\n                // 0 0 1 .. NAL .. 0 0 0\n                // ^ sync point        ^ i\n                // advance the sync point to a NAL start, if necessary\n\n                for (; syncPoint < len - 3; syncPoint++) {\n                    if (buffer[syncPoint + 2] === 1) {\n                        // the sync point is properly aligned\n                        i = syncPoint + 5;\n                        break;\n                    }\n                }\n                while (i < len) {\n                    // look at the current byte to determine if we've hit the end of\n                    // a NAL unit boundary\n                    switch (buffer[i]) {\n                        case 0:\n                            // skip past non-sync sequences\n                            if (buffer[i - 1] !== 0) {\n                                i += 2;\n                                break;\n                            } else if (buffer[i - 2] !== 0) {\n                                i++;\n                                break;\n                            } // deliver the NAL unit if it isn't empty\n\n                            if (syncPoint + 3 !== i - 2) {\n                                this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n                            } // drop trailing zeroes\n\n                            do {\n                                i++;\n                            } while (buffer[i] !== 1 && i < len);\n                            syncPoint = i - 2;\n                            i += 3;\n                            break;\n                        case 1:\n                            // skip past non-sync sequences\n                            if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {\n                                i += 3;\n                                break;\n                            } // deliver the NAL unit\n\n                            this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n                            syncPoint = i - 2;\n                            i += 3;\n                            break;\n                        default:\n                            // the current byte isn't a one or zero, so it cannot be part\n                            // of a sync sequence\n                            i += 3;\n                            break;\n                    }\n                } // filter out the NAL units that were delivered\n\n                buffer = buffer.subarray(syncPoint);\n                i -= syncPoint;\n                syncPoint = 0;\n            };\n            this.reset = function () {\n                buffer = null;\n                syncPoint = 0;\n                this.trigger('reset');\n            };\n            this.flush = function () {\n                // deliver the last buffered NAL unit\n                if (buffer && buffer.byteLength > 3) {\n                    this.trigger('data', buffer.subarray(syncPoint + 3));\n                } // reset the stream state\n\n                buffer = null;\n                syncPoint = 0;\n                this.trigger('done');\n            };\n            this.endTimeline = function () {\n                this.flush();\n                this.trigger('endedtimeline');\n            };\n        };\n        NalByteStream.prototype = new Stream$2(); // values of profile_idc that indicate additional fields are included in the SPS\n        // see Recommendation ITU-T H.264 (4/2013),\n        // 7.3.2.1.1 Sequence parameter set data syntax\n\n        PROFILES_WITH_OPTIONAL_SPS_DATA = {\n            100: true,\n            110: true,\n            122: true,\n            244: true,\n            44: true,\n            83: true,\n            86: true,\n            118: true,\n            128: true,\n            // TODO: the three profiles below don't\n            // appear to have sps data in the specificiation anymore?\n            138: true,\n            139: true,\n            134: true\n        };\n        /**\n         * Accepts input from a ElementaryStream and produces H.264 NAL unit data\n         * events.\n         */\n\n        H264Stream$1 = function () {\n            var nalByteStream = new NalByteStream(),\n                self,\n                trackId,\n                currentPts,\n                currentDts,\n                discardEmulationPreventionBytes,\n                readSequenceParameterSet,\n                skipScalingList;\n            H264Stream$1.prototype.init.call(this);\n            self = this;\n            /*\n       * Pushes a packet from a stream onto the NalByteStream\n       *\n       * @param {Object} packet - A packet received from a stream\n       * @param {Uint8Array} packet.data - The raw bytes of the packet\n       * @param {Number} packet.dts - Decode timestamp of the packet\n       * @param {Number} packet.pts - Presentation timestamp of the packet\n       * @param {Number} packet.trackId - The id of the h264 track this packet came from\n       * @param {('video'|'audio')} packet.type - The type of packet\n       *\n       */\n\n            this.push = function (packet) {\n                if (packet.type !== 'video') {\n                    return;\n                }\n                trackId = packet.trackId;\n                currentPts = packet.pts;\n                currentDts = packet.dts;\n                nalByteStream.push(packet);\n            };\n            /*\n       * Identify NAL unit types and pass on the NALU, trackId, presentation and decode timestamps\n       * for the NALUs to the next stream component.\n       * Also, preprocess caption and sequence parameter NALUs.\n       *\n       * @param {Uint8Array} data - A NAL unit identified by `NalByteStream.push`\n       * @see NalByteStream.push\n       */\n\n            nalByteStream.on('data', function (data) {\n                var event = {\n                    trackId: trackId,\n                    pts: currentPts,\n                    dts: currentDts,\n                    data: data,\n                    nalUnitTypeCode: data[0] & 0x1f\n                };\n                switch (event.nalUnitTypeCode) {\n                    case 0x05:\n                        event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';\n                        break;\n                    case 0x06:\n                        event.nalUnitType = 'sei_rbsp';\n                        event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n                        break;\n                    case 0x07:\n                        event.nalUnitType = 'seq_parameter_set_rbsp';\n                        event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n                        event.config = readSequenceParameterSet(event.escapedRBSP);\n                        break;\n                    case 0x08:\n                        event.nalUnitType = 'pic_parameter_set_rbsp';\n                        break;\n                    case 0x09:\n                        event.nalUnitType = 'access_unit_delimiter_rbsp';\n                        break;\n                } // This triggers data on the H264Stream\n\n                self.trigger('data', event);\n            });\n            nalByteStream.on('done', function () {\n                self.trigger('done');\n            });\n            nalByteStream.on('partialdone', function () {\n                self.trigger('partialdone');\n            });\n            nalByteStream.on('reset', function () {\n                self.trigger('reset');\n            });\n            nalByteStream.on('endedtimeline', function () {\n                self.trigger('endedtimeline');\n            });\n            this.flush = function () {\n                nalByteStream.flush();\n            };\n            this.partialFlush = function () {\n                nalByteStream.partialFlush();\n            };\n            this.reset = function () {\n                nalByteStream.reset();\n            };\n            this.endTimeline = function () {\n                nalByteStream.endTimeline();\n            };\n            /**\n             * Advance the ExpGolomb decoder past a scaling list. The scaling\n             * list is optionally transmitted as part of a sequence parameter\n             * set and is not relevant to transmuxing.\n             * @param count {number} the number of entries in this scaling list\n             * @param expGolombDecoder {object} an ExpGolomb pointed to the\n             * start of a scaling list\n             * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n             */\n\n            skipScalingList = function (count, expGolombDecoder) {\n                var lastScale = 8,\n                    nextScale = 8,\n                    j,\n                    deltaScale;\n                for (j = 0; j < count; j++) {\n                    if (nextScale !== 0) {\n                        deltaScale = expGolombDecoder.readExpGolomb();\n                        nextScale = (lastScale + deltaScale + 256) % 256;\n                    }\n                    lastScale = nextScale === 0 ? lastScale : nextScale;\n                }\n            };\n            /**\n             * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n             * Sequence Payload\"\n             * @param data {Uint8Array} the bytes of a RBSP from a NAL\n             * unit\n             * @return {Uint8Array} the RBSP without any Emulation\n             * Prevention Bytes\n             */\n\n            discardEmulationPreventionBytes = function (data) {\n                var length = data.byteLength,\n                    emulationPreventionBytesPositions = [],\n                    i = 1,\n                    newLength,\n                    newData; // Find all `Emulation Prevention Bytes`\n\n                while (i < length - 2) {\n                    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n                        emulationPreventionBytesPositions.push(i + 2);\n                        i += 2;\n                    } else {\n                        i++;\n                    }\n                } // If no Emulation Prevention Bytes were found just return the original\n                // array\n\n                if (emulationPreventionBytesPositions.length === 0) {\n                    return data;\n                } // Create a new array to hold the NAL unit data\n\n                newLength = length - emulationPreventionBytesPositions.length;\n                newData = new Uint8Array(newLength);\n                var sourceIndex = 0;\n                for (i = 0; i < newLength; sourceIndex++, i++) {\n                    if (sourceIndex === emulationPreventionBytesPositions[0]) {\n                        // Skip this byte\n                        sourceIndex++; // Remove this position index\n\n                        emulationPreventionBytesPositions.shift();\n                    }\n                    newData[i] = data[sourceIndex];\n                }\n                return newData;\n            };\n            /**\n             * Read a sequence parameter set and return some interesting video\n             * properties. A sequence parameter set is the H264 metadata that\n             * describes the properties of upcoming video frames.\n             * @param data {Uint8Array} the bytes of a sequence parameter set\n             * @return {object} an object with configuration parsed from the\n             * sequence parameter set, including the dimensions of the\n             * associated video frames.\n             */\n\n            readSequenceParameterSet = function (data) {\n                var frameCropLeftOffset = 0,\n                    frameCropRightOffset = 0,\n                    frameCropTopOffset = 0,\n                    frameCropBottomOffset = 0,\n                    expGolombDecoder,\n                    profileIdc,\n                    levelIdc,\n                    profileCompatibility,\n                    chromaFormatIdc,\n                    picOrderCntType,\n                    numRefFramesInPicOrderCntCycle,\n                    picWidthInMbsMinus1,\n                    picHeightInMapUnitsMinus1,\n                    frameMbsOnlyFlag,\n                    scalingListCount,\n                    sarRatio = [1, 1],\n                    aspectRatioIdc,\n                    i;\n                expGolombDecoder = new ExpGolomb(data);\n                profileIdc = expGolombDecoder.readUnsignedByte(); // profile_idc\n\n                profileCompatibility = expGolombDecoder.readUnsignedByte(); // constraint_set[0-5]_flag\n\n                levelIdc = expGolombDecoder.readUnsignedByte(); // level_idc u(8)\n\n                expGolombDecoder.skipUnsignedExpGolomb(); // seq_parameter_set_id\n                // some profiles have more optional data we don't need\n\n                if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {\n                    chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();\n                    if (chromaFormatIdc === 3) {\n                        expGolombDecoder.skipBits(1); // separate_colour_plane_flag\n                    }\n\n                    expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_luma_minus8\n\n                    expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_chroma_minus8\n\n                    expGolombDecoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n\n                    if (expGolombDecoder.readBoolean()) {\n                        // seq_scaling_matrix_present_flag\n                        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n                        for (i = 0; i < scalingListCount; i++) {\n                            if (expGolombDecoder.readBoolean()) {\n                                // seq_scaling_list_present_flag[ i ]\n                                if (i < 6) {\n                                    skipScalingList(16, expGolombDecoder);\n                                } else {\n                                    skipScalingList(64, expGolombDecoder);\n                                }\n                            }\n                        }\n                    }\n                }\n                expGolombDecoder.skipUnsignedExpGolomb(); // log2_max_frame_num_minus4\n\n                picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();\n                if (picOrderCntType === 0) {\n                    expGolombDecoder.readUnsignedExpGolomb(); // log2_max_pic_order_cnt_lsb_minus4\n                } else if (picOrderCntType === 1) {\n                    expGolombDecoder.skipBits(1); // delta_pic_order_always_zero_flag\n\n                    expGolombDecoder.skipExpGolomb(); // offset_for_non_ref_pic\n\n                    expGolombDecoder.skipExpGolomb(); // offset_for_top_to_bottom_field\n\n                    numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();\n                    for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n                        expGolombDecoder.skipExpGolomb(); // offset_for_ref_frame[ i ]\n                    }\n                }\n\n                expGolombDecoder.skipUnsignedExpGolomb(); // max_num_ref_frames\n\n                expGolombDecoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n\n                picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n                picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n                frameMbsOnlyFlag = expGolombDecoder.readBits(1);\n                if (frameMbsOnlyFlag === 0) {\n                    expGolombDecoder.skipBits(1); // mb_adaptive_frame_field_flag\n                }\n\n                expGolombDecoder.skipBits(1); // direct_8x8_inference_flag\n\n                if (expGolombDecoder.readBoolean()) {\n                    // frame_cropping_flag\n                    frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();\n                    frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();\n                    frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();\n                    frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();\n                }\n                if (expGolombDecoder.readBoolean()) {\n                    // vui_parameters_present_flag\n                    if (expGolombDecoder.readBoolean()) {\n                        // aspect_ratio_info_present_flag\n                        aspectRatioIdc = expGolombDecoder.readUnsignedByte();\n                        switch (aspectRatioIdc) {\n                            case 1:\n                                sarRatio = [1, 1];\n                                break;\n                            case 2:\n                                sarRatio = [12, 11];\n                                break;\n                            case 3:\n                                sarRatio = [10, 11];\n                                break;\n                            case 4:\n                                sarRatio = [16, 11];\n                                break;\n                            case 5:\n                                sarRatio = [40, 33];\n                                break;\n                            case 6:\n                                sarRatio = [24, 11];\n                                break;\n                            case 7:\n                                sarRatio = [20, 11];\n                                break;\n                            case 8:\n                                sarRatio = [32, 11];\n                                break;\n                            case 9:\n                                sarRatio = [80, 33];\n                                break;\n                            case 10:\n                                sarRatio = [18, 11];\n                                break;\n                            case 11:\n                                sarRatio = [15, 11];\n                                break;\n                            case 12:\n                                sarRatio = [64, 33];\n                                break;\n                            case 13:\n                                sarRatio = [160, 99];\n                                break;\n                            case 14:\n                                sarRatio = [4, 3];\n                                break;\n                            case 15:\n                                sarRatio = [3, 2];\n                                break;\n                            case 16:\n                                sarRatio = [2, 1];\n                                break;\n                            case 255:\n                            {\n                                sarRatio = [expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()];\n                                break;\n                            }\n                        }\n                        if (sarRatio) {\n                            sarRatio[0] / sarRatio[1];\n                        }\n                    }\n                }\n                return {\n                    profileIdc: profileIdc,\n                    levelIdc: levelIdc,\n                    profileCompatibility: profileCompatibility,\n                    width: (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2,\n                    height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,\n                    // sar is sample aspect ratio\n                    sarRatio: sarRatio\n                };\n            };\n        };\n        H264Stream$1.prototype = new Stream$2();\n        var h264 = {\n            H264Stream: H264Stream$1,\n            NalByteStream: NalByteStream\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Utilities to detect basic properties and metadata about Aac data.\n         */\n\n        var ADTS_SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n        var parseId3TagSize = function (header, byteIndex) {\n            var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9],\n                flags = header[byteIndex + 5],\n                footerPresent = (flags & 16) >> 4; // if we get a negative returnSize clamp it to 0\n\n            returnSize = returnSize >= 0 ? returnSize : 0;\n            if (footerPresent) {\n                return returnSize + 20;\n            }\n            return returnSize + 10;\n        };\n        var getId3Offset = function (data, offset) {\n            if (data.length - offset < 10 || data[offset] !== 'I'.charCodeAt(0) || data[offset + 1] !== 'D'.charCodeAt(0) || data[offset + 2] !== '3'.charCodeAt(0)) {\n                return offset;\n            }\n            offset += parseId3TagSize(data, offset);\n            return getId3Offset(data, offset);\n        }; // TODO: use vhs-utils\n\n        var isLikelyAacData$1 = function (data) {\n            var offset = getId3Offset(data, 0);\n            return data.length >= offset + 2 && (data[offset] & 0xFF) === 0xFF && (data[offset + 1] & 0xF0) === 0xF0 &&\n                // verify that the 2 layer bits are 0, aka this\n                // is not mp3 data but aac data.\n                (data[offset + 1] & 0x16) === 0x10;\n        };\n        var parseSyncSafeInteger = function (data) {\n            return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n        }; // return a percent-encoded representation of the specified byte range\n        // @see http://en.wikipedia.org/wiki/Percent-encoding\n\n        var percentEncode = function (bytes, start, end) {\n            var i,\n                result = '';\n            for (i = start; i < end; i++) {\n                result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n            }\n            return result;\n        }; // return the string representation of the specified byte range,\n        // interpreted as ISO-8859-1.\n\n        var parseIso88591 = function (bytes, start, end) {\n            return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n        };\n\n        var parseAdtsSize = function (header, byteIndex) {\n            var lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n                middle = header[byteIndex + 4] << 3,\n                highTwo = header[byteIndex + 3] & 0x3 << 11;\n            return highTwo | middle | lowThree;\n        };\n        var parseType$4 = function (header, byteIndex) {\n            if (header[byteIndex] === 'I'.charCodeAt(0) && header[byteIndex + 1] === 'D'.charCodeAt(0) && header[byteIndex + 2] === '3'.charCodeAt(0)) {\n                return 'timed-metadata';\n            } else if (header[byteIndex] & 0xff === 0xff && (header[byteIndex + 1] & 0xf0) === 0xf0) {\n                return 'audio';\n            }\n            return null;\n        };\n        var parseSampleRate = function (packet) {\n            var i = 0;\n            while (i + 5 < packet.length) {\n                if (packet[i] !== 0xFF || (packet[i + 1] & 0xF6) !== 0xF0) {\n                    // If a valid header was not found,  jump one forward and attempt to\n                    // find a valid ADTS header starting at the next byte\n                    i++;\n                    continue;\n                }\n                return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 0x3c) >>> 2];\n            }\n            return null;\n        };\n        var parseAacTimestamp = function (packet) {\n            var frameStart, frameSize, frame, frameHeader; // find the start of the first frame and the end of the tag\n\n            frameStart = 10;\n            if (packet[5] & 0x40) {\n                // advance the frame start past the extended header\n                frameStart += 4; // header size field\n\n                frameStart += parseSyncSafeInteger(packet.subarray(10, 14));\n            } // parse one or more ID3 frames\n            // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n            do {\n                // determine the number of bytes in this frame\n                frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));\n                if (frameSize < 1) {\n                    return null;\n                }\n                frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);\n                if (frameHeader === 'PRIV') {\n                    frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);\n                    for (var i = 0; i < frame.byteLength; i++) {\n                        if (frame[i] === 0) {\n                            var owner = parseIso88591(frame, 0, i);\n                            if (owner === 'com.apple.streaming.transportStreamTimestamp') {\n                                var d = frame.subarray(i + 1);\n                                var size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n                                size *= 4;\n                                size += d[7] & 0x03;\n                                return size;\n                            }\n                            break;\n                        }\n                    }\n                }\n                frameStart += 10; // advance past the frame header\n\n                frameStart += frameSize; // advance past the frame body\n            } while (frameStart < packet.byteLength);\n            return null;\n        };\n        var utils = {\n            isLikelyAacData: isLikelyAacData$1,\n            parseId3TagSize: parseId3TagSize,\n            parseAdtsSize: parseAdtsSize,\n            parseType: parseType$4,\n            parseSampleRate: parseSampleRate,\n            parseAacTimestamp: parseAacTimestamp\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * A stream-based aac to mp4 converter. This utility can be used to\n         * deliver mp4s to a SourceBuffer on platforms that support native\n         * Media Source Extensions.\n         */\n\n        var Stream$1 = stream;\n        var aacUtils = utils; // Constants\n\n        var AacStream$1;\n        /**\n         * Splits an incoming stream of binary data into ADTS and ID3 Frames.\n         */\n\n        AacStream$1 = function () {\n            var everything = new Uint8Array(),\n                timeStamp = 0;\n            AacStream$1.prototype.init.call(this);\n            this.setTimestamp = function (timestamp) {\n                timeStamp = timestamp;\n            };\n            this.push = function (bytes) {\n                var frameSize = 0,\n                    byteIndex = 0,\n                    bytesLeft,\n                    chunk,\n                    packet,\n                    tempLength; // If there are bytes remaining from the last segment, prepend them to the\n                // bytes that were pushed in\n\n                if (everything.length) {\n                    tempLength = everything.length;\n                    everything = new Uint8Array(bytes.byteLength + tempLength);\n                    everything.set(everything.subarray(0, tempLength));\n                    everything.set(bytes, tempLength);\n                } else {\n                    everything = bytes;\n                }\n                while (everything.length - byteIndex >= 3) {\n                    if (everything[byteIndex] === 'I'.charCodeAt(0) && everything[byteIndex + 1] === 'D'.charCodeAt(0) && everything[byteIndex + 2] === '3'.charCodeAt(0)) {\n                        // Exit early because we don't have enough to parse\n                        // the ID3 tag header\n                        if (everything.length - byteIndex < 10) {\n                            break;\n                        } // check framesize\n\n                        frameSize = aacUtils.parseId3TagSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\n                        // to emit a full packet\n                        // Add to byteIndex to support multiple ID3 tags in sequence\n\n                        if (byteIndex + frameSize > everything.length) {\n                            break;\n                        }\n                        chunk = {\n                            type: 'timed-metadata',\n                            data: everything.subarray(byteIndex, byteIndex + frameSize)\n                        };\n                        this.trigger('data', chunk);\n                        byteIndex += frameSize;\n                        continue;\n                    } else if ((everything[byteIndex] & 0xff) === 0xff && (everything[byteIndex + 1] & 0xf0) === 0xf0) {\n                        // Exit early because we don't have enough to parse\n                        // the ADTS frame header\n                        if (everything.length - byteIndex < 7) {\n                            break;\n                        }\n                        frameSize = aacUtils.parseAdtsSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\n                        // to emit a full packet\n\n                        if (byteIndex + frameSize > everything.length) {\n                            break;\n                        }\n                        packet = {\n                            type: 'audio',\n                            data: everything.subarray(byteIndex, byteIndex + frameSize),\n                            pts: timeStamp,\n                            dts: timeStamp\n                        };\n                        this.trigger('data', packet);\n                        byteIndex += frameSize;\n                        continue;\n                    }\n                    byteIndex++;\n                }\n                bytesLeft = everything.length - byteIndex;\n                if (bytesLeft > 0) {\n                    everything = everything.subarray(byteIndex);\n                } else {\n                    everything = new Uint8Array();\n                }\n            };\n            this.reset = function () {\n                everything = new Uint8Array();\n                this.trigger('reset');\n            };\n            this.endTimeline = function () {\n                everything = new Uint8Array();\n                this.trigger('endedtimeline');\n            };\n        };\n        AacStream$1.prototype = new Stream$1();\n        var aac = AacStream$1;\n        var AUDIO_PROPERTIES$1 = ['audioobjecttype', 'channelcount', 'samplerate', 'samplingfrequencyindex', 'samplesize'];\n        var audioProperties = AUDIO_PROPERTIES$1;\n        var VIDEO_PROPERTIES$1 = ['width', 'height', 'profileIdc', 'levelIdc', 'profileCompatibility', 'sarRatio'];\n        var videoProperties = VIDEO_PROPERTIES$1;\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * A stream-based mp2t to mp4 converter. This utility can be used to\n         * deliver mp4s to a SourceBuffer on platforms that support native\n         * Media Source Extensions.\n         */\n\n        var Stream = stream;\n        var mp4 = mp4Generator;\n        var frameUtils = frameUtils$1;\n        var audioFrameUtils = audioFrameUtils$1;\n        var trackDecodeInfo = trackDecodeInfo$1;\n        var m2ts = m2ts_1;\n        var clock = clock$2;\n        var AdtsStream = adts;\n        var H264Stream = h264.H264Stream;\n        var AacStream = aac;\n        var isLikelyAacData = utils.isLikelyAacData;\n        var ONE_SECOND_IN_TS$1 = clock$2.ONE_SECOND_IN_TS;\n        var AUDIO_PROPERTIES = audioProperties;\n        var VIDEO_PROPERTIES = videoProperties; // object types\n\n        var VideoSegmentStream, AudioSegmentStream, Transmuxer, CoalesceStream;\n        var retriggerForStream = function (key, event) {\n            event.stream = key;\n            this.trigger('log', event);\n        };\n        var addPipelineLogRetriggers = function (transmuxer, pipeline) {\n            var keys = Object.keys(pipeline);\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i]; // skip non-stream keys and headOfPipeline\n                // which is just a duplicate\n\n                if (key === 'headOfPipeline' || !pipeline[key].on) {\n                    continue;\n                }\n                pipeline[key].on('log', retriggerForStream.bind(transmuxer, key));\n            }\n        };\n        /**\n         * Compare two arrays (even typed) for same-ness\n         */\n\n        var arrayEquals = function (a, b) {\n            var i;\n            if (a.length !== b.length) {\n                return false;\n            } // compare the value of each element in the array\n\n            for (i = 0; i < a.length; i++) {\n                if (a[i] !== b[i]) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        var generateSegmentTimingInfo = function (baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {\n            var ptsOffsetFromDts = startPts - startDts,\n                decodeDuration = endDts - startDts,\n                presentationDuration = endPts - startPts; // The PTS and DTS values are based on the actual stream times from the segment,\n            // however, the player time values will reflect a start from the baseMediaDecodeTime.\n            // In order to provide relevant values for the player times, base timing info on the\n            // baseMediaDecodeTime and the DTS and PTS durations of the segment.\n\n            return {\n                start: {\n                    dts: baseMediaDecodeTime,\n                    pts: baseMediaDecodeTime + ptsOffsetFromDts\n                },\n                end: {\n                    dts: baseMediaDecodeTime + decodeDuration,\n                    pts: baseMediaDecodeTime + presentationDuration\n                },\n                prependedContentDuration: prependedContentDuration,\n                baseMediaDecodeTime: baseMediaDecodeTime\n            };\n        };\n        /**\n         * Constructs a single-track, ISO BMFF media segment from AAC data\n         * events. The output of this stream can be fed to a SourceBuffer\n         * configured with a suitable initialization segment.\n         * @param track {object} track metadata configuration\n         * @param options {object} transmuxer options object\n         * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n         *        in the source; false to adjust the first segment to start at 0.\n         */\n\n        AudioSegmentStream = function (track, options) {\n            var adtsFrames = [],\n                sequenceNumber,\n                earliestAllowedDts = 0,\n                audioAppendStartTs = 0,\n                videoBaseMediaDecodeTime = Infinity;\n            options = options || {};\n            sequenceNumber = options.firstSequenceNumber || 0;\n            AudioSegmentStream.prototype.init.call(this);\n            this.push = function (data) {\n                trackDecodeInfo.collectDtsInfo(track, data);\n                if (track) {\n                    AUDIO_PROPERTIES.forEach(function (prop) {\n                        track[prop] = data[prop];\n                    });\n                } // buffer audio data until end() is called\n\n                adtsFrames.push(data);\n            };\n            this.setEarliestDts = function (earliestDts) {\n                earliestAllowedDts = earliestDts;\n            };\n            this.setVideoBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n                videoBaseMediaDecodeTime = baseMediaDecodeTime;\n            };\n            this.setAudioAppendStart = function (timestamp) {\n                audioAppendStartTs = timestamp;\n            };\n            this.flush = function () {\n                var frames, moof, mdat, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed; // return early if no audio data has been observed\n\n                if (adtsFrames.length === 0) {\n                    this.trigger('done', 'AudioSegmentStream');\n                    return;\n                }\n                frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);\n                track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps); // amount of audio filled but the value is in video clock rather than audio clock\n\n                videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime); // we have to build the index from byte locations to\n                // samples (that is, adts frames) in the audio data\n\n                track.samples = audioFrameUtils.generateSampleTable(frames); // concatenate the audio data to constuct the mdat\n\n                mdat = mp4.mdat(audioFrameUtils.concatenateFrameData(frames));\n                adtsFrames = [];\n                moof = mp4.moof(sequenceNumber, [track]);\n                boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // bump the sequence number for next time\n\n                sequenceNumber++;\n                boxes.set(moof);\n                boxes.set(mdat, moof.byteLength);\n                trackDecodeInfo.clearDtsInfo(track);\n                frameDuration = Math.ceil(ONE_SECOND_IN_TS$1 * 1024 / track.samplerate); // TODO this check was added to maintain backwards compatibility (particularly with\n                // tests) on adding the timingInfo event. However, it seems unlikely that there's a\n                // valid use-case where an init segment/data should be triggered without associated\n                // frames. Leaving for now, but should be looked into.\n\n                if (frames.length) {\n                    segmentDuration = frames.length * frameDuration;\n                    this.trigger('segmentTimingInfo', generateSegmentTimingInfo(\n                        // The audio track's baseMediaDecodeTime is in audio clock cycles, but the\n                        // frame info is in video clock cycles. Convert to match expectation of\n                        // listeners (that all timestamps will be based on video clock cycles).\n                        clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate),\n                        // frame times are already in video clock, as is segment duration\n                        frames[0].dts, frames[0].pts, frames[0].dts + segmentDuration, frames[0].pts + segmentDuration, videoClockCyclesOfSilencePrefixed || 0));\n                    this.trigger('timingInfo', {\n                        start: frames[0].pts,\n                        end: frames[0].pts + segmentDuration\n                    });\n                }\n                this.trigger('data', {\n                    track: track,\n                    boxes: boxes\n                });\n                this.trigger('done', 'AudioSegmentStream');\n            };\n            this.reset = function () {\n                trackDecodeInfo.clearDtsInfo(track);\n                adtsFrames = [];\n                this.trigger('reset');\n            };\n        };\n        AudioSegmentStream.prototype = new Stream();\n        /**\n         * Constructs a single-track, ISO BMFF media segment from H264 data\n         * events. The output of this stream can be fed to a SourceBuffer\n         * configured with a suitable initialization segment.\n         * @param track {object} track metadata configuration\n         * @param options {object} transmuxer options object\n         * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\n         *        gopsToAlignWith list when attempting to align gop pts\n         * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n         *        in the source; false to adjust the first segment to start at 0.\n         */\n\n        VideoSegmentStream = function (track, options) {\n            var sequenceNumber,\n                nalUnits = [],\n                gopsToAlignWith = [],\n                config,\n                pps;\n            options = options || {};\n            sequenceNumber = options.firstSequenceNumber || 0;\n            VideoSegmentStream.prototype.init.call(this);\n            delete track.minPTS;\n            this.gopCache_ = [];\n            /**\n             * Constructs a ISO BMFF segment given H264 nalUnits\n             * @param {Object} nalUnit A data event representing a nalUnit\n             * @param {String} nalUnit.nalUnitType\n             * @param {Object} nalUnit.config Properties for a mp4 track\n             * @param {Uint8Array} nalUnit.data The nalUnit bytes\n             * @see lib/codecs/h264.js\n             **/\n\n            this.push = function (nalUnit) {\n                trackDecodeInfo.collectDtsInfo(track, nalUnit); // record the track config\n\n                if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n                    config = nalUnit.config;\n                    track.sps = [nalUnit.data];\n                    VIDEO_PROPERTIES.forEach(function (prop) {\n                        track[prop] = config[prop];\n                    }, this);\n                }\n                if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' && !pps) {\n                    pps = nalUnit.data;\n                    track.pps = [nalUnit.data];\n                } // buffer video until flush() is called\n\n                nalUnits.push(nalUnit);\n            };\n            /**\n             * Pass constructed ISO BMFF track and boxes on to the\n             * next stream in the pipeline\n             **/\n\n            this.flush = function () {\n                var frames,\n                    gopForFusion,\n                    gops,\n                    moof,\n                    mdat,\n                    boxes,\n                    prependedContentDuration = 0,\n                    firstGop,\n                    lastGop; // Throw away nalUnits at the start of the byte stream until\n                // we find the first AUD\n\n                while (nalUnits.length) {\n                    if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n                        break;\n                    }\n                    nalUnits.shift();\n                } // Return early if no video data has been observed\n\n                if (nalUnits.length === 0) {\n                    this.resetStream_();\n                    this.trigger('done', 'VideoSegmentStream');\n                    return;\n                } // Organize the raw nal-units into arrays that represent\n                // higher-level constructs such as frames and gops\n                // (group-of-pictures)\n\n                frames = frameUtils.groupNalsIntoFrames(nalUnits);\n                gops = frameUtils.groupFramesIntoGops(frames); // If the first frame of this fragment is not a keyframe we have\n                // a problem since MSE (on Chrome) requires a leading keyframe.\n                //\n                // We have two approaches to repairing this situation:\n                // 1) GOP-FUSION:\n                //    This is where we keep track of the GOPS (group-of-pictures)\n                //    from previous fragments and attempt to find one that we can\n                //    prepend to the current fragment in order to create a valid\n                //    fragment.\n                // 2) KEYFRAME-PULLING:\n                //    Here we search for the first keyframe in the fragment and\n                //    throw away all the frames between the start of the fragment\n                //    and that keyframe. We then extend the duration and pull the\n                //    PTS of the keyframe forward so that it covers the time range\n                //    of the frames that were disposed of.\n                //\n                // #1 is far prefereable over #2 which can cause \"stuttering\" but\n                // requires more things to be just right.\n\n                if (!gops[0][0].keyFrame) {\n                    // Search for a gop for fusion from our gopCache\n                    gopForFusion = this.getGopForFusion_(nalUnits[0], track);\n                    if (gopForFusion) {\n                        // in order to provide more accurate timing information about the segment, save\n                        // the number of seconds prepended to the original segment due to GOP fusion\n                        prependedContentDuration = gopForFusion.duration;\n                        gops.unshift(gopForFusion); // Adjust Gops' metadata to account for the inclusion of the\n                        // new gop at the beginning\n\n                        gops.byteLength += gopForFusion.byteLength;\n                        gops.nalCount += gopForFusion.nalCount;\n                        gops.pts = gopForFusion.pts;\n                        gops.dts = gopForFusion.dts;\n                        gops.duration += gopForFusion.duration;\n                    } else {\n                        // If we didn't find a candidate gop fall back to keyframe-pulling\n                        gops = frameUtils.extendFirstKeyFrame(gops);\n                    }\n                } // Trim gops to align with gopsToAlignWith\n\n                if (gopsToAlignWith.length) {\n                    var alignedGops;\n                    if (options.alignGopsAtEnd) {\n                        alignedGops = this.alignGopsAtEnd_(gops);\n                    } else {\n                        alignedGops = this.alignGopsAtStart_(gops);\n                    }\n                    if (!alignedGops) {\n                        // save all the nals in the last GOP into the gop cache\n                        this.gopCache_.unshift({\n                            gop: gops.pop(),\n                            pps: track.pps,\n                            sps: track.sps\n                        }); // Keep a maximum of 6 GOPs in the cache\n\n                        this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\n\n                        nalUnits = []; // return early no gops can be aligned with desired gopsToAlignWith\n\n                        this.resetStream_();\n                        this.trigger('done', 'VideoSegmentStream');\n                        return;\n                    } // Some gops were trimmed. clear dts info so minSegmentDts and pts are correct\n                    // when recalculated before sending off to CoalesceStream\n\n                    trackDecodeInfo.clearDtsInfo(track);\n                    gops = alignedGops;\n                }\n                trackDecodeInfo.collectDtsInfo(track, gops); // First, we have to build the index from byte locations to\n                // samples (that is, frames) in the video data\n\n                track.samples = frameUtils.generateSampleTable(gops); // Concatenate the video data and construct the mdat\n\n                mdat = mp4.mdat(frameUtils.concatenateNalData(gops));\n                track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n                this.trigger('processedGopsInfo', gops.map(function (gop) {\n                    return {\n                        pts: gop.pts,\n                        dts: gop.dts,\n                        byteLength: gop.byteLength\n                    };\n                }));\n                firstGop = gops[0];\n                lastGop = gops[gops.length - 1];\n                this.trigger('segmentTimingInfo', generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));\n                this.trigger('timingInfo', {\n                    start: gops[0].pts,\n                    end: gops[gops.length - 1].pts + gops[gops.length - 1].duration\n                }); // save all the nals in the last GOP into the gop cache\n\n                this.gopCache_.unshift({\n                    gop: gops.pop(),\n                    pps: track.pps,\n                    sps: track.sps\n                }); // Keep a maximum of 6 GOPs in the cache\n\n                this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\n\n                nalUnits = [];\n                this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);\n                this.trigger('timelineStartInfo', track.timelineStartInfo);\n                moof = mp4.moof(sequenceNumber, [track]); // it would be great to allocate this array up front instead of\n                // throwing away hundreds of media segment fragments\n\n                boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // Bump the sequence number for next time\n\n                sequenceNumber++;\n                boxes.set(moof);\n                boxes.set(mdat, moof.byteLength);\n                this.trigger('data', {\n                    track: track,\n                    boxes: boxes\n                });\n                this.resetStream_(); // Continue with the flush process now\n\n                this.trigger('done', 'VideoSegmentStream');\n            };\n            this.reset = function () {\n                this.resetStream_();\n                nalUnits = [];\n                this.gopCache_.length = 0;\n                gopsToAlignWith.length = 0;\n                this.trigger('reset');\n            };\n            this.resetStream_ = function () {\n                trackDecodeInfo.clearDtsInfo(track); // reset config and pps because they may differ across segments\n                // for instance, when we are rendition switching\n\n                config = undefined;\n                pps = undefined;\n            }; // Search for a candidate Gop for gop-fusion from the gop cache and\n            // return it or return null if no good candidate was found\n\n            this.getGopForFusion_ = function (nalUnit) {\n                var halfSecond = 45000,\n                    // Half-a-second in a 90khz clock\n                    allowableOverlap = 10000,\n                    // About 3 frames @ 30fps\n                    nearestDistance = Infinity,\n                    dtsDistance,\n                    nearestGopObj,\n                    currentGop,\n                    currentGopObj,\n                    i; // Search for the GOP nearest to the beginning of this nal unit\n\n                for (i = 0; i < this.gopCache_.length; i++) {\n                    currentGopObj = this.gopCache_[i];\n                    currentGop = currentGopObj.gop; // Reject Gops with different SPS or PPS\n\n                    if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\n                        continue;\n                    } // Reject Gops that would require a negative baseMediaDecodeTime\n\n                    if (currentGop.dts < track.timelineStartInfo.dts) {\n                        continue;\n                    } // The distance between the end of the gop and the start of the nalUnit\n\n                    dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration; // Only consider GOPS that start before the nal unit and end within\n                    // a half-second of the nal unit\n\n                    if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {\n                        // Always use the closest GOP we found if there is more than\n                        // one candidate\n                        if (!nearestGopObj || nearestDistance > dtsDistance) {\n                            nearestGopObj = currentGopObj;\n                            nearestDistance = dtsDistance;\n                        }\n                    }\n                }\n                if (nearestGopObj) {\n                    return nearestGopObj.gop;\n                }\n                return null;\n            }; // trim gop list to the first gop found that has a matching pts with a gop in the list\n            // of gopsToAlignWith starting from the START of the list\n\n            this.alignGopsAtStart_ = function (gops) {\n                var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;\n                byteLength = gops.byteLength;\n                nalCount = gops.nalCount;\n                duration = gops.duration;\n                alignIndex = gopIndex = 0;\n                while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {\n                    align = gopsToAlignWith[alignIndex];\n                    gop = gops[gopIndex];\n                    if (align.pts === gop.pts) {\n                        break;\n                    }\n                    if (gop.pts > align.pts) {\n                        // this current gop starts after the current gop we want to align on, so increment\n                        // align index\n                        alignIndex++;\n                        continue;\n                    } // current gop starts before the current gop we want to align on. so increment gop\n                    // index\n\n                    gopIndex++;\n                    byteLength -= gop.byteLength;\n                    nalCount -= gop.nalCount;\n                    duration -= gop.duration;\n                }\n                if (gopIndex === 0) {\n                    // no gops to trim\n                    return gops;\n                }\n                if (gopIndex === gops.length) {\n                    // all gops trimmed, skip appending all gops\n                    return null;\n                }\n                alignedGops = gops.slice(gopIndex);\n                alignedGops.byteLength = byteLength;\n                alignedGops.duration = duration;\n                alignedGops.nalCount = nalCount;\n                alignedGops.pts = alignedGops[0].pts;\n                alignedGops.dts = alignedGops[0].dts;\n                return alignedGops;\n            }; // trim gop list to the first gop found that has a matching pts with a gop in the list\n            // of gopsToAlignWith starting from the END of the list\n\n            this.alignGopsAtEnd_ = function (gops) {\n                var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;\n                alignIndex = gopsToAlignWith.length - 1;\n                gopIndex = gops.length - 1;\n                alignEndIndex = null;\n                matchFound = false;\n                while (alignIndex >= 0 && gopIndex >= 0) {\n                    align = gopsToAlignWith[alignIndex];\n                    gop = gops[gopIndex];\n                    if (align.pts === gop.pts) {\n                        matchFound = true;\n                        break;\n                    }\n                    if (align.pts > gop.pts) {\n                        alignIndex--;\n                        continue;\n                    }\n                    if (alignIndex === gopsToAlignWith.length - 1) {\n                        // gop.pts is greater than the last alignment candidate. If no match is found\n                        // by the end of this loop, we still want to append gops that come after this\n                        // point\n                        alignEndIndex = gopIndex;\n                    }\n                    gopIndex--;\n                }\n                if (!matchFound && alignEndIndex === null) {\n                    return null;\n                }\n                var trimIndex;\n                if (matchFound) {\n                    trimIndex = gopIndex;\n                } else {\n                    trimIndex = alignEndIndex;\n                }\n                if (trimIndex === 0) {\n                    return gops;\n                }\n                var alignedGops = gops.slice(trimIndex);\n                var metadata = alignedGops.reduce(function (total, gop) {\n                    total.byteLength += gop.byteLength;\n                    total.duration += gop.duration;\n                    total.nalCount += gop.nalCount;\n                    return total;\n                }, {\n                    byteLength: 0,\n                    duration: 0,\n                    nalCount: 0\n                });\n                alignedGops.byteLength = metadata.byteLength;\n                alignedGops.duration = metadata.duration;\n                alignedGops.nalCount = metadata.nalCount;\n                alignedGops.pts = alignedGops[0].pts;\n                alignedGops.dts = alignedGops[0].dts;\n                return alignedGops;\n            };\n            this.alignGopsWith = function (newGopsToAlignWith) {\n                gopsToAlignWith = newGopsToAlignWith;\n            };\n        };\n        VideoSegmentStream.prototype = new Stream();\n        /**\n         * A Stream that can combine multiple streams (ie. audio & video)\n         * into a single output segment for MSE. Also supports audio-only\n         * and video-only streams.\n         * @param options {object} transmuxer options object\n         * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n         *        in the source; false to adjust the first segment to start at media timeline start.\n         */\n\n        CoalesceStream = function (options, metadataStream) {\n            // Number of Tracks per output segment\n            // If greater than 1, we combine multiple\n            // tracks into a single segment\n            this.numberOfTracks = 0;\n            this.metadataStream = metadataStream;\n            options = options || {};\n            if (typeof options.remux !== 'undefined') {\n                this.remuxTracks = !!options.remux;\n            } else {\n                this.remuxTracks = true;\n            }\n            if (typeof options.keepOriginalTimestamps === 'boolean') {\n                this.keepOriginalTimestamps = options.keepOriginalTimestamps;\n            } else {\n                this.keepOriginalTimestamps = false;\n            }\n            this.pendingTracks = [];\n            this.videoTrack = null;\n            this.pendingBoxes = [];\n            this.pendingCaptions = [];\n            this.pendingMetadata = [];\n            this.pendingBytes = 0;\n            this.emittedTracks = 0;\n            CoalesceStream.prototype.init.call(this); // Take output from multiple\n\n            this.push = function (output) {\n                // buffer incoming captions until the associated video segment\n                // finishes\n                if (output.text) {\n                    return this.pendingCaptions.push(output);\n                } // buffer incoming id3 tags until the final flush\n\n                if (output.frames) {\n                    return this.pendingMetadata.push(output);\n                } // Add this track to the list of pending tracks and store\n                // important information required for the construction of\n                // the final segment\n\n                this.pendingTracks.push(output.track);\n                this.pendingBytes += output.boxes.byteLength; // TODO: is there an issue for this against chrome?\n                // We unshift audio and push video because\n                // as of Chrome 75 when switching from\n                // one init segment to another if the video\n                // mdat does not appear after the audio mdat\n                // only audio will play for the duration of our transmux.\n\n                if (output.track.type === 'video') {\n                    this.videoTrack = output.track;\n                    this.pendingBoxes.push(output.boxes);\n                }\n                if (output.track.type === 'audio') {\n                    this.audioTrack = output.track;\n                    this.pendingBoxes.unshift(output.boxes);\n                }\n            };\n        };\n        CoalesceStream.prototype = new Stream();\n        CoalesceStream.prototype.flush = function (flushSource) {\n            var offset = 0,\n                event = {\n                    captions: [],\n                    captionStreams: {},\n                    metadata: [],\n                    info: {}\n                },\n                caption,\n                id3,\n                initSegment,\n                timelineStartPts = 0,\n                i;\n            if (this.pendingTracks.length < this.numberOfTracks) {\n                if (flushSource !== 'VideoSegmentStream' && flushSource !== 'AudioSegmentStream') {\n                    // Return because we haven't received a flush from a data-generating\n                    // portion of the segment (meaning that we have only recieved meta-data\n                    // or captions.)\n                    return;\n                } else if (this.remuxTracks) {\n                    // Return until we have enough tracks from the pipeline to remux (if we\n                    // are remuxing audio and video into a single MP4)\n                    return;\n                } else if (this.pendingTracks.length === 0) {\n                    // In the case where we receive a flush without any data having been\n                    // received we consider it an emitted track for the purposes of coalescing\n                    // `done` events.\n                    // We do this for the case where there is an audio and video track in the\n                    // segment but no audio data. (seen in several playlists with alternate\n                    // audio tracks and no audio present in the main TS segments.)\n                    this.emittedTracks++;\n                    if (this.emittedTracks >= this.numberOfTracks) {\n                        this.trigger('done');\n                        this.emittedTracks = 0;\n                    }\n                    return;\n                }\n            }\n            if (this.videoTrack) {\n                timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n                VIDEO_PROPERTIES.forEach(function (prop) {\n                    event.info[prop] = this.videoTrack[prop];\n                }, this);\n            } else if (this.audioTrack) {\n                timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n                AUDIO_PROPERTIES.forEach(function (prop) {\n                    event.info[prop] = this.audioTrack[prop];\n                }, this);\n            }\n            if (this.videoTrack || this.audioTrack) {\n                if (this.pendingTracks.length === 1) {\n                    event.type = this.pendingTracks[0].type;\n                } else {\n                    event.type = 'combined';\n                }\n                this.emittedTracks += this.pendingTracks.length;\n                initSegment = mp4.initSegment(this.pendingTracks); // Create a new typed array to hold the init segment\n\n                event.initSegment = new Uint8Array(initSegment.byteLength); // Create an init segment containing a moov\n                // and track definitions\n\n                event.initSegment.set(initSegment); // Create a new typed array to hold the moof+mdats\n\n                event.data = new Uint8Array(this.pendingBytes); // Append each moof+mdat (one per track) together\n\n                for (i = 0; i < this.pendingBoxes.length; i++) {\n                    event.data.set(this.pendingBoxes[i], offset);\n                    offset += this.pendingBoxes[i].byteLength;\n                } // Translate caption PTS times into second offsets to match the\n                // video timeline for the segment, and add track info\n\n                for (i = 0; i < this.pendingCaptions.length; i++) {\n                    caption = this.pendingCaptions[i];\n                    caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);\n                    caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);\n                    event.captionStreams[caption.stream] = true;\n                    event.captions.push(caption);\n                } // Translate ID3 frame PTS times into second offsets to match the\n                // video timeline for the segment\n\n                for (i = 0; i < this.pendingMetadata.length; i++) {\n                    id3 = this.pendingMetadata[i];\n                    id3.cueTime = clock.metadataTsToSeconds(id3.pts, timelineStartPts, this.keepOriginalTimestamps);\n                    event.metadata.push(id3);\n                } // We add this to every single emitted segment even though we only need\n                // it for the first\n\n                event.metadata.dispatchType = this.metadataStream.dispatchType; // Reset stream state\n\n                this.pendingTracks.length = 0;\n                this.videoTrack = null;\n                this.pendingBoxes.length = 0;\n                this.pendingCaptions.length = 0;\n                this.pendingBytes = 0;\n                this.pendingMetadata.length = 0; // Emit the built segment\n                // We include captions and ID3 tags for backwards compatibility,\n                // ideally we should send only video and audio in the data event\n\n                this.trigger('data', event); // Emit each caption to the outside world\n                // Ideally, this would happen immediately on parsing captions,\n                // but we need to ensure that video data is sent back first\n                // so that caption timing can be adjusted to match video timing\n\n                for (i = 0; i < event.captions.length; i++) {\n                    caption = event.captions[i];\n                    this.trigger('caption', caption);\n                } // Emit each id3 tag to the outside world\n                // Ideally, this would happen immediately on parsing the tag,\n                // but we need to ensure that video data is sent back first\n                // so that ID3 frame timing can be adjusted to match video timing\n\n                for (i = 0; i < event.metadata.length; i++) {\n                    id3 = event.metadata[i];\n                    this.trigger('id3Frame', id3);\n                }\n            } // Only emit `done` if all tracks have been flushed and emitted\n\n            if (this.emittedTracks >= this.numberOfTracks) {\n                this.trigger('done');\n                this.emittedTracks = 0;\n            }\n        };\n        CoalesceStream.prototype.setRemux = function (val) {\n            this.remuxTracks = val;\n        };\n        /**\n         * A Stream that expects MP2T binary data as input and produces\n         * corresponding media segments, suitable for use with Media Source\n         * Extension (MSE) implementations that support the ISO BMFF byte\n         * stream format, like Chrome.\n         */\n\n        Transmuxer = function (options) {\n            var self = this,\n                hasFlushed = true,\n                videoTrack,\n                audioTrack;\n            Transmuxer.prototype.init.call(this);\n            options = options || {};\n            this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n            this.transmuxPipeline_ = {};\n            this.setupAacPipeline = function () {\n                var pipeline = {};\n                this.transmuxPipeline_ = pipeline;\n                pipeline.type = 'aac';\n                pipeline.metadataStream = new m2ts.MetadataStream(); // set up the parsing pipeline\n\n                pipeline.aacStream = new AacStream();\n                pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n                pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n                pipeline.adtsStream = new AdtsStream();\n                pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n                pipeline.headOfPipeline = pipeline.aacStream;\n                pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);\n                pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);\n                pipeline.metadataStream.on('timestamp', function (frame) {\n                    pipeline.aacStream.setTimestamp(frame.timeStamp);\n                });\n                pipeline.aacStream.on('data', function (data) {\n                    if (data.type !== 'timed-metadata' && data.type !== 'audio' || pipeline.audioSegmentStream) {\n                        return;\n                    }\n                    audioTrack = audioTrack || {\n                        timelineStartInfo: {\n                            baseMediaDecodeTime: self.baseMediaDecodeTime\n                        },\n                        codec: 'adts',\n                        type: 'audio'\n                    }; // hook up the audio segment stream to the first track with aac data\n\n                    pipeline.coalesceStream.numberOfTracks++;\n                    pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);\n                    pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));\n                    pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo')); // Set up the final part of the audio pipeline\n\n                    pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream); // emit pmt info\n\n                    self.trigger('trackinfo', {\n                        hasAudio: !!audioTrack,\n                        hasVideo: !!videoTrack\n                    });\n                }); // Re-emit any data coming from the coalesce stream to the outside world\n\n                pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data')); // Let the consumer know we have finished flushing the entire pipeline\n\n                pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n                addPipelineLogRetriggers(this, pipeline);\n            };\n            this.setupTsPipeline = function () {\n                var pipeline = {};\n                this.transmuxPipeline_ = pipeline;\n                pipeline.type = 'ts';\n                pipeline.metadataStream = new m2ts.MetadataStream(); // set up the parsing pipeline\n\n                pipeline.packetStream = new m2ts.TransportPacketStream();\n                pipeline.parseStream = new m2ts.TransportParseStream();\n                pipeline.elementaryStream = new m2ts.ElementaryStream();\n                pipeline.timestampRolloverStream = new m2ts.TimestampRolloverStream();\n                pipeline.adtsStream = new AdtsStream();\n                pipeline.h264Stream = new H264Stream();\n                pipeline.captionStream = new m2ts.CaptionStream(options);\n                pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n                pipeline.headOfPipeline = pipeline.packetStream; // disassemble MPEG2-TS packets into elementary streams\n\n                pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream); // !!THIS ORDER IS IMPORTANT!!\n                // demux the streams\n\n                pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);\n                pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);\n                pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream); // Hook up CEA-608/708 caption stream\n\n                pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);\n                pipeline.elementaryStream.on('data', function (data) {\n                    var i;\n                    if (data.type === 'metadata') {\n                        i = data.tracks.length; // scan the tracks listed in the metadata\n\n                        while (i--) {\n                            if (!videoTrack && data.tracks[i].type === 'video') {\n                                videoTrack = data.tracks[i];\n                                videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n                            } else if (!audioTrack && data.tracks[i].type === 'audio') {\n                                audioTrack = data.tracks[i];\n                                audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n                            }\n                        } // hook up the video segment stream to the first track with h264 data\n\n                        if (videoTrack && !pipeline.videoSegmentStream) {\n                            pipeline.coalesceStream.numberOfTracks++;\n                            pipeline.videoSegmentStream = new VideoSegmentStream(videoTrack, options);\n                            pipeline.videoSegmentStream.on('log', self.getLogTrigger_('videoSegmentStream'));\n                            pipeline.videoSegmentStream.on('timelineStartInfo', function (timelineStartInfo) {\n                                // When video emits timelineStartInfo data after a flush, we forward that\n                                // info to the AudioSegmentStream, if it exists, because video timeline\n                                // data takes precedence.  Do not do this if keepOriginalTimestamps is set,\n                                // because this is a particularly subtle form of timestamp alteration.\n                                if (audioTrack && !options.keepOriginalTimestamps) {\n                                    audioTrack.timelineStartInfo = timelineStartInfo; // On the first segment we trim AAC frames that exist before the\n                                    // very earliest DTS we have seen in video because Chrome will\n                                    // interpret any video track with a baseMediaDecodeTime that is\n                                    // non-zero as a gap.\n\n                                    pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self.baseMediaDecodeTime);\n                                }\n                            });\n                            pipeline.videoSegmentStream.on('processedGopsInfo', self.trigger.bind(self, 'gopInfo'));\n                            pipeline.videoSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'videoSegmentTimingInfo'));\n                            pipeline.videoSegmentStream.on('baseMediaDecodeTime', function (baseMediaDecodeTime) {\n                                if (audioTrack) {\n                                    pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);\n                                }\n                            });\n                            pipeline.videoSegmentStream.on('timingInfo', self.trigger.bind(self, 'videoTimingInfo')); // Set up the final part of the video pipeline\n\n                            pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);\n                        }\n                        if (audioTrack && !pipeline.audioSegmentStream) {\n                            // hook up the audio segment stream to the first track with aac data\n                            pipeline.coalesceStream.numberOfTracks++;\n                            pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);\n                            pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));\n                            pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo'));\n                            pipeline.audioSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'audioSegmentTimingInfo')); // Set up the final part of the audio pipeline\n\n                            pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);\n                        } // emit pmt info\n\n                        self.trigger('trackinfo', {\n                            hasAudio: !!audioTrack,\n                            hasVideo: !!videoTrack\n                        });\n                    }\n                }); // Re-emit any data coming from the coalesce stream to the outside world\n\n                pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n                pipeline.coalesceStream.on('id3Frame', function (id3Frame) {\n                    id3Frame.dispatchType = pipeline.metadataStream.dispatchType;\n                    self.trigger('id3Frame', id3Frame);\n                });\n                pipeline.coalesceStream.on('caption', this.trigger.bind(this, 'caption')); // Let the consumer know we have finished flushing the entire pipeline\n\n                pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n                addPipelineLogRetriggers(this, pipeline);\n            }; // hook up the segment streams once track metadata is delivered\n\n            this.setBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n                var pipeline = this.transmuxPipeline_;\n                if (!options.keepOriginalTimestamps) {\n                    this.baseMediaDecodeTime = baseMediaDecodeTime;\n                }\n                if (audioTrack) {\n                    audioTrack.timelineStartInfo.dts = undefined;\n                    audioTrack.timelineStartInfo.pts = undefined;\n                    trackDecodeInfo.clearDtsInfo(audioTrack);\n                    if (pipeline.audioTimestampRolloverStream) {\n                        pipeline.audioTimestampRolloverStream.discontinuity();\n                    }\n                }\n                if (videoTrack) {\n                    if (pipeline.videoSegmentStream) {\n                        pipeline.videoSegmentStream.gopCache_ = [];\n                    }\n                    videoTrack.timelineStartInfo.dts = undefined;\n                    videoTrack.timelineStartInfo.pts = undefined;\n                    trackDecodeInfo.clearDtsInfo(videoTrack);\n                    pipeline.captionStream.reset();\n                }\n                if (pipeline.timestampRolloverStream) {\n                    pipeline.timestampRolloverStream.discontinuity();\n                }\n            };\n            this.setAudioAppendStart = function (timestamp) {\n                if (audioTrack) {\n                    this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);\n                }\n            };\n            this.setRemux = function (val) {\n                var pipeline = this.transmuxPipeline_;\n                options.remux = val;\n                if (pipeline && pipeline.coalesceStream) {\n                    pipeline.coalesceStream.setRemux(val);\n                }\n            };\n            this.alignGopsWith = function (gopsToAlignWith) {\n                if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {\n                    this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);\n                }\n            };\n            this.getLogTrigger_ = function (key) {\n                var self = this;\n                return function (event) {\n                    event.stream = key;\n                    self.trigger('log', event);\n                };\n            }; // feed incoming data to the front of the parsing pipeline\n\n            this.push = function (data) {\n                if (hasFlushed) {\n                    var isAac = isLikelyAacData(data);\n                    if (isAac && this.transmuxPipeline_.type !== 'aac') {\n                        this.setupAacPipeline();\n                    } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\n                        this.setupTsPipeline();\n                    }\n                    hasFlushed = false;\n                }\n                this.transmuxPipeline_.headOfPipeline.push(data);\n            }; // flush any buffered data\n\n            this.flush = function () {\n                hasFlushed = true; // Start at the top of the pipeline and flush all pending work\n\n                this.transmuxPipeline_.headOfPipeline.flush();\n            };\n            this.endTimeline = function () {\n                this.transmuxPipeline_.headOfPipeline.endTimeline();\n            };\n            this.reset = function () {\n                if (this.transmuxPipeline_.headOfPipeline) {\n                    this.transmuxPipeline_.headOfPipeline.reset();\n                }\n            }; // Caption data has to be reset when seeking outside buffered range\n\n            this.resetCaptions = function () {\n                if (this.transmuxPipeline_.captionStream) {\n                    this.transmuxPipeline_.captionStream.reset();\n                }\n            };\n        };\n        Transmuxer.prototype = new Stream();\n        var transmuxer = {\n            Transmuxer: Transmuxer,\n            VideoSegmentStream: VideoSegmentStream,\n            AudioSegmentStream: AudioSegmentStream,\n            AUDIO_PROPERTIES: AUDIO_PROPERTIES,\n            VIDEO_PROPERTIES: VIDEO_PROPERTIES,\n            // exported for testing\n            generateSegmentTimingInfo: generateSegmentTimingInfo\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         */\n\n        var toUnsigned$3 = function (value) {\n            return value >>> 0;\n        };\n        var toHexString$1 = function (value) {\n            return ('00' + value.toString(16)).slice(-2);\n        };\n        var bin = {\n            toUnsigned: toUnsigned$3,\n            toHexString: toHexString$1\n        };\n        var parseType$3 = function (buffer) {\n            var result = '';\n            result += String.fromCharCode(buffer[0]);\n            result += String.fromCharCode(buffer[1]);\n            result += String.fromCharCode(buffer[2]);\n            result += String.fromCharCode(buffer[3]);\n            return result;\n        };\n        var parseType_1 = parseType$3;\n        var toUnsigned$2 = bin.toUnsigned;\n        var parseType$2 = parseType_1;\n        var findBox$2 = function (data, path) {\n            var results = [],\n                i,\n                size,\n                type,\n                end,\n                subresults;\n            if (!path.length) {\n                // short-circuit the search for empty paths\n                return null;\n            }\n            for (i = 0; i < data.byteLength;) {\n                size = toUnsigned$2(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);\n                type = parseType$2(data.subarray(i + 4, i + 8));\n                end = size > 1 ? i + size : data.byteLength;\n                if (type === path[0]) {\n                    if (path.length === 1) {\n                        // this is the end of the path and we've found the box we were\n                        // looking for\n                        results.push(data.subarray(i + 8, end));\n                    } else {\n                        // recursively search for the next box along the path\n                        subresults = findBox$2(data.subarray(i + 8, end), path.slice(1));\n                        if (subresults.length) {\n                            results = results.concat(subresults);\n                        }\n                    }\n                }\n                i = end;\n            } // we've finished searching all of data\n\n            return results;\n        };\n        var findBox_1 = findBox$2;\n        var toUnsigned$1 = bin.toUnsigned;\n        var getUint64$2 = numbers.getUint64;\n        var tfdt = function (data) {\n            var result = {\n                version: data[0],\n                flags: new Uint8Array(data.subarray(1, 4))\n            };\n            if (result.version === 1) {\n                result.baseMediaDecodeTime = getUint64$2(data.subarray(4));\n            } else {\n                result.baseMediaDecodeTime = toUnsigned$1(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);\n            }\n            return result;\n        };\n        var parseTfdt$2 = tfdt;\n        var parseSampleFlags$1 = function (flags) {\n            return {\n                isLeading: (flags[0] & 0x0c) >>> 2,\n                dependsOn: flags[0] & 0x03,\n                isDependedOn: (flags[1] & 0xc0) >>> 6,\n                hasRedundancy: (flags[1] & 0x30) >>> 4,\n                paddingValue: (flags[1] & 0x0e) >>> 1,\n                isNonSyncSample: flags[1] & 0x01,\n                degradationPriority: flags[2] << 8 | flags[3]\n            };\n        };\n        var parseSampleFlags_1 = parseSampleFlags$1;\n        var parseSampleFlags = parseSampleFlags_1;\n        var trun = function (data) {\n            var result = {\n                    version: data[0],\n                    flags: new Uint8Array(data.subarray(1, 4)),\n                    samples: []\n                },\n                view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n                // Flag interpretation\n                dataOffsetPresent = result.flags[2] & 0x01,\n                // compare with 2nd byte of 0x1\n                firstSampleFlagsPresent = result.flags[2] & 0x04,\n                // compare with 2nd byte of 0x4\n                sampleDurationPresent = result.flags[1] & 0x01,\n                // compare with 2nd byte of 0x100\n                sampleSizePresent = result.flags[1] & 0x02,\n                // compare with 2nd byte of 0x200\n                sampleFlagsPresent = result.flags[1] & 0x04,\n                // compare with 2nd byte of 0x400\n                sampleCompositionTimeOffsetPresent = result.flags[1] & 0x08,\n                // compare with 2nd byte of 0x800\n                sampleCount = view.getUint32(4),\n                offset = 8,\n                sample;\n            if (dataOffsetPresent) {\n                // 32 bit signed integer\n                result.dataOffset = view.getInt32(offset);\n                offset += 4;\n            } // Overrides the flags for the first sample only. The order of\n            // optional values will be: duration, size, compositionTimeOffset\n\n            if (firstSampleFlagsPresent && sampleCount) {\n                sample = {\n                    flags: parseSampleFlags(data.subarray(offset, offset + 4))\n                };\n                offset += 4;\n                if (sampleDurationPresent) {\n                    sample.duration = view.getUint32(offset);\n                    offset += 4;\n                }\n                if (sampleSizePresent) {\n                    sample.size = view.getUint32(offset);\n                    offset += 4;\n                }\n                if (sampleCompositionTimeOffsetPresent) {\n                    if (result.version === 1) {\n                        sample.compositionTimeOffset = view.getInt32(offset);\n                    } else {\n                        sample.compositionTimeOffset = view.getUint32(offset);\n                    }\n                    offset += 4;\n                }\n                result.samples.push(sample);\n                sampleCount--;\n            }\n            while (sampleCount--) {\n                sample = {};\n                if (sampleDurationPresent) {\n                    sample.duration = view.getUint32(offset);\n                    offset += 4;\n                }\n                if (sampleSizePresent) {\n                    sample.size = view.getUint32(offset);\n                    offset += 4;\n                }\n                if (sampleFlagsPresent) {\n                    sample.flags = parseSampleFlags(data.subarray(offset, offset + 4));\n                    offset += 4;\n                }\n                if (sampleCompositionTimeOffsetPresent) {\n                    if (result.version === 1) {\n                        sample.compositionTimeOffset = view.getInt32(offset);\n                    } else {\n                        sample.compositionTimeOffset = view.getUint32(offset);\n                    }\n                    offset += 4;\n                }\n                result.samples.push(sample);\n            }\n            return result;\n        };\n        var parseTrun$2 = trun;\n        var tfhd = function (data) {\n            var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n                result = {\n                    version: data[0],\n                    flags: new Uint8Array(data.subarray(1, 4)),\n                    trackId: view.getUint32(4)\n                },\n                baseDataOffsetPresent = result.flags[2] & 0x01,\n                sampleDescriptionIndexPresent = result.flags[2] & 0x02,\n                defaultSampleDurationPresent = result.flags[2] & 0x08,\n                defaultSampleSizePresent = result.flags[2] & 0x10,\n                defaultSampleFlagsPresent = result.flags[2] & 0x20,\n                durationIsEmpty = result.flags[0] & 0x010000,\n                defaultBaseIsMoof = result.flags[0] & 0x020000,\n                i;\n            i = 8;\n            if (baseDataOffsetPresent) {\n                i += 4; // truncate top 4 bytes\n                // FIXME: should we read the full 64 bits?\n\n                result.baseDataOffset = view.getUint32(12);\n                i += 4;\n            }\n            if (sampleDescriptionIndexPresent) {\n                result.sampleDescriptionIndex = view.getUint32(i);\n                i += 4;\n            }\n            if (defaultSampleDurationPresent) {\n                result.defaultSampleDuration = view.getUint32(i);\n                i += 4;\n            }\n            if (defaultSampleSizePresent) {\n                result.defaultSampleSize = view.getUint32(i);\n                i += 4;\n            }\n            if (defaultSampleFlagsPresent) {\n                result.defaultSampleFlags = view.getUint32(i);\n            }\n            if (durationIsEmpty) {\n                result.durationIsEmpty = true;\n            }\n            if (!baseDataOffsetPresent && defaultBaseIsMoof) {\n                result.baseDataOffsetIsMoof = true;\n            }\n            return result;\n        };\n        var parseTfhd$2 = tfhd;\n        var win;\n        if (typeof window !== \"undefined\") {\n            win = window;\n        } else if (typeof commonjsGlobal !== \"undefined\") {\n            win = commonjsGlobal;\n        } else if (typeof self !== \"undefined\") {\n            win = self;\n        } else {\n            win = {};\n        }\n        var window_1 = win;\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Reads in-band CEA-708 captions out of FMP4 segments.\n         * @see https://en.wikipedia.org/wiki/CEA-708\n         */\n\n        var discardEmulationPreventionBytes = captionPacketParser.discardEmulationPreventionBytes;\n        var CaptionStream = captionStream.CaptionStream;\n        var findBox$1 = findBox_1;\n        var parseTfdt$1 = parseTfdt$2;\n        var parseTrun$1 = parseTrun$2;\n        var parseTfhd$1 = parseTfhd$2;\n        var window$2 = window_1;\n        /**\n         * Maps an offset in the mdat to a sample based on the the size of the samples.\n         * Assumes that `parseSamples` has been called first.\n         *\n         * @param {Number} offset - The offset into the mdat\n         * @param {Object[]} samples - An array of samples, parsed using `parseSamples`\n         * @return {?Object} The matching sample, or null if no match was found.\n         *\n         * @see ISO-BMFF-12/2015, Section 8.8.8\n         **/\n\n        var mapToSample = function (offset, samples) {\n            var approximateOffset = offset;\n            for (var i = 0; i < samples.length; i++) {\n                var sample = samples[i];\n                if (approximateOffset < sample.size) {\n                    return sample;\n                }\n                approximateOffset -= sample.size;\n            }\n            return null;\n        };\n        /**\n         * Finds SEI nal units contained in a Media Data Box.\n         * Assumes that `parseSamples` has been called first.\n         *\n         * @param {Uint8Array} avcStream - The bytes of the mdat\n         * @param {Object[]} samples - The samples parsed out by `parseSamples`\n         * @param {Number} trackId - The trackId of this video track\n         * @return {Object[]} seiNals - the parsed SEI NALUs found.\n         *   The contents of the seiNal should match what is expected by\n         *   CaptionStream.push (nalUnitType, size, data, escapedRBSP, pts, dts)\n         *\n         * @see ISO-BMFF-12/2015, Section 8.1.1\n         * @see Rec. ITU-T H.264, 7.3.2.3.1\n         **/\n\n        var findSeiNals = function (avcStream, samples, trackId) {\n            var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n                result = {\n                    logs: [],\n                    seiNals: []\n                },\n                seiNal,\n                i,\n                length,\n                lastMatchedSample;\n            for (i = 0; i + 4 < avcStream.length; i += length) {\n                length = avcView.getUint32(i);\n                i += 4; // Bail if this doesn't appear to be an H264 stream\n\n                if (length <= 0) {\n                    continue;\n                }\n                switch (avcStream[i] & 0x1F) {\n                    case 0x06:\n                        var data = avcStream.subarray(i + 1, i + 1 + length);\n                        var matchingSample = mapToSample(i, samples);\n                        seiNal = {\n                            nalUnitType: 'sei_rbsp',\n                            size: length,\n                            data: data,\n                            escapedRBSP: discardEmulationPreventionBytes(data),\n                            trackId: trackId\n                        };\n                        if (matchingSample) {\n                            seiNal.pts = matchingSample.pts;\n                            seiNal.dts = matchingSample.dts;\n                            lastMatchedSample = matchingSample;\n                        } else if (lastMatchedSample) {\n                            // If a matching sample cannot be found, use the last\n                            // sample's values as they should be as close as possible\n                            seiNal.pts = lastMatchedSample.pts;\n                            seiNal.dts = lastMatchedSample.dts;\n                        } else {\n                            result.logs.push({\n                                level: 'warn',\n                                message: 'We\\'ve encountered a nal unit without data at ' + i + ' for trackId ' + trackId + '. See mux.js#223.'\n                            });\n                            break;\n                        }\n                        result.seiNals.push(seiNal);\n                        break;\n                }\n            }\n            return result;\n        };\n        /**\n         * Parses sample information out of Track Run Boxes and calculates\n         * the absolute presentation and decode timestamps of each sample.\n         *\n         * @param {Array<Uint8Array>} truns - The Trun Run boxes to be parsed\n         * @param {Number|BigInt} baseMediaDecodeTime - base media decode time from tfdt\n         @see ISO-BMFF-12/2015, Section 8.8.12\n         * @param {Object} tfhd - The parsed Track Fragment Header\n         *   @see inspect.parseTfhd\n         * @return {Object[]} the parsed samples\n         *\n         * @see ISO-BMFF-12/2015, Section 8.8.8\n         **/\n\n        var parseSamples = function (truns, baseMediaDecodeTime, tfhd) {\n            var currentDts = baseMediaDecodeTime;\n            var defaultSampleDuration = tfhd.defaultSampleDuration || 0;\n            var defaultSampleSize = tfhd.defaultSampleSize || 0;\n            var trackId = tfhd.trackId;\n            var allSamples = [];\n            truns.forEach(function (trun) {\n                // Note: We currently do not parse the sample table as well\n                // as the trun. It's possible some sources will require this.\n                // moov > trak > mdia > minf > stbl\n                var trackRun = parseTrun$1(trun);\n                var samples = trackRun.samples;\n                samples.forEach(function (sample) {\n                    if (sample.duration === undefined) {\n                        sample.duration = defaultSampleDuration;\n                    }\n                    if (sample.size === undefined) {\n                        sample.size = defaultSampleSize;\n                    }\n                    sample.trackId = trackId;\n                    sample.dts = currentDts;\n                    if (sample.compositionTimeOffset === undefined) {\n                        sample.compositionTimeOffset = 0;\n                    }\n                    if (typeof currentDts === 'bigint') {\n                        sample.pts = currentDts + window$2.BigInt(sample.compositionTimeOffset);\n                        currentDts += window$2.BigInt(sample.duration);\n                    } else {\n                        sample.pts = currentDts + sample.compositionTimeOffset;\n                        currentDts += sample.duration;\n                    }\n                });\n                allSamples = allSamples.concat(samples);\n            });\n            return allSamples;\n        };\n        /**\n         * Parses out caption nals from an FMP4 segment's video tracks.\n         *\n         * @param {Uint8Array} segment - The bytes of a single segment\n         * @param {Number} videoTrackId - The trackId of a video track in the segment\n         * @return {Object.<Number, Object[]>} A mapping of video trackId to\n         *   a list of seiNals found in that track\n         **/\n\n        var parseCaptionNals = function (segment, videoTrackId) {\n            // To get the samples\n            var trafs = findBox$1(segment, ['moof', 'traf']); // To get SEI NAL units\n\n            var mdats = findBox$1(segment, ['mdat']);\n            var captionNals = {};\n            var mdatTrafPairs = []; // Pair up each traf with a mdat as moofs and mdats are in pairs\n\n            mdats.forEach(function (mdat, index) {\n                var matchingTraf = trafs[index];\n                mdatTrafPairs.push({\n                    mdat: mdat,\n                    traf: matchingTraf\n                });\n            });\n            mdatTrafPairs.forEach(function (pair) {\n                var mdat = pair.mdat;\n                var traf = pair.traf;\n                var tfhd = findBox$1(traf, ['tfhd']); // Exactly 1 tfhd per traf\n\n                var headerInfo = parseTfhd$1(tfhd[0]);\n                var trackId = headerInfo.trackId;\n                var tfdt = findBox$1(traf, ['tfdt']); // Either 0 or 1 tfdt per traf\n\n                var baseMediaDecodeTime = tfdt.length > 0 ? parseTfdt$1(tfdt[0]).baseMediaDecodeTime : 0;\n                var truns = findBox$1(traf, ['trun']);\n                var samples;\n                var result; // Only parse video data for the chosen video track\n\n                if (videoTrackId === trackId && truns.length > 0) {\n                    samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);\n                    result = findSeiNals(mdat, samples, trackId);\n                    if (!captionNals[trackId]) {\n                        captionNals[trackId] = {\n                            seiNals: [],\n                            logs: []\n                        };\n                    }\n                    captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals);\n                    captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs);\n                }\n            });\n            return captionNals;\n        };\n        /**\n         * Parses out inband captions from an MP4 container and returns\n         * caption objects that can be used by WebVTT and the TextTrack API.\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/VTTCue\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrack\n         * Assumes that `probe.getVideoTrackIds` and `probe.timescale` have been called first\n         *\n         * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n         * @param {Number} trackId - The id of the video track to parse\n         * @param {Number} timescale - The timescale for the video track from the init segment\n         *\n         * @return {?Object[]} parsedCaptions - A list of captions or null if no video tracks\n         * @return {Number} parsedCaptions[].startTime - The time to show the caption in seconds\n         * @return {Number} parsedCaptions[].endTime - The time to stop showing the caption in seconds\n         * @return {String} parsedCaptions[].text - The visible content of the caption\n         **/\n\n        var parseEmbeddedCaptions = function (segment, trackId, timescale) {\n            var captionNals; // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n\n            if (trackId === null) {\n                return null;\n            }\n            captionNals = parseCaptionNals(segment, trackId);\n            var trackNals = captionNals[trackId] || {};\n            return {\n                seiNals: trackNals.seiNals,\n                logs: trackNals.logs,\n                timescale: timescale\n            };\n        };\n        /**\n         * Converts SEI NALUs into captions that can be used by video.js\n         **/\n\n        var CaptionParser = function () {\n            var isInitialized = false;\n            var captionStream; // Stores segments seen before trackId and timescale are set\n\n            var segmentCache; // Stores video track ID of the track being parsed\n\n            var trackId; // Stores the timescale of the track being parsed\n\n            var timescale; // Stores captions parsed so far\n\n            var parsedCaptions; // Stores whether we are receiving partial data or not\n\n            var parsingPartial;\n            /**\n             * A method to indicate whether a CaptionParser has been initalized\n             * @returns {Boolean}\n             **/\n\n            this.isInitialized = function () {\n                return isInitialized;\n            };\n            /**\n             * Initializes the underlying CaptionStream, SEI NAL parsing\n             * and management, and caption collection\n             **/\n\n            this.init = function (options) {\n                captionStream = new CaptionStream();\n                isInitialized = true;\n                parsingPartial = options ? options.isPartial : false; // Collect dispatched captions\n\n                captionStream.on('data', function (event) {\n                    // Convert to seconds in the source's timescale\n                    event.startTime = event.startPts / timescale;\n                    event.endTime = event.endPts / timescale;\n                    parsedCaptions.captions.push(event);\n                    parsedCaptions.captionStreams[event.stream] = true;\n                });\n                captionStream.on('log', function (log) {\n                    parsedCaptions.logs.push(log);\n                });\n            };\n            /**\n             * Determines if a new video track will be selected\n             * or if the timescale changed\n             * @return {Boolean}\n             **/\n\n            this.isNewInit = function (videoTrackIds, timescales) {\n                if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === 'object' && Object.keys(timescales).length === 0) {\n                    return false;\n                }\n                return trackId !== videoTrackIds[0] || timescale !== timescales[trackId];\n            };\n            /**\n             * Parses out SEI captions and interacts with underlying\n             * CaptionStream to return dispatched captions\n             *\n             * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n             * @param {Number[]} videoTrackIds - A list of video tracks found in the init segment\n             * @param {Object.<Number, Number>} timescales - The timescales found in the init segment\n             * @see parseEmbeddedCaptions\n             * @see m2ts/caption-stream.js\n             **/\n\n            this.parse = function (segment, videoTrackIds, timescales) {\n                var parsedData;\n                if (!this.isInitialized()) {\n                    return null; // This is not likely to be a video segment\n                } else if (!videoTrackIds || !timescales) {\n                    return null;\n                } else if (this.isNewInit(videoTrackIds, timescales)) {\n                    // Use the first video track only as there is no\n                    // mechanism to switch to other video tracks\n                    trackId = videoTrackIds[0];\n                    timescale = timescales[trackId]; // If an init segment has not been seen yet, hold onto segment\n                    // data until we have one.\n                    // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n                } else if (trackId === null || !timescale) {\n                    segmentCache.push(segment);\n                    return null;\n                } // Now that a timescale and trackId is set, parse cached segments\n\n                while (segmentCache.length > 0) {\n                    var cachedSegment = segmentCache.shift();\n                    this.parse(cachedSegment, videoTrackIds, timescales);\n                }\n                parsedData = parseEmbeddedCaptions(segment, trackId, timescale);\n                if (parsedData && parsedData.logs) {\n                    parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs);\n                }\n                if (parsedData === null || !parsedData.seiNals) {\n                    if (parsedCaptions.logs.length) {\n                        return {\n                            logs: parsedCaptions.logs,\n                            captions: [],\n                            captionStreams: []\n                        };\n                    }\n                    return null;\n                }\n                this.pushNals(parsedData.seiNals); // Force the parsed captions to be dispatched\n\n                this.flushStream();\n                return parsedCaptions;\n            };\n            /**\n             * Pushes SEI NALUs onto CaptionStream\n             * @param {Object[]} nals - A list of SEI nals parsed using `parseCaptionNals`\n             * Assumes that `parseCaptionNals` has been called first\n             * @see m2ts/caption-stream.js\n             **/\n\n            this.pushNals = function (nals) {\n                if (!this.isInitialized() || !nals || nals.length === 0) {\n                    return null;\n                }\n                nals.forEach(function (nal) {\n                    captionStream.push(nal);\n                });\n            };\n            /**\n             * Flushes underlying CaptionStream to dispatch processed, displayable captions\n             * @see m2ts/caption-stream.js\n             **/\n\n            this.flushStream = function () {\n                if (!this.isInitialized()) {\n                    return null;\n                }\n                if (!parsingPartial) {\n                    captionStream.flush();\n                } else {\n                    captionStream.partialFlush();\n                }\n            };\n            /**\n             * Reset caption buckets for new data\n             **/\n\n            this.clearParsedCaptions = function () {\n                parsedCaptions.captions = [];\n                parsedCaptions.captionStreams = {};\n                parsedCaptions.logs = [];\n            };\n            /**\n             * Resets underlying CaptionStream\n             * @see m2ts/caption-stream.js\n             **/\n\n            this.resetCaptionStream = function () {\n                if (!this.isInitialized()) {\n                    return null;\n                }\n                captionStream.reset();\n            };\n            /**\n             * Convenience method to clear all captions flushed from the\n             * CaptionStream and still being parsed\n             * @see m2ts/caption-stream.js\n             **/\n\n            this.clearAllCaptions = function () {\n                this.clearParsedCaptions();\n                this.resetCaptionStream();\n            };\n            /**\n             * Reset caption parser\n             **/\n\n            this.reset = function () {\n                segmentCache = [];\n                trackId = null;\n                timescale = null;\n                if (!parsedCaptions) {\n                    parsedCaptions = {\n                        captions: [],\n                        // CC1, CC2, CC3, CC4\n                        captionStreams: {},\n                        logs: []\n                    };\n                } else {\n                    this.clearParsedCaptions();\n                }\n                this.resetCaptionStream();\n            };\n            this.reset();\n        };\n        var captionParser = CaptionParser;\n        /**\n         * Returns the first string in the data array ending with a null char '\\0'\n         * @param {UInt8} data\n         * @returns the string with the null char\n         */\n\n        var uint8ToCString$1 = function (data) {\n            var index = 0;\n            var curChar = String.fromCharCode(data[index]);\n            var retString = '';\n            while (curChar !== '\\0') {\n                retString += curChar;\n                index++;\n                curChar = String.fromCharCode(data[index]);\n            } // Add nullChar\n\n            retString += curChar;\n            return retString;\n        };\n        var string = {\n            uint8ToCString: uint8ToCString$1\n        };\n        var uint8ToCString = string.uint8ToCString;\n        var getUint64$1 = numbers.getUint64;\n        /**\n         * Based on: ISO/IEC 23009 Section: 5.10.3.3\n         * References:\n         * https://dashif-documents.azurewebsites.net/Events/master/event.html#emsg-format\n         * https://aomediacodec.github.io/id3-emsg/\n         *\n         * Takes emsg box data as a uint8 array and returns a emsg box object\n         * @param {UInt8Array} boxData data from emsg box\n         * @returns A parsed emsg box object\n         */\n\n        var parseEmsgBox = function (boxData) {\n            // version + flags\n            var offset = 4;\n            var version = boxData[0];\n            var scheme_id_uri, value, timescale, presentation_time, presentation_time_delta, event_duration, id, message_data;\n            if (version === 0) {\n                scheme_id_uri = uint8ToCString(boxData.subarray(offset));\n                offset += scheme_id_uri.length;\n                value = uint8ToCString(boxData.subarray(offset));\n                offset += value.length;\n                var dv = new DataView(boxData.buffer);\n                timescale = dv.getUint32(offset);\n                offset += 4;\n                presentation_time_delta = dv.getUint32(offset);\n                offset += 4;\n                event_duration = dv.getUint32(offset);\n                offset += 4;\n                id = dv.getUint32(offset);\n                offset += 4;\n            } else if (version === 1) {\n                var dv = new DataView(boxData.buffer);\n                timescale = dv.getUint32(offset);\n                offset += 4;\n                presentation_time = getUint64$1(boxData.subarray(offset));\n                offset += 8;\n                event_duration = dv.getUint32(offset);\n                offset += 4;\n                id = dv.getUint32(offset);\n                offset += 4;\n                scheme_id_uri = uint8ToCString(boxData.subarray(offset));\n                offset += scheme_id_uri.length;\n                value = uint8ToCString(boxData.subarray(offset));\n                offset += value.length;\n            }\n            message_data = new Uint8Array(boxData.subarray(offset, boxData.byteLength));\n            var emsgBox = {\n                scheme_id_uri,\n                value,\n                // if timescale is undefined or 0 set to 1\n                timescale: timescale ? timescale : 1,\n                presentation_time,\n                presentation_time_delta,\n                event_duration,\n                id,\n                message_data\n            };\n            return isValidEmsgBox(version, emsgBox) ? emsgBox : undefined;\n        };\n        /**\n         * Scales a presentation time or time delta with an offset with a provided timescale\n         * @param {number} presentationTime\n         * @param {number} timescale\n         * @param {number} timeDelta\n         * @param {number} offset\n         * @returns the scaled time as a number\n         */\n\n        var scaleTime = function (presentationTime, timescale, timeDelta, offset) {\n            return presentationTime || presentationTime === 0 ? presentationTime / timescale : offset + timeDelta / timescale;\n        };\n        /**\n         * Checks the emsg box data for validity based on the version\n         * @param {number} version of the emsg box to validate\n         * @param {Object} emsg the emsg data to validate\n         * @returns if the box is valid as a boolean\n         */\n\n        var isValidEmsgBox = function (version, emsg) {\n            var hasScheme = emsg.scheme_id_uri !== '\\0';\n            var isValidV0Box = version === 0 && isDefined(emsg.presentation_time_delta) && hasScheme;\n            var isValidV1Box = version === 1 && isDefined(emsg.presentation_time) && hasScheme; // Only valid versions of emsg are 0 and 1\n\n            return !(version > 1) && isValidV0Box || isValidV1Box;\n        }; // Utility function to check if an object is defined\n\n        var isDefined = function (data) {\n            return data !== undefined || data !== null;\n        };\n        var emsg$1 = {\n            parseEmsgBox: parseEmsgBox,\n            scaleTime: scaleTime\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Utilities to detect basic properties and metadata about MP4s.\n         */\n\n        var toUnsigned = bin.toUnsigned;\n        var toHexString = bin.toHexString;\n        var findBox = findBox_1;\n        var parseType$1 = parseType_1;\n        var emsg = emsg$1;\n        var parseTfhd = parseTfhd$2;\n        var parseTrun = parseTrun$2;\n        var parseTfdt = parseTfdt$2;\n        var getUint64 = numbers.getUint64;\n        var timescale, startTime, compositionStartTime, getVideoTrackIds, getTracks, getTimescaleFromMediaHeader, getEmsgID3;\n        var window$1 = window_1;\n        var parseId3Frames = parseId3.parseId3Frames;\n        /**\n         * Parses an MP4 initialization segment and extracts the timescale\n         * values for any declared tracks. Timescale values indicate the\n         * number of clock ticks per second to assume for time-based values\n         * elsewhere in the MP4.\n         *\n         * To determine the start time of an MP4, you need two pieces of\n         * information: the timescale unit and the earliest base media decode\n         * time. Multiple timescales can be specified within an MP4 but the\n         * base media decode time is always expressed in the timescale from\n         * the media header box for the track:\n         * ```\n         * moov > trak > mdia > mdhd.timescale\n         * ```\n         * @param init {Uint8Array} the bytes of the init segment\n         * @return {object} a hash of track ids to timescale values or null if\n         * the init segment is malformed.\n         */\n\n        timescale = function (init) {\n            var result = {},\n                traks = findBox(init, ['moov', 'trak']); // mdhd timescale\n\n            return traks.reduce(function (result, trak) {\n                var tkhd, version, index, id, mdhd;\n                tkhd = findBox(trak, ['tkhd'])[0];\n                if (!tkhd) {\n                    return null;\n                }\n                version = tkhd[0];\n                index = version === 0 ? 12 : 20;\n                id = toUnsigned(tkhd[index] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3]);\n                mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n                if (!mdhd) {\n                    return null;\n                }\n                version = mdhd[0];\n                index = version === 0 ? 12 : 20;\n                result[id] = toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);\n                return result;\n            }, result);\n        };\n        /**\n         * Determine the base media decode start time, in seconds, for an MP4\n         * fragment. If multiple fragments are specified, the earliest time is\n         * returned.\n         *\n         * The base media decode time can be parsed from track fragment\n         * metadata:\n         * ```\n         * moof > traf > tfdt.baseMediaDecodeTime\n         * ```\n         * It requires the timescale value from the mdhd to interpret.\n         *\n         * @param timescale {object} a hash of track ids to timescale values.\n         * @return {number} the earliest base media decode start time for the\n         * fragment, in seconds\n         */\n\n        startTime = function (timescale, fragment) {\n            var trafs; // we need info from two childrend of each track fragment box\n\n            trafs = findBox(fragment, ['moof', 'traf']); // determine the start times for each track\n\n            var lowestTime = trafs.reduce(function (acc, traf) {\n                var tfhd = findBox(traf, ['tfhd'])[0]; // get the track id from the tfhd\n\n                var id = toUnsigned(tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7]); // assume a 90kHz clock if no timescale was specified\n\n                var scale = timescale[id] || 90e3; // get the base media decode time from the tfdt\n\n                var tfdt = findBox(traf, ['tfdt'])[0];\n                var dv = new DataView(tfdt.buffer, tfdt.byteOffset, tfdt.byteLength);\n                var baseTime; // version 1 is 64 bit\n\n                if (tfdt[0] === 1) {\n                    baseTime = getUint64(tfdt.subarray(4, 12));\n                } else {\n                    baseTime = dv.getUint32(4);\n                } // convert base time to seconds if it is a valid number.\n\n                let seconds;\n                if (typeof baseTime === 'bigint') {\n                    seconds = baseTime / window$1.BigInt(scale);\n                } else if (typeof baseTime === 'number' && !isNaN(baseTime)) {\n                    seconds = baseTime / scale;\n                }\n                if (seconds < Number.MAX_SAFE_INTEGER) {\n                    seconds = Number(seconds);\n                }\n                if (seconds < acc) {\n                    acc = seconds;\n                }\n                return acc;\n            }, Infinity);\n            return typeof lowestTime === 'bigint' || isFinite(lowestTime) ? lowestTime : 0;\n        };\n        /**\n         * Determine the composition start, in seconds, for an MP4\n         * fragment.\n         *\n         * The composition start time of a fragment can be calculated using the base\n         * media decode time, composition time offset, and timescale, as follows:\n         *\n         * compositionStartTime = (baseMediaDecodeTime + compositionTimeOffset) / timescale\n         *\n         * All of the aforementioned information is contained within a media fragment's\n         * `traf` box, except for timescale info, which comes from the initialization\n         * segment, so a track id (also contained within a `traf`) is also necessary to\n         * associate it with a timescale\n         *\n         *\n         * @param timescales {object} - a hash of track ids to timescale values.\n         * @param fragment {Unit8Array} - the bytes of a media segment\n         * @return {number} the composition start time for the fragment, in seconds\n         **/\n\n        compositionStartTime = function (timescales, fragment) {\n            var trafBoxes = findBox(fragment, ['moof', 'traf']);\n            var baseMediaDecodeTime = 0;\n            var compositionTimeOffset = 0;\n            var trackId;\n            if (trafBoxes && trafBoxes.length) {\n                // The spec states that track run samples contained within a `traf` box are contiguous, but\n                // it does not explicitly state whether the `traf` boxes themselves are contiguous.\n                // We will assume that they are, so we only need the first to calculate start time.\n                var tfhd = findBox(trafBoxes[0], ['tfhd'])[0];\n                var trun = findBox(trafBoxes[0], ['trun'])[0];\n                var tfdt = findBox(trafBoxes[0], ['tfdt'])[0];\n                if (tfhd) {\n                    var parsedTfhd = parseTfhd(tfhd);\n                    trackId = parsedTfhd.trackId;\n                }\n                if (tfdt) {\n                    var parsedTfdt = parseTfdt(tfdt);\n                    baseMediaDecodeTime = parsedTfdt.baseMediaDecodeTime;\n                }\n                if (trun) {\n                    var parsedTrun = parseTrun(trun);\n                    if (parsedTrun.samples && parsedTrun.samples.length) {\n                        compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0;\n                    }\n                }\n            } // Get timescale for this specific track. Assume a 90kHz clock if no timescale was\n            // specified.\n\n            var timescale = timescales[trackId] || 90e3; // return the composition start time, in seconds\n\n            if (typeof baseMediaDecodeTime === 'bigint') {\n                compositionTimeOffset = window$1.BigInt(compositionTimeOffset);\n                timescale = window$1.BigInt(timescale);\n            }\n            var result = (baseMediaDecodeTime + compositionTimeOffset) / timescale;\n            if (typeof result === 'bigint' && result < Number.MAX_SAFE_INTEGER) {\n                result = Number(result);\n            }\n            return result;\n        };\n        /**\n         * Find the trackIds of the video tracks in this source.\n         * Found by parsing the Handler Reference and Track Header Boxes:\n         *   moov > trak > mdia > hdlr\n         *   moov > trak > tkhd\n         *\n         * @param {Uint8Array} init - The bytes of the init segment for this source\n         * @return {Number[]} A list of trackIds\n         *\n         * @see ISO-BMFF-12/2015, Section 8.4.3\n         **/\n\n        getVideoTrackIds = function (init) {\n            var traks = findBox(init, ['moov', 'trak']);\n            var videoTrackIds = [];\n            traks.forEach(function (trak) {\n                var hdlrs = findBox(trak, ['mdia', 'hdlr']);\n                var tkhds = findBox(trak, ['tkhd']);\n                hdlrs.forEach(function (hdlr, index) {\n                    var handlerType = parseType$1(hdlr.subarray(8, 12));\n                    var tkhd = tkhds[index];\n                    var view;\n                    var version;\n                    var trackId;\n                    if (handlerType === 'vide') {\n                        view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n                        version = view.getUint8(0);\n                        trackId = version === 0 ? view.getUint32(12) : view.getUint32(20);\n                        videoTrackIds.push(trackId);\n                    }\n                });\n            });\n            return videoTrackIds;\n        };\n        getTimescaleFromMediaHeader = function (mdhd) {\n            // mdhd is a FullBox, meaning it will have its own version as the first byte\n            var version = mdhd[0];\n            var index = version === 0 ? 12 : 20;\n            return toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);\n        };\n        /**\n         * Get all the video, audio, and hint tracks from a non fragmented\n         * mp4 segment\n         */\n\n        getTracks = function (init) {\n            var traks = findBox(init, ['moov', 'trak']);\n            var tracks = [];\n            traks.forEach(function (trak) {\n                var track = {};\n                var tkhd = findBox(trak, ['tkhd'])[0];\n                var view, tkhdVersion; // id\n\n                if (tkhd) {\n                    view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n                    tkhdVersion = view.getUint8(0);\n                    track.id = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);\n                }\n                var hdlr = findBox(trak, ['mdia', 'hdlr'])[0]; // type\n\n                if (hdlr) {\n                    var type = parseType$1(hdlr.subarray(8, 12));\n                    if (type === 'vide') {\n                        track.type = 'video';\n                    } else if (type === 'soun') {\n                        track.type = 'audio';\n                    } else {\n                        track.type = type;\n                    }\n                } // codec\n\n                var stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n                if (stsd) {\n                    var sampleDescriptions = stsd.subarray(8); // gives the codec type string\n\n                    track.codec = parseType$1(sampleDescriptions.subarray(4, 8));\n                    var codecBox = findBox(sampleDescriptions, [track.codec])[0];\n                    var codecConfig, codecConfigType;\n                    if (codecBox) {\n                        // https://tools.ietf.org/html/rfc6381#section-3.3\n                        if (/^[asm]vc[1-9]$/i.test(track.codec)) {\n                            // we don't need anything but the \"config\" parameter of the\n                            // avc1 codecBox\n                            codecConfig = codecBox.subarray(78);\n                            codecConfigType = parseType$1(codecConfig.subarray(4, 8));\n                            if (codecConfigType === 'avcC' && codecConfig.length > 11) {\n                                track.codec += '.'; // left padded with zeroes for single digit hex\n                                // profile idc\n\n                                track.codec += toHexString(codecConfig[9]); // the byte containing the constraint_set flags\n\n                                track.codec += toHexString(codecConfig[10]); // level idc\n\n                                track.codec += toHexString(codecConfig[11]);\n                            } else {\n                                // TODO: show a warning that we couldn't parse the codec\n                                // and are using the default\n                                track.codec = 'avc1.4d400d';\n                            }\n                        } else if (/^mp4[a,v]$/i.test(track.codec)) {\n                            // we do not need anything but the streamDescriptor of the mp4a codecBox\n                            codecConfig = codecBox.subarray(28);\n                            codecConfigType = parseType$1(codecConfig.subarray(4, 8));\n                            if (codecConfigType === 'esds' && codecConfig.length > 20 && codecConfig[19] !== 0) {\n                                track.codec += '.' + toHexString(codecConfig[19]); // this value is only a single digit\n\n                                track.codec += '.' + toHexString(codecConfig[20] >>> 2 & 0x3f).replace(/^0/, '');\n                            } else {\n                                // TODO: show a warning that we couldn't parse the codec\n                                // and are using the default\n                                track.codec = 'mp4a.40.2';\n                            }\n                        } else {\n                            // flac, opus, etc\n                            track.codec = track.codec.toLowerCase();\n                        }\n                    }\n                }\n                var mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n                if (mdhd) {\n                    track.timescale = getTimescaleFromMediaHeader(mdhd);\n                }\n                tracks.push(track);\n            });\n            return tracks;\n        };\n        /**\n         * Returns an array of emsg ID3 data from the provided segmentData.\n         * An offset can also be provided as the Latest Arrival Time to calculate\n         * the Event Start Time of v0 EMSG boxes.\n         * See: https://dashif-documents.azurewebsites.net/Events/master/event.html#Inband-event-timing\n         *\n         * @param {Uint8Array} segmentData the segment byte array.\n         * @param {number} offset the segment start time or Latest Arrival Time,\n         * @return {Object[]} an array of ID3 parsed from EMSG boxes\n         */\n\n        getEmsgID3 = function (segmentData, offset = 0) {\n            var emsgBoxes = findBox(segmentData, ['emsg']);\n            return emsgBoxes.map(data => {\n                var parsedBox = emsg.parseEmsgBox(new Uint8Array(data));\n                var parsedId3Frames = parseId3Frames(parsedBox.message_data);\n                return {\n                    cueTime: emsg.scaleTime(parsedBox.presentation_time, parsedBox.timescale, parsedBox.presentation_time_delta, offset),\n                    duration: emsg.scaleTime(parsedBox.event_duration, parsedBox.timescale),\n                    frames: parsedId3Frames\n                };\n            });\n        };\n        var probe$2 = {\n            // export mp4 inspector's findBox and parseType for backwards compatibility\n            findBox: findBox,\n            parseType: parseType$1,\n            timescale: timescale,\n            startTime: startTime,\n            compositionStartTime: compositionStartTime,\n            videoTrackIds: getVideoTrackIds,\n            tracks: getTracks,\n            getTimescaleFromMediaHeader: getTimescaleFromMediaHeader,\n            getEmsgID3: getEmsgID3\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Utilities to detect basic properties and metadata about TS Segments.\n         */\n\n        var StreamTypes$1 = streamTypes;\n        var parsePid = function (packet) {\n            var pid = packet[1] & 0x1f;\n            pid <<= 8;\n            pid |= packet[2];\n            return pid;\n        };\n        var parsePayloadUnitStartIndicator = function (packet) {\n            return !!(packet[1] & 0x40);\n        };\n        var parseAdaptionField = function (packet) {\n            var offset = 0; // if an adaption field is present, its length is specified by the\n            // fifth byte of the TS packet header. The adaptation field is\n            // used to add stuffing to PES packets that don't fill a complete\n            // TS packet, and to specify some forms of timing and control data\n            // that we do not currently use.\n\n            if ((packet[3] & 0x30) >>> 4 > 0x01) {\n                offset += packet[4] + 1;\n            }\n            return offset;\n        };\n        var parseType = function (packet, pmtPid) {\n            var pid = parsePid(packet);\n            if (pid === 0) {\n                return 'pat';\n            } else if (pid === pmtPid) {\n                return 'pmt';\n            } else if (pmtPid) {\n                return 'pes';\n            }\n            return null;\n        };\n        var parsePat = function (packet) {\n            var pusi = parsePayloadUnitStartIndicator(packet);\n            var offset = 4 + parseAdaptionField(packet);\n            if (pusi) {\n                offset += packet[offset] + 1;\n            }\n            return (packet[offset + 10] & 0x1f) << 8 | packet[offset + 11];\n        };\n        var parsePmt = function (packet) {\n            var programMapTable = {};\n            var pusi = parsePayloadUnitStartIndicator(packet);\n            var payloadOffset = 4 + parseAdaptionField(packet);\n            if (pusi) {\n                payloadOffset += packet[payloadOffset] + 1;\n            } // PMTs can be sent ahead of the time when they should actually\n            // take effect. We don't believe this should ever be the case\n            // for HLS but we'll ignore \"forward\" PMT declarations if we see\n            // them. Future PMT declarations have the current_next_indicator\n            // set to zero.\n\n            if (!(packet[payloadOffset + 5] & 0x01)) {\n                return;\n            }\n            var sectionLength, tableEnd, programInfoLength; // the mapping table ends at the end of the current section\n\n            sectionLength = (packet[payloadOffset + 1] & 0x0f) << 8 | packet[payloadOffset + 2];\n            tableEnd = 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\n            // long the program info descriptors are\n\n            programInfoLength = (packet[payloadOffset + 10] & 0x0f) << 8 | packet[payloadOffset + 11]; // advance the offset to the first entry in the mapping table\n\n            var offset = 12 + programInfoLength;\n            while (offset < tableEnd) {\n                var i = payloadOffset + offset; // add an entry that maps the elementary_pid to the stream_type\n\n                programMapTable[(packet[i + 1] & 0x1F) << 8 | packet[i + 2]] = packet[i]; // move to the next table entry\n                // skip past the elementary stream descriptors, if present\n\n                offset += ((packet[i + 3] & 0x0F) << 8 | packet[i + 4]) + 5;\n            }\n            return programMapTable;\n        };\n        var parsePesType = function (packet, programMapTable) {\n            var pid = parsePid(packet);\n            var type = programMapTable[pid];\n            switch (type) {\n                case StreamTypes$1.H264_STREAM_TYPE:\n                    return 'video';\n                case StreamTypes$1.ADTS_STREAM_TYPE:\n                    return 'audio';\n                case StreamTypes$1.METADATA_STREAM_TYPE:\n                    return 'timed-metadata';\n                default:\n                    return null;\n            }\n        };\n        var parsePesTime = function (packet) {\n            var pusi = parsePayloadUnitStartIndicator(packet);\n            if (!pusi) {\n                return null;\n            }\n            var offset = 4 + parseAdaptionField(packet);\n            if (offset >= packet.byteLength) {\n                // From the H 222.0 MPEG-TS spec\n                // \"For transport stream packets carrying PES packets, stuffing is needed when there\n                //  is insufficient PES packet data to completely fill the transport stream packet\n                //  payload bytes. Stuffing is accomplished by defining an adaptation field longer than\n                //  the sum of the lengths of the data elements in it, so that the payload bytes\n                //  remaining after the adaptation field exactly accommodates the available PES packet\n                //  data.\"\n                //\n                // If the offset is >= the length of the packet, then the packet contains no data\n                // and instead is just adaption field stuffing bytes\n                return null;\n            }\n            var pes = null;\n            var ptsDtsFlags; // PES packets may be annotated with a PTS value, or a PTS value\n            // and a DTS value. Determine what combination of values is\n            // available to work with.\n\n            ptsDtsFlags = packet[offset + 7]; // PTS and DTS are normally stored as a 33-bit number.  Javascript\n            // performs all bitwise operations on 32-bit integers but javascript\n            // supports a much greater range (52-bits) of integer using standard\n            // mathematical operations.\n            // We construct a 31-bit value using bitwise operators over the 31\n            // most significant bits and then multiply by 4 (equal to a left-shift\n            // of 2) before we add the final 2 least significant bits of the\n            // timestamp (equal to an OR.)\n\n            if (ptsDtsFlags & 0xC0) {\n                pes = {}; // the PTS and DTS are not written out directly. For information\n                // on how they are encoded, see\n                // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n\n                pes.pts = (packet[offset + 9] & 0x0E) << 27 | (packet[offset + 10] & 0xFF) << 20 | (packet[offset + 11] & 0xFE) << 12 | (packet[offset + 12] & 0xFF) << 5 | (packet[offset + 13] & 0xFE) >>> 3;\n                pes.pts *= 4; // Left shift by 2\n\n                pes.pts += (packet[offset + 13] & 0x06) >>> 1; // OR by the two LSBs\n\n                pes.dts = pes.pts;\n                if (ptsDtsFlags & 0x40) {\n                    pes.dts = (packet[offset + 14] & 0x0E) << 27 | (packet[offset + 15] & 0xFF) << 20 | (packet[offset + 16] & 0xFE) << 12 | (packet[offset + 17] & 0xFF) << 5 | (packet[offset + 18] & 0xFE) >>> 3;\n                    pes.dts *= 4; // Left shift by 2\n\n                    pes.dts += (packet[offset + 18] & 0x06) >>> 1; // OR by the two LSBs\n                }\n            }\n\n            return pes;\n        };\n        var parseNalUnitType = function (type) {\n            switch (type) {\n                case 0x05:\n                    return 'slice_layer_without_partitioning_rbsp_idr';\n                case 0x06:\n                    return 'sei_rbsp';\n                case 0x07:\n                    return 'seq_parameter_set_rbsp';\n                case 0x08:\n                    return 'pic_parameter_set_rbsp';\n                case 0x09:\n                    return 'access_unit_delimiter_rbsp';\n                default:\n                    return null;\n            }\n        };\n        var videoPacketContainsKeyFrame = function (packet) {\n            var offset = 4 + parseAdaptionField(packet);\n            var frameBuffer = packet.subarray(offset);\n            var frameI = 0;\n            var frameSyncPoint = 0;\n            var foundKeyFrame = false;\n            var nalType; // advance the sync point to a NAL start, if necessary\n\n            for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {\n                if (frameBuffer[frameSyncPoint + 2] === 1) {\n                    // the sync point is properly aligned\n                    frameI = frameSyncPoint + 5;\n                    break;\n                }\n            }\n            while (frameI < frameBuffer.byteLength) {\n                // look at the current byte to determine if we've hit the end of\n                // a NAL unit boundary\n                switch (frameBuffer[frameI]) {\n                    case 0:\n                        // skip past non-sync sequences\n                        if (frameBuffer[frameI - 1] !== 0) {\n                            frameI += 2;\n                            break;\n                        } else if (frameBuffer[frameI - 2] !== 0) {\n                            frameI++;\n                            break;\n                        }\n                        if (frameSyncPoint + 3 !== frameI - 2) {\n                            nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n                            if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n                                foundKeyFrame = true;\n                            }\n                        } // drop trailing zeroes\n\n                        do {\n                            frameI++;\n                        } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);\n                        frameSyncPoint = frameI - 2;\n                        frameI += 3;\n                        break;\n                    case 1:\n                        // skip past non-sync sequences\n                        if (frameBuffer[frameI - 1] !== 0 || frameBuffer[frameI - 2] !== 0) {\n                            frameI += 3;\n                            break;\n                        }\n                        nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n                        if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n                            foundKeyFrame = true;\n                        }\n                        frameSyncPoint = frameI - 2;\n                        frameI += 3;\n                        break;\n                    default:\n                        // the current byte isn't a one or zero, so it cannot be part\n                        // of a sync sequence\n                        frameI += 3;\n                        break;\n                }\n            }\n            frameBuffer = frameBuffer.subarray(frameSyncPoint);\n            frameI -= frameSyncPoint;\n            frameSyncPoint = 0; // parse the final nal\n\n            if (frameBuffer && frameBuffer.byteLength > 3) {\n                nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n                if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n                    foundKeyFrame = true;\n                }\n            }\n            return foundKeyFrame;\n        };\n        var probe$1 = {\n            parseType: parseType,\n            parsePat: parsePat,\n            parsePmt: parsePmt,\n            parsePayloadUnitStartIndicator: parsePayloadUnitStartIndicator,\n            parsePesType: parsePesType,\n            parsePesTime: parsePesTime,\n            videoPacketContainsKeyFrame: videoPacketContainsKeyFrame\n        };\n        /**\n         * mux.js\n         *\n         * Copyright (c) Brightcove\n         * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n         *\n         * Parse mpeg2 transport stream packets to extract basic timing information\n         */\n\n        var StreamTypes = streamTypes;\n        var handleRollover = timestampRolloverStream.handleRollover;\n        var probe = {};\n        probe.ts = probe$1;\n        probe.aac = utils;\n        var ONE_SECOND_IN_TS = clock$2.ONE_SECOND_IN_TS;\n        var MP2T_PACKET_LENGTH = 188,\n            // bytes\n            SYNC_BYTE = 0x47;\n        /**\n         * walks through segment data looking for pat and pmt packets to parse out\n         * program map table information\n         */\n\n        var parsePsi_ = function (bytes, pmt) {\n            var startIndex = 0,\n                endIndex = MP2T_PACKET_LENGTH,\n                packet,\n                type;\n            while (endIndex < bytes.byteLength) {\n                // Look for a pair of start and end sync bytes in the data..\n                if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n                    // We found a packet\n                    packet = bytes.subarray(startIndex, endIndex);\n                    type = probe.ts.parseType(packet, pmt.pid);\n                    switch (type) {\n                        case 'pat':\n                            pmt.pid = probe.ts.parsePat(packet);\n                            break;\n                        case 'pmt':\n                            var table = probe.ts.parsePmt(packet);\n                            pmt.table = pmt.table || {};\n                            Object.keys(table).forEach(function (key) {\n                                pmt.table[key] = table[key];\n                            });\n                            break;\n                    }\n                    startIndex += MP2T_PACKET_LENGTH;\n                    endIndex += MP2T_PACKET_LENGTH;\n                    continue;\n                } // If we get here, we have somehow become de-synchronized and we need to step\n                // forward one byte at a time until we find a pair of sync bytes that denote\n                // a packet\n\n                startIndex++;\n                endIndex++;\n            }\n        };\n        /**\n         * walks through the segment data from the start and end to get timing information\n         * for the first and last audio pes packets\n         */\n\n        var parseAudioPes_ = function (bytes, pmt, result) {\n            var startIndex = 0,\n                endIndex = MP2T_PACKET_LENGTH,\n                packet,\n                type,\n                pesType,\n                pusi,\n                parsed;\n            var endLoop = false; // Start walking from start of segment to get first audio packet\n\n            while (endIndex <= bytes.byteLength) {\n                // Look for a pair of start and end sync bytes in the data..\n                if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n                    // We found a packet\n                    packet = bytes.subarray(startIndex, endIndex);\n                    type = probe.ts.parseType(packet, pmt.pid);\n                    switch (type) {\n                        case 'pes':\n                            pesType = probe.ts.parsePesType(packet, pmt.table);\n                            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n                            if (pesType === 'audio' && pusi) {\n                                parsed = probe.ts.parsePesTime(packet);\n                                if (parsed) {\n                                    parsed.type = 'audio';\n                                    result.audio.push(parsed);\n                                    endLoop = true;\n                                }\n                            }\n                            break;\n                    }\n                    if (endLoop) {\n                        break;\n                    }\n                    startIndex += MP2T_PACKET_LENGTH;\n                    endIndex += MP2T_PACKET_LENGTH;\n                    continue;\n                } // If we get here, we have somehow become de-synchronized and we need to step\n                // forward one byte at a time until we find a pair of sync bytes that denote\n                // a packet\n\n                startIndex++;\n                endIndex++;\n            } // Start walking from end of segment to get last audio packet\n\n            endIndex = bytes.byteLength;\n            startIndex = endIndex - MP2T_PACKET_LENGTH;\n            endLoop = false;\n            while (startIndex >= 0) {\n                // Look for a pair of start and end sync bytes in the data..\n                if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n                    // We found a packet\n                    packet = bytes.subarray(startIndex, endIndex);\n                    type = probe.ts.parseType(packet, pmt.pid);\n                    switch (type) {\n                        case 'pes':\n                            pesType = probe.ts.parsePesType(packet, pmt.table);\n                            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n                            if (pesType === 'audio' && pusi) {\n                                parsed = probe.ts.parsePesTime(packet);\n                                if (parsed) {\n                                    parsed.type = 'audio';\n                                    result.audio.push(parsed);\n                                    endLoop = true;\n                                }\n                            }\n                            break;\n                    }\n                    if (endLoop) {\n                        break;\n                    }\n                    startIndex -= MP2T_PACKET_LENGTH;\n                    endIndex -= MP2T_PACKET_LENGTH;\n                    continue;\n                } // If we get here, we have somehow become de-synchronized and we need to step\n                // forward one byte at a time until we find a pair of sync bytes that denote\n                // a packet\n\n                startIndex--;\n                endIndex--;\n            }\n        };\n        /**\n         * walks through the segment data from the start and end to get timing information\n         * for the first and last video pes packets as well as timing information for the first\n         * key frame.\n         */\n\n        var parseVideoPes_ = function (bytes, pmt, result) {\n            var startIndex = 0,\n                endIndex = MP2T_PACKET_LENGTH,\n                packet,\n                type,\n                pesType,\n                pusi,\n                parsed,\n                frame,\n                i,\n                pes;\n            var endLoop = false;\n            var currentFrame = {\n                data: [],\n                size: 0\n            }; // Start walking from start of segment to get first video packet\n\n            while (endIndex < bytes.byteLength) {\n                // Look for a pair of start and end sync bytes in the data..\n                if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n                    // We found a packet\n                    packet = bytes.subarray(startIndex, endIndex);\n                    type = probe.ts.parseType(packet, pmt.pid);\n                    switch (type) {\n                        case 'pes':\n                            pesType = probe.ts.parsePesType(packet, pmt.table);\n                            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n                            if (pesType === 'video') {\n                                if (pusi && !endLoop) {\n                                    parsed = probe.ts.parsePesTime(packet);\n                                    if (parsed) {\n                                        parsed.type = 'video';\n                                        result.video.push(parsed);\n                                        endLoop = true;\n                                    }\n                                }\n                                if (!result.firstKeyFrame) {\n                                    if (pusi) {\n                                        if (currentFrame.size !== 0) {\n                                            frame = new Uint8Array(currentFrame.size);\n                                            i = 0;\n                                            while (currentFrame.data.length) {\n                                                pes = currentFrame.data.shift();\n                                                frame.set(pes, i);\n                                                i += pes.byteLength;\n                                            }\n                                            if (probe.ts.videoPacketContainsKeyFrame(frame)) {\n                                                var firstKeyFrame = probe.ts.parsePesTime(frame); // PTS/DTS may not be available. Simply *not* setting\n                                                // the keyframe seems to work fine with HLS playback\n                                                // and definitely preferable to a crash with TypeError...\n\n                                                if (firstKeyFrame) {\n                                                    result.firstKeyFrame = firstKeyFrame;\n                                                    result.firstKeyFrame.type = 'video';\n                                                } else {\n                                                    // eslint-disable-next-line\n                                                    console.warn('Failed to extract PTS/DTS from PES at first keyframe. ' + 'This could be an unusual TS segment, or else mux.js did not ' + 'parse your TS segment correctly. If you know your TS ' + 'segments do contain PTS/DTS on keyframes please file a bug ' + 'report! You can try ffprobe to double check for yourself.');\n                                                }\n                                            }\n                                            currentFrame.size = 0;\n                                        }\n                                    }\n                                    currentFrame.data.push(packet);\n                                    currentFrame.size += packet.byteLength;\n                                }\n                            }\n                            break;\n                    }\n                    if (endLoop && result.firstKeyFrame) {\n                        break;\n                    }\n                    startIndex += MP2T_PACKET_LENGTH;\n                    endIndex += MP2T_PACKET_LENGTH;\n                    continue;\n                } // If we get here, we have somehow become de-synchronized and we need to step\n                // forward one byte at a time until we find a pair of sync bytes that denote\n                // a packet\n\n                startIndex++;\n                endIndex++;\n            } // Start walking from end of segment to get last video packet\n\n            endIndex = bytes.byteLength;\n            startIndex = endIndex - MP2T_PACKET_LENGTH;\n            endLoop = false;\n            while (startIndex >= 0) {\n                // Look for a pair of start and end sync bytes in the data..\n                if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n                    // We found a packet\n                    packet = bytes.subarray(startIndex, endIndex);\n                    type = probe.ts.parseType(packet, pmt.pid);\n                    switch (type) {\n                        case 'pes':\n                            pesType = probe.ts.parsePesType(packet, pmt.table);\n                            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n                            if (pesType === 'video' && pusi) {\n                                parsed = probe.ts.parsePesTime(packet);\n                                if (parsed) {\n                                    parsed.type = 'video';\n                                    result.video.push(parsed);\n                                    endLoop = true;\n                                }\n                            }\n                            break;\n                    }\n                    if (endLoop) {\n                        break;\n                    }\n                    startIndex -= MP2T_PACKET_LENGTH;\n                    endIndex -= MP2T_PACKET_LENGTH;\n                    continue;\n                } // If we get here, we have somehow become de-synchronized and we need to step\n                // forward one byte at a time until we find a pair of sync bytes that denote\n                // a packet\n\n                startIndex--;\n                endIndex--;\n            }\n        };\n        /**\n         * Adjusts the timestamp information for the segment to account for\n         * rollover and convert to seconds based on pes packet timescale (90khz clock)\n         */\n\n        var adjustTimestamp_ = function (segmentInfo, baseTimestamp) {\n            if (segmentInfo.audio && segmentInfo.audio.length) {\n                var audioBaseTimestamp = baseTimestamp;\n                if (typeof audioBaseTimestamp === 'undefined' || isNaN(audioBaseTimestamp)) {\n                    audioBaseTimestamp = segmentInfo.audio[0].dts;\n                }\n                segmentInfo.audio.forEach(function (info) {\n                    info.dts = handleRollover(info.dts, audioBaseTimestamp);\n                    info.pts = handleRollover(info.pts, audioBaseTimestamp); // time in seconds\n\n                    info.dtsTime = info.dts / ONE_SECOND_IN_TS;\n                    info.ptsTime = info.pts / ONE_SECOND_IN_TS;\n                });\n            }\n            if (segmentInfo.video && segmentInfo.video.length) {\n                var videoBaseTimestamp = baseTimestamp;\n                if (typeof videoBaseTimestamp === 'undefined' || isNaN(videoBaseTimestamp)) {\n                    videoBaseTimestamp = segmentInfo.video[0].dts;\n                }\n                segmentInfo.video.forEach(function (info) {\n                    info.dts = handleRollover(info.dts, videoBaseTimestamp);\n                    info.pts = handleRollover(info.pts, videoBaseTimestamp); // time in seconds\n\n                    info.dtsTime = info.dts / ONE_SECOND_IN_TS;\n                    info.ptsTime = info.pts / ONE_SECOND_IN_TS;\n                });\n                if (segmentInfo.firstKeyFrame) {\n                    var frame = segmentInfo.firstKeyFrame;\n                    frame.dts = handleRollover(frame.dts, videoBaseTimestamp);\n                    frame.pts = handleRollover(frame.pts, videoBaseTimestamp); // time in seconds\n\n                    frame.dtsTime = frame.dts / ONE_SECOND_IN_TS;\n                    frame.ptsTime = frame.pts / ONE_SECOND_IN_TS;\n                }\n            }\n        };\n        /**\n         * inspects the aac data stream for start and end time information\n         */\n\n        var inspectAac_ = function (bytes) {\n            var endLoop = false,\n                audioCount = 0,\n                sampleRate = null,\n                timestamp = null,\n                frameSize = 0,\n                byteIndex = 0,\n                packet;\n            while (bytes.length - byteIndex >= 3) {\n                var type = probe.aac.parseType(bytes, byteIndex);\n                switch (type) {\n                    case 'timed-metadata':\n                        // Exit early because we don't have enough to parse\n                        // the ID3 tag header\n                        if (bytes.length - byteIndex < 10) {\n                            endLoop = true;\n                            break;\n                        }\n                        frameSize = probe.aac.parseId3TagSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\n                        // to emit a full packet\n\n                        if (frameSize > bytes.length) {\n                            endLoop = true;\n                            break;\n                        }\n                        if (timestamp === null) {\n                            packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n                            timestamp = probe.aac.parseAacTimestamp(packet);\n                        }\n                        byteIndex += frameSize;\n                        break;\n                    case 'audio':\n                        // Exit early because we don't have enough to parse\n                        // the ADTS frame header\n                        if (bytes.length - byteIndex < 7) {\n                            endLoop = true;\n                            break;\n                        }\n                        frameSize = probe.aac.parseAdtsSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\n                        // to emit a full packet\n\n                        if (frameSize > bytes.length) {\n                            endLoop = true;\n                            break;\n                        }\n                        if (sampleRate === null) {\n                            packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n                            sampleRate = probe.aac.parseSampleRate(packet);\n                        }\n                        audioCount++;\n                        byteIndex += frameSize;\n                        break;\n                    default:\n                        byteIndex++;\n                        break;\n                }\n                if (endLoop) {\n                    return null;\n                }\n            }\n            if (sampleRate === null || timestamp === null) {\n                return null;\n            }\n            var audioTimescale = ONE_SECOND_IN_TS / sampleRate;\n            var result = {\n                audio: [{\n                    type: 'audio',\n                    dts: timestamp,\n                    pts: timestamp\n                }, {\n                    type: 'audio',\n                    dts: timestamp + audioCount * 1024 * audioTimescale,\n                    pts: timestamp + audioCount * 1024 * audioTimescale\n                }]\n            };\n            return result;\n        };\n        /**\n         * inspects the transport stream segment data for start and end time information\n         * of the audio and video tracks (when present) as well as the first key frame's\n         * start time.\n         */\n\n        var inspectTs_ = function (bytes) {\n            var pmt = {\n                pid: null,\n                table: null\n            };\n            var result = {};\n            parsePsi_(bytes, pmt);\n            for (var pid in pmt.table) {\n                if (pmt.table.hasOwnProperty(pid)) {\n                    var type = pmt.table[pid];\n                    switch (type) {\n                        case StreamTypes.H264_STREAM_TYPE:\n                            result.video = [];\n                            parseVideoPes_(bytes, pmt, result);\n                            if (result.video.length === 0) {\n                                delete result.video;\n                            }\n                            break;\n                        case StreamTypes.ADTS_STREAM_TYPE:\n                            result.audio = [];\n                            parseAudioPes_(bytes, pmt, result);\n                            if (result.audio.length === 0) {\n                                delete result.audio;\n                            }\n                            break;\n                    }\n                }\n            }\n            return result;\n        };\n        /**\n         * Inspects segment byte data and returns an object with start and end timing information\n         *\n         * @param {Uint8Array} bytes The segment byte data\n         * @param {Number} baseTimestamp Relative reference timestamp used when adjusting frame\n         *  timestamps for rollover. This value must be in 90khz clock.\n         * @return {Object} Object containing start and end frame timing info of segment.\n         */\n\n        var inspect = function (bytes, baseTimestamp) {\n            var isAacData = probe.aac.isLikelyAacData(bytes);\n            var result;\n            if (isAacData) {\n                result = inspectAac_(bytes);\n            } else {\n                result = inspectTs_(bytes);\n            }\n            if (!result || !result.audio && !result.video) {\n                return null;\n            }\n            adjustTimestamp_(result, baseTimestamp);\n            return result;\n        };\n        var tsInspector = {\n            inspect: inspect,\n            parseAudioPes_: parseAudioPes_\n        };\n        /* global self */\n\n        /**\n         * Re-emits transmuxer events by converting them into messages to the\n         * world outside the worker.\n         *\n         * @param {Object} transmuxer the transmuxer to wire events on\n         * @private\n         */\n\n        const wireTransmuxerEvents = function (self, transmuxer) {\n            transmuxer.on('data', function (segment) {\n                // transfer ownership of the underlying ArrayBuffer\n                // instead of doing a copy to save memory\n                // ArrayBuffers are transferable but generic TypedArrays are not\n                // @link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers#Passing_data_by_transferring_ownership_(transferable_objects)\n                const initArray = segment.initSegment;\n                segment.initSegment = {\n                    data: initArray.buffer,\n                    byteOffset: initArray.byteOffset,\n                    byteLength: initArray.byteLength\n                };\n                const typedArray = segment.data;\n                segment.data = typedArray.buffer;\n                self.postMessage({\n                    action: 'data',\n                    segment,\n                    byteOffset: typedArray.byteOffset,\n                    byteLength: typedArray.byteLength\n                }, [segment.data]);\n            });\n            transmuxer.on('done', function (data) {\n                self.postMessage({\n                    action: 'done'\n                });\n            });\n            transmuxer.on('gopInfo', function (gopInfo) {\n                self.postMessage({\n                    action: 'gopInfo',\n                    gopInfo\n                });\n            });\n            transmuxer.on('videoSegmentTimingInfo', function (timingInfo) {\n                const videoSegmentTimingInfo = {\n                    start: {\n                        decode: clock$2.videoTsToSeconds(timingInfo.start.dts),\n                        presentation: clock$2.videoTsToSeconds(timingInfo.start.pts)\n                    },\n                    end: {\n                        decode: clock$2.videoTsToSeconds(timingInfo.end.dts),\n                        presentation: clock$2.videoTsToSeconds(timingInfo.end.pts)\n                    },\n                    baseMediaDecodeTime: clock$2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)\n                };\n                if (timingInfo.prependedContentDuration) {\n                    videoSegmentTimingInfo.prependedContentDuration = clock$2.videoTsToSeconds(timingInfo.prependedContentDuration);\n                }\n                self.postMessage({\n                    action: 'videoSegmentTimingInfo',\n                    videoSegmentTimingInfo\n                });\n            });\n            transmuxer.on('audioSegmentTimingInfo', function (timingInfo) {\n                // Note that all times for [audio/video]SegmentTimingInfo events are in video clock\n                const audioSegmentTimingInfo = {\n                    start: {\n                        decode: clock$2.videoTsToSeconds(timingInfo.start.dts),\n                        presentation: clock$2.videoTsToSeconds(timingInfo.start.pts)\n                    },\n                    end: {\n                        decode: clock$2.videoTsToSeconds(timingInfo.end.dts),\n                        presentation: clock$2.videoTsToSeconds(timingInfo.end.pts)\n                    },\n                    baseMediaDecodeTime: clock$2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)\n                };\n                if (timingInfo.prependedContentDuration) {\n                    audioSegmentTimingInfo.prependedContentDuration = clock$2.videoTsToSeconds(timingInfo.prependedContentDuration);\n                }\n                self.postMessage({\n                    action: 'audioSegmentTimingInfo',\n                    audioSegmentTimingInfo\n                });\n            });\n            transmuxer.on('id3Frame', function (id3Frame) {\n                self.postMessage({\n                    action: 'id3Frame',\n                    id3Frame\n                });\n            });\n            transmuxer.on('caption', function (caption) {\n                self.postMessage({\n                    action: 'caption',\n                    caption\n                });\n            });\n            transmuxer.on('trackinfo', function (trackInfo) {\n                self.postMessage({\n                    action: 'trackinfo',\n                    trackInfo\n                });\n            });\n            transmuxer.on('audioTimingInfo', function (audioTimingInfo) {\n                // convert to video TS since we prioritize video time over audio\n                self.postMessage({\n                    action: 'audioTimingInfo',\n                    audioTimingInfo: {\n                        start: clock$2.videoTsToSeconds(audioTimingInfo.start),\n                        end: clock$2.videoTsToSeconds(audioTimingInfo.end)\n                    }\n                });\n            });\n            transmuxer.on('videoTimingInfo', function (videoTimingInfo) {\n                self.postMessage({\n                    action: 'videoTimingInfo',\n                    videoTimingInfo: {\n                        start: clock$2.videoTsToSeconds(videoTimingInfo.start),\n                        end: clock$2.videoTsToSeconds(videoTimingInfo.end)\n                    }\n                });\n            });\n            transmuxer.on('log', function (log) {\n                self.postMessage({\n                    action: 'log',\n                    log\n                });\n            });\n        };\n        /**\n         * All incoming messages route through this hash. If no function exists\n         * to handle an incoming message, then we ignore the message.\n         *\n         * @class MessageHandlers\n         * @param {Object} options the options to initialize with\n         */\n\n        class MessageHandlers {\n            constructor(self, options) {\n                this.options = options || {};\n                this.self = self;\n                this.init();\n            }\n            /**\n             * initialize our web worker and wire all the events.\n             */\n\n            init() {\n                if (this.transmuxer) {\n                    this.transmuxer.dispose();\n                }\n                this.transmuxer = new transmuxer.Transmuxer(this.options);\n                wireTransmuxerEvents(this.self, this.transmuxer);\n            }\n            pushMp4Captions(data) {\n                if (!this.captionParser) {\n                    this.captionParser = new captionParser();\n                    this.captionParser.init();\n                }\n                const segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);\n                const parsed = this.captionParser.parse(segment, data.trackIds, data.timescales);\n                this.self.postMessage({\n                    action: 'mp4Captions',\n                    captions: parsed && parsed.captions || [],\n                    logs: parsed && parsed.logs || [],\n                    data: segment.buffer\n                }, [segment.buffer]);\n            }\n            probeMp4StartTime({\n                                  timescales,\n                                  data\n                              }) {\n                const startTime = probe$2.startTime(timescales, data);\n                this.self.postMessage({\n                    action: 'probeMp4StartTime',\n                    startTime,\n                    data\n                }, [data.buffer]);\n            }\n            probeMp4Tracks({\n                               data\n                           }) {\n                const tracks = probe$2.tracks(data);\n                this.self.postMessage({\n                    action: 'probeMp4Tracks',\n                    tracks,\n                    data\n                }, [data.buffer]);\n            }\n            /**\n             * Probe an mpeg2-ts segment to determine the start time of the segment in it's\n             * internal \"media time,\" as well as whether it contains video and/or audio.\n             *\n             * @private\n             * @param {Uint8Array} bytes - segment bytes\n             * @param {number} baseStartTime\n             *        Relative reference timestamp used when adjusting frame timestamps for rollover.\n             *        This value should be in seconds, as it's converted to a 90khz clock within the\n             *        function body.\n             * @return {Object} The start time of the current segment in \"media time\" as well as\n             *                  whether it contains video and/or audio\n             */\n\n            probeTs({\n                        data,\n                        baseStartTime\n                    }) {\n                const tsStartTime = typeof baseStartTime === 'number' && !isNaN(baseStartTime) ? baseStartTime * clock$2.ONE_SECOND_IN_TS : void 0;\n                const timeInfo = tsInspector.inspect(data, tsStartTime);\n                let result = null;\n                if (timeInfo) {\n                    result = {\n                        // each type's time info comes back as an array of 2 times, start and end\n                        hasVideo: timeInfo.video && timeInfo.video.length === 2 || false,\n                        hasAudio: timeInfo.audio && timeInfo.audio.length === 2 || false\n                    };\n                    if (result.hasVideo) {\n                        result.videoStart = timeInfo.video[0].ptsTime;\n                    }\n                    if (result.hasAudio) {\n                        result.audioStart = timeInfo.audio[0].ptsTime;\n                    }\n                }\n                this.self.postMessage({\n                    action: 'probeTs',\n                    result,\n                    data\n                }, [data.buffer]);\n            }\n            clearAllMp4Captions() {\n                if (this.captionParser) {\n                    this.captionParser.clearAllCaptions();\n                }\n            }\n            clearParsedMp4Captions() {\n                if (this.captionParser) {\n                    this.captionParser.clearParsedCaptions();\n                }\n            }\n            /**\n             * Adds data (a ts segment) to the start of the transmuxer pipeline for\n             * processing.\n             *\n             * @param {ArrayBuffer} data data to push into the muxer\n             */\n\n            push(data) {\n                // Cast array buffer to correct type for transmuxer\n                const segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);\n                this.transmuxer.push(segment);\n            }\n            /**\n             * Recreate the transmuxer so that the next segment added via `push`\n             * start with a fresh transmuxer.\n             */\n\n            reset() {\n                this.transmuxer.reset();\n            }\n            /**\n             * Set the value that will be used as the `baseMediaDecodeTime` time for the\n             * next segment pushed in. Subsequent segments will have their `baseMediaDecodeTime`\n             * set relative to the first based on the PTS values.\n             *\n             * @param {Object} data used to set the timestamp offset in the muxer\n             */\n\n            setTimestampOffset(data) {\n                const timestampOffset = data.timestampOffset || 0;\n                this.transmuxer.setBaseMediaDecodeTime(Math.round(clock$2.secondsToVideoTs(timestampOffset)));\n            }\n            setAudioAppendStart(data) {\n                this.transmuxer.setAudioAppendStart(Math.ceil(clock$2.secondsToVideoTs(data.appendStart)));\n            }\n            setRemux(data) {\n                this.transmuxer.setRemux(data.remux);\n            }\n            /**\n             * Forces the pipeline to finish processing the last segment and emit it's\n             * results.\n             *\n             * @param {Object} data event data, not really used\n             */\n\n            flush(data) {\n                this.transmuxer.flush(); // transmuxed done action is fired after both audio/video pipelines are flushed\n\n                self.postMessage({\n                    action: 'done',\n                    type: 'transmuxed'\n                });\n            }\n            endTimeline() {\n                this.transmuxer.endTimeline(); // transmuxed endedtimeline action is fired after both audio/video pipelines end their\n                // timelines\n\n                self.postMessage({\n                    action: 'endedtimeline',\n                    type: 'transmuxed'\n                });\n            }\n            alignGopsWith(data) {\n                this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());\n            }\n        }\n        /**\n         * Our web worker interface so that things can talk to mux.js\n         * that will be running in a web worker. the scope is passed to this by\n         * webworkify.\n         *\n         * @param {Object} self the scope for the web worker\n         */\n\n        self.onmessage = function (event) {\n            if (event.data.action === 'init' && event.data.options) {\n                this.messageHandlers = new MessageHandlers(self, event.data.options);\n                return;\n            }\n            if (!this.messageHandlers) {\n                this.messageHandlers = new MessageHandlers(self);\n            }\n            if (event.data && event.data.action && event.data.action !== 'init') {\n                if (this.messageHandlers[event.data.action]) {\n                    this.messageHandlers[event.data.action](event.data);\n                }\n            }\n        };\n    }));\n    var TransmuxWorker = factory(workerCode$1);\n    /* rollup-plugin-worker-factory end for worker!/Users/ddashkevich/projects/http-streaming/src/transmuxer-worker.js */\n\n    const handleData_ = (event, transmuxedData, callback) => {\n        const {\n            type,\n            initSegment,\n            captions,\n            captionStreams,\n            metadata,\n            videoFrameDtsTime,\n            videoFramePtsTime\n        } = event.data.segment;\n        transmuxedData.buffer.push({\n            captions,\n            captionStreams,\n            metadata\n        });\n        const boxes = event.data.segment.boxes || {\n            data: event.data.segment.data\n        };\n        const result = {\n            type,\n            // cast ArrayBuffer to TypedArray\n            data: new Uint8Array(boxes.data, boxes.data.byteOffset, boxes.data.byteLength),\n            initSegment: new Uint8Array(initSegment.data, initSegment.byteOffset, initSegment.byteLength)\n        };\n        if (typeof videoFrameDtsTime !== 'undefined') {\n            result.videoFrameDtsTime = videoFrameDtsTime;\n        }\n        if (typeof videoFramePtsTime !== 'undefined') {\n            result.videoFramePtsTime = videoFramePtsTime;\n        }\n        callback(result);\n    };\n    const handleDone_ = ({\n                             transmuxedData,\n                             callback\n                         }) => {\n        // Previously we only returned data on data events,\n        // not on done events. Clear out the buffer to keep that consistent.\n        transmuxedData.buffer = []; // all buffers should have been flushed from the muxer, so start processing anything we\n        // have received\n\n        callback(transmuxedData);\n    };\n    const handleGopInfo_ = (event, transmuxedData) => {\n        transmuxedData.gopInfo = event.data.gopInfo;\n    };\n    const processTransmux = options => {\n        const {\n            transmuxer,\n            bytes,\n            audioAppendStart,\n            gopsToAlignWith,\n            remux,\n            onData,\n            onTrackInfo,\n            onAudioTimingInfo,\n            onVideoTimingInfo,\n            onVideoSegmentTimingInfo,\n            onAudioSegmentTimingInfo,\n            onId3,\n            onCaptions,\n            onDone,\n            onEndedTimeline,\n            onTransmuxerLog,\n            isEndOfTimeline\n        } = options;\n        const transmuxedData = {\n            buffer: []\n        };\n        let waitForEndedTimelineEvent = isEndOfTimeline;\n        const handleMessage = event => {\n            if (transmuxer.currentTransmux !== options) {\n                // disposed\n                return;\n            }\n            if (event.data.action === 'data') {\n                handleData_(event, transmuxedData, onData);\n            }\n            if (event.data.action === 'trackinfo') {\n                onTrackInfo(event.data.trackInfo);\n            }\n            if (event.data.action === 'gopInfo') {\n                handleGopInfo_(event, transmuxedData);\n            }\n            if (event.data.action === 'audioTimingInfo') {\n                onAudioTimingInfo(event.data.audioTimingInfo);\n            }\n            if (event.data.action === 'videoTimingInfo') {\n                onVideoTimingInfo(event.data.videoTimingInfo);\n            }\n            if (event.data.action === 'videoSegmentTimingInfo') {\n                onVideoSegmentTimingInfo(event.data.videoSegmentTimingInfo);\n            }\n            if (event.data.action === 'audioSegmentTimingInfo') {\n                onAudioSegmentTimingInfo(event.data.audioSegmentTimingInfo);\n            }\n            if (event.data.action === 'id3Frame') {\n                onId3([event.data.id3Frame], event.data.id3Frame.dispatchType);\n            }\n            if (event.data.action === 'caption') {\n                onCaptions(event.data.caption);\n            }\n            if (event.data.action === 'endedtimeline') {\n                waitForEndedTimelineEvent = false;\n                onEndedTimeline();\n            }\n            if (event.data.action === 'log') {\n                onTransmuxerLog(event.data.log);\n            } // wait for the transmuxed event since we may have audio and video\n\n            if (event.data.type !== 'transmuxed') {\n                return;\n            } // If the \"endedtimeline\" event has not yet fired, and this segment represents the end\n            // of a timeline, that means there may still be data events before the segment\n            // processing can be considerred complete. In that case, the final event should be\n            // an \"endedtimeline\" event with the type \"transmuxed.\"\n\n            if (waitForEndedTimelineEvent) {\n                return;\n            }\n            transmuxer.onmessage = null;\n            handleDone_({\n                transmuxedData,\n                callback: onDone\n            });\n            /* eslint-disable no-use-before-define */\n\n            dequeue(transmuxer);\n            /* eslint-enable */\n        };\n\n        transmuxer.onmessage = handleMessage;\n        if (audioAppendStart) {\n            transmuxer.postMessage({\n                action: 'setAudioAppendStart',\n                appendStart: audioAppendStart\n            });\n        } // allow empty arrays to be passed to clear out GOPs\n\n        if (Array.isArray(gopsToAlignWith)) {\n            transmuxer.postMessage({\n                action: 'alignGopsWith',\n                gopsToAlignWith\n            });\n        }\n        if (typeof remux !== 'undefined') {\n            transmuxer.postMessage({\n                action: 'setRemux',\n                remux\n            });\n        }\n        if (bytes.byteLength) {\n            const buffer = bytes instanceof ArrayBuffer ? bytes : bytes.buffer;\n            const byteOffset = bytes instanceof ArrayBuffer ? 0 : bytes.byteOffset;\n            transmuxer.postMessage({\n                action: 'push',\n                // Send the typed-array of data as an ArrayBuffer so that\n                // it can be sent as a \"Transferable\" and avoid the costly\n                // memory copy\n                data: buffer,\n                // To recreate the original typed-array, we need information\n                // about what portion of the ArrayBuffer it was a view into\n                byteOffset,\n                byteLength: bytes.byteLength\n            }, [buffer]);\n        }\n        if (isEndOfTimeline) {\n            transmuxer.postMessage({\n                action: 'endTimeline'\n            });\n        } // even if we didn't push any bytes, we have to make sure we flush in case we reached\n        // the end of the segment\n\n        transmuxer.postMessage({\n            action: 'flush'\n        });\n    };\n    const dequeue = transmuxer => {\n        transmuxer.currentTransmux = null;\n        if (transmuxer.transmuxQueue.length) {\n            transmuxer.currentTransmux = transmuxer.transmuxQueue.shift();\n            if (typeof transmuxer.currentTransmux === 'function') {\n                transmuxer.currentTransmux();\n            } else {\n                processTransmux(transmuxer.currentTransmux);\n            }\n        }\n    };\n    const processAction = (transmuxer, action) => {\n        transmuxer.postMessage({\n            action\n        });\n        dequeue(transmuxer);\n    };\n    const enqueueAction = (action, transmuxer) => {\n        if (!transmuxer.currentTransmux) {\n            transmuxer.currentTransmux = action;\n            processAction(transmuxer, action);\n            return;\n        }\n        transmuxer.transmuxQueue.push(processAction.bind(null, transmuxer, action));\n    };\n    const reset = transmuxer => {\n        enqueueAction('reset', transmuxer);\n    };\n    const endTimeline = transmuxer => {\n        enqueueAction('endTimeline', transmuxer);\n    };\n    const transmux = options => {\n        if (!options.transmuxer.currentTransmux) {\n            options.transmuxer.currentTransmux = options;\n            processTransmux(options);\n            return;\n        }\n        options.transmuxer.transmuxQueue.push(options);\n    };\n    const createTransmuxer = options => {\n        const transmuxer = new TransmuxWorker();\n        transmuxer.currentTransmux = null;\n        transmuxer.transmuxQueue = [];\n        const term = transmuxer.terminate;\n        transmuxer.terminate = () => {\n            transmuxer.currentTransmux = null;\n            transmuxer.transmuxQueue.length = 0;\n            return term.call(transmuxer);\n        };\n        transmuxer.postMessage({\n            action: 'init',\n            options\n        });\n        return transmuxer;\n    };\n    var segmentTransmuxer = {\n        reset,\n        endTimeline,\n        transmux,\n        createTransmuxer\n    };\n    const workerCallback = function (options) {\n        const transmuxer = options.transmuxer;\n        const endAction = options.endAction || options.action;\n        const callback = options.callback;\n        const message = _extends$1({}, options, {\n            endAction: null,\n            transmuxer: null,\n            callback: null\n        });\n        const listenForEndEvent = event => {\n            if (event.data.action !== endAction) {\n                return;\n            }\n            transmuxer.removeEventListener('message', listenForEndEvent); // transfer ownership of bytes back to us.\n\n            if (event.data.data) {\n                event.data.data = new Uint8Array(event.data.data, options.byteOffset || 0, options.byteLength || event.data.data.byteLength);\n                if (options.data) {\n                    options.data = event.data.data;\n                }\n            }\n            callback(event.data);\n        };\n        transmuxer.addEventListener('message', listenForEndEvent);\n        if (options.data) {\n            const isArrayBuffer = options.data instanceof ArrayBuffer;\n            message.byteOffset = isArrayBuffer ? 0 : options.data.byteOffset;\n            message.byteLength = options.data.byteLength;\n            const transfers = [isArrayBuffer ? options.data : options.data.buffer];\n            transmuxer.postMessage(message, transfers);\n        } else {\n            transmuxer.postMessage(message);\n        }\n    };\n    const REQUEST_ERRORS = {\n        FAILURE: 2,\n        TIMEOUT: -101,\n        ABORTED: -102\n    };\n    /**\n     * Abort all requests\n     *\n     * @param {Object} activeXhrs - an object that tracks all XHR requests\n     */\n\n    const abortAll = activeXhrs => {\n        activeXhrs.forEach(xhr => {\n            xhr.abort();\n        });\n    };\n    /**\n     * Gather important bandwidth stats once a request has completed\n     *\n     * @param {Object} request - the XHR request from which to gather stats\n     */\n\n    const getRequestStats = request => {\n        return {\n            bandwidth: request.bandwidth,\n            bytesReceived: request.bytesReceived || 0,\n            roundTripTime: request.roundTripTime || 0\n        };\n    };\n    /**\n     * If possible gather bandwidth stats as a request is in\n     * progress\n     *\n     * @param {Event} progressEvent - an event object from an XHR's progress event\n     */\n\n    const getProgressStats = progressEvent => {\n        const request = progressEvent.target;\n        const roundTripTime = Date.now() - request.requestTime;\n        const stats = {\n            bandwidth: Infinity,\n            bytesReceived: 0,\n            roundTripTime: roundTripTime || 0\n        };\n        stats.bytesReceived = progressEvent.loaded; // This can result in Infinity if stats.roundTripTime is 0 but that is ok\n        // because we should only use bandwidth stats on progress to determine when\n        // abort a request early due to insufficient bandwidth\n\n        stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1000);\n        return stats;\n    };\n    /**\n     * Handle all error conditions in one place and return an object\n     * with all the information\n     *\n     * @param {Error|null} error - if non-null signals an error occured with the XHR\n     * @param {Object} request -  the XHR request that possibly generated the error\n     */\n\n    const handleErrors = (error, request) => {\n        if (request.timedout) {\n            return {\n                status: request.status,\n                message: 'HLS request timed-out at URL: ' + request.uri,\n                code: REQUEST_ERRORS.TIMEOUT,\n                xhr: request\n            };\n        }\n        if (request.aborted) {\n            return {\n                status: request.status,\n                message: 'HLS request aborted at URL: ' + request.uri,\n                code: REQUEST_ERRORS.ABORTED,\n                xhr: request\n            };\n        }\n        if (error) {\n            return {\n                status: request.status,\n                message: 'HLS request errored at URL: ' + request.uri,\n                code: REQUEST_ERRORS.FAILURE,\n                xhr: request\n            };\n        }\n        if (request.responseType === 'arraybuffer' && request.response.byteLength === 0) {\n            return {\n                status: request.status,\n                message: 'Empty HLS response at URL: ' + request.uri,\n                code: REQUEST_ERRORS.FAILURE,\n                xhr: request\n            };\n        }\n        return null;\n    };\n    /**\n     * Handle responses for key data and convert the key data to the correct format\n     * for the decryption step later\n     *\n     * @param {Object} segment - a simplified copy of the segmentInfo object\n     *                           from SegmentLoader\n     * @param {Array} objects - objects to add the key bytes to.\n     * @param {Function} finishProcessingFn - a callback to execute to continue processing\n     *                                        this request\n     */\n\n    const handleKeyResponse = (segment, objects, finishProcessingFn) => (error, request) => {\n        const response = request.response;\n        const errorObj = handleErrors(error, request);\n        if (errorObj) {\n            return finishProcessingFn(errorObj, segment);\n        }\n        if (response.byteLength !== 16) {\n            return finishProcessingFn({\n                status: request.status,\n                message: 'Invalid HLS key at URL: ' + request.uri,\n                code: REQUEST_ERRORS.FAILURE,\n                xhr: request\n            }, segment);\n        }\n        const view = new DataView(response);\n        const bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);\n        for (let i = 0; i < objects.length; i++) {\n            objects[i].bytes = bytes;\n        }\n        return finishProcessingFn(null, segment);\n    };\n    const parseInitSegment = (segment, callback) => {\n        const type = detectContainerForBytes(segment.map.bytes); // TODO: We should also handle ts init segments here, but we\n        // only know how to parse mp4 init segments at the moment\n\n        if (type !== 'mp4') {\n            const uri = segment.map.resolvedUri || segment.map.uri;\n            return callback({\n                internal: true,\n                message: `Found unsupported ${type || 'unknown'} container for initialization segment at URL: ${uri}`,\n                code: REQUEST_ERRORS.FAILURE\n            });\n        }\n        workerCallback({\n            action: 'probeMp4Tracks',\n            data: segment.map.bytes,\n            transmuxer: segment.transmuxer,\n            callback: ({\n                           tracks,\n                           data\n                       }) => {\n                // transfer bytes back to us\n                segment.map.bytes = data;\n                tracks.forEach(function (track) {\n                    segment.map.tracks = segment.map.tracks || {}; // only support one track of each type for now\n\n                    if (segment.map.tracks[track.type]) {\n                        return;\n                    }\n                    segment.map.tracks[track.type] = track;\n                    if (typeof track.id === 'number' && track.timescale) {\n                        segment.map.timescales = segment.map.timescales || {};\n                        segment.map.timescales[track.id] = track.timescale;\n                    }\n                });\n                return callback(null);\n            }\n        });\n    };\n    /**\n     * Handle init-segment responses\n     *\n     * @param {Object} segment - a simplified copy of the segmentInfo object\n     *                           from SegmentLoader\n     * @param {Function} finishProcessingFn - a callback to execute to continue processing\n     *                                        this request\n     */\n\n    const handleInitSegmentResponse = ({\n                                           segment,\n                                           finishProcessingFn\n                                       }) => (error, request) => {\n        const errorObj = handleErrors(error, request);\n        if (errorObj) {\n            return finishProcessingFn(errorObj, segment);\n        }\n        const bytes = new Uint8Array(request.response); // init segment is encypted, we will have to wait\n        // until the key request is done to decrypt.\n\n        if (segment.map.key) {\n            segment.map.encryptedBytes = bytes;\n            return finishProcessingFn(null, segment);\n        }\n        segment.map.bytes = bytes;\n        parseInitSegment(segment, function (parseError) {\n            if (parseError) {\n                parseError.xhr = request;\n                parseError.status = request.status;\n                return finishProcessingFn(parseError, segment);\n            }\n            finishProcessingFn(null, segment);\n        });\n    };\n    /**\n     * Response handler for segment-requests being sure to set the correct\n     * property depending on whether the segment is encryped or not\n     * Also records and keeps track of stats that are used for ABR purposes\n     *\n     * @param {Object} segment - a simplified copy of the segmentInfo object\n     *                           from SegmentLoader\n     * @param {Function} finishProcessingFn - a callback to execute to continue processing\n     *                                        this request\n     */\n\n    const handleSegmentResponse = ({\n                                       segment,\n                                       finishProcessingFn,\n                                       responseType\n                                   }) => (error, request) => {\n        const errorObj = handleErrors(error, request);\n        if (errorObj) {\n            return finishProcessingFn(errorObj, segment);\n        }\n        const newBytes =\n            // although responseText \"should\" exist, this guard serves to prevent an error being\n            // thrown for two primary cases:\n            // 1. the mime type override stops working, or is not implemented for a specific\n            //    browser\n            // 2. when using mock XHR libraries like sinon that do not allow the override behavior\n            responseType === 'arraybuffer' || !request.responseText ? request.response : stringToArrayBuffer(request.responseText.substring(segment.lastReachedChar || 0));\n        segment.stats = getRequestStats(request);\n        if (segment.key) {\n            segment.encryptedBytes = new Uint8Array(newBytes);\n        } else {\n            segment.bytes = new Uint8Array(newBytes);\n        }\n        return finishProcessingFn(null, segment);\n    };\n    const transmuxAndNotify = ({\n                                   segment,\n                                   bytes,\n                                   trackInfoFn,\n                                   timingInfoFn,\n                                   videoSegmentTimingInfoFn,\n                                   audioSegmentTimingInfoFn,\n                                   id3Fn,\n                                   captionsFn,\n                                   isEndOfTimeline,\n                                   endedTimelineFn,\n                                   dataFn,\n                                   doneFn,\n                                   onTransmuxerLog\n                               }) => {\n        const fmp4Tracks = segment.map && segment.map.tracks || {};\n        const isMuxed = Boolean(fmp4Tracks.audio && fmp4Tracks.video); // Keep references to each function so we can null them out after we're done with them.\n        // One reason for this is that in the case of full segments, we want to trust start\n        // times from the probe, rather than the transmuxer.\n\n        let audioStartFn = timingInfoFn.bind(null, segment, 'audio', 'start');\n        const audioEndFn = timingInfoFn.bind(null, segment, 'audio', 'end');\n        let videoStartFn = timingInfoFn.bind(null, segment, 'video', 'start');\n        const videoEndFn = timingInfoFn.bind(null, segment, 'video', 'end');\n        const finish = () => transmux({\n            bytes,\n            transmuxer: segment.transmuxer,\n            audioAppendStart: segment.audioAppendStart,\n            gopsToAlignWith: segment.gopsToAlignWith,\n            remux: isMuxed,\n            onData: result => {\n                result.type = result.type === 'combined' ? 'video' : result.type;\n                dataFn(segment, result);\n            },\n            onTrackInfo: trackInfo => {\n                if (trackInfoFn) {\n                    if (isMuxed) {\n                        trackInfo.isMuxed = true;\n                    }\n                    trackInfoFn(segment, trackInfo);\n                }\n            },\n            onAudioTimingInfo: audioTimingInfo => {\n                // we only want the first start value we encounter\n                if (audioStartFn && typeof audioTimingInfo.start !== 'undefined') {\n                    audioStartFn(audioTimingInfo.start);\n                    audioStartFn = null;\n                } // we want to continually update the end time\n\n                if (audioEndFn && typeof audioTimingInfo.end !== 'undefined') {\n                    audioEndFn(audioTimingInfo.end);\n                }\n            },\n            onVideoTimingInfo: videoTimingInfo => {\n                // we only want the first start value we encounter\n                if (videoStartFn && typeof videoTimingInfo.start !== 'undefined') {\n                    videoStartFn(videoTimingInfo.start);\n                    videoStartFn = null;\n                } // we want to continually update the end time\n\n                if (videoEndFn && typeof videoTimingInfo.end !== 'undefined') {\n                    videoEndFn(videoTimingInfo.end);\n                }\n            },\n            onVideoSegmentTimingInfo: videoSegmentTimingInfo => {\n                videoSegmentTimingInfoFn(videoSegmentTimingInfo);\n            },\n            onAudioSegmentTimingInfo: audioSegmentTimingInfo => {\n                audioSegmentTimingInfoFn(audioSegmentTimingInfo);\n            },\n            onId3: (id3Frames, dispatchType) => {\n                id3Fn(segment, id3Frames, dispatchType);\n            },\n            onCaptions: captions => {\n                captionsFn(segment, [captions]);\n            },\n            isEndOfTimeline,\n            onEndedTimeline: () => {\n                endedTimelineFn();\n            },\n            onTransmuxerLog,\n            onDone: result => {\n                if (!doneFn) {\n                    return;\n                }\n                result.type = result.type === 'combined' ? 'video' : result.type;\n                doneFn(null, segment, result);\n            }\n        }); // In the transmuxer, we don't yet have the ability to extract a \"proper\" start time.\n        // Meaning cached frame data may corrupt our notion of where this segment\n        // really starts. To get around this, probe for the info needed.\n\n        workerCallback({\n            action: 'probeTs',\n            transmuxer: segment.transmuxer,\n            data: bytes,\n            baseStartTime: segment.baseStartTime,\n            callback: data => {\n                segment.bytes = bytes = data.data;\n                const probeResult = data.result;\n                if (probeResult) {\n                    trackInfoFn(segment, {\n                        hasAudio: probeResult.hasAudio,\n                        hasVideo: probeResult.hasVideo,\n                        isMuxed\n                    });\n                    trackInfoFn = null;\n                    if (probeResult.hasAudio && !isMuxed) {\n                        audioStartFn(probeResult.audioStart);\n                    }\n                    if (probeResult.hasVideo) {\n                        videoStartFn(probeResult.videoStart);\n                    }\n                    audioStartFn = null;\n                    videoStartFn = null;\n                }\n                finish();\n            }\n        });\n    };\n    const handleSegmentBytes = ({\n                                    segment,\n                                    bytes,\n                                    trackInfoFn,\n                                    timingInfoFn,\n                                    videoSegmentTimingInfoFn,\n                                    audioSegmentTimingInfoFn,\n                                    id3Fn,\n                                    captionsFn,\n                                    isEndOfTimeline,\n                                    endedTimelineFn,\n                                    dataFn,\n                                    doneFn,\n                                    onTransmuxerLog\n                                }) => {\n        let bytesAsUint8Array = new Uint8Array(bytes); // TODO:\n        // We should have a handler that fetches the number of bytes required\n        // to check if something is fmp4. This will allow us to save bandwidth\n        // because we can only exclude a playlist and abort requests\n        // by codec after trackinfo triggers.\n\n        if (isLikelyFmp4MediaSegment(bytesAsUint8Array)) {\n            segment.isFmp4 = true;\n            const {\n                tracks\n            } = segment.map;\n            const trackInfo = {\n                isFmp4: true,\n                hasVideo: !!tracks.video,\n                hasAudio: !!tracks.audio\n            }; // if we have a audio track, with a codec that is not set to\n            // encrypted audio\n\n            if (tracks.audio && tracks.audio.codec && tracks.audio.codec !== 'enca') {\n                trackInfo.audioCodec = tracks.audio.codec;\n            } // if we have a video track, with a codec that is not set to\n            // encrypted video\n\n            if (tracks.video && tracks.video.codec && tracks.video.codec !== 'encv') {\n                trackInfo.videoCodec = tracks.video.codec;\n            }\n            if (tracks.video && tracks.audio) {\n                trackInfo.isMuxed = true;\n            } // since we don't support appending fmp4 data on progress, we know we have the full\n            // segment here\n\n            trackInfoFn(segment, trackInfo); // The probe doesn't provide the segment end time, so only callback with the start\n            // time. The end time can be roughly calculated by the receiver using the duration.\n            //\n            // Note that the start time returned by the probe reflects the baseMediaDecodeTime, as\n            // that is the true start of the segment (where the playback engine should begin\n            // decoding).\n\n            const finishLoading = captions => {\n                // if the track still has audio at this point it is only possible\n                // for it to be audio only. See `tracks.video && tracks.audio` if statement\n                // above.\n                // we make sure to use segment.bytes here as that\n                dataFn(segment, {\n                    data: bytesAsUint8Array,\n                    type: trackInfo.hasAudio && !trackInfo.isMuxed ? 'audio' : 'video'\n                });\n                if (captions && captions.length) {\n                    captionsFn(segment, captions);\n                }\n                doneFn(null, segment, {});\n            };\n            workerCallback({\n                action: 'probeMp4StartTime',\n                timescales: segment.map.timescales,\n                data: bytesAsUint8Array,\n                transmuxer: segment.transmuxer,\n                callback: ({\n                               data,\n                               startTime\n                           }) => {\n                    // transfer bytes back to us\n                    bytes = data.buffer;\n                    segment.bytes = bytesAsUint8Array = data;\n                    if (trackInfo.hasAudio && !trackInfo.isMuxed) {\n                        timingInfoFn(segment, 'audio', 'start', startTime);\n                    }\n                    if (trackInfo.hasVideo) {\n                        timingInfoFn(segment, 'video', 'start', startTime);\n                    } // Run through the CaptionParser in case there are captions.\n                    // Initialize CaptionParser if it hasn't been yet\n\n                    if (!tracks.video || !data.byteLength || !segment.transmuxer) {\n                        finishLoading();\n                        return;\n                    }\n                    workerCallback({\n                        action: 'pushMp4Captions',\n                        endAction: 'mp4Captions',\n                        transmuxer: segment.transmuxer,\n                        data: bytesAsUint8Array,\n                        timescales: segment.map.timescales,\n                        trackIds: [tracks.video.id],\n                        callback: message => {\n                            // transfer bytes back to us\n                            bytes = message.data.buffer;\n                            segment.bytes = bytesAsUint8Array = message.data;\n                            message.logs.forEach(function (log) {\n                                onTransmuxerLog(merge(log, {\n                                    stream: 'mp4CaptionParser'\n                                }));\n                            });\n                            finishLoading(message.captions);\n                        }\n                    });\n                }\n            });\n            return;\n        } // VTT or other segments that don't need processing\n\n        if (!segment.transmuxer) {\n            doneFn(null, segment, {});\n            return;\n        }\n        if (typeof segment.container === 'undefined') {\n            segment.container = detectContainerForBytes(bytesAsUint8Array);\n        }\n        if (segment.container !== 'ts' && segment.container !== 'aac') {\n            trackInfoFn(segment, {\n                hasAudio: false,\n                hasVideo: false\n            });\n            doneFn(null, segment, {});\n            return;\n        } // ts or aac\n\n        transmuxAndNotify({\n            segment,\n            bytes,\n            trackInfoFn,\n            timingInfoFn,\n            videoSegmentTimingInfoFn,\n            audioSegmentTimingInfoFn,\n            id3Fn,\n            captionsFn,\n            isEndOfTimeline,\n            endedTimelineFn,\n            dataFn,\n            doneFn,\n            onTransmuxerLog\n        });\n    };\n    const decrypt = function ({\n                                  id,\n                                  key,\n                                  encryptedBytes,\n                                  decryptionWorker\n                              }, callback) {\n        const decryptionHandler = event => {\n            if (event.data.source === id) {\n                decryptionWorker.removeEventListener('message', decryptionHandler);\n                const decrypted = event.data.decrypted;\n                callback(new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength));\n            }\n        };\n        decryptionWorker.addEventListener('message', decryptionHandler);\n        let keyBytes;\n        if (key.bytes.slice) {\n            keyBytes = key.bytes.slice();\n        } else {\n            keyBytes = new Uint32Array(Array.prototype.slice.call(key.bytes));\n        } // incrementally decrypt the bytes\n\n        decryptionWorker.postMessage(createTransferableMessage({\n            source: id,\n            encrypted: encryptedBytes,\n            key: keyBytes,\n            iv: key.iv\n        }), [encryptedBytes.buffer, keyBytes.buffer]);\n    };\n    /**\n     * Decrypt the segment via the decryption web worker\n     *\n     * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128 decryption\n     *                                       routines\n     * @param {Object} segment - a simplified copy of the segmentInfo object\n     *                           from SegmentLoader\n     * @param {Function} trackInfoFn - a callback that receives track info\n     * @param {Function} timingInfoFn - a callback that receives timing info\n     * @param {Function} videoSegmentTimingInfoFn\n     *                   a callback that receives video timing info based on media times and\n     *                   any adjustments made by the transmuxer\n     * @param {Function} audioSegmentTimingInfoFn\n     *                   a callback that receives audio timing info based on media times and\n     *                   any adjustments made by the transmuxer\n     * @param {boolean}  isEndOfTimeline\n     *                   true if this segment represents the last segment in a timeline\n     * @param {Function} endedTimelineFn\n     *                   a callback made when a timeline is ended, will only be called if\n     *                   isEndOfTimeline is true\n     * @param {Function} dataFn - a callback that is executed when segment bytes are available\n     *                            and ready to use\n     * @param {Function} doneFn - a callback that is executed after decryption has completed\n     */\n\n    const decryptSegment = ({\n                                decryptionWorker,\n                                segment,\n                                trackInfoFn,\n                                timingInfoFn,\n                                videoSegmentTimingInfoFn,\n                                audioSegmentTimingInfoFn,\n                                id3Fn,\n                                captionsFn,\n                                isEndOfTimeline,\n                                endedTimelineFn,\n                                dataFn,\n                                doneFn,\n                                onTransmuxerLog\n                            }) => {\n        decrypt({\n            id: segment.requestId,\n            key: segment.key,\n            encryptedBytes: segment.encryptedBytes,\n            decryptionWorker\n        }, decryptedBytes => {\n            segment.bytes = decryptedBytes;\n            handleSegmentBytes({\n                segment,\n                bytes: segment.bytes,\n                trackInfoFn,\n                timingInfoFn,\n                videoSegmentTimingInfoFn,\n                audioSegmentTimingInfoFn,\n                id3Fn,\n                captionsFn,\n                isEndOfTimeline,\n                endedTimelineFn,\n                dataFn,\n                doneFn,\n                onTransmuxerLog\n            });\n        });\n    };\n    /**\n     * This function waits for all XHRs to finish (with either success or failure)\n     * before continueing processing via it's callback. The function gathers errors\n     * from each request into a single errors array so that the error status for\n     * each request can be examined later.\n     *\n     * @param {Object} activeXhrs - an object that tracks all XHR requests\n     * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128 decryption\n     *                                       routines\n     * @param {Function} trackInfoFn - a callback that receives track info\n     * @param {Function} timingInfoFn - a callback that receives timing info\n     * @param {Function} videoSegmentTimingInfoFn\n     *                   a callback that receives video timing info based on media times and\n     *                   any adjustments made by the transmuxer\n     * @param {Function} audioSegmentTimingInfoFn\n     *                   a callback that receives audio timing info based on media times and\n     *                   any adjustments made by the transmuxer\n     * @param {Function} id3Fn - a callback that receives ID3 metadata\n     * @param {Function} captionsFn - a callback that receives captions\n     * @param {boolean}  isEndOfTimeline\n     *                   true if this segment represents the last segment in a timeline\n     * @param {Function} endedTimelineFn\n     *                   a callback made when a timeline is ended, will only be called if\n     *                   isEndOfTimeline is true\n     * @param {Function} dataFn - a callback that is executed when segment bytes are available\n     *                            and ready to use\n     * @param {Function} doneFn - a callback that is executed after all resources have been\n     *                            downloaded and any decryption completed\n     */\n\n    const waitForCompletion = ({\n                                   activeXhrs,\n                                   decryptionWorker,\n                                   trackInfoFn,\n                                   timingInfoFn,\n                                   videoSegmentTimingInfoFn,\n                                   audioSegmentTimingInfoFn,\n                                   id3Fn,\n                                   captionsFn,\n                                   isEndOfTimeline,\n                                   endedTimelineFn,\n                                   dataFn,\n                                   doneFn,\n                                   onTransmuxerLog\n                               }) => {\n        let count = 0;\n        let didError = false;\n        return (error, segment) => {\n            if (didError) {\n                return;\n            }\n            if (error) {\n                didError = true; // If there are errors, we have to abort any outstanding requests\n\n                abortAll(activeXhrs); // Even though the requests above are aborted, and in theory we could wait until we\n                // handle the aborted events from those requests, there are some cases where we may\n                // never get an aborted event. For instance, if the network connection is lost and\n                // there were two requests, the first may have triggered an error immediately, while\n                // the second request remains unsent. In that case, the aborted algorithm will not\n                // trigger an abort: see https://xhr.spec.whatwg.org/#the-abort()-method\n                //\n                // We also can't rely on the ready state of the XHR, since the request that\n                // triggered the connection error may also show as a ready state of 0 (unsent).\n                // Therefore, we have to finish this group of requests immediately after the first\n                // seen error.\n\n                return doneFn(error, segment);\n            }\n            count += 1;\n            if (count === activeXhrs.length) {\n                const segmentFinish = function () {\n                    if (segment.encryptedBytes) {\n                        return decryptSegment({\n                            decryptionWorker,\n                            segment,\n                            trackInfoFn,\n                            timingInfoFn,\n                            videoSegmentTimingInfoFn,\n                            audioSegmentTimingInfoFn,\n                            id3Fn,\n                            captionsFn,\n                            isEndOfTimeline,\n                            endedTimelineFn,\n                            dataFn,\n                            doneFn,\n                            onTransmuxerLog\n                        });\n                    } // Otherwise, everything is ready just continue\n\n                    handleSegmentBytes({\n                        segment,\n                        bytes: segment.bytes,\n                        trackInfoFn,\n                        timingInfoFn,\n                        videoSegmentTimingInfoFn,\n                        audioSegmentTimingInfoFn,\n                        id3Fn,\n                        captionsFn,\n                        isEndOfTimeline,\n                        endedTimelineFn,\n                        dataFn,\n                        doneFn,\n                        onTransmuxerLog\n                    });\n                }; // Keep track of when *all* of the requests have completed\n\n                segment.endOfAllRequests = Date.now();\n                if (segment.map && segment.map.encryptedBytes && !segment.map.bytes) {\n                    return decrypt({\n                        decryptionWorker,\n                        // add -init to the \"id\" to differentiate between segment\n                        // and init segment decryption, just in case they happen\n                        // at the same time at some point in the future.\n                        id: segment.requestId + '-init',\n                        encryptedBytes: segment.map.encryptedBytes,\n                        key: segment.map.key\n                    }, decryptedBytes => {\n                        segment.map.bytes = decryptedBytes;\n                        parseInitSegment(segment, parseError => {\n                            if (parseError) {\n                                abortAll(activeXhrs);\n                                return doneFn(parseError, segment);\n                            }\n                            segmentFinish();\n                        });\n                    });\n                }\n                segmentFinish();\n            }\n        };\n    };\n    /**\n     * Calls the abort callback if any request within the batch was aborted. Will only call\n     * the callback once per batch of requests, even if multiple were aborted.\n     *\n     * @param {Object} loadendState - state to check to see if the abort function was called\n     * @param {Function} abortFn - callback to call for abort\n     */\n\n    const handleLoadEnd = ({\n                               loadendState,\n                               abortFn\n                           }) => event => {\n        const request = event.target;\n        if (request.aborted && abortFn && !loadendState.calledAbortFn) {\n            abortFn();\n            loadendState.calledAbortFn = true;\n        }\n    };\n    /**\n     * Simple progress event callback handler that gathers some stats before\n     * executing a provided callback with the `segment` object\n     *\n     * @param {Object} segment - a simplified copy of the segmentInfo object\n     *                           from SegmentLoader\n     * @param {Function} progressFn - a callback that is executed each time a progress event\n     *                                is received\n     * @param {Function} trackInfoFn - a callback that receives track info\n     * @param {Function} timingInfoFn - a callback that receives timing info\n     * @param {Function} videoSegmentTimingInfoFn\n     *                   a callback that receives video timing info based on media times and\n     *                   any adjustments made by the transmuxer\n     * @param {Function} audioSegmentTimingInfoFn\n     *                   a callback that receives audio timing info based on media times and\n     *                   any adjustments made by the transmuxer\n     * @param {boolean}  isEndOfTimeline\n     *                   true if this segment represents the last segment in a timeline\n     * @param {Function} endedTimelineFn\n     *                   a callback made when a timeline is ended, will only be called if\n     *                   isEndOfTimeline is true\n     * @param {Function} dataFn - a callback that is executed when segment bytes are available\n     *                            and ready to use\n     * @param {Event} event - the progress event object from XMLHttpRequest\n     */\n\n    const handleProgress = ({\n                                segment,\n                                progressFn,\n                                trackInfoFn,\n                                timingInfoFn,\n                                videoSegmentTimingInfoFn,\n                                audioSegmentTimingInfoFn,\n                                id3Fn,\n                                captionsFn,\n                                isEndOfTimeline,\n                                endedTimelineFn,\n                                dataFn\n                            }) => event => {\n        const request = event.target;\n        if (request.aborted) {\n            return;\n        }\n        segment.stats = merge(segment.stats, getProgressStats(event)); // record the time that we receive the first byte of data\n\n        if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) {\n            segment.stats.firstBytesReceivedAt = Date.now();\n        }\n        return progressFn(event, segment);\n    };\n    /**\n     * Load all resources and does any processing necessary for a media-segment\n     *\n     * Features:\n     *   decrypts the media-segment if it has a key uri and an iv\n     *   aborts *all* requests if *any* one request fails\n     *\n     * The segment object, at minimum, has the following format:\n     * {\n     *   resolvedUri: String,\n     *   [transmuxer]: Object,\n     *   [byterange]: {\n     *     offset: Number,\n     *     length: Number\n     *   },\n     *   [key]: {\n     *     resolvedUri: String\n     *     [byterange]: {\n     *       offset: Number,\n     *       length: Number\n     *     },\n     *     iv: {\n     *       bytes: Uint32Array\n     *     }\n     *   },\n     *   [map]: {\n     *     resolvedUri: String,\n     *     [byterange]: {\n     *       offset: Number,\n     *       length: Number\n     *     },\n     *     [bytes]: Uint8Array\n     *   }\n     * }\n     * ...where [name] denotes optional properties\n     *\n     * @param {Function} xhr - an instance of the xhr wrapper in xhr.js\n     * @param {Object} xhrOptions - the base options to provide to all xhr requests\n     * @param {WebWorker} decryptionWorker - a WebWorker interface to AES-128\n     *                                       decryption routines\n     * @param {Object} segment - a simplified copy of the segmentInfo object\n     *                           from SegmentLoader\n     * @param {Function} abortFn - a callback called (only once) if any piece of a request was\n     *                             aborted\n     * @param {Function} progressFn - a callback that receives progress events from the main\n     *                                segment's xhr request\n     * @param {Function} trackInfoFn - a callback that receives track info\n     * @param {Function} timingInfoFn - a callback that receives timing info\n     * @param {Function} videoSegmentTimingInfoFn\n     *                   a callback that receives video timing info based on media times and\n     *                   any adjustments made by the transmuxer\n     * @param {Function} audioSegmentTimingInfoFn\n     *                   a callback that receives audio timing info based on media times and\n     *                   any adjustments made by the transmuxer\n     * @param {Function} id3Fn - a callback that receives ID3 metadata\n     * @param {Function} captionsFn - a callback that receives captions\n     * @param {boolean}  isEndOfTimeline\n     *                   true if this segment represents the last segment in a timeline\n     * @param {Function} endedTimelineFn\n     *                   a callback made when a timeline is ended, will only be called if\n     *                   isEndOfTimeline is true\n     * @param {Function} dataFn - a callback that receives data from the main segment's xhr\n     *                            request, transmuxed if needed\n     * @param {Function} doneFn - a callback that is executed only once all requests have\n     *                            succeeded or failed\n     * @return {Function} a function that, when invoked, immediately aborts all\n     *                     outstanding requests\n     */\n\n    const mediaSegmentRequest = ({\n                                     xhr,\n                                     xhrOptions,\n                                     decryptionWorker,\n                                     segment,\n                                     abortFn,\n                                     progressFn,\n                                     trackInfoFn,\n                                     timingInfoFn,\n                                     videoSegmentTimingInfoFn,\n                                     audioSegmentTimingInfoFn,\n                                     id3Fn,\n                                     captionsFn,\n                                     isEndOfTimeline,\n                                     endedTimelineFn,\n                                     dataFn,\n                                     doneFn,\n                                     onTransmuxerLog\n                                 }) => {\n        const activeXhrs = [];\n        const finishProcessingFn = waitForCompletion({\n            activeXhrs,\n            decryptionWorker,\n            trackInfoFn,\n            timingInfoFn,\n            videoSegmentTimingInfoFn,\n            audioSegmentTimingInfoFn,\n            id3Fn,\n            captionsFn,\n            isEndOfTimeline,\n            endedTimelineFn,\n            dataFn,\n            doneFn,\n            onTransmuxerLog\n        }); // optionally, request the decryption key\n\n        if (segment.key && !segment.key.bytes) {\n            const objects = [segment.key];\n            if (segment.map && !segment.map.bytes && segment.map.key && segment.map.key.resolvedUri === segment.key.resolvedUri) {\n                objects.push(segment.map.key);\n            }\n            const keyRequestOptions = merge(xhrOptions, {\n                uri: segment.key.resolvedUri,\n                responseType: 'arraybuffer'\n            });\n            const keyRequestCallback = handleKeyResponse(segment, objects, finishProcessingFn);\n            const keyXhr = xhr(keyRequestOptions, keyRequestCallback);\n            activeXhrs.push(keyXhr);\n        } // optionally, request the associated media init segment\n\n        if (segment.map && !segment.map.bytes) {\n            const differentMapKey = segment.map.key && (!segment.key || segment.key.resolvedUri !== segment.map.key.resolvedUri);\n            if (differentMapKey) {\n                const mapKeyRequestOptions = merge(xhrOptions, {\n                    uri: segment.map.key.resolvedUri,\n                    responseType: 'arraybuffer'\n                });\n                const mapKeyRequestCallback = handleKeyResponse(segment, [segment.map.key], finishProcessingFn);\n                const mapKeyXhr = xhr(mapKeyRequestOptions, mapKeyRequestCallback);\n                activeXhrs.push(mapKeyXhr);\n            }\n            const initSegmentOptions = merge(xhrOptions, {\n                uri: segment.map.resolvedUri,\n                responseType: 'arraybuffer',\n                headers: segmentXhrHeaders(segment.map)\n            });\n            const initSegmentRequestCallback = handleInitSegmentResponse({\n                segment,\n                finishProcessingFn\n            });\n            const initSegmentXhr = xhr(initSegmentOptions, initSegmentRequestCallback);\n            activeXhrs.push(initSegmentXhr);\n        }\n        const segmentRequestOptions = merge(xhrOptions, {\n            uri: segment.part && segment.part.resolvedUri || segment.resolvedUri,\n            responseType: 'arraybuffer',\n            headers: segmentXhrHeaders(segment)\n        });\n        const segmentRequestCallback = handleSegmentResponse({\n            segment,\n            finishProcessingFn,\n            responseType: segmentRequestOptions.responseType\n        });\n        const segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);\n        segmentXhr.addEventListener('progress', handleProgress({\n            segment,\n            progressFn,\n            trackInfoFn,\n            timingInfoFn,\n            videoSegmentTimingInfoFn,\n            audioSegmentTimingInfoFn,\n            id3Fn,\n            captionsFn,\n            isEndOfTimeline,\n            endedTimelineFn,\n            dataFn\n        }));\n        activeXhrs.push(segmentXhr); // since all parts of the request must be considered, but should not make callbacks\n        // multiple times, provide a shared state object\n\n        const loadendState = {};\n        activeXhrs.forEach(activeXhr => {\n            activeXhr.addEventListener('loadend', handleLoadEnd({\n                loadendState,\n                abortFn\n            }));\n        });\n        return () => abortAll(activeXhrs);\n    };\n\n    /**\n     * @file - codecs.js - Handles tasks regarding codec strings such as translating them to\n     * codec strings, or translating codec strings into objects that can be examined.\n     */\n    const logFn$1 = logger('CodecUtils');\n    /**\n     * Returns a set of codec strings parsed from the playlist or the default\n     * codec strings if no codecs were specified in the playlist\n     *\n     * @param {Playlist} media the current media playlist\n     * @return {Object} an object with the video and audio codecs\n     */\n\n    const getCodecs = function (media) {\n        // if the codecs were explicitly specified, use them instead of the\n        // defaults\n        const mediaAttributes = media.attributes || {};\n        if (mediaAttributes.CODECS) {\n            return parseCodecs(mediaAttributes.CODECS);\n        }\n    };\n    const isMaat = (main, media) => {\n        const mediaAttributes = media.attributes || {};\n        return main && main.mediaGroups && main.mediaGroups.AUDIO && mediaAttributes.AUDIO && main.mediaGroups.AUDIO[mediaAttributes.AUDIO];\n    };\n    const isMuxed = (main, media) => {\n        if (!isMaat(main, media)) {\n            return true;\n        }\n        const mediaAttributes = media.attributes || {};\n        const audioGroup = main.mediaGroups.AUDIO[mediaAttributes.AUDIO];\n        for (const groupId in audioGroup) {\n            // If an audio group has a URI (the case for HLS, as HLS will use external playlists),\n            // or there are listed playlists (the case for DASH, as the manifest will have already\n            // provided all of the details necessary to generate the audio playlist, as opposed to\n            // HLS' externally requested playlists), then the content is demuxed.\n            if (!audioGroup[groupId].uri && !audioGroup[groupId].playlists) {\n                return true;\n            }\n        }\n        return false;\n    };\n    const unwrapCodecList = function (codecList) {\n        const codecs = {};\n        codecList.forEach(({\n                               mediaType,\n                               type,\n                               details\n                           }) => {\n            codecs[mediaType] = codecs[mediaType] || [];\n            codecs[mediaType].push(translateLegacyCodec(`${type}${details}`));\n        });\n        Object.keys(codecs).forEach(function (mediaType) {\n            if (codecs[mediaType].length > 1) {\n                logFn$1(`multiple ${mediaType} codecs found as attributes: ${codecs[mediaType].join(', ')}. Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.`);\n                codecs[mediaType] = null;\n                return;\n            }\n            codecs[mediaType] = codecs[mediaType][0];\n        });\n        return codecs;\n    };\n    const codecCount = function (codecObj) {\n        let count = 0;\n        if (codecObj.audio) {\n            count++;\n        }\n        if (codecObj.video) {\n            count++;\n        }\n        return count;\n    };\n    /**\n     * Calculates the codec strings for a working configuration of\n     * SourceBuffers to play variant streams in a main playlist. If\n     * there is no possible working configuration, an empty object will be\n     * returned.\n     *\n     * @param main {Object} the m3u8 object for the main playlist\n     * @param media {Object} the m3u8 object for the variant playlist\n     * @return {Object} the codec strings.\n     *\n     * @private\n     */\n\n    const codecsForPlaylist = function (main, media) {\n        const mediaAttributes = media.attributes || {};\n        const codecInfo = unwrapCodecList(getCodecs(media) || []); // HLS with multiple-audio tracks must always get an audio codec.\n        // Put another way, there is no way to have a video-only multiple-audio HLS!\n\n        if (isMaat(main, media) && !codecInfo.audio) {\n            if (!isMuxed(main, media)) {\n                // It is possible for codecs to be specified on the audio media group playlist but\n                // not on the rendition playlist. This is mostly the case for DASH, where audio and\n                // video are always separate (and separately specified).\n                const defaultCodecs = unwrapCodecList(codecsFromDefault(main, mediaAttributes.AUDIO) || []);\n                if (defaultCodecs.audio) {\n                    codecInfo.audio = defaultCodecs.audio;\n                }\n            }\n        }\n        return codecInfo;\n    };\n    const logFn = logger('PlaylistSelector');\n    const representationToString = function (representation) {\n        if (!representation || !representation.playlist) {\n            return;\n        }\n        const playlist = representation.playlist;\n        return JSON.stringify({\n            id: playlist.id,\n            bandwidth: representation.bandwidth,\n            width: representation.width,\n            height: representation.height,\n            codecs: playlist.attributes && playlist.attributes.CODECS || ''\n        });\n    }; // Utilities\n\n    /**\n     * Returns the CSS value for the specified property on an element\n     * using `getComputedStyle`. Firefox has a long-standing issue where\n     * getComputedStyle() may return null when running in an iframe with\n     * `display: none`.\n     *\n     * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n     * @param {HTMLElement} el the htmlelement to work on\n     * @param {string} the proprety to get the style for\n     */\n\n    const safeGetComputedStyle = function (el, property) {\n        if (!el) {\n            return '';\n        }\n        const result = window.getComputedStyle(el);\n        if (!result) {\n            return '';\n        }\n        return result[property];\n    };\n    /**\n     * Resuable stable sort function\n     *\n     * @param {Playlists} array\n     * @param {Function} sortFn Different comparators\n     * @function stableSort\n     */\n\n    const stableSort = function (array, sortFn) {\n        const newArray = array.slice();\n        array.sort(function (left, right) {\n            const cmp = sortFn(left, right);\n            if (cmp === 0) {\n                return newArray.indexOf(left) - newArray.indexOf(right);\n            }\n            return cmp;\n        });\n    };\n    /**\n     * A comparator function to sort two playlist object by bandwidth.\n     *\n     * @param {Object} left a media playlist object\n     * @param {Object} right a media playlist object\n     * @return {number} Greater than zero if the bandwidth attribute of\n     * left is greater than the corresponding attribute of right. Less\n     * than zero if the bandwidth of right is greater than left and\n     * exactly zero if the two are equal.\n     */\n\n    const comparePlaylistBandwidth = function (left, right) {\n        let leftBandwidth;\n        let rightBandwidth;\n        if (left.attributes.BANDWIDTH) {\n            leftBandwidth = left.attributes.BANDWIDTH;\n        }\n        leftBandwidth = leftBandwidth || window.Number.MAX_VALUE;\n        if (right.attributes.BANDWIDTH) {\n            rightBandwidth = right.attributes.BANDWIDTH;\n        }\n        rightBandwidth = rightBandwidth || window.Number.MAX_VALUE;\n        return leftBandwidth - rightBandwidth;\n    };\n    /**\n     * A comparator function to sort two playlist object by resolution (width).\n     *\n     * @param {Object} left a media playlist object\n     * @param {Object} right a media playlist object\n     * @return {number} Greater than zero if the resolution.width attribute of\n     * left is greater than the corresponding attribute of right. Less\n     * than zero if the resolution.width of right is greater than left and\n     * exactly zero if the two are equal.\n     */\n\n    const comparePlaylistResolution = function (left, right) {\n        let leftWidth;\n        let rightWidth;\n        if (left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) {\n            leftWidth = left.attributes.RESOLUTION.width;\n        }\n        leftWidth = leftWidth || window.Number.MAX_VALUE;\n        if (right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) {\n            rightWidth = right.attributes.RESOLUTION.width;\n        }\n        rightWidth = rightWidth || window.Number.MAX_VALUE; // NOTE - Fallback to bandwidth sort as appropriate in cases where multiple renditions\n        // have the same media dimensions/ resolution\n\n        if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) {\n            return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;\n        }\n        return leftWidth - rightWidth;\n    };\n    /**\n     * Chooses the appropriate media playlist based on bandwidth and player size\n     *\n     * @param {Object} main\n     *        Object representation of the main manifest\n     * @param {number} playerBandwidth\n     *        Current calculated bandwidth of the player\n     * @param {number} playerWidth\n     *        Current width of the player element (should account for the device pixel ratio)\n     * @param {number} playerHeight\n     *        Current height of the player element (should account for the device pixel ratio)\n     * @param {boolean} limitRenditionByPlayerDimensions\n     *        True if the player width and height should be used during the selection, false otherwise\n     * @param {Object} playlistController\n     *        the current playlistController object\n     * @return {Playlist} the highest bitrate playlist less than the\n     * currently detected bandwidth, accounting for some amount of\n     * bandwidth variance\n     */\n\n    let simpleSelector = function (main, playerBandwidth, playerWidth, playerHeight, limitRenditionByPlayerDimensions, playlistController) {\n        // If we end up getting called before `main` is available, exit early\n        if (!main) {\n            return;\n        }\n        const options = {\n            bandwidth: playerBandwidth,\n            width: playerWidth,\n            height: playerHeight,\n            limitRenditionByPlayerDimensions\n        };\n        let playlists = main.playlists; // if playlist is audio only, select between currently active audio group playlists.\n\n        if (Playlist.isAudioOnly(main)) {\n            playlists = playlistController.getAudioTrackPlaylists_(); // add audioOnly to options so that we log audioOnly: true\n            // at the buttom of this function for debugging.\n\n            options.audioOnly = true;\n        } // convert the playlists to an intermediary representation to make comparisons easier\n\n        let sortedPlaylistReps = playlists.map(playlist => {\n            let bandwidth;\n            const width = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;\n            const height = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;\n            bandwidth = playlist.attributes && playlist.attributes.BANDWIDTH;\n            bandwidth = bandwidth || window.Number.MAX_VALUE;\n            return {\n                bandwidth,\n                width,\n                height,\n                playlist\n            };\n        });\n        stableSort(sortedPlaylistReps, (left, right) => left.bandwidth - right.bandwidth); // filter out any playlists that have been excluded due to\n        // incompatible configurations\n\n        sortedPlaylistReps = sortedPlaylistReps.filter(rep => !Playlist.isIncompatible(rep.playlist)); // filter out any playlists that have been disabled manually through the representations\n        // api or excluded temporarily due to playback errors.\n\n        let enabledPlaylistReps = sortedPlaylistReps.filter(rep => Playlist.isEnabled(rep.playlist));\n        if (!enabledPlaylistReps.length) {\n            // if there are no enabled playlists, then they have all been excluded or disabled\n            // by the user through the representations api. In this case, ignore exclusion and\n            // fallback to what the user wants by using playlists the user has not disabled.\n            enabledPlaylistReps = sortedPlaylistReps.filter(rep => !Playlist.isDisabled(rep.playlist));\n        } // filter out any variant that has greater effective bitrate\n        // than the current estimated bandwidth\n\n        const bandwidthPlaylistReps = enabledPlaylistReps.filter(rep => rep.bandwidth * Config.BANDWIDTH_VARIANCE < playerBandwidth);\n        let highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1]; // get all of the renditions with the same (highest) bandwidth\n        // and then taking the very first element\n\n        const bandwidthBestRep = bandwidthPlaylistReps.filter(rep => rep.bandwidth === highestRemainingBandwidthRep.bandwidth)[0]; // if we're not going to limit renditions by player size, make an early decision.\n\n        if (limitRenditionByPlayerDimensions === false) {\n            const chosenRep = bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];\n            if (chosenRep && chosenRep.playlist) {\n                let type = 'sortedPlaylistReps';\n                if (bandwidthBestRep) {\n                    type = 'bandwidthBestRep';\n                }\n                if (enabledPlaylistReps[0]) {\n                    type = 'enabledPlaylistReps';\n                }\n                logFn(`choosing ${representationToString(chosenRep)} using ${type} with options`, options);\n                return chosenRep.playlist;\n            }\n            logFn('could not choose a playlist with options', options);\n            return null;\n        } // filter out playlists without resolution information\n\n        const haveResolution = bandwidthPlaylistReps.filter(rep => rep.width && rep.height); // sort variants by resolution\n\n        stableSort(haveResolution, (left, right) => left.width - right.width); // if we have the exact resolution as the player use it\n\n        const resolutionBestRepList = haveResolution.filter(rep => rep.width === playerWidth && rep.height === playerHeight);\n        highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1]; // ensure that we pick the highest bandwidth variant that have exact resolution\n\n        const resolutionBestRep = resolutionBestRepList.filter(rep => rep.bandwidth === highestRemainingBandwidthRep.bandwidth)[0];\n        let resolutionPlusOneList;\n        let resolutionPlusOneSmallest;\n        let resolutionPlusOneRep; // find the smallest variant that is larger than the player\n        // if there is no match of exact resolution\n\n        if (!resolutionBestRep) {\n            resolutionPlusOneList = haveResolution.filter(rep => rep.width > playerWidth || rep.height > playerHeight); // find all the variants have the same smallest resolution\n\n            resolutionPlusOneSmallest = resolutionPlusOneList.filter(rep => rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height); // ensure that we also pick the highest bandwidth variant that\n            // is just-larger-than the video player\n\n            highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];\n            resolutionPlusOneRep = resolutionPlusOneSmallest.filter(rep => rep.bandwidth === highestRemainingBandwidthRep.bandwidth)[0];\n        }\n        let leastPixelDiffRep; // If this selector proves to be better than others,\n        // resolutionPlusOneRep and resolutionBestRep and all\n        // the code involving them should be removed.\n\n        if (playlistController.leastPixelDiffSelector) {\n            // find the variant that is closest to the player's pixel size\n            const leastPixelDiffList = haveResolution.map(rep => {\n                rep.pixelDiff = Math.abs(rep.width - playerWidth) + Math.abs(rep.height - playerHeight);\n                return rep;\n            }); // get the highest bandwidth, closest resolution playlist\n\n            stableSort(leastPixelDiffList, (left, right) => {\n                // sort by highest bandwidth if pixelDiff is the same\n                if (left.pixelDiff === right.pixelDiff) {\n                    return right.bandwidth - left.bandwidth;\n                }\n                return left.pixelDiff - right.pixelDiff;\n            });\n            leastPixelDiffRep = leastPixelDiffList[0];\n        } // fallback chain of variants\n\n        const chosenRep = leastPixelDiffRep || resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];\n        if (chosenRep && chosenRep.playlist) {\n            let type = 'sortedPlaylistReps';\n            if (leastPixelDiffRep) {\n                type = 'leastPixelDiffRep';\n            } else if (resolutionPlusOneRep) {\n                type = 'resolutionPlusOneRep';\n            } else if (resolutionBestRep) {\n                type = 'resolutionBestRep';\n            } else if (bandwidthBestRep) {\n                type = 'bandwidthBestRep';\n            } else if (enabledPlaylistReps[0]) {\n                type = 'enabledPlaylistReps';\n            }\n            logFn(`choosing ${representationToString(chosenRep)} using ${type} with options`, options);\n            return chosenRep.playlist;\n        }\n        logFn('could not choose a playlist with options', options);\n        return null;\n    };\n\n    /**\n     * Chooses the appropriate media playlist based on the most recent\n     * bandwidth estimate and the player size.\n     *\n     * Expects to be called within the context of an instance of VhsHandler\n     *\n     * @return {Playlist} the highest bitrate playlist less than the\n     * currently detected bandwidth, accounting for some amount of\n     * bandwidth variance\n     */\n\n    const lastBandwidthSelector = function () {\n        const pixelRatio = this.useDevicePixelRatio ? window.devicePixelRatio || 1 : 1;\n        return simpleSelector(this.playlists.main, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.playlistController_);\n    };\n    /**\n     * Chooses the appropriate media playlist based on an\n     * exponential-weighted moving average of the bandwidth after\n     * filtering for player size.\n     *\n     * Expects to be called within the context of an instance of VhsHandler\n     *\n     * @param {number} decay - a number between 0 and 1. Higher values of\n     * this parameter will cause previous bandwidth estimates to lose\n     * significance more quickly.\n     * @return {Function} a function which can be invoked to create a new\n     * playlist selector function.\n     * @see https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n     */\n\n    const movingAverageBandwidthSelector = function (decay) {\n        let average = -1;\n        let lastSystemBandwidth = -1;\n        if (decay < 0 || decay > 1) {\n            throw new Error('Moving average bandwidth decay must be between 0 and 1.');\n        }\n        return function () {\n            const pixelRatio = this.useDevicePixelRatio ? window.devicePixelRatio || 1 : 1;\n            if (average < 0) {\n                average = this.systemBandwidth;\n                lastSystemBandwidth = this.systemBandwidth;\n            } // stop the average value from decaying for every 250ms\n            // when the systemBandwidth is constant\n            // and\n            // stop average from setting to a very low value when the\n            // systemBandwidth becomes 0 in case of chunk cancellation\n\n            if (this.systemBandwidth > 0 && this.systemBandwidth !== lastSystemBandwidth) {\n                average = decay * this.systemBandwidth + (1 - decay) * average;\n                lastSystemBandwidth = this.systemBandwidth;\n            }\n            return simpleSelector(this.playlists.main, average, parseInt(safeGetComputedStyle(this.tech_.el(), 'width'), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), 'height'), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.playlistController_);\n        };\n    };\n    /**\n     * Chooses the appropriate media playlist based on the potential to rebuffer\n     *\n     * @param {Object} settings\n     *        Object of information required to use this selector\n     * @param {Object} settings.main\n     *        Object representation of the main manifest\n     * @param {number} settings.currentTime\n     *        The current time of the player\n     * @param {number} settings.bandwidth\n     *        Current measured bandwidth\n     * @param {number} settings.duration\n     *        Duration of the media\n     * @param {number} settings.segmentDuration\n     *        Segment duration to be used in round trip time calculations\n     * @param {number} settings.timeUntilRebuffer\n     *        Time left in seconds until the player has to rebuffer\n     * @param {number} settings.currentTimeline\n     *        The current timeline segments are being loaded from\n     * @param {SyncController} settings.syncController\n     *        SyncController for determining if we have a sync point for a given playlist\n     * @return {Object|null}\n     *         {Object} return.playlist\n     *         The highest bandwidth playlist with the least amount of rebuffering\n     *         {Number} return.rebufferingImpact\n     *         The amount of time in seconds switching to this playlist will rebuffer. A\n     *         negative value means that switching will cause zero rebuffering.\n     */\n\n    const minRebufferMaxBandwidthSelector = function (settings) {\n        const {\n            main,\n            currentTime,\n            bandwidth,\n            duration,\n            segmentDuration,\n            timeUntilRebuffer,\n            currentTimeline,\n            syncController\n        } = settings; // filter out any playlists that have been excluded due to\n        // incompatible configurations\n\n        const compatiblePlaylists = main.playlists.filter(playlist => !Playlist.isIncompatible(playlist)); // filter out any playlists that have been disabled manually through the representations\n        // api or excluded temporarily due to playback errors.\n\n        let enabledPlaylists = compatiblePlaylists.filter(Playlist.isEnabled);\n        if (!enabledPlaylists.length) {\n            // if there are no enabled playlists, then they have all been excluded or disabled\n            // by the user through the representations api. In this case, ignore exclusion and\n            // fallback to what the user wants by using playlists the user has not disabled.\n            enabledPlaylists = compatiblePlaylists.filter(playlist => !Playlist.isDisabled(playlist));\n        }\n        const bandwidthPlaylists = enabledPlaylists.filter(Playlist.hasAttribute.bind(null, 'BANDWIDTH'));\n        const rebufferingEstimates = bandwidthPlaylists.map(playlist => {\n            const syncPoint = syncController.getSyncPoint(playlist, duration, currentTimeline, currentTime); // If there is no sync point for this playlist, switching to it will require a\n            // sync request first. This will double the request time\n\n            const numRequests = syncPoint ? 1 : 2;\n            const requestTimeEstimate = Playlist.estimateSegmentRequestTime(segmentDuration, bandwidth, playlist);\n            const rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer;\n            return {\n                playlist,\n                rebufferingImpact\n            };\n        });\n        const noRebufferingPlaylists = rebufferingEstimates.filter(estimate => estimate.rebufferingImpact <= 0); // Sort by bandwidth DESC\n\n        stableSort(noRebufferingPlaylists, (a, b) => comparePlaylistBandwidth(b.playlist, a.playlist));\n        if (noRebufferingPlaylists.length) {\n            return noRebufferingPlaylists[0];\n        }\n        stableSort(rebufferingEstimates, (a, b) => a.rebufferingImpact - b.rebufferingImpact);\n        return rebufferingEstimates[0] || null;\n    };\n    /**\n     * Chooses the appropriate media playlist, which in this case is the lowest bitrate\n     * one with video.  If no renditions with video exist, return the lowest audio rendition.\n     *\n     * Expects to be called within the context of an instance of VhsHandler\n     *\n     * @return {Object|null}\n     *         {Object} return.playlist\n     *         The lowest bitrate playlist that contains a video codec.  If no such rendition\n     *         exists pick the lowest audio rendition.\n     */\n\n    const lowestBitrateCompatibleVariantSelector = function () {\n        // filter out any playlists that have been excluded due to\n        // incompatible configurations or playback errors\n        const playlists = this.playlists.main.playlists.filter(Playlist.isEnabled); // Sort ascending by bitrate\n\n        stableSort(playlists, (a, b) => comparePlaylistBandwidth(a, b)); // Parse and assume that playlists with no video codec have no video\n        // (this is not necessarily true, although it is generally true).\n        //\n        // If an entire manifest has no valid videos everything will get filtered\n        // out.\n\n        const playlistsWithVideo = playlists.filter(playlist => !!codecsForPlaylist(this.playlists.main, playlist).video);\n        return playlistsWithVideo[0] || null;\n    };\n\n    /**\n     * Combine all segments into a single Uint8Array\n     *\n     * @param {Object} segmentObj\n     * @return {Uint8Array} concatenated bytes\n     * @private\n     */\n    const concatSegments = segmentObj => {\n        let offset = 0;\n        let tempBuffer;\n        if (segmentObj.bytes) {\n            tempBuffer = new Uint8Array(segmentObj.bytes); // combine the individual segments into one large typed-array\n\n            segmentObj.segments.forEach(segment => {\n                tempBuffer.set(segment, offset);\n                offset += segment.byteLength;\n            });\n        }\n        return tempBuffer;\n    };\n\n    /**\n     * @file text-tracks.js\n     */\n    /**\n     * Create captions text tracks on video.js if they do not exist\n     *\n     * @param {Object} inbandTextTracks a reference to current inbandTextTracks\n     * @param {Object} tech the video.js tech\n     * @param {Object} captionStream the caption stream to create\n     * @private\n     */\n\n    const createCaptionsTrackIfNotExists = function (inbandTextTracks, tech, captionStream) {\n        if (!inbandTextTracks[captionStream]) {\n            tech.trigger({\n                type: 'usage',\n                name: 'vhs-608'\n            });\n            let instreamId = captionStream; // we need to translate SERVICEn for 708 to how mux.js currently labels them\n\n            if (/^cc708_/.test(captionStream)) {\n                instreamId = 'SERVICE' + captionStream.split('_')[1];\n            }\n            const track = tech.textTracks().getTrackById(instreamId);\n            if (track) {\n                // Resuse an existing track with a CC# id because this was\n                // very likely created by videojs-contrib-hls from information\n                // in the m3u8 for us to use\n                inbandTextTracks[captionStream] = track;\n            } else {\n                // This section gets called when we have caption services that aren't specified in the manifest.\n                // Manifest level caption services are handled in media-groups.js under CLOSED-CAPTIONS.\n                const captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};\n                let label = captionStream;\n                let language = captionStream;\n                let def = false;\n                const captionService = captionServices[instreamId];\n                if (captionService) {\n                    label = captionService.label;\n                    language = captionService.language;\n                    def = captionService.default;\n                } // Otherwise, create a track with the default `CC#` label and\n                // without a language\n\n                inbandTextTracks[captionStream] = tech.addRemoteTextTrack({\n                    kind: 'captions',\n                    id: instreamId,\n                    // TODO: investigate why this doesn't seem to turn the caption on by default\n                    default: def,\n                    label,\n                    language\n                }, false).track;\n            }\n        }\n    };\n    /**\n     * Add caption text track data to a source handler given an array of captions\n     *\n     * @param {Object}\n     *   @param {Object} inbandTextTracks the inband text tracks\n     *   @param {number} timestampOffset the timestamp offset of the source buffer\n     *   @param {Array} captionArray an array of caption data\n     * @private\n     */\n\n    const addCaptionData = function ({\n                                         inbandTextTracks,\n                                         captionArray,\n                                         timestampOffset\n                                     }) {\n        if (!captionArray) {\n            return;\n        }\n        const Cue = window.WebKitDataCue || window.VTTCue;\n        captionArray.forEach(caption => {\n            const track = caption.stream;\n            inbandTextTracks[track].addCue(new Cue(caption.startTime + timestampOffset, caption.endTime + timestampOffset, caption.text));\n        });\n    };\n    /**\n     * Define properties on a cue for backwards compatability,\n     * but warn the user that the way that they are using it\n     * is depricated and will be removed at a later date.\n     *\n     * @param {Cue} cue the cue to add the properties on\n     * @private\n     */\n\n    const deprecateOldCue = function (cue) {\n        Object.defineProperties(cue.frame, {\n            id: {\n                get() {\n                    videojs.log.warn('cue.frame.id is deprecated. Use cue.value.key instead.');\n                    return cue.value.key;\n                }\n            },\n            value: {\n                get() {\n                    videojs.log.warn('cue.frame.value is deprecated. Use cue.value.data instead.');\n                    return cue.value.data;\n                }\n            },\n            privateData: {\n                get() {\n                    videojs.log.warn('cue.frame.privateData is deprecated. Use cue.value.data instead.');\n                    return cue.value.data;\n                }\n            }\n        });\n    };\n    /**\n     * Add metadata text track data to a source handler given an array of metadata\n     *\n     * @param {Object}\n     *   @param {Object} inbandTextTracks the inband text tracks\n     *   @param {Array} metadataArray an array of meta data\n     *   @param {number} timestampOffset the timestamp offset of the source buffer\n     *   @param {number} videoDuration the duration of the video\n     * @private\n     */\n\n    const addMetadata = ({\n                             inbandTextTracks,\n                             metadataArray,\n                             timestampOffset,\n                             videoDuration\n                         }) => {\n        if (!metadataArray) {\n            return;\n        }\n        const Cue = window.WebKitDataCue || window.VTTCue;\n        const metadataTrack = inbandTextTracks.metadataTrack_;\n        if (!metadataTrack) {\n            return;\n        }\n        metadataArray.forEach(metadata => {\n            const time = metadata.cueTime + timestampOffset; // if time isn't a finite number between 0 and Infinity, like NaN,\n            // ignore this bit of metadata.\n            // This likely occurs when you have an non-timed ID3 tag like TIT2,\n            // which is the \"Title/Songname/Content description\" frame\n\n            if (typeof time !== 'number' || window.isNaN(time) || time < 0 || !(time < Infinity)) {\n                return;\n            }\n            metadata.frames.forEach(frame => {\n                const cue = new Cue(time, time, frame.value || frame.url || frame.data || '');\n                cue.frame = frame;\n                cue.value = frame;\n                deprecateOldCue(cue);\n                metadataTrack.addCue(cue);\n            });\n        });\n        if (!metadataTrack.cues || !metadataTrack.cues.length) {\n            return;\n        } // Updating the metadeta cues so that\n        // the endTime of each cue is the startTime of the next cue\n        // the endTime of last cue is the duration of the video\n\n        const cues = metadataTrack.cues;\n        const cuesArray = []; // Create a copy of the TextTrackCueList...\n        // ...disregarding cues with a falsey value\n\n        for (let i = 0; i < cues.length; i++) {\n            if (cues[i]) {\n                cuesArray.push(cues[i]);\n            }\n        } // Group cues by their startTime value\n\n        const cuesGroupedByStartTime = cuesArray.reduce((obj, cue) => {\n            const timeSlot = obj[cue.startTime] || [];\n            timeSlot.push(cue);\n            obj[cue.startTime] = timeSlot;\n            return obj;\n        }, {}); // Sort startTimes by ascending order\n\n        const sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort((a, b) => Number(a) - Number(b)); // Map each cue group's endTime to the next group's startTime\n\n        sortedStartTimes.forEach((startTime, idx) => {\n            const cueGroup = cuesGroupedByStartTime[startTime];\n            const nextTime = Number(sortedStartTimes[idx + 1]) || videoDuration; // Map each cue's endTime the next group's startTime\n\n            cueGroup.forEach(cue => {\n                cue.endTime = nextTime;\n            });\n        });\n    };\n    /**\n     * Create metadata text track on video.js if it does not exist\n     *\n     * @param {Object} inbandTextTracks a reference to current inbandTextTracks\n     * @param {string} dispatchType the inband metadata track dispatch type\n     * @param {Object} tech the video.js tech\n     * @private\n     */\n\n    const createMetadataTrackIfNotExists = (inbandTextTracks, dispatchType, tech) => {\n        if (inbandTextTracks.metadataTrack_) {\n            return;\n        }\n        inbandTextTracks.metadataTrack_ = tech.addRemoteTextTrack({\n            kind: 'metadata',\n            label: 'Timed Metadata'\n        }, false).track;\n        inbandTextTracks.metadataTrack_.inBandMetadataTrackDispatchType = dispatchType;\n    };\n    /**\n     * Remove cues from a track on video.js.\n     *\n     * @param {Double} start start of where we should remove the cue\n     * @param {Double} end end of where the we should remove the cue\n     * @param {Object} track the text track to remove the cues from\n     * @private\n     */\n\n    const removeCuesFromTrack = function (start, end, track) {\n        let i;\n        let cue;\n        if (!track) {\n            return;\n        }\n        if (!track.cues) {\n            return;\n        }\n        i = track.cues.length;\n        while (i--) {\n            cue = track.cues[i]; // Remove any cue within the provided start and end time\n\n            if (cue.startTime >= start && cue.endTime <= end) {\n                track.removeCue(cue);\n            }\n        }\n    };\n    /**\n     * Remove duplicate cues from a track on video.js (a cue is considered a\n     * duplicate if it has the same time interval and text as another)\n     *\n     * @param {Object} track the text track to remove the duplicate cues from\n     * @private\n     */\n\n    const removeDuplicateCuesFromTrack = function (track) {\n        const cues = track.cues;\n        if (!cues) {\n            return;\n        }\n        for (let i = 0; i < cues.length; i++) {\n            const duplicates = [];\n            let occurrences = 0;\n            for (let j = 0; j < cues.length; j++) {\n                if (cues[i].startTime === cues[j].startTime && cues[i].endTime === cues[j].endTime && cues[i].text === cues[j].text) {\n                    occurrences++;\n                    if (occurrences > 1) {\n                        duplicates.push(cues[j]);\n                    }\n                }\n            }\n            if (duplicates.length) {\n                duplicates.forEach(dupe => track.removeCue(dupe));\n            }\n        }\n    };\n\n    /**\n     * Returns a list of gops in the buffer that have a pts value of 3 seconds or more in\n     * front of current time.\n     *\n     * @param {Array} buffer\n     *        The current buffer of gop information\n     * @param {number} currentTime\n     *        The current time\n     * @param {Double} mapping\n     *        Offset to map display time to stream presentation time\n     * @return {Array}\n     *         List of gops considered safe to append over\n     */\n\n    const gopsSafeToAlignWith = (buffer, currentTime, mapping) => {\n        if (typeof currentTime === 'undefined' || currentTime === null || !buffer.length) {\n            return [];\n        } // pts value for current time + 3 seconds to give a bit more wiggle room\n\n        const currentTimePts = Math.ceil((currentTime - mapping + 3) * clock_1);\n        let i;\n        for (i = 0; i < buffer.length; i++) {\n            if (buffer[i].pts > currentTimePts) {\n                break;\n            }\n        }\n        return buffer.slice(i);\n    };\n    /**\n     * Appends gop information (timing and byteLength) received by the transmuxer for the\n     * gops appended in the last call to appendBuffer\n     *\n     * @param {Array} buffer\n     *        The current buffer of gop information\n     * @param {Array} gops\n     *        List of new gop information\n     * @param {boolean} replace\n     *        If true, replace the buffer with the new gop information. If false, append the\n     *        new gop information to the buffer in the right location of time.\n     * @return {Array}\n     *         Updated list of gop information\n     */\n\n    const updateGopBuffer = (buffer, gops, replace) => {\n        if (!gops.length) {\n            return buffer;\n        }\n        if (replace) {\n            // If we are in safe append mode, then completely overwrite the gop buffer\n            // with the most recent appeneded data. This will make sure that when appending\n            // future segments, we only try to align with gops that are both ahead of current\n            // time and in the last segment appended.\n            return gops.slice();\n        }\n        const start = gops[0].pts;\n        let i = 0;\n        for (i; i < buffer.length; i++) {\n            if (buffer[i].pts >= start) {\n                break;\n            }\n        }\n        return buffer.slice(0, i).concat(gops);\n    };\n    /**\n     * Removes gop information in buffer that overlaps with provided start and end\n     *\n     * @param {Array} buffer\n     *        The current buffer of gop information\n     * @param {Double} start\n     *        position to start the remove at\n     * @param {Double} end\n     *        position to end the remove at\n     * @param {Double} mapping\n     *        Offset to map display time to stream presentation time\n     */\n\n    const removeGopBuffer = (buffer, start, end, mapping) => {\n        const startPts = Math.ceil((start - mapping) * clock_1);\n        const endPts = Math.ceil((end - mapping) * clock_1);\n        const updatedBuffer = buffer.slice();\n        let i = buffer.length;\n        while (i--) {\n            if (buffer[i].pts <= endPts) {\n                break;\n            }\n        }\n        if (i === -1) {\n            // no removal because end of remove range is before start of buffer\n            return updatedBuffer;\n        }\n        let j = i + 1;\n        while (j--) {\n            if (buffer[j].pts <= startPts) {\n                break;\n            }\n        } // clamp remove range start to 0 index\n\n        j = Math.max(j, 0);\n        updatedBuffer.splice(j, i - j + 1);\n        return updatedBuffer;\n    };\n    const shallowEqual = function (a, b) {\n        // if both are undefined\n        // or one or the other is undefined\n        // they are not equal\n        if (!a && !b || !a && b || a && !b) {\n            return false;\n        } // they are the same object and thus, equal\n\n        if (a === b) {\n            return true;\n        } // sort keys so we can make sure they have\n        // all the same keys later.\n\n        const akeys = Object.keys(a).sort();\n        const bkeys = Object.keys(b).sort(); // different number of keys, not equal\n\n        if (akeys.length !== bkeys.length) {\n            return false;\n        }\n        for (let i = 0; i < akeys.length; i++) {\n            const key = akeys[i]; // different sorted keys, not equal\n\n            if (key !== bkeys[i]) {\n                return false;\n            } // different values, not equal\n\n            if (a[key] !== b[key]) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    // https://www.w3.org/TR/WebIDL-1/#quotaexceedederror\n    const QUOTA_EXCEEDED_ERR = 22;\n\n    /**\n     * The segment loader has no recourse except to fetch a segment in the\n     * current playlist and use the internal timestamps in that segment to\n     * generate a syncPoint. This function returns a good candidate index\n     * for that process.\n     *\n     * @param {Array} segments - the segments array from a playlist.\n     * @return {number} An index of a segment from the playlist to load\n     */\n\n    const getSyncSegmentCandidate = function (currentTimeline, segments, targetTime) {\n        segments = segments || [];\n        const timelineSegments = [];\n        let time = 0;\n        for (let i = 0; i < segments.length; i++) {\n            const segment = segments[i];\n            if (currentTimeline === segment.timeline) {\n                timelineSegments.push(i);\n                time += segment.duration;\n                if (time > targetTime) {\n                    return i;\n                }\n            }\n        }\n        if (timelineSegments.length === 0) {\n            return 0;\n        } // default to the last timeline segment\n\n        return timelineSegments[timelineSegments.length - 1];\n    }; // In the event of a quota exceeded error, keep at least one second of back buffer. This\n    // number was arbitrarily chosen and may be updated in the future, but seemed reasonable\n    // as a start to prevent any potential issues with removing content too close to the\n    // playhead.\n\n    const MIN_BACK_BUFFER = 1; // in ms\n\n    const CHECK_BUFFER_DELAY = 500;\n    const finite = num => typeof num === 'number' && isFinite(num); // With most content hovering around 30fps, if a segment has a duration less than a half\n    // frame at 30fps or one frame at 60fps, the bandwidth and throughput calculations will\n    // not accurately reflect the rest of the content.\n\n    const MIN_SEGMENT_DURATION_TO_SAVE_STATS = 1 / 60;\n    const illegalMediaSwitch = (loaderType, startingMedia, trackInfo) => {\n        // Although these checks should most likely cover non 'main' types, for now it narrows\n        // the scope of our checks.\n        if (loaderType !== 'main' || !startingMedia || !trackInfo) {\n            return null;\n        }\n        if (!trackInfo.hasAudio && !trackInfo.hasVideo) {\n            return 'Neither audio nor video found in segment.';\n        }\n        if (startingMedia.hasVideo && !trackInfo.hasVideo) {\n            return 'Only audio found in segment when we expected video.' + ' We can\\'t switch to audio only from a stream that had video.' + ' To get rid of this message, please add codec information to the manifest.';\n        }\n        if (!startingMedia.hasVideo && trackInfo.hasVideo) {\n            return 'Video found in segment when we expected only audio.' + ' We can\\'t switch to a stream with video from an audio only stream.' + ' To get rid of this message, please add codec information to the manifest.';\n        }\n        return null;\n    };\n    /**\n     * Calculates a time value that is safe to remove from the back buffer without interrupting\n     * playback.\n     *\n     * @param {TimeRange} seekable\n     *        The current seekable range\n     * @param {number} currentTime\n     *        The current time of the player\n     * @param {number} targetDuration\n     *        The target duration of the current playlist\n     * @return {number}\n     *         Time that is safe to remove from the back buffer without interrupting playback\n     */\n\n    const safeBackBufferTrimTime = (seekable, currentTime, targetDuration) => {\n        // 30 seconds before the playhead provides a safe default for trimming.\n        //\n        // Choosing a reasonable default is particularly important for high bitrate content and\n        // VOD videos/live streams with large windows, as the buffer may end up overfilled and\n        // throw an APPEND_BUFFER_ERR.\n        let trimTime = currentTime - Config.BACK_BUFFER_LENGTH;\n        if (seekable.length) {\n            // Some live playlists may have a shorter window of content than the full allowed back\n            // buffer. For these playlists, don't save content that's no longer within the window.\n            trimTime = Math.max(trimTime, seekable.start(0));\n        } // Don't remove within target duration of the current time to avoid the possibility of\n        // removing the GOP currently being played, as removing it can cause playback stalls.\n\n        const maxTrimTime = currentTime - targetDuration;\n        return Math.min(maxTrimTime, trimTime);\n    };\n    const segmentInfoString = segmentInfo => {\n        const {\n            startOfSegment,\n            duration,\n            segment,\n            part,\n            playlist: {\n                mediaSequence: seq,\n                id,\n                segments = []\n            },\n            mediaIndex: index,\n            partIndex,\n            timeline\n        } = segmentInfo;\n        const segmentLen = segments.length - 1;\n        let selection = 'mediaIndex/partIndex increment';\n        if (segmentInfo.getMediaInfoForTime) {\n            selection = `getMediaInfoForTime (${segmentInfo.getMediaInfoForTime})`;\n        } else if (segmentInfo.isSyncRequest) {\n            selection = 'getSyncSegmentCandidate (isSyncRequest)';\n        }\n        if (segmentInfo.independent) {\n            selection += ` with independent ${segmentInfo.independent}`;\n        }\n        const hasPartIndex = typeof partIndex === 'number';\n        const name = segmentInfo.segment.uri ? 'segment' : 'pre-segment';\n        const zeroBasedPartCount = hasPartIndex ? getKnownPartCount({\n            preloadSegment: segment\n        }) - 1 : 0;\n        return `${name} [${seq + index}/${seq + segmentLen}]` + (hasPartIndex ? ` part [${partIndex}/${zeroBasedPartCount}]` : '') + ` segment start/end [${segment.start} => ${segment.end}]` + (hasPartIndex ? ` part start/end [${part.start} => ${part.end}]` : '') + ` startOfSegment [${startOfSegment}]` + ` duration [${duration}]` + ` timeline [${timeline}]` + ` selected by [${selection}]` + ` playlist [${id}]`;\n    };\n    const timingInfoPropertyForMedia = mediaType => `${mediaType}TimingInfo`;\n    /**\n     * Returns the timestamp offset to use for the segment.\n     *\n     * @param {number} segmentTimeline\n     *        The timeline of the segment\n     * @param {number} currentTimeline\n     *        The timeline currently being followed by the loader\n     * @param {number} startOfSegment\n     *        The estimated segment start\n     * @param {TimeRange[]} buffered\n     *        The loader's buffer\n     * @param {boolean} overrideCheck\n     *        If true, no checks are made to see if the timestamp offset value should be set,\n     *        but sets it directly to a value.\n     *\n     * @return {number|null}\n     *         Either a number representing a new timestamp offset, or null if the segment is\n     *         part of the same timeline\n     */\n\n    const timestampOffsetForSegment = ({\n                                           segmentTimeline,\n                                           currentTimeline,\n                                           startOfSegment,\n                                           buffered,\n                                           overrideCheck\n                                       }) => {\n        // Check to see if we are crossing a discontinuity to see if we need to set the\n        // timestamp offset on the transmuxer and source buffer.\n        //\n        // Previously, we changed the timestampOffset if the start of this segment was less than\n        // the currently set timestampOffset, but this isn't desirable as it can produce bad\n        // behavior, especially around long running live streams.\n        if (!overrideCheck && segmentTimeline === currentTimeline) {\n            return null;\n        } // When changing renditions, it's possible to request a segment on an older timeline. For\n        // instance, given two renditions with the following:\n        //\n        // #EXTINF:10\n        // segment1\n        // #EXT-X-DISCONTINUITY\n        // #EXTINF:10\n        // segment2\n        // #EXTINF:10\n        // segment3\n        //\n        // And the current player state:\n        //\n        // current time: 8\n        // buffer: 0 => 20\n        //\n        // The next segment on the current rendition would be segment3, filling the buffer from\n        // 20s onwards. However, if a rendition switch happens after segment2 was requested,\n        // then the next segment to be requested will be segment1 from the new rendition in\n        // order to fill time 8 and onwards. Using the buffered end would result in repeated\n        // content (since it would position segment1 of the new rendition starting at 20s). This\n        // case can be identified when the new segment's timeline is a prior value. Instead of\n        // using the buffered end, the startOfSegment can be used, which, hopefully, will be\n        // more accurate to the actual start time of the segment.\n\n        if (segmentTimeline < currentTimeline) {\n            return startOfSegment;\n        } // segmentInfo.startOfSegment used to be used as the timestamp offset, however, that\n        // value uses the end of the last segment if it is available. While this value\n        // should often be correct, it's better to rely on the buffered end, as the new\n        // content post discontinuity should line up with the buffered end as if it were\n        // time 0 for the new content.\n\n        return buffered.length ? buffered.end(buffered.length - 1) : startOfSegment;\n    };\n    /**\n     * Returns whether or not the loader should wait for a timeline change from the timeline\n     * change controller before processing the segment.\n     *\n     * Primary timing in VHS goes by video. This is different from most media players, as\n     * audio is more often used as the primary timing source. For the foreseeable future, VHS\n     * will continue to use video as the primary timing source, due to the current logic and\n     * expectations built around it.\n\n     * Since the timing follows video, in order to maintain sync, the video loader is\n     * responsible for setting both audio and video source buffer timestamp offsets.\n     *\n     * Setting different values for audio and video source buffers could lead to\n     * desyncing. The following examples demonstrate some of the situations where this\n     * distinction is important. Note that all of these cases involve demuxed content. When\n     * content is muxed, the audio and video are packaged together, therefore syncing\n     * separate media playlists is not an issue.\n     *\n     * CASE 1: Audio prepares to load a new timeline before video:\n     *\n     * Timeline:       0                 1\n     * Audio Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n     * Audio Loader:                     ^\n     * Video Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n     * Video Loader              ^\n     *\n     * In the above example, the audio loader is preparing to load the 6th segment, the first\n     * after a discontinuity, while the video loader is still loading the 5th segment, before\n     * the discontinuity.\n     *\n     * If the audio loader goes ahead and loads and appends the 6th segment before the video\n     * loader crosses the discontinuity, then when appended, the 6th audio segment will use\n     * the timestamp offset from timeline 0. This will likely lead to desyncing. In addition,\n     * the audio loader must provide the audioAppendStart value to trim the content in the\n     * transmuxer, and that value relies on the audio timestamp offset. Since the audio\n     * timestamp offset is set by the video (main) loader, the audio loader shouldn't load the\n     * segment until that value is provided.\n     *\n     * CASE 2: Video prepares to load a new timeline before audio:\n     *\n     * Timeline:       0                 1\n     * Audio Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n     * Audio Loader:             ^\n     * Video Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n     * Video Loader                      ^\n     *\n     * In the above example, the video loader is preparing to load the 6th segment, the first\n     * after a discontinuity, while the audio loader is still loading the 5th segment, before\n     * the discontinuity.\n     *\n     * If the video loader goes ahead and loads and appends the 6th segment, then once the\n     * segment is loaded and processed, both the video and audio timestamp offsets will be\n     * set, since video is used as the primary timing source. This is to ensure content lines\n     * up appropriately, as any modifications to the video timing are reflected by audio when\n     * the video loader sets the audio and video timestamp offsets to the same value. However,\n     * setting the timestamp offset for audio before audio has had a chance to change\n     * timelines will likely lead to desyncing, as the audio loader will append segment 5 with\n     * a timestamp intended to apply to segments from timeline 1 rather than timeline 0.\n     *\n     * CASE 3: When seeking, audio prepares to load a new timeline before video\n     *\n     * Timeline:       0                 1\n     * Audio Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n     * Audio Loader:           ^\n     * Video Segments: 0 1 2 3 4 5 DISCO 6 7 8 9\n     * Video Loader            ^\n     *\n     * In the above example, both audio and video loaders are loading segments from timeline\n     * 0, but imagine that the seek originated from timeline 1.\n     *\n     * When seeking to a new timeline, the timestamp offset will be set based on the expected\n     * segment start of the loaded video segment. In order to maintain sync, the audio loader\n     * must wait for the video loader to load its segment and update both the audio and video\n     * timestamp offsets before it may load and append its own segment. This is the case\n     * whether the seek results in a mismatched segment request (e.g., the audio loader\n     * chooses to load segment 3 and the video loader chooses to load segment 4) or the\n     * loaders choose to load the same segment index from each playlist, as the segments may\n     * not be aligned perfectly, even for matching segment indexes.\n     *\n     * @param {Object} timelinechangeController\n     * @param {number} currentTimeline\n     *        The timeline currently being followed by the loader\n     * @param {number} segmentTimeline\n     *        The timeline of the segment being loaded\n     * @param {('main'|'audio')} loaderType\n     *        The loader type\n     * @param {boolean} audioDisabled\n     *        Whether the audio is disabled for the loader. This should only be true when the\n     *        loader may have muxed audio in its segment, but should not append it, e.g., for\n     *        the main loader when an alternate audio playlist is active.\n     *\n     * @return {boolean}\n     *         Whether the loader should wait for a timeline change from the timeline change\n     *         controller before processing the segment\n     */\n\n    const shouldWaitForTimelineChange = ({\n                                             timelineChangeController,\n                                             currentTimeline,\n                                             segmentTimeline,\n                                             loaderType,\n                                             audioDisabled\n                                         }) => {\n        if (currentTimeline === segmentTimeline) {\n            return false;\n        }\n        if (loaderType === 'audio') {\n            const lastMainTimelineChange = timelineChangeController.lastTimelineChange({\n                type: 'main'\n            }); // Audio loader should wait if:\n            //\n            // * main hasn't had a timeline change yet (thus has not loaded its first segment)\n            // * main hasn't yet changed to the timeline audio is looking to load\n\n            return !lastMainTimelineChange || lastMainTimelineChange.to !== segmentTimeline;\n        } // The main loader only needs to wait for timeline changes if there's demuxed audio.\n        // Otherwise, there's nothing to wait for, since audio would be muxed into the main\n        // loader's segments (or the content is audio/video only and handled by the main\n        // loader).\n\n        if (loaderType === 'main' && audioDisabled) {\n            const pendingAudioTimelineChange = timelineChangeController.pendingTimelineChange({\n                type: 'audio'\n            }); // Main loader should wait for the audio loader if audio is not pending a timeline\n            // change to the current timeline.\n            //\n            // Since the main loader is responsible for setting the timestamp offset for both\n            // audio and video, the main loader must wait for audio to be about to change to its\n            // timeline before setting the offset, otherwise, if audio is behind in loading,\n            // segments from the previous timeline would be adjusted by the new timestamp offset.\n            //\n            // This requirement means that video will not cross a timeline until the audio is\n            // about to cross to it, so that way audio and video will always cross the timeline\n            // together.\n            //\n            // In addition to normal timeline changes, these rules also apply to the start of a\n            // stream (going from a non-existent timeline, -1, to timeline 0). It's important\n            // that these rules apply to the first timeline change because if they did not, it's\n            // possible that the main loader will cross two timelines before the audio loader has\n            // crossed one. Logic may be implemented to handle the startup as a special case, but\n            // it's easier to simply treat all timeline changes the same.\n\n            if (pendingAudioTimelineChange && pendingAudioTimelineChange.to === segmentTimeline) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    };\n    const mediaDuration = timingInfos => {\n        let maxDuration = 0;\n        ['video', 'audio'].forEach(function (type) {\n            const typeTimingInfo = timingInfos[`${type}TimingInfo`];\n            if (!typeTimingInfo) {\n                return;\n            }\n            const {\n                start,\n                end\n            } = typeTimingInfo;\n            let duration;\n            if (typeof start === 'bigint' || typeof end === 'bigint') {\n                duration = window.BigInt(end) - window.BigInt(start);\n            } else if (typeof start === 'number' && typeof end === 'number') {\n                duration = end - start;\n            }\n            if (typeof duration !== 'undefined' && duration > maxDuration) {\n                maxDuration = duration;\n            }\n        }); // convert back to a number if it is lower than MAX_SAFE_INTEGER\n        // as we only need BigInt when we are above that.\n\n        if (typeof maxDuration === 'bigint' && maxDuration < Number.MAX_SAFE_INTEGER) {\n            maxDuration = Number(maxDuration);\n        }\n        return maxDuration;\n    };\n    const segmentTooLong = ({\n                                segmentDuration,\n                                maxDuration\n                            }) => {\n        // 0 duration segments are most likely due to metadata only segments or a lack of\n        // information.\n        if (!segmentDuration) {\n            return false;\n        } // For HLS:\n        //\n        // https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1\n        // The EXTINF duration of each Media Segment in the Playlist\n        // file, when rounded to the nearest integer, MUST be less than or equal\n        // to the target duration; longer segments can trigger playback stalls\n        // or other errors.\n        //\n        // For DASH, the mpd-parser uses the largest reported segment duration as the target\n        // duration. Although that reported duration is occasionally approximate (i.e., not\n        // exact), a strict check may report that a segment is too long more often in DASH.\n\n        return Math.round(segmentDuration) > maxDuration + TIME_FUDGE_FACTOR;\n    };\n    const getTroublesomeSegmentDurationMessage = (segmentInfo, sourceType) => {\n        // Right now we aren't following DASH's timing model exactly, so only perform\n        // this check for HLS content.\n        if (sourceType !== 'hls') {\n            return null;\n        }\n        const segmentDuration = mediaDuration({\n            audioTimingInfo: segmentInfo.audioTimingInfo,\n            videoTimingInfo: segmentInfo.videoTimingInfo\n        }); // Don't report if we lack information.\n        //\n        // If the segment has a duration of 0 it is either a lack of information or a\n        // metadata only segment and shouldn't be reported here.\n\n        if (!segmentDuration) {\n            return null;\n        }\n        const targetDuration = segmentInfo.playlist.targetDuration;\n        const isSegmentWayTooLong = segmentTooLong({\n            segmentDuration,\n            maxDuration: targetDuration * 2\n        });\n        const isSegmentSlightlyTooLong = segmentTooLong({\n            segmentDuration,\n            maxDuration: targetDuration\n        });\n        const segmentTooLongMessage = `Segment with index ${segmentInfo.mediaIndex} ` + `from playlist ${segmentInfo.playlist.id} ` + `has a duration of ${segmentDuration} ` + `when the reported duration is ${segmentInfo.duration} ` + `and the target duration is ${targetDuration}. ` + 'For HLS content, a duration in excess of the target duration may result in ' + 'playback issues. See the HLS specification section on EXT-X-TARGETDURATION for ' + 'more details: ' + 'https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1';\n        if (isSegmentWayTooLong || isSegmentSlightlyTooLong) {\n            return {\n                severity: isSegmentWayTooLong ? 'warn' : 'info',\n                message: segmentTooLongMessage\n            };\n        }\n        return null;\n    };\n    /**\n     * An object that manages segment loading and appending.\n     *\n     * @class SegmentLoader\n     * @param {Object} options required and optional options\n     * @extends videojs.EventTarget\n     */\n\n    class SegmentLoader extends videojs.EventTarget {\n        constructor(settings, options = {}) {\n            super(); // check pre-conditions\n\n            if (!settings) {\n                throw new TypeError('Initialization settings are required');\n            }\n            if (typeof settings.currentTime !== 'function') {\n                throw new TypeError('No currentTime getter specified');\n            }\n            if (!settings.mediaSource) {\n                throw new TypeError('No MediaSource specified');\n            } // public properties\n\n            this.bandwidth = settings.bandwidth;\n            this.throughput = {\n                rate: 0,\n                count: 0\n            };\n            this.roundTrip = NaN;\n            this.resetStats_();\n            this.mediaIndex = null;\n            this.partIndex = null; // private settings\n\n            this.hasPlayed_ = settings.hasPlayed;\n            this.currentTime_ = settings.currentTime;\n            this.seekable_ = settings.seekable;\n            this.seeking_ = settings.seeking;\n            this.duration_ = settings.duration;\n            this.mediaSource_ = settings.mediaSource;\n            this.vhs_ = settings.vhs;\n            this.loaderType_ = settings.loaderType;\n            this.currentMediaInfo_ = void 0;\n            this.startingMediaInfo_ = void 0;\n            this.segmentMetadataTrack_ = settings.segmentMetadataTrack;\n            this.goalBufferLength_ = settings.goalBufferLength;\n            this.sourceType_ = settings.sourceType;\n            this.sourceUpdater_ = settings.sourceUpdater;\n            this.inbandTextTracks_ = settings.inbandTextTracks;\n            this.state_ = 'INIT';\n            this.timelineChangeController_ = settings.timelineChangeController;\n            this.shouldSaveSegmentTimingInfo_ = true;\n            this.parse708captions_ = settings.parse708captions;\n            this.useDtsForTimestampOffset_ = settings.useDtsForTimestampOffset;\n            this.captionServices_ = settings.captionServices;\n            this.exactManifestTimings = settings.exactManifestTimings; // private instance variables\n\n            this.checkBufferTimeout_ = null;\n            this.error_ = void 0;\n            this.currentTimeline_ = -1;\n            this.pendingSegment_ = null;\n            this.xhrOptions_ = null;\n            this.pendingSegments_ = [];\n            this.audioDisabled_ = false;\n            this.isPendingTimestampOffset_ = false; // TODO possibly move gopBuffer and timeMapping info to a separate controller\n\n            this.gopBuffer_ = [];\n            this.timeMapping_ = 0;\n            this.safeAppend_ = videojs.browser.IE_VERSION >= 11;\n            this.appendInitSegment_ = {\n                audio: true,\n                video: true\n            };\n            this.playlistOfLastInitSegment_ = {\n                audio: null,\n                video: null\n            };\n            this.callQueue_ = []; // If the segment loader prepares to load a segment, but does not have enough\n            // information yet to start the loading process (e.g., if the audio loader wants to\n            // load a segment from the next timeline but the main loader hasn't yet crossed that\n            // timeline), then the load call will be added to the queue until it is ready to be\n            // processed.\n\n            this.loadQueue_ = [];\n            this.metadataQueue_ = {\n                id3: [],\n                caption: []\n            };\n            this.waitingOnRemove_ = false;\n            this.quotaExceededErrorRetryTimeout_ = null; // Fragmented mp4 playback\n\n            this.activeInitSegmentId_ = null;\n            this.initSegments_ = {}; // HLSe playback\n\n            this.cacheEncryptionKeys_ = settings.cacheEncryptionKeys;\n            this.keyCache_ = {};\n            this.decrypter_ = settings.decrypter; // Manages the tracking and generation of sync-points, mappings\n            // between a time in the display time and a segment index within\n            // a playlist\n\n            this.syncController_ = settings.syncController;\n            this.syncPoint_ = {\n                segmentIndex: 0,\n                time: 0\n            };\n            this.transmuxer_ = this.createTransmuxer_();\n            this.triggerSyncInfoUpdate_ = () => this.trigger('syncinfoupdate');\n            this.syncController_.on('syncinfoupdate', this.triggerSyncInfoUpdate_);\n            this.mediaSource_.addEventListener('sourceopen', () => {\n                if (!this.isEndOfStream_()) {\n                    this.ended_ = false;\n                }\n            }); // ...for determining the fetch location\n\n            this.fetchAtBuffer_ = false;\n            this.logger_ = logger(`SegmentLoader[${this.loaderType_}]`);\n            Object.defineProperty(this, 'state', {\n                get() {\n                    return this.state_;\n                },\n                set(newState) {\n                    if (newState !== this.state_) {\n                        this.logger_(`${this.state_} -> ${newState}`);\n                        this.state_ = newState;\n                        this.trigger('statechange');\n                    }\n                }\n            });\n            this.sourceUpdater_.on('ready', () => {\n                if (this.hasEnoughInfoToAppend_()) {\n                    this.processCallQueue_();\n                }\n            }); // Only the main loader needs to listen for pending timeline changes, as the main\n            // loader should wait for audio to be ready to change its timeline so that both main\n            // and audio timelines change together. For more details, see the\n            // shouldWaitForTimelineChange function.\n\n            if (this.loaderType_ === 'main') {\n                this.timelineChangeController_.on('pendingtimelinechange', () => {\n                    if (this.hasEnoughInfoToAppend_()) {\n                        this.processCallQueue_();\n                    }\n                });\n            } // The main loader only listens on pending timeline changes, but the audio loader,\n            // since its loads follow main, needs to listen on timeline changes. For more details,\n            // see the shouldWaitForTimelineChange function.\n\n            if (this.loaderType_ === 'audio') {\n                this.timelineChangeController_.on('timelinechange', () => {\n                    if (this.hasEnoughInfoToLoad_()) {\n                        this.processLoadQueue_();\n                    }\n                    if (this.hasEnoughInfoToAppend_()) {\n                        this.processCallQueue_();\n                    }\n                });\n            }\n        }\n        createTransmuxer_() {\n            return segmentTransmuxer.createTransmuxer({\n                remux: false,\n                alignGopsAtEnd: this.safeAppend_,\n                keepOriginalTimestamps: true,\n                parse708captions: this.parse708captions_,\n                captionServices: this.captionServices_\n            });\n        }\n        /**\n         * reset all of our media stats\n         *\n         * @private\n         */\n\n        resetStats_() {\n            this.mediaBytesTransferred = 0;\n            this.mediaRequests = 0;\n            this.mediaRequestsAborted = 0;\n            this.mediaRequestsTimedout = 0;\n            this.mediaRequestsErrored = 0;\n            this.mediaTransferDuration = 0;\n            this.mediaSecondsLoaded = 0;\n            this.mediaAppends = 0;\n        }\n        /**\n         * dispose of the SegmentLoader and reset to the default state\n         */\n\n        dispose() {\n            this.trigger('dispose');\n            this.state = 'DISPOSED';\n            this.pause();\n            this.abort_();\n            if (this.transmuxer_) {\n                this.transmuxer_.terminate();\n            }\n            this.resetStats_();\n            if (this.checkBufferTimeout_) {\n                window.clearTimeout(this.checkBufferTimeout_);\n            }\n            if (this.syncController_ && this.triggerSyncInfoUpdate_) {\n                this.syncController_.off('syncinfoupdate', this.triggerSyncInfoUpdate_);\n            }\n            this.off();\n        }\n        setAudio(enable) {\n            this.audioDisabled_ = !enable;\n            if (enable) {\n                this.appendInitSegment_.audio = true;\n            } else {\n                // remove current track audio if it gets disabled\n                this.sourceUpdater_.removeAudio(0, this.duration_());\n            }\n        }\n        /**\n         * abort anything that is currently doing on with the SegmentLoader\n         * and reset to a default state\n         */\n\n        abort() {\n            if (this.state !== 'WAITING') {\n                if (this.pendingSegment_) {\n                    this.pendingSegment_ = null;\n                }\n                return;\n            }\n            this.abort_(); // We aborted the requests we were waiting on, so reset the loader's state to READY\n            // since we are no longer \"waiting\" on any requests. XHR callback is not always run\n            // when the request is aborted. This will prevent the loader from being stuck in the\n            // WAITING state indefinitely.\n\n            this.state = 'READY'; // don't wait for buffer check timeouts to begin fetching the\n            // next segment\n\n            if (!this.paused()) {\n                this.monitorBuffer_();\n            }\n        }\n        /**\n         * abort all pending xhr requests and null any pending segements\n         *\n         * @private\n         */\n\n        abort_() {\n            if (this.pendingSegment_ && this.pendingSegment_.abortRequests) {\n                this.pendingSegment_.abortRequests();\n            } // clear out the segment being processed\n\n            this.pendingSegment_ = null;\n            this.callQueue_ = [];\n            this.loadQueue_ = [];\n            this.metadataQueue_.id3 = [];\n            this.metadataQueue_.caption = [];\n            this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_);\n            this.waitingOnRemove_ = false;\n            window.clearTimeout(this.quotaExceededErrorRetryTimeout_);\n            this.quotaExceededErrorRetryTimeout_ = null;\n        }\n        checkForAbort_(requestId) {\n            // If the state is APPENDING, then aborts will not modify the state, meaning the first\n            // callback that happens should reset the state to READY so that loading can continue.\n            if (this.state === 'APPENDING' && !this.pendingSegment_) {\n                this.state = 'READY';\n                return true;\n            }\n            if (!this.pendingSegment_ || this.pendingSegment_.requestId !== requestId) {\n                return true;\n            }\n            return false;\n        }\n        /**\n         * set an error on the segment loader and null out any pending segements\n         *\n         * @param {Error} error the error to set on the SegmentLoader\n         * @return {Error} the error that was set or that is currently set\n         */\n\n        error(error) {\n            if (typeof error !== 'undefined') {\n                this.logger_('error occurred:', error);\n                this.error_ = error;\n            }\n            this.pendingSegment_ = null;\n            return this.error_;\n        }\n        endOfStream() {\n            this.ended_ = true;\n            if (this.transmuxer_) {\n                // need to clear out any cached data to prepare for the new segment\n                segmentTransmuxer.reset(this.transmuxer_);\n            }\n            this.gopBuffer_.length = 0;\n            this.pause();\n            this.trigger('ended');\n        }\n        /**\n         * Indicates which time ranges are buffered\n         *\n         * @return {TimeRange}\n         *         TimeRange object representing the current buffered ranges\n         */\n\n        buffered_() {\n            const trackInfo = this.getMediaInfo_();\n            if (!this.sourceUpdater_ || !trackInfo) {\n                return createTimeRanges();\n            }\n            if (this.loaderType_ === 'main') {\n                const {\n                    hasAudio,\n                    hasVideo,\n                    isMuxed\n                } = trackInfo;\n                if (hasVideo && hasAudio && !this.audioDisabled_ && !isMuxed) {\n                    return this.sourceUpdater_.buffered();\n                }\n                if (hasVideo) {\n                    return this.sourceUpdater_.videoBuffered();\n                }\n            } // One case that can be ignored for now is audio only with alt audio,\n            // as we don't yet have proper support for that.\n\n            return this.sourceUpdater_.audioBuffered();\n        }\n        /**\n         * Gets and sets init segment for the provided map\n         *\n         * @param {Object} map\n         *        The map object representing the init segment to get or set\n         * @param {boolean=} set\n         *        If true, the init segment for the provided map should be saved\n         * @return {Object}\n         *         map object for desired init segment\n         */\n\n        initSegmentForMap(map, set = false) {\n            if (!map) {\n                return null;\n            }\n            const id = initSegmentId(map);\n            let storedMap = this.initSegments_[id];\n            if (set && !storedMap && map.bytes) {\n                this.initSegments_[id] = storedMap = {\n                    resolvedUri: map.resolvedUri,\n                    byterange: map.byterange,\n                    bytes: map.bytes,\n                    tracks: map.tracks,\n                    timescales: map.timescales\n                };\n            }\n            return storedMap || map;\n        }\n        /**\n         * Gets and sets key for the provided key\n         *\n         * @param {Object} key\n         *        The key object representing the key to get or set\n         * @param {boolean=} set\n         *        If true, the key for the provided key should be saved\n         * @return {Object}\n         *         Key object for desired key\n         */\n\n        segmentKey(key, set = false) {\n            if (!key) {\n                return null;\n            }\n            const id = segmentKeyId(key);\n            let storedKey = this.keyCache_[id]; // TODO: We should use the HTTP Expires header to invalidate our cache per\n            // https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-6.2.3\n\n            if (this.cacheEncryptionKeys_ && set && !storedKey && key.bytes) {\n                this.keyCache_[id] = storedKey = {\n                    resolvedUri: key.resolvedUri,\n                    bytes: key.bytes\n                };\n            }\n            const result = {\n                resolvedUri: (storedKey || key).resolvedUri\n            };\n            if (storedKey) {\n                result.bytes = storedKey.bytes;\n            }\n            return result;\n        }\n        /**\n         * Returns true if all configuration required for loading is present, otherwise false.\n         *\n         * @return {boolean} True if the all configuration is ready for loading\n         * @private\n         */\n\n        couldBeginLoading_() {\n            return this.playlist_ && !this.paused();\n        }\n        /**\n         * load a playlist and start to fill the buffer\n         */\n\n        load() {\n            // un-pause\n            this.monitorBuffer_(); // if we don't have a playlist yet, keep waiting for one to be\n            // specified\n\n            if (!this.playlist_) {\n                return;\n            } // if all the configuration is ready, initialize and begin loading\n\n            if (this.state === 'INIT' && this.couldBeginLoading_()) {\n                return this.init_();\n            } // if we're in the middle of processing a segment already, don't\n            // kick off an additional segment request\n\n            if (!this.couldBeginLoading_() || this.state !== 'READY' && this.state !== 'INIT') {\n                return;\n            }\n            this.state = 'READY';\n        }\n        /**\n         * Once all the starting parameters have been specified, begin\n         * operation. This method should only be invoked from the INIT\n         * state.\n         *\n         * @private\n         */\n\n        init_() {\n            this.state = 'READY'; // if this is the audio segment loader, and it hasn't been inited before, then any old\n            // audio data from the muxed content should be removed\n\n            this.resetEverything();\n            return this.monitorBuffer_();\n        }\n        /**\n         * set a playlist on the segment loader\n         *\n         * @param {PlaylistLoader} media the playlist to set on the segment loader\n         */\n\n        playlist(newPlaylist, options = {}) {\n            if (!newPlaylist) {\n                return;\n            }\n            const oldPlaylist = this.playlist_;\n            const segmentInfo = this.pendingSegment_;\n            this.playlist_ = newPlaylist;\n            this.xhrOptions_ = options; // when we haven't started playing yet, the start of a live playlist\n            // is always our zero-time so force a sync update each time the playlist\n            // is refreshed from the server\n            //\n            // Use the INIT state to determine if playback has started, as the playlist sync info\n            // should be fixed once requests begin (as sync points are generated based on sync\n            // info), but not before then.\n\n            if (this.state === 'INIT') {\n                newPlaylist.syncInfo = {\n                    mediaSequence: newPlaylist.mediaSequence,\n                    time: 0\n                }; // Setting the date time mapping means mapping the program date time (if available)\n                // to time 0 on the player's timeline. The playlist's syncInfo serves a similar\n                // purpose, mapping the initial mediaSequence to time zero. Since the syncInfo can\n                // be updated as the playlist is refreshed before the loader starts loading, the\n                // program date time mapping needs to be updated as well.\n                //\n                // This mapping is only done for the main loader because a program date time should\n                // map equivalently between playlists.\n\n                if (this.loaderType_ === 'main') {\n                    this.syncController_.setDateTimeMappingForStart(newPlaylist);\n                }\n            }\n            let oldId = null;\n            if (oldPlaylist) {\n                if (oldPlaylist.id) {\n                    oldId = oldPlaylist.id;\n                } else if (oldPlaylist.uri) {\n                    oldId = oldPlaylist.uri;\n                }\n            }\n            this.logger_(`playlist update [${oldId} => ${newPlaylist.id || newPlaylist.uri}]`); // in VOD, this is always a rendition switch (or we updated our syncInfo above)\n            // in LIVE, we always want to update with new playlists (including refreshes)\n\n            this.trigger('syncinfoupdate'); // if we were unpaused but waiting for a playlist, start\n            // buffering now\n\n            if (this.state === 'INIT' && this.couldBeginLoading_()) {\n                return this.init_();\n            }\n            if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {\n                if (this.mediaIndex !== null) {\n                    // we must reset/resync the segment loader when we switch renditions and\n                    // the segment loader is already synced to the previous rendition\n                    // on playlist changes we want it to be possible to fetch\n                    // at the buffer for vod but not for live. So we use resetLoader\n                    // for live and resyncLoader for vod. We want this because\n                    // if a playlist uses independent and non-independent segments/parts the\n                    // buffer may not accurately reflect the next segment that we should try\n                    // downloading.\n                    if (!newPlaylist.endList) {\n                        this.resetLoader();\n                    } else {\n                        this.resyncLoader();\n                    }\n                }\n                this.currentMediaInfo_ = void 0;\n                this.trigger('playlistupdate'); // the rest of this function depends on `oldPlaylist` being defined\n\n                return;\n            } // we reloaded the same playlist so we are in a live scenario\n            // and we will likely need to adjust the mediaIndex\n\n            const mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;\n            this.logger_(`live window shift [${mediaSequenceDiff}]`); // update the mediaIndex on the SegmentLoader\n            // this is important because we can abort a request and this value must be\n            // equal to the last appended mediaIndex\n\n            if (this.mediaIndex !== null) {\n                this.mediaIndex -= mediaSequenceDiff; // this can happen if we are going to load the first segment, but get a playlist\n                // update during that. mediaIndex would go from 0 to -1 if mediaSequence in the\n                // new playlist was incremented by 1.\n\n                if (this.mediaIndex < 0) {\n                    this.mediaIndex = null;\n                    this.partIndex = null;\n                } else {\n                    const segment = this.playlist_.segments[this.mediaIndex]; // partIndex should remain the same for the same segment\n                    // unless parts fell off of the playlist for this segment.\n                    // In that case we need to reset partIndex and resync\n\n                    if (this.partIndex && (!segment.parts || !segment.parts.length || !segment.parts[this.partIndex])) {\n                        const mediaIndex = this.mediaIndex;\n                        this.logger_(`currently processing part (index ${this.partIndex}) no longer exists.`);\n                        this.resetLoader(); // We want to throw away the partIndex and the data associated with it,\n                        // as the part was dropped from our current playlists segment.\n                        // The mediaIndex will still be valid so keep that around.\n\n                        this.mediaIndex = mediaIndex;\n                    }\n                }\n            } // update the mediaIndex on the SegmentInfo object\n            // this is important because we will update this.mediaIndex with this value\n            // in `handleAppendsDone_` after the segment has been successfully appended\n\n            if (segmentInfo) {\n                segmentInfo.mediaIndex -= mediaSequenceDiff;\n                if (segmentInfo.mediaIndex < 0) {\n                    segmentInfo.mediaIndex = null;\n                    segmentInfo.partIndex = null;\n                } else {\n                    // we need to update the referenced segment so that timing information is\n                    // saved for the new playlist's segment, however, if the segment fell off the\n                    // playlist, we can leave the old reference and just lose the timing info\n                    if (segmentInfo.mediaIndex >= 0) {\n                        segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];\n                    }\n                    if (segmentInfo.partIndex >= 0 && segmentInfo.segment.parts) {\n                        segmentInfo.part = segmentInfo.segment.parts[segmentInfo.partIndex];\n                    }\n                }\n            }\n            this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);\n        }\n        /**\n         * Prevent the loader from fetching additional segments. If there\n         * is a segment request outstanding, it will finish processing\n         * before the loader halts. A segment loader can be unpaused by\n         * calling load().\n         */\n\n        pause() {\n            if (this.checkBufferTimeout_) {\n                window.clearTimeout(this.checkBufferTimeout_);\n                this.checkBufferTimeout_ = null;\n            }\n        }\n        /**\n         * Returns whether the segment loader is fetching additional\n         * segments when given the opportunity. This property can be\n         * modified through calls to pause() and load().\n         */\n\n        paused() {\n            return this.checkBufferTimeout_ === null;\n        }\n        /**\n         * Delete all the buffered data and reset the SegmentLoader\n         *\n         * @param {Function} [done] an optional callback to be executed when the remove\n         * operation is complete\n         */\n\n        resetEverything(done) {\n            this.ended_ = false;\n            this.activeInitSegmentId_ = null;\n            this.appendInitSegment_ = {\n                audio: true,\n                video: true\n            };\n            this.resetLoader(); // remove from 0, the earliest point, to Infinity, to signify removal of everything.\n            // VTT Segment Loader doesn't need to do anything but in the regular SegmentLoader,\n            // we then clamp the value to duration if necessary.\n\n            this.remove(0, Infinity, done); // clears fmp4 captions\n\n            if (this.transmuxer_) {\n                this.transmuxer_.postMessage({\n                    action: 'clearAllMp4Captions'\n                }); // reset the cache in the transmuxer\n\n                this.transmuxer_.postMessage({\n                    action: 'reset'\n                });\n            }\n        }\n        /**\n         * Force the SegmentLoader to resync and start loading around the currentTime instead\n         * of starting at the end of the buffer\n         *\n         * Useful for fast quality changes\n         */\n\n        resetLoader() {\n            this.fetchAtBuffer_ = false;\n            this.resyncLoader();\n        }\n        /**\n         * Force the SegmentLoader to restart synchronization and make a conservative guess\n         * before returning to the simple walk-forward method\n         */\n\n        resyncLoader() {\n            if (this.transmuxer_) {\n                // need to clear out any cached data to prepare for the new segment\n                segmentTransmuxer.reset(this.transmuxer_);\n            }\n            this.mediaIndex = null;\n            this.partIndex = null;\n            this.syncPoint_ = null;\n            this.isPendingTimestampOffset_ = false;\n            this.callQueue_ = [];\n            this.loadQueue_ = [];\n            this.metadataQueue_.id3 = [];\n            this.metadataQueue_.caption = [];\n            this.abort();\n            if (this.transmuxer_) {\n                this.transmuxer_.postMessage({\n                    action: 'clearParsedMp4Captions'\n                });\n            }\n        }\n        /**\n         * Remove any data in the source buffer between start and end times\n         *\n         * @param {number} start - the start time of the region to remove from the buffer\n         * @param {number} end - the end time of the region to remove from the buffer\n         * @param {Function} [done] - an optional callback to be executed when the remove\n         * @param {boolean} force - force all remove operations to happen\n         * operation is complete\n         */\n\n        remove(start, end, done = () => {}, force = false) {\n            // clamp end to duration if we need to remove everything.\n            // This is due to a browser bug that causes issues if we remove to Infinity.\n            // videojs/videojs-contrib-hls#1225\n            if (end === Infinity) {\n                end = this.duration_();\n            } // skip removes that would throw an error\n            // commonly happens during a rendition switch at the start of a video\n            // from start 0 to end 0\n\n            if (end <= start) {\n                this.logger_('skipping remove because end ${end} is <= start ${start}');\n                return;\n            }\n            if (!this.sourceUpdater_ || !this.getMediaInfo_()) {\n                this.logger_('skipping remove because no source updater or starting media info'); // nothing to remove if we haven't processed any media\n\n                return;\n            } // set it to one to complete this function's removes\n\n            let removesRemaining = 1;\n            const removeFinished = () => {\n                removesRemaining--;\n                if (removesRemaining === 0) {\n                    done();\n                }\n            };\n            if (force || !this.audioDisabled_) {\n                removesRemaining++;\n                this.sourceUpdater_.removeAudio(start, end, removeFinished);\n            } // While it would be better to only remove video if the main loader has video, this\n            // should be safe with audio only as removeVideo will call back even if there's no\n            // video buffer.\n            //\n            // In theory we can check to see if there's video before calling the remove, but in\n            // the event that we're switching between renditions and from video to audio only\n            // (when we add support for that), we may need to clear the video contents despite\n            // what the new media will contain.\n\n            if (force || this.loaderType_ === 'main') {\n                this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start, end, this.timeMapping_);\n                removesRemaining++;\n                this.sourceUpdater_.removeVideo(start, end, removeFinished);\n            } // remove any captions and ID3 tags\n\n            for (const track in this.inbandTextTracks_) {\n                removeCuesFromTrack(start, end, this.inbandTextTracks_[track]);\n            }\n            removeCuesFromTrack(start, end, this.segmentMetadataTrack_); // finished this function's removes\n\n            removeFinished();\n        }\n        /**\n         * (re-)schedule monitorBufferTick_ to run as soon as possible\n         *\n         * @private\n         */\n\n        monitorBuffer_() {\n            if (this.checkBufferTimeout_) {\n                window.clearTimeout(this.checkBufferTimeout_);\n            }\n            this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), 1);\n        }\n        /**\n         * As long as the SegmentLoader is in the READY state, periodically\n         * invoke fillBuffer_().\n         *\n         * @private\n         */\n\n        monitorBufferTick_() {\n            if (this.state === 'READY') {\n                this.fillBuffer_();\n            }\n            if (this.checkBufferTimeout_) {\n                window.clearTimeout(this.checkBufferTimeout_);\n            }\n            this.checkBufferTimeout_ = window.setTimeout(this.monitorBufferTick_.bind(this), CHECK_BUFFER_DELAY);\n        }\n        /**\n         * fill the buffer with segements unless the sourceBuffers are\n         * currently updating\n         *\n         * Note: this function should only ever be called by monitorBuffer_\n         * and never directly\n         *\n         * @private\n         */\n\n        fillBuffer_() {\n            // TODO since the source buffer maintains a queue, and we shouldn't call this function\n            // except when we're ready for the next segment, this check can most likely be removed\n            if (this.sourceUpdater_.updating()) {\n                return;\n            } // see if we need to begin loading immediately\n\n            const segmentInfo = this.chooseNextRequest_();\n            if (!segmentInfo) {\n                return;\n            }\n            if (typeof segmentInfo.timestampOffset === 'number') {\n                this.isPendingTimestampOffset_ = false;\n                this.timelineChangeController_.pendingTimelineChange({\n                    type: this.loaderType_,\n                    from: this.currentTimeline_,\n                    to: segmentInfo.timeline\n                });\n            }\n            this.loadSegment_(segmentInfo);\n        }\n        /**\n         * Determines if we should call endOfStream on the media source based\n         * on the state of the buffer or if appened segment was the final\n         * segment in the playlist.\n         *\n         * @param {number} [mediaIndex] the media index of segment we last appended\n         * @param {Object} [playlist] a media playlist object\n         * @return {boolean} do we need to call endOfStream on the MediaSource\n         */\n\n        isEndOfStream_(mediaIndex = this.mediaIndex, playlist = this.playlist_, partIndex = this.partIndex) {\n            if (!playlist || !this.mediaSource_) {\n                return false;\n            }\n            const segment = typeof mediaIndex === 'number' && playlist.segments[mediaIndex]; // mediaIndex is zero based but length is 1 based\n\n            const appendedLastSegment = mediaIndex + 1 === playlist.segments.length; // true if there are no parts, or this is the last part.\n\n            const appendedLastPart = !segment || !segment.parts || partIndex + 1 === segment.parts.length; // if we've buffered to the end of the video, we need to call endOfStream\n            // so that MediaSources can trigger the `ended` event when it runs out of\n            // buffered data instead of waiting for me\n\n            return playlist.endList && this.mediaSource_.readyState === 'open' && appendedLastSegment && appendedLastPart;\n        }\n        /**\n         * Determines what request should be made given current segment loader state.\n         *\n         * @return {Object} a request object that describes the segment/part to load\n         */\n\n        chooseNextRequest_() {\n            const buffered = this.buffered_();\n            const bufferedEnd = lastBufferedEnd(buffered) || 0;\n            const bufferedTime = timeAheadOf(buffered, this.currentTime_());\n            const preloaded = !this.hasPlayed_() && bufferedTime >= 1;\n            const haveEnoughBuffer = bufferedTime >= this.goalBufferLength_();\n            const segments = this.playlist_.segments; // return no segment if:\n            // 1. we don't have segments\n            // 2. The video has not yet played and we already downloaded a segment\n            // 3. we already have enough buffered time\n\n            if (!segments.length || preloaded || haveEnoughBuffer) {\n                return null;\n            }\n            this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());\n            const next = {\n                partIndex: null,\n                mediaIndex: null,\n                startOfSegment: null,\n                playlist: this.playlist_,\n                isSyncRequest: Boolean(!this.syncPoint_)\n            };\n            if (next.isSyncRequest) {\n                next.mediaIndex = getSyncSegmentCandidate(this.currentTimeline_, segments, bufferedEnd);\n            } else if (this.mediaIndex !== null) {\n                const segment = segments[this.mediaIndex];\n                const partIndex = typeof this.partIndex === 'number' ? this.partIndex : -1;\n                next.startOfSegment = segment.end ? segment.end : bufferedEnd;\n                if (segment.parts && segment.parts[partIndex + 1]) {\n                    next.mediaIndex = this.mediaIndex;\n                    next.partIndex = partIndex + 1;\n                } else {\n                    next.mediaIndex = this.mediaIndex + 1;\n                }\n            } else {\n                // Find the segment containing the end of the buffer or current time.\n                const {\n                    segmentIndex,\n                    startTime,\n                    partIndex\n                } = Playlist.getMediaInfoForTime({\n                    exactManifestTimings: this.exactManifestTimings,\n                    playlist: this.playlist_,\n                    currentTime: this.fetchAtBuffer_ ? bufferedEnd : this.currentTime_(),\n                    startingPartIndex: this.syncPoint_.partIndex,\n                    startingSegmentIndex: this.syncPoint_.segmentIndex,\n                    startTime: this.syncPoint_.time\n                });\n                next.getMediaInfoForTime = this.fetchAtBuffer_ ? `bufferedEnd ${bufferedEnd}` : `currentTime ${this.currentTime_()}`;\n                next.mediaIndex = segmentIndex;\n                next.startOfSegment = startTime;\n                next.partIndex = partIndex;\n            }\n            const nextSegment = segments[next.mediaIndex];\n            let nextPart = nextSegment && typeof next.partIndex === 'number' && nextSegment.parts && nextSegment.parts[next.partIndex]; // if the next segment index is invalid or\n            // the next partIndex is invalid do not choose a next segment.\n\n            if (!nextSegment || typeof next.partIndex === 'number' && !nextPart) {\n                return null;\n            } // if the next segment has parts, and we don't have a partIndex.\n            // Set partIndex to 0\n\n            if (typeof next.partIndex !== 'number' && nextSegment.parts) {\n                next.partIndex = 0;\n                nextPart = nextSegment.parts[0];\n            } // if we have no buffered data then we need to make sure\n            // that the next part we append is \"independent\" if possible.\n            // So we check if the previous part is independent, and request\n            // it if it is.\n\n            if (!bufferedTime && nextPart && !nextPart.independent) {\n                if (next.partIndex === 0) {\n                    const lastSegment = segments[next.mediaIndex - 1];\n                    const lastSegmentLastPart = lastSegment.parts && lastSegment.parts.length && lastSegment.parts[lastSegment.parts.length - 1];\n                    if (lastSegmentLastPart && lastSegmentLastPart.independent) {\n                        next.mediaIndex -= 1;\n                        next.partIndex = lastSegment.parts.length - 1;\n                        next.independent = 'previous segment';\n                    }\n                } else if (nextSegment.parts[next.partIndex - 1].independent) {\n                    next.partIndex -= 1;\n                    next.independent = 'previous part';\n                }\n            }\n            const ended = this.mediaSource_ && this.mediaSource_.readyState === 'ended'; // do not choose a next segment if all of the following:\n            // 1. this is the last segment in the playlist\n            // 2. end of stream has been called on the media source already\n            // 3. the player is not seeking\n\n            if (next.mediaIndex >= segments.length - 1 && ended && !this.seeking_()) {\n                return null;\n            }\n            return this.generateSegmentInfo_(next);\n        }\n        generateSegmentInfo_(options) {\n            const {\n                independent,\n                playlist,\n                mediaIndex,\n                startOfSegment,\n                isSyncRequest,\n                partIndex,\n                forceTimestampOffset,\n                getMediaInfoForTime\n            } = options;\n            const segment = playlist.segments[mediaIndex];\n            const part = typeof partIndex === 'number' && segment.parts[partIndex];\n            const segmentInfo = {\n                requestId: 'segment-loader-' + Math.random(),\n                // resolve the segment URL relative to the playlist\n                uri: part && part.resolvedUri || segment.resolvedUri,\n                // the segment's mediaIndex at the time it was requested\n                mediaIndex,\n                partIndex: part ? partIndex : null,\n                // whether or not to update the SegmentLoader's state with this\n                // segment's mediaIndex\n                isSyncRequest,\n                startOfSegment,\n                // the segment's playlist\n                playlist,\n                // unencrypted bytes of the segment\n                bytes: null,\n                // when a key is defined for this segment, the encrypted bytes\n                encryptedBytes: null,\n                // The target timestampOffset for this segment when we append it\n                // to the source buffer\n                timestampOffset: null,\n                // The timeline that the segment is in\n                timeline: segment.timeline,\n                // The expected duration of the segment in seconds\n                duration: part && part.duration || segment.duration,\n                // retain the segment in case the playlist updates while doing an async process\n                segment,\n                part,\n                byteLength: 0,\n                transmuxer: this.transmuxer_,\n                // type of getMediaInfoForTime that was used to get this segment\n                getMediaInfoForTime,\n                independent\n            };\n            const overrideCheck = typeof forceTimestampOffset !== 'undefined' ? forceTimestampOffset : this.isPendingTimestampOffset_;\n            segmentInfo.timestampOffset = this.timestampOffsetForSegment_({\n                segmentTimeline: segment.timeline,\n                currentTimeline: this.currentTimeline_,\n                startOfSegment,\n                buffered: this.buffered_(),\n                overrideCheck\n            });\n            const audioBufferedEnd = lastBufferedEnd(this.sourceUpdater_.audioBuffered());\n            if (typeof audioBufferedEnd === 'number') {\n                // since the transmuxer is using the actual timing values, but the buffer is\n                // adjusted by the timestamp offset, we must adjust the value here\n                segmentInfo.audioAppendStart = audioBufferedEnd - this.sourceUpdater_.audioTimestampOffset();\n            }\n            if (this.sourceUpdater_.videoBuffered().length) {\n                segmentInfo.gopsToAlignWith = gopsSafeToAlignWith(this.gopBuffer_,\n                    // since the transmuxer is using the actual timing values, but the time is\n                    // adjusted by the timestmap offset, we must adjust the value here\n                    this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(), this.timeMapping_);\n            }\n            return segmentInfo;\n        } // get the timestampoffset for a segment,\n        // added so that vtt segment loader can override and prevent\n        // adding timestamp offsets.\n\n        timestampOffsetForSegment_(options) {\n            return timestampOffsetForSegment(options);\n        }\n        /**\n         * Determines if the network has enough bandwidth to complete the current segment\n         * request in a timely manner. If not, the request will be aborted early and bandwidth\n         * updated to trigger a playlist switch.\n         *\n         * @param {Object} stats\n         *        Object containing stats about the request timing and size\n         * @private\n         */\n\n        earlyAbortWhenNeeded_(stats) {\n            if (this.vhs_.tech_.paused() ||\n                // Don't abort if the current playlist is on the lowestEnabledRendition\n                // TODO: Replace using timeout with a boolean indicating whether this playlist is\n                //       the lowestEnabledRendition.\n                !this.xhrOptions_.timeout ||\n                // Don't abort if we have no bandwidth information to estimate segment sizes\n                !this.playlist_.attributes.BANDWIDTH) {\n                return;\n            } // Wait at least 1 second since the first byte of data has been received before\n            // using the calculated bandwidth from the progress event to allow the bitrate\n            // to stabilize\n\n            if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1000) {\n                return;\n            }\n            const currentTime = this.currentTime_();\n            const measuredBandwidth = stats.bandwidth;\n            const segmentDuration = this.pendingSegment_.duration;\n            const requestTimeRemaining = Playlist.estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived); // Subtract 1 from the timeUntilRebuffer so we still consider an early abort\n            // if we are only left with less than 1 second when the request completes.\n            // A negative timeUntilRebuffering indicates we are already rebuffering\n\n            const timeUntilRebuffer$1 = timeUntilRebuffer(this.buffered_(), currentTime, this.vhs_.tech_.playbackRate()) - 1; // Only consider aborting early if the estimated time to finish the download\n            // is larger than the estimated time until the player runs out of forward buffer\n\n            if (requestTimeRemaining <= timeUntilRebuffer$1) {\n                return;\n            }\n            const switchCandidate = minRebufferMaxBandwidthSelector({\n                main: this.vhs_.playlists.main,\n                currentTime,\n                bandwidth: measuredBandwidth,\n                duration: this.duration_(),\n                segmentDuration,\n                timeUntilRebuffer: timeUntilRebuffer$1,\n                currentTimeline: this.currentTimeline_,\n                syncController: this.syncController_\n            });\n            if (!switchCandidate) {\n                return;\n            }\n            const rebufferingImpact = requestTimeRemaining - timeUntilRebuffer$1;\n            const timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;\n            let minimumTimeSaving = 0.5; // If we are already rebuffering, increase the amount of variance we add to the\n            // potential round trip time of the new request so that we are not too aggressive\n            // with switching to a playlist that might save us a fraction of a second.\n\n            if (timeUntilRebuffer$1 <= TIME_FUDGE_FACTOR) {\n                minimumTimeSaving = 1;\n            }\n            if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) {\n                return;\n            } // set the bandwidth to that of the desired playlist being sure to scale by\n            // BANDWIDTH_VARIANCE and add one so the playlist selector does not exclude it\n            // don't trigger a bandwidthupdate as the bandwidth is artifial\n\n            this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * Config.BANDWIDTH_VARIANCE + 1;\n            this.trigger('earlyabort');\n        }\n        handleAbort_(segmentInfo) {\n            this.logger_(`Aborting ${segmentInfoString(segmentInfo)}`);\n            this.mediaRequestsAborted += 1;\n        }\n        /**\n         * XHR `progress` event handler\n         *\n         * @param {Event}\n         *        The XHR `progress` event\n         * @param {Object} simpleSegment\n         *        A simplified segment object copy\n         * @private\n         */\n\n        handleProgress_(event, simpleSegment) {\n            this.earlyAbortWhenNeeded_(simpleSegment.stats);\n            if (this.checkForAbort_(simpleSegment.requestId)) {\n                return;\n            }\n            this.trigger('progress');\n        }\n        handleTrackInfo_(simpleSegment, trackInfo) {\n            this.earlyAbortWhenNeeded_(simpleSegment.stats);\n            if (this.checkForAbort_(simpleSegment.requestId)) {\n                return;\n            }\n            if (this.checkForIllegalMediaSwitch(trackInfo)) {\n                return;\n            }\n            trackInfo = trackInfo || {}; // When we have track info, determine what media types this loader is dealing with.\n            // Guard against cases where we're not getting track info at all until we are\n            // certain that all streams will provide it.\n\n            if (!shallowEqual(this.currentMediaInfo_, trackInfo)) {\n                this.appendInitSegment_ = {\n                    audio: true,\n                    video: true\n                };\n                this.startingMediaInfo_ = trackInfo;\n                this.currentMediaInfo_ = trackInfo;\n                this.logger_('trackinfo update', trackInfo);\n                this.trigger('trackinfo');\n            } // trackinfo may cause an abort if the trackinfo\n            // causes a codec change to an unsupported codec.\n\n            if (this.checkForAbort_(simpleSegment.requestId)) {\n                return;\n            } // set trackinfo on the pending segment so that\n            // it can append.\n\n            this.pendingSegment_.trackInfo = trackInfo; // check if any calls were waiting on the track info\n\n            if (this.hasEnoughInfoToAppend_()) {\n                this.processCallQueue_();\n            }\n        }\n        handleTimingInfo_(simpleSegment, mediaType, timeType, time) {\n            this.earlyAbortWhenNeeded_(simpleSegment.stats);\n            if (this.checkForAbort_(simpleSegment.requestId)) {\n                return;\n            }\n            const segmentInfo = this.pendingSegment_;\n            const timingInfoProperty = timingInfoPropertyForMedia(mediaType);\n            segmentInfo[timingInfoProperty] = segmentInfo[timingInfoProperty] || {};\n            segmentInfo[timingInfoProperty][timeType] = time;\n            this.logger_(`timinginfo: ${mediaType} - ${timeType} - ${time}`); // check if any calls were waiting on the timing info\n\n            if (this.hasEnoughInfoToAppend_()) {\n                this.processCallQueue_();\n            }\n        }\n        handleCaptions_(simpleSegment, captionData) {\n            this.earlyAbortWhenNeeded_(simpleSegment.stats);\n            if (this.checkForAbort_(simpleSegment.requestId)) {\n                return;\n            } // This could only happen with fmp4 segments, but\n            // should still not happen in general\n\n            if (captionData.length === 0) {\n                this.logger_('SegmentLoader received no captions from a caption event');\n                return;\n            }\n            const segmentInfo = this.pendingSegment_; // Wait until we have some video data so that caption timing\n            // can be adjusted by the timestamp offset\n\n            if (!segmentInfo.hasAppendedData_) {\n                this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, simpleSegment, captionData));\n                return;\n            }\n            const timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();\n            const captionTracks = {}; // get total start/end and captions for each track/stream\n\n            captionData.forEach(caption => {\n                // caption.stream is actually a track name...\n                // set to the existing values in tracks or default values\n                captionTracks[caption.stream] = captionTracks[caption.stream] || {\n                    // Infinity, as any other value will be less than this\n                    startTime: Infinity,\n                    captions: [],\n                    // 0 as an other value will be more than this\n                    endTime: 0\n                };\n                const captionTrack = captionTracks[caption.stream];\n                captionTrack.startTime = Math.min(captionTrack.startTime, caption.startTime + timestampOffset);\n                captionTrack.endTime = Math.max(captionTrack.endTime, caption.endTime + timestampOffset);\n                captionTrack.captions.push(caption);\n            });\n            Object.keys(captionTracks).forEach(trackName => {\n                const {\n                    startTime,\n                    endTime,\n                    captions\n                } = captionTracks[trackName];\n                const inbandTextTracks = this.inbandTextTracks_;\n                this.logger_(`adding cues from ${startTime} -> ${endTime} for ${trackName}`);\n                createCaptionsTrackIfNotExists(inbandTextTracks, this.vhs_.tech_, trackName); // clear out any cues that start and end at the same time period for the same track.\n                // We do this because a rendition change that also changes the timescale for captions\n                // will result in captions being re-parsed for certain segments. If we add them again\n                // without clearing we will have two of the same captions visible.\n\n                removeCuesFromTrack(startTime, endTime, inbandTextTracks[trackName]);\n                addCaptionData({\n                    captionArray: captions,\n                    inbandTextTracks,\n                    timestampOffset\n                });\n            }); // Reset stored captions since we added parsed\n            // captions to a text track at this point\n\n            if (this.transmuxer_) {\n                this.transmuxer_.postMessage({\n                    action: 'clearParsedMp4Captions'\n                });\n            }\n        }\n        handleId3_(simpleSegment, id3Frames, dispatchType) {\n            this.earlyAbortWhenNeeded_(simpleSegment.stats);\n            if (this.checkForAbort_(simpleSegment.requestId)) {\n                return;\n            }\n            const segmentInfo = this.pendingSegment_; // we need to have appended data in order for the timestamp offset to be set\n\n            if (!segmentInfo.hasAppendedData_) {\n                this.metadataQueue_.id3.push(this.handleId3_.bind(this, simpleSegment, id3Frames, dispatchType));\n                return;\n            }\n            const timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset(); // There's potentially an issue where we could double add metadata if there's a muxed\n            // audio/video source with a metadata track, and an alt audio with a metadata track.\n            // However, this probably won't happen, and if it does it can be handled then.\n\n            createMetadataTrackIfNotExists(this.inbandTextTracks_, dispatchType, this.vhs_.tech_);\n            addMetadata({\n                inbandTextTracks: this.inbandTextTracks_,\n                metadataArray: id3Frames,\n                timestampOffset,\n                videoDuration: this.duration_()\n            });\n        }\n        processMetadataQueue_() {\n            this.metadataQueue_.id3.forEach(fn => fn());\n            this.metadataQueue_.caption.forEach(fn => fn());\n            this.metadataQueue_.id3 = [];\n            this.metadataQueue_.caption = [];\n        }\n        processCallQueue_() {\n            const callQueue = this.callQueue_; // Clear out the queue before the queued functions are run, since some of the\n            // functions may check the length of the load queue and default to pushing themselves\n            // back onto the queue.\n\n            this.callQueue_ = [];\n            callQueue.forEach(fun => fun());\n        }\n        processLoadQueue_() {\n            const loadQueue = this.loadQueue_; // Clear out the queue before the queued functions are run, since some of the\n            // functions may check the length of the load queue and default to pushing themselves\n            // back onto the queue.\n\n            this.loadQueue_ = [];\n            loadQueue.forEach(fun => fun());\n        }\n        /**\n         * Determines whether the loader has enough info to load the next segment.\n         *\n         * @return {boolean}\n         *         Whether or not the loader has enough info to load the next segment\n         */\n\n        hasEnoughInfoToLoad_() {\n            // Since primary timing goes by video, only the audio loader potentially needs to wait\n            // to load.\n            if (this.loaderType_ !== 'audio') {\n                return true;\n            }\n            const segmentInfo = this.pendingSegment_; // A fill buffer must have already run to establish a pending segment before there's\n            // enough info to load.\n\n            if (!segmentInfo) {\n                return false;\n            } // The first segment can and should be loaded immediately so that source buffers are\n            // created together (before appending). Source buffer creation uses the presence of\n            // audio and video data to determine whether to create audio/video source buffers, and\n            // uses processed (transmuxed or parsed) media to determine the types required.\n\n            if (!this.getCurrentMediaInfo_()) {\n                return true;\n            }\n            if (\n                // Technically, instead of waiting to load a segment on timeline changes, a segment\n                // can be requested and downloaded and only wait before it is transmuxed or parsed.\n                // But in practice, there are a few reasons why it is better to wait until a loader\n                // is ready to append that segment before requesting and downloading:\n                //\n                // 1. Because audio and main loaders cross discontinuities together, if this loader\n                //    is waiting for the other to catch up, then instead of requesting another\n                //    segment and using up more bandwidth, by not yet loading, more bandwidth is\n                //    allotted to the loader currently behind.\n                // 2. media-segment-request doesn't have to have logic to consider whether a segment\n                // is ready to be processed or not, isolating the queueing behavior to the loader.\n                // 3. The audio loader bases some of its segment properties on timing information\n                //    provided by the main loader, meaning that, if the logic for waiting on\n                //    processing was in media-segment-request, then it would also need to know how\n                //    to re-generate the segment information after the main loader caught up.\n                shouldWaitForTimelineChange({\n                    timelineChangeController: this.timelineChangeController_,\n                    currentTimeline: this.currentTimeline_,\n                    segmentTimeline: segmentInfo.timeline,\n                    loaderType: this.loaderType_,\n                    audioDisabled: this.audioDisabled_\n                })) {\n                return false;\n            }\n            return true;\n        }\n        getCurrentMediaInfo_(segmentInfo = this.pendingSegment_) {\n            return segmentInfo && segmentInfo.trackInfo || this.currentMediaInfo_;\n        }\n        getMediaInfo_(segmentInfo = this.pendingSegment_) {\n            return this.getCurrentMediaInfo_(segmentInfo) || this.startingMediaInfo_;\n        }\n        getPendingSegmentPlaylist() {\n            return this.pendingSegment_ ? this.pendingSegment_.playlist : null;\n        }\n        hasEnoughInfoToAppend_() {\n            if (!this.sourceUpdater_.ready()) {\n                return false;\n            } // If content needs to be removed or the loader is waiting on an append reattempt,\n            // then no additional content should be appended until the prior append is resolved.\n\n            if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) {\n                return false;\n            }\n            const segmentInfo = this.pendingSegment_;\n            const trackInfo = this.getCurrentMediaInfo_(); // no segment to append any data for or\n            // we do not have information on this specific\n            // segment yet\n\n            if (!segmentInfo || !trackInfo) {\n                return false;\n            }\n            const {\n                hasAudio,\n                hasVideo,\n                isMuxed\n            } = trackInfo;\n            if (hasVideo && !segmentInfo.videoTimingInfo) {\n                return false;\n            } // muxed content only relies on video timing information for now.\n\n            if (hasAudio && !this.audioDisabled_ && !isMuxed && !segmentInfo.audioTimingInfo) {\n                return false;\n            }\n            if (shouldWaitForTimelineChange({\n                timelineChangeController: this.timelineChangeController_,\n                currentTimeline: this.currentTimeline_,\n                segmentTimeline: segmentInfo.timeline,\n                loaderType: this.loaderType_,\n                audioDisabled: this.audioDisabled_\n            })) {\n                return false;\n            }\n            return true;\n        }\n        handleData_(simpleSegment, result) {\n            this.earlyAbortWhenNeeded_(simpleSegment.stats);\n            if (this.checkForAbort_(simpleSegment.requestId)) {\n                return;\n            } // If there's anything in the call queue, then this data came later and should be\n            // executed after the calls currently queued.\n\n            if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {\n                this.callQueue_.push(this.handleData_.bind(this, simpleSegment, result));\n                return;\n            }\n            const segmentInfo = this.pendingSegment_; // update the time mapping so we can translate from display time to media time\n\n            this.setTimeMapping_(segmentInfo.timeline); // for tracking overall stats\n\n            this.updateMediaSecondsLoaded_(segmentInfo.part || segmentInfo.segment); // Note that the state isn't changed from loading to appending. This is because abort\n            // logic may change behavior depending on the state, and changing state too early may\n            // inflate our estimates of bandwidth. In the future this should be re-examined to\n            // note more granular states.\n            // don't process and append data if the mediaSource is closed\n\n            if (this.mediaSource_.readyState === 'closed') {\n                return;\n            } // if this request included an initialization segment, save that data\n            // to the initSegment cache\n\n            if (simpleSegment.map) {\n                simpleSegment.map = this.initSegmentForMap(simpleSegment.map, true); // move over init segment properties to media request\n\n                segmentInfo.segment.map = simpleSegment.map;\n            } // if this request included a segment key, save that data in the cache\n\n            if (simpleSegment.key) {\n                this.segmentKey(simpleSegment.key, true);\n            }\n            segmentInfo.isFmp4 = simpleSegment.isFmp4;\n            segmentInfo.timingInfo = segmentInfo.timingInfo || {};\n            if (segmentInfo.isFmp4) {\n                this.trigger('fmp4');\n                segmentInfo.timingInfo.start = segmentInfo[timingInfoPropertyForMedia(result.type)].start;\n            } else {\n                const trackInfo = this.getCurrentMediaInfo_();\n                const useVideoTimingInfo = this.loaderType_ === 'main' && trackInfo && trackInfo.hasVideo;\n                let firstVideoFrameTimeForData;\n                if (useVideoTimingInfo) {\n                    firstVideoFrameTimeForData = segmentInfo.videoTimingInfo.start;\n                } // Segment loader knows more about segment timing than the transmuxer (in certain\n                // aspects), so make any changes required for a more accurate start time.\n                // Don't set the end time yet, as the segment may not be finished processing.\n\n                segmentInfo.timingInfo.start = this.trueSegmentStart_({\n                    currentStart: segmentInfo.timingInfo.start,\n                    playlist: segmentInfo.playlist,\n                    mediaIndex: segmentInfo.mediaIndex,\n                    currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),\n                    useVideoTimingInfo,\n                    firstVideoFrameTimeForData,\n                    videoTimingInfo: segmentInfo.videoTimingInfo,\n                    audioTimingInfo: segmentInfo.audioTimingInfo\n                });\n            } // Init segments for audio and video only need to be appended in certain cases. Now\n            // that data is about to be appended, we can check the final cases to determine\n            // whether we should append an init segment.\n\n            this.updateAppendInitSegmentStatus(segmentInfo, result.type); // Timestamp offset should be updated once we get new data and have its timing info,\n            // as we use the start of the segment to offset the best guess (playlist provided)\n            // timestamp offset.\n\n            this.updateSourceBufferTimestampOffset_(segmentInfo); // if this is a sync request we need to determine whether it should\n            // be appended or not.\n\n            if (segmentInfo.isSyncRequest) {\n                // first save/update our timing info for this segment.\n                // this is what allows us to choose an accurate segment\n                // and the main reason we make a sync request.\n                this.updateTimingInfoEnd_(segmentInfo);\n                this.syncController_.saveSegmentTimingInfo({\n                    segmentInfo,\n                    shouldSaveTimelineMapping: this.loaderType_ === 'main'\n                });\n                const next = this.chooseNextRequest_(); // If the sync request isn't the segment that would be requested next\n                // after taking into account its timing info, do not append it.\n\n                if (next.mediaIndex !== segmentInfo.mediaIndex || next.partIndex !== segmentInfo.partIndex) {\n                    this.logger_('sync segment was incorrect, not appending');\n                    return;\n                } // otherwise append it like any other segment as our guess was correct.\n\n                this.logger_('sync segment was correct, appending');\n            } // Save some state so that in the future anything waiting on first append (and/or\n            // timestamp offset(s)) can process immediately. While the extra state isn't optimal,\n            // we need some notion of whether the timestamp offset or other relevant information\n            // has had a chance to be set.\n\n            segmentInfo.hasAppendedData_ = true; // Now that the timestamp offset should be set, we can append any waiting ID3 tags.\n\n            this.processMetadataQueue_();\n            this.appendData_(segmentInfo, result);\n        }\n        updateAppendInitSegmentStatus(segmentInfo, type) {\n            // alt audio doesn't manage timestamp offset\n            if (this.loaderType_ === 'main' && typeof segmentInfo.timestampOffset === 'number' &&\n                // in the case that we're handling partial data, we don't want to append an init\n                // segment for each chunk\n                !segmentInfo.changedTimestampOffset) {\n                // if the timestamp offset changed, the timeline may have changed, so we have to re-\n                // append init segments\n                this.appendInitSegment_ = {\n                    audio: true,\n                    video: true\n                };\n            }\n            if (this.playlistOfLastInitSegment_[type] !== segmentInfo.playlist) {\n                // make sure we append init segment on playlist changes, in case the media config\n                // changed\n                this.appendInitSegment_[type] = true;\n            }\n        }\n        getInitSegmentAndUpdateState_({\n                                          type,\n                                          initSegment,\n                                          map,\n                                          playlist\n                                      }) {\n            // \"The EXT-X-MAP tag specifies how to obtain the Media Initialization Section\n            // (Section 3) required to parse the applicable Media Segments.  It applies to every\n            // Media Segment that appears after it in the Playlist until the next EXT-X-MAP tag\n            // or until the end of the playlist.\"\n            // https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.5\n            if (map) {\n                const id = initSegmentId(map);\n                if (this.activeInitSegmentId_ === id) {\n                    // don't need to re-append the init segment if the ID matches\n                    return null;\n                } // a map-specified init segment takes priority over any transmuxed (or otherwise\n                // obtained) init segment\n                //\n                // this also caches the init segment for later use\n\n                initSegment = this.initSegmentForMap(map, true).bytes;\n                this.activeInitSegmentId_ = id;\n            } // We used to always prepend init segments for video, however, that shouldn't be\n            // necessary. Instead, we should only append on changes, similar to what we've always\n            // done for audio. This is more important (though may not be that important) for\n            // frame-by-frame appending for LHLS, simply because of the increased quantity of\n            // appends.\n\n            if (initSegment && this.appendInitSegment_[type]) {\n                // Make sure we track the playlist that we last used for the init segment, so that\n                // we can re-append the init segment in the event that we get data from a new\n                // playlist. Discontinuities and track changes are handled in other sections.\n                this.playlistOfLastInitSegment_[type] = playlist; // Disable future init segment appends for this type. Until a change is necessary.\n\n                this.appendInitSegment_[type] = false; // we need to clear out the fmp4 active init segment id, since\n                // we are appending the muxer init segment\n\n                this.activeInitSegmentId_ = null;\n                return initSegment;\n            }\n            return null;\n        }\n        handleQuotaExceededError_({\n                                      segmentInfo,\n                                      type,\n                                      bytes\n                                  }, error) {\n            const audioBuffered = this.sourceUpdater_.audioBuffered();\n            const videoBuffered = this.sourceUpdater_.videoBuffered(); // For now we're ignoring any notion of gaps in the buffer, but they, in theory,\n            // should be cleared out during the buffer removals. However, log in case it helps\n            // debug.\n\n            if (audioBuffered.length > 1) {\n                this.logger_('On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: ' + timeRangesToArray(audioBuffered).join(', '));\n            }\n            if (videoBuffered.length > 1) {\n                this.logger_('On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: ' + timeRangesToArray(videoBuffered).join(', '));\n            }\n            const audioBufferStart = audioBuffered.length ? audioBuffered.start(0) : 0;\n            const audioBufferEnd = audioBuffered.length ? audioBuffered.end(audioBuffered.length - 1) : 0;\n            const videoBufferStart = videoBuffered.length ? videoBuffered.start(0) : 0;\n            const videoBufferEnd = videoBuffered.length ? videoBuffered.end(videoBuffered.length - 1) : 0;\n            if (audioBufferEnd - audioBufferStart <= MIN_BACK_BUFFER && videoBufferEnd - videoBufferStart <= MIN_BACK_BUFFER) {\n                // Can't remove enough buffer to make room for new segment (or the browser doesn't\n                // allow for appends of segments this size). In the future, it may be possible to\n                // split up the segment and append in pieces, but for now, error out this playlist\n                // in an attempt to switch to a more manageable rendition.\n                this.logger_('On QUOTA_EXCEEDED_ERR, single segment too large to append to ' + 'buffer, triggering an error. ' + `Appended byte length: ${bytes.byteLength}, ` + `audio buffer: ${timeRangesToArray(audioBuffered).join(', ')}, ` + `video buffer: ${timeRangesToArray(videoBuffered).join(', ')}, `);\n                this.error({\n                    message: 'Quota exceeded error with append of a single segment of content',\n                    excludeUntil: Infinity\n                });\n                this.trigger('error');\n                return;\n            } // To try to resolve the quota exceeded error, clear back buffer and retry. This means\n            // that the segment-loader should block on future events until this one is handled, so\n            // that it doesn't keep moving onto further segments. Adding the call to the call\n            // queue will prevent further appends until waitingOnRemove_ and\n            // quotaExceededErrorRetryTimeout_ are cleared.\n            //\n            // Note that this will only block the current loader. In the case of demuxed content,\n            // the other load may keep filling as fast as possible. In practice, this should be\n            // OK, as it is a rare case when either audio has a high enough bitrate to fill up a\n            // source buffer, or video fills without enough room for audio to append (and without\n            // the availability of clearing out seconds of back buffer to make room for audio).\n            // But it might still be good to handle this case in the future as a TODO.\n\n            this.waitingOnRemove_ = true;\n            this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {\n                segmentInfo,\n                type,\n                bytes\n            }));\n            const currentTime = this.currentTime_(); // Try to remove as much audio and video as possible to make room for new content\n            // before retrying.\n\n            const timeToRemoveUntil = currentTime - MIN_BACK_BUFFER;\n            this.logger_(`On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to ${timeToRemoveUntil}`);\n            this.remove(0, timeToRemoveUntil, () => {\n                this.logger_(`On QUOTA_EXCEEDED_ERR, retrying append in ${MIN_BACK_BUFFER}s`);\n                this.waitingOnRemove_ = false; // wait the length of time alotted in the back buffer to prevent wasted\n                // attempts (since we can't clear less than the minimum)\n\n                this.quotaExceededErrorRetryTimeout_ = window.setTimeout(() => {\n                    this.logger_('On QUOTA_EXCEEDED_ERR, re-processing call queue');\n                    this.quotaExceededErrorRetryTimeout_ = null;\n                    this.processCallQueue_();\n                }, MIN_BACK_BUFFER * 1000);\n            }, true);\n        }\n        handleAppendError_({\n                               segmentInfo,\n                               type,\n                               bytes\n                           }, error) {\n            // if there's no error, nothing to do\n            if (!error) {\n                return;\n            }\n            if (error.code === QUOTA_EXCEEDED_ERR) {\n                this.handleQuotaExceededError_({\n                    segmentInfo,\n                    type,\n                    bytes\n                }); // A quota exceeded error should be recoverable with a future re-append, so no need\n                // to trigger an append error.\n\n                return;\n            }\n            this.logger_('Received non QUOTA_EXCEEDED_ERR on append', error);\n            this.error(`${type} append of ${bytes.length}b failed for segment ` + `#${segmentInfo.mediaIndex} in playlist ${segmentInfo.playlist.id}`); // If an append errors, we often can't recover.\n            // (see https://w3c.github.io/media-source/#sourcebuffer-append-error).\n            //\n            // Trigger a special error so that it can be handled separately from normal,\n            // recoverable errors.\n\n            this.trigger('appenderror');\n        }\n        appendToSourceBuffer_({\n                                  segmentInfo,\n                                  type,\n                                  initSegment,\n                                  data,\n                                  bytes\n                              }) {\n            // If this is a re-append, bytes were already created and don't need to be recreated\n            if (!bytes) {\n                const segments = [data];\n                let byteLength = data.byteLength;\n                if (initSegment) {\n                    // if the media initialization segment is changing, append it before the content\n                    // segment\n                    segments.unshift(initSegment);\n                    byteLength += initSegment.byteLength;\n                } // Technically we should be OK appending the init segment separately, however, we\n                // haven't yet tested that, and prepending is how we have always done things.\n\n                bytes = concatSegments({\n                    bytes: byteLength,\n                    segments\n                });\n            }\n            this.sourceUpdater_.appendBuffer({\n                segmentInfo,\n                type,\n                bytes\n            }, this.handleAppendError_.bind(this, {\n                segmentInfo,\n                type,\n                bytes\n            }));\n        }\n        handleSegmentTimingInfo_(type, requestId, segmentTimingInfo) {\n            if (!this.pendingSegment_ || requestId !== this.pendingSegment_.requestId) {\n                return;\n            }\n            const segment = this.pendingSegment_.segment;\n            const timingInfoProperty = `${type}TimingInfo`;\n            if (!segment[timingInfoProperty]) {\n                segment[timingInfoProperty] = {};\n            }\n            segment[timingInfoProperty].transmuxerPrependedSeconds = segmentTimingInfo.prependedContentDuration || 0;\n            segment[timingInfoProperty].transmuxedPresentationStart = segmentTimingInfo.start.presentation;\n            segment[timingInfoProperty].transmuxedDecodeStart = segmentTimingInfo.start.decode;\n            segment[timingInfoProperty].transmuxedPresentationEnd = segmentTimingInfo.end.presentation;\n            segment[timingInfoProperty].transmuxedDecodeEnd = segmentTimingInfo.end.decode; // mainly used as a reference for debugging\n\n            segment[timingInfoProperty].baseMediaDecodeTime = segmentTimingInfo.baseMediaDecodeTime;\n        }\n        appendData_(segmentInfo, result) {\n            const {\n                type,\n                data\n            } = result;\n            if (!data || !data.byteLength) {\n                return;\n            }\n            if (type === 'audio' && this.audioDisabled_) {\n                return;\n            }\n            const initSegment = this.getInitSegmentAndUpdateState_({\n                type,\n                initSegment: result.initSegment,\n                playlist: segmentInfo.playlist,\n                map: segmentInfo.isFmp4 ? segmentInfo.segment.map : null\n            });\n            this.appendToSourceBuffer_({\n                segmentInfo,\n                type,\n                initSegment,\n                data\n            });\n        }\n        /**\n         * load a specific segment from a request into the buffer\n         *\n         * @private\n         */\n\n        loadSegment_(segmentInfo) {\n            this.state = 'WAITING';\n            this.pendingSegment_ = segmentInfo;\n            this.trimBackBuffer_(segmentInfo);\n            if (typeof segmentInfo.timestampOffset === 'number') {\n                if (this.transmuxer_) {\n                    this.transmuxer_.postMessage({\n                        action: 'clearAllMp4Captions'\n                    });\n                }\n            }\n            if (!this.hasEnoughInfoToLoad_()) {\n                this.loadQueue_.push(() => {\n                    // regenerate the audioAppendStart, timestampOffset, etc as they\n                    // may have changed since this function was added to the queue.\n                    const options = _extends$1({}, segmentInfo, {\n                        forceTimestampOffset: true\n                    });\n                    _extends$1(segmentInfo, this.generateSegmentInfo_(options));\n                    this.isPendingTimestampOffset_ = false;\n                    this.updateTransmuxerAndRequestSegment_(segmentInfo);\n                });\n                return;\n            }\n            this.updateTransmuxerAndRequestSegment_(segmentInfo);\n        }\n        updateTransmuxerAndRequestSegment_(segmentInfo) {\n            // We'll update the source buffer's timestamp offset once we have transmuxed data, but\n            // the transmuxer still needs to be updated before then.\n            //\n            // Even though keepOriginalTimestamps is set to true for the transmuxer, timestamp\n            // offset must be passed to the transmuxer for stream correcting adjustments.\n            if (this.shouldUpdateTransmuxerTimestampOffset_(segmentInfo.timestampOffset)) {\n                this.gopBuffer_.length = 0; // gopsToAlignWith was set before the GOP buffer was cleared\n\n                segmentInfo.gopsToAlignWith = [];\n                this.timeMapping_ = 0; // reset values in the transmuxer since a discontinuity should start fresh\n\n                this.transmuxer_.postMessage({\n                    action: 'reset'\n                });\n                this.transmuxer_.postMessage({\n                    action: 'setTimestampOffset',\n                    timestampOffset: segmentInfo.timestampOffset\n                });\n            }\n            const simpleSegment = this.createSimplifiedSegmentObj_(segmentInfo);\n            const isEndOfStream = this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex);\n            const isWalkingForward = this.mediaIndex !== null;\n            const isDiscontinuity = segmentInfo.timeline !== this.currentTimeline_ &&\n                // currentTimeline starts at -1, so we shouldn't end the timeline switching to 0,\n                // the first timeline\n                segmentInfo.timeline > 0;\n            const isEndOfTimeline = isEndOfStream || isWalkingForward && isDiscontinuity;\n            this.logger_(`Requesting ${segmentInfoString(segmentInfo)}`); // If there's an init segment associated with this segment, but it is not cached (identified by a lack of bytes),\n            // then this init segment has never been seen before and should be appended.\n            //\n            // At this point the content type (audio/video or both) is not yet known, but it should be safe to set\n            // both to true and leave the decision of whether to append the init segment to append time.\n\n            if (simpleSegment.map && !simpleSegment.map.bytes) {\n                this.logger_('going to request init segment.');\n                this.appendInitSegment_ = {\n                    video: true,\n                    audio: true\n                };\n            }\n            segmentInfo.abortRequests = mediaSegmentRequest({\n                xhr: this.vhs_.xhr,\n                xhrOptions: this.xhrOptions_,\n                decryptionWorker: this.decrypter_,\n                segment: simpleSegment,\n                abortFn: this.handleAbort_.bind(this, segmentInfo),\n                progressFn: this.handleProgress_.bind(this),\n                trackInfoFn: this.handleTrackInfo_.bind(this),\n                timingInfoFn: this.handleTimingInfo_.bind(this),\n                videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, 'video', segmentInfo.requestId),\n                audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, 'audio', segmentInfo.requestId),\n                captionsFn: this.handleCaptions_.bind(this),\n                isEndOfTimeline,\n                endedTimelineFn: () => {\n                    this.logger_('received endedtimeline callback');\n                },\n                id3Fn: this.handleId3_.bind(this),\n                dataFn: this.handleData_.bind(this),\n                doneFn: this.segmentRequestFinished_.bind(this),\n                onTransmuxerLog: ({\n                                      message,\n                                      level,\n                                      stream\n                                  }) => {\n                    this.logger_(`${segmentInfoString(segmentInfo)} logged from transmuxer stream ${stream} as a ${level}: ${message}`);\n                }\n            });\n        }\n        /**\n         * trim the back buffer so that we don't have too much data\n         * in the source buffer\n         *\n         * @private\n         *\n         * @param {Object} segmentInfo - the current segment\n         */\n\n        trimBackBuffer_(segmentInfo) {\n            const removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10); // Chrome has a hard limit of 150MB of\n            // buffer and a very conservative \"garbage collector\"\n            // We manually clear out the old buffer to ensure\n            // we don't trigger the QuotaExceeded error\n            // on the source buffer during subsequent appends\n\n            if (removeToTime > 0) {\n                this.remove(0, removeToTime);\n            }\n        }\n        /**\n         * created a simplified copy of the segment object with just the\n         * information necessary to perform the XHR and decryption\n         *\n         * @private\n         *\n         * @param {Object} segmentInfo - the current segment\n         * @return {Object} a simplified segment object copy\n         */\n\n        createSimplifiedSegmentObj_(segmentInfo) {\n            const segment = segmentInfo.segment;\n            const part = segmentInfo.part;\n            const simpleSegment = {\n                resolvedUri: part ? part.resolvedUri : segment.resolvedUri,\n                byterange: part ? part.byterange : segment.byterange,\n                requestId: segmentInfo.requestId,\n                transmuxer: segmentInfo.transmuxer,\n                audioAppendStart: segmentInfo.audioAppendStart,\n                gopsToAlignWith: segmentInfo.gopsToAlignWith,\n                part: segmentInfo.part\n            };\n            const previousSegment = segmentInfo.playlist.segments[segmentInfo.mediaIndex - 1];\n            if (previousSegment && previousSegment.timeline === segment.timeline) {\n                // The baseStartTime of a segment is used to handle rollover when probing the TS\n                // segment to retrieve timing information. Since the probe only looks at the media's\n                // times (e.g., PTS and DTS values of the segment), and doesn't consider the\n                // player's time (e.g., player.currentTime()), baseStartTime should reflect the\n                // media time as well. transmuxedDecodeEnd represents the end time of a segment, in\n                // seconds of media time, so should be used here. The previous segment is used since\n                // the end of the previous segment should represent the beginning of the current\n                // segment, so long as they are on the same timeline.\n                if (previousSegment.videoTimingInfo) {\n                    simpleSegment.baseStartTime = previousSegment.videoTimingInfo.transmuxedDecodeEnd;\n                } else if (previousSegment.audioTimingInfo) {\n                    simpleSegment.baseStartTime = previousSegment.audioTimingInfo.transmuxedDecodeEnd;\n                }\n            }\n            if (segment.key) {\n                // if the media sequence is greater than 2^32, the IV will be incorrect\n                // assuming 10s segments, that would be about 1300 years\n                const iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);\n                simpleSegment.key = this.segmentKey(segment.key);\n                simpleSegment.key.iv = iv;\n            }\n            if (segment.map) {\n                simpleSegment.map = this.initSegmentForMap(segment.map);\n            }\n            return simpleSegment;\n        }\n        saveTransferStats_(stats) {\n            // every request counts as a media request even if it has been aborted\n            // or canceled due to a timeout\n            this.mediaRequests += 1;\n            if (stats) {\n                this.mediaBytesTransferred += stats.bytesReceived;\n                this.mediaTransferDuration += stats.roundTripTime;\n            }\n        }\n        saveBandwidthRelatedStats_(duration, stats) {\n            // byteLength will be used for throughput, and should be based on bytes receieved,\n            // which we only know at the end of the request and should reflect total bytes\n            // downloaded rather than just bytes processed from components of the segment\n            this.pendingSegment_.byteLength = stats.bytesReceived;\n            if (duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {\n                this.logger_(`Ignoring segment's bandwidth because its duration of ${duration}` + ` is less than the min to record ${MIN_SEGMENT_DURATION_TO_SAVE_STATS}`);\n                return;\n            }\n            this.bandwidth = stats.bandwidth;\n            this.roundTrip = stats.roundTripTime;\n        }\n        handleTimeout_() {\n            // although the VTT segment loader bandwidth isn't really used, it's good to\n            // maintain functinality between segment loaders\n            this.mediaRequestsTimedout += 1;\n            this.bandwidth = 1;\n            this.roundTrip = NaN;\n            this.trigger('bandwidthupdate');\n            this.trigger('timeout');\n        }\n        /**\n         * Handle the callback from the segmentRequest function and set the\n         * associated SegmentLoader state and errors if necessary\n         *\n         * @private\n         */\n\n        segmentRequestFinished_(error, simpleSegment, result) {\n            // TODO handle special cases, e.g., muxed audio/video but only audio in the segment\n            // check the call queue directly since this function doesn't need to deal with any\n            // data, and can continue even if the source buffers are not set up and we didn't get\n            // any data from the segment\n            if (this.callQueue_.length) {\n                this.callQueue_.push(this.segmentRequestFinished_.bind(this, error, simpleSegment, result));\n                return;\n            }\n            this.saveTransferStats_(simpleSegment.stats); // The request was aborted and the SegmentLoader has already been reset\n\n            if (!this.pendingSegment_) {\n                return;\n            } // the request was aborted and the SegmentLoader has already started\n            // another request. this can happen when the timeout for an aborted\n            // request triggers due to a limitation in the XHR library\n            // do not count this as any sort of request or we risk double-counting\n\n            if (simpleSegment.requestId !== this.pendingSegment_.requestId) {\n                return;\n            } // an error occurred from the active pendingSegment_ so reset everything\n\n            if (error) {\n                this.pendingSegment_ = null;\n                this.state = 'READY'; // aborts are not a true error condition and nothing corrective needs to be done\n\n                if (error.code === REQUEST_ERRORS.ABORTED) {\n                    return;\n                }\n                this.pause(); // the error is really just that at least one of the requests timed-out\n                // set the bandwidth to a very low value and trigger an ABR switch to\n                // take emergency action\n\n                if (error.code === REQUEST_ERRORS.TIMEOUT) {\n                    this.handleTimeout_();\n                    return;\n                } // if control-flow has arrived here, then the error is real\n                // emit an error event to exclude the current playlist\n\n                this.mediaRequestsErrored += 1;\n                this.error(error);\n                this.trigger('error');\n                return;\n            }\n            const segmentInfo = this.pendingSegment_; // the response was a success so set any bandwidth stats the request\n            // generated for ABR purposes\n\n            this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);\n            segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;\n            if (result.gopInfo) {\n                this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, result.gopInfo, this.safeAppend_);\n            } // Although we may have already started appending on progress, we shouldn't switch the\n            // state away from loading until we are officially done loading the segment data.\n\n            this.state = 'APPENDING'; // used for testing\n\n            this.trigger('appending');\n            this.waitForAppendsToComplete_(segmentInfo);\n        }\n        setTimeMapping_(timeline) {\n            const timelineMapping = this.syncController_.mappingForTimeline(timeline);\n            if (timelineMapping !== null) {\n                this.timeMapping_ = timelineMapping;\n            }\n        }\n        updateMediaSecondsLoaded_(segment) {\n            if (typeof segment.start === 'number' && typeof segment.end === 'number') {\n                this.mediaSecondsLoaded += segment.end - segment.start;\n            } else {\n                this.mediaSecondsLoaded += segment.duration;\n            }\n        }\n        shouldUpdateTransmuxerTimestampOffset_(timestampOffset) {\n            if (timestampOffset === null) {\n                return false;\n            } // note that we're potentially using the same timestamp offset for both video and\n            // audio\n\n            if (this.loaderType_ === 'main' && timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {\n                return true;\n            }\n            if (!this.audioDisabled_ && timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {\n                return true;\n            }\n            return false;\n        }\n        trueSegmentStart_({\n                              currentStart,\n                              playlist,\n                              mediaIndex,\n                              firstVideoFrameTimeForData,\n                              currentVideoTimestampOffset,\n                              useVideoTimingInfo,\n                              videoTimingInfo,\n                              audioTimingInfo\n                          }) {\n            if (typeof currentStart !== 'undefined') {\n                // if start was set once, keep using it\n                return currentStart;\n            }\n            if (!useVideoTimingInfo) {\n                return audioTimingInfo.start;\n            }\n            const previousSegment = playlist.segments[mediaIndex - 1]; // The start of a segment should be the start of the first full frame contained\n            // within that segment. Since the transmuxer maintains a cache of incomplete data\n            // from and/or the last frame seen, the start time may reflect a frame that starts\n            // in the previous segment. Check for that case and ensure the start time is\n            // accurate for the segment.\n\n            if (mediaIndex === 0 || !previousSegment || typeof previousSegment.start === 'undefined' || previousSegment.end !== firstVideoFrameTimeForData + currentVideoTimestampOffset) {\n                return firstVideoFrameTimeForData;\n            }\n            return videoTimingInfo.start;\n        }\n        waitForAppendsToComplete_(segmentInfo) {\n            const trackInfo = this.getCurrentMediaInfo_(segmentInfo);\n            if (!trackInfo) {\n                this.error({\n                    message: 'No starting media returned, likely due to an unsupported media format.',\n                    playlistExclusionDuration: Infinity\n                });\n                this.trigger('error');\n                return;\n            } // Although transmuxing is done, appends may not yet be finished. Throw a marker\n            // on each queue this loader is responsible for to ensure that the appends are\n            // complete.\n\n            const {\n                hasAudio,\n                hasVideo,\n                isMuxed\n            } = trackInfo;\n            const waitForVideo = this.loaderType_ === 'main' && hasVideo;\n            const waitForAudio = !this.audioDisabled_ && hasAudio && !isMuxed;\n            segmentInfo.waitingOnAppends = 0; // segments with no data\n\n            if (!segmentInfo.hasAppendedData_) {\n                if (!segmentInfo.timingInfo && typeof segmentInfo.timestampOffset === 'number') {\n                    // When there's no audio or video data in the segment, there's no audio or video\n                    // timing information.\n                    //\n                    // If there's no audio or video timing information, then the timestamp offset\n                    // can't be adjusted to the appropriate value for the transmuxer and source\n                    // buffers.\n                    //\n                    // Therefore, the next segment should be used to set the timestamp offset.\n                    this.isPendingTimestampOffset_ = true;\n                } // override settings for metadata only segments\n\n                segmentInfo.timingInfo = {\n                    start: 0\n                };\n                segmentInfo.waitingOnAppends++;\n                if (!this.isPendingTimestampOffset_) {\n                    // update the timestampoffset\n                    this.updateSourceBufferTimestampOffset_(segmentInfo); // make sure the metadata queue is processed even though we have\n                    // no video/audio data.\n\n                    this.processMetadataQueue_();\n                } // append is \"done\" instantly with no data.\n\n                this.checkAppendsDone_(segmentInfo);\n                return;\n            } // Since source updater could call back synchronously, do the increments first.\n\n            if (waitForVideo) {\n                segmentInfo.waitingOnAppends++;\n            }\n            if (waitForAudio) {\n                segmentInfo.waitingOnAppends++;\n            }\n            if (waitForVideo) {\n                this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));\n            }\n            if (waitForAudio) {\n                this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));\n            }\n        }\n        checkAppendsDone_(segmentInfo) {\n            if (this.checkForAbort_(segmentInfo.requestId)) {\n                return;\n            }\n            segmentInfo.waitingOnAppends--;\n            if (segmentInfo.waitingOnAppends === 0) {\n                this.handleAppendsDone_();\n            }\n        }\n        checkForIllegalMediaSwitch(trackInfo) {\n            const illegalMediaSwitchError = illegalMediaSwitch(this.loaderType_, this.getCurrentMediaInfo_(), trackInfo);\n            if (illegalMediaSwitchError) {\n                this.error({\n                    message: illegalMediaSwitchError,\n                    playlistExclusionDuration: Infinity\n                });\n                this.trigger('error');\n                return true;\n            }\n            return false;\n        }\n        updateSourceBufferTimestampOffset_(segmentInfo) {\n            if (segmentInfo.timestampOffset === null ||\n                // we don't yet have the start for whatever media type (video or audio) has\n                // priority, timing-wise, so we must wait\n                typeof segmentInfo.timingInfo.start !== 'number' ||\n                // already updated the timestamp offset for this segment\n                segmentInfo.changedTimestampOffset ||\n                // the alt audio loader should not be responsible for setting the timestamp offset\n                this.loaderType_ !== 'main') {\n                return;\n            }\n            let didChange = false; // Primary timing goes by video, and audio is trimmed in the transmuxer, meaning that\n            // the timing info here comes from video. In the event that the audio is longer than\n            // the video, this will trim the start of the audio.\n            // This also trims any offset from 0 at the beginning of the media\n\n            segmentInfo.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({\n                videoTimingInfo: segmentInfo.segment.videoTimingInfo,\n                audioTimingInfo: segmentInfo.segment.audioTimingInfo,\n                timingInfo: segmentInfo.timingInfo\n            }); // In the event that there are part segment downloads, each will try to update the\n            // timestamp offset. Retaining this bit of state prevents us from updating in the\n            // future (within the same segment), however, there may be a better way to handle it.\n\n            segmentInfo.changedTimestampOffset = true;\n            if (segmentInfo.timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {\n                this.sourceUpdater_.videoTimestampOffset(segmentInfo.timestampOffset);\n                didChange = true;\n            }\n            if (segmentInfo.timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {\n                this.sourceUpdater_.audioTimestampOffset(segmentInfo.timestampOffset);\n                didChange = true;\n            }\n            if (didChange) {\n                this.trigger('timestampoffset');\n            }\n        }\n        getSegmentStartTimeForTimestampOffsetCalculation_({\n                                                              videoTimingInfo,\n                                                              audioTimingInfo,\n                                                              timingInfo\n                                                          }) {\n            if (!this.useDtsForTimestampOffset_) {\n                return timingInfo.start;\n            }\n            if (videoTimingInfo && typeof videoTimingInfo.transmuxedDecodeStart === 'number') {\n                return videoTimingInfo.transmuxedDecodeStart;\n            } // handle audio only\n\n            if (audioTimingInfo && typeof audioTimingInfo.transmuxedDecodeStart === 'number') {\n                return audioTimingInfo.transmuxedDecodeStart;\n            } // handle content not transmuxed (e.g., MP4)\n\n            return timingInfo.start;\n        }\n        updateTimingInfoEnd_(segmentInfo) {\n            segmentInfo.timingInfo = segmentInfo.timingInfo || {};\n            const trackInfo = this.getMediaInfo_();\n            const useVideoTimingInfo = this.loaderType_ === 'main' && trackInfo && trackInfo.hasVideo;\n            const prioritizedTimingInfo = useVideoTimingInfo && segmentInfo.videoTimingInfo ? segmentInfo.videoTimingInfo : segmentInfo.audioTimingInfo;\n            if (!prioritizedTimingInfo) {\n                return;\n            }\n            segmentInfo.timingInfo.end = typeof prioritizedTimingInfo.end === 'number' ?\n                // End time may not exist in a case where we aren't parsing the full segment (one\n                // current example is the case of fmp4), so use the rough duration to calculate an\n                // end time.\n                prioritizedTimingInfo.end : prioritizedTimingInfo.start + segmentInfo.duration;\n        }\n        /**\n         * callback to run when appendBuffer is finished. detects if we are\n         * in a good state to do things with the data we got, or if we need\n         * to wait for more\n         *\n         * @private\n         */\n\n        handleAppendsDone_() {\n            // appendsdone can cause an abort\n            if (this.pendingSegment_) {\n                this.trigger('appendsdone');\n            }\n            if (!this.pendingSegment_) {\n                this.state = 'READY'; // TODO should this move into this.checkForAbort to speed up requests post abort in\n                // all appending cases?\n\n                if (!this.paused()) {\n                    this.monitorBuffer_();\n                }\n                return;\n            }\n            const segmentInfo = this.pendingSegment_; // Now that the end of the segment has been reached, we can set the end time. It's\n            // best to wait until all appends are done so we're sure that the primary media is\n            // finished (and we have its end time).\n\n            this.updateTimingInfoEnd_(segmentInfo);\n            if (this.shouldSaveSegmentTimingInfo_) {\n                // Timeline mappings should only be saved for the main loader. This is for multiple\n                // reasons:\n                //\n                // 1) Only one mapping is saved per timeline, meaning that if both the audio loader\n                //    and the main loader try to save the timeline mapping, whichever comes later\n                //    will overwrite the first. In theory this is OK, as the mappings should be the\n                //    same, however, it breaks for (2)\n                // 2) In the event of a live stream, the initial live point will make for a somewhat\n                //    arbitrary mapping. If audio and video streams are not perfectly in-sync, then\n                //    the mapping will be off for one of the streams, dependent on which one was\n                //    first saved (see (1)).\n                // 3) Primary timing goes by video in VHS, so the mapping should be video.\n                //\n                // Since the audio loader will wait for the main loader to load the first segment,\n                // the main loader will save the first timeline mapping, and ensure that there won't\n                // be a case where audio loads two segments without saving a mapping (thus leading\n                // to missing segment timing info).\n                this.syncController_.saveSegmentTimingInfo({\n                    segmentInfo,\n                    shouldSaveTimelineMapping: this.loaderType_ === 'main'\n                });\n            }\n            const segmentDurationMessage = getTroublesomeSegmentDurationMessage(segmentInfo, this.sourceType_);\n            if (segmentDurationMessage) {\n                if (segmentDurationMessage.severity === 'warn') {\n                    videojs.log.warn(segmentDurationMessage.message);\n                } else {\n                    this.logger_(segmentDurationMessage.message);\n                }\n            }\n            this.recordThroughput_(segmentInfo);\n            this.pendingSegment_ = null;\n            this.state = 'READY';\n            if (segmentInfo.isSyncRequest) {\n                this.trigger('syncinfoupdate'); // if the sync request was not appended\n                // then it was not the correct segment.\n                // throw it away and use the data it gave us\n                // to get the correct one.\n\n                if (!segmentInfo.hasAppendedData_) {\n                    this.logger_(`Throwing away un-appended sync request ${segmentInfoString(segmentInfo)}`);\n                    return;\n                }\n            }\n            this.logger_(`Appended ${segmentInfoString(segmentInfo)}`);\n            this.addSegmentMetadataCue_(segmentInfo);\n            this.fetchAtBuffer_ = true;\n            if (this.currentTimeline_ !== segmentInfo.timeline) {\n                this.timelineChangeController_.lastTimelineChange({\n                    type: this.loaderType_,\n                    from: this.currentTimeline_,\n                    to: segmentInfo.timeline\n                }); // If audio is not disabled, the main segment loader is responsible for updating\n                // the audio timeline as well. If the content is video only, this won't have any\n                // impact.\n\n                if (this.loaderType_ === 'main' && !this.audioDisabled_) {\n                    this.timelineChangeController_.lastTimelineChange({\n                        type: 'audio',\n                        from: this.currentTimeline_,\n                        to: segmentInfo.timeline\n                    });\n                }\n            }\n            this.currentTimeline_ = segmentInfo.timeline; // We must update the syncinfo to recalculate the seekable range before\n            // the following conditional otherwise it may consider this a bad \"guess\"\n            // and attempt to resync when the post-update seekable window and live\n            // point would mean that this was the perfect segment to fetch\n\n            this.trigger('syncinfoupdate');\n            const segment = segmentInfo.segment;\n            const part = segmentInfo.part;\n            const badSegmentGuess = segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3;\n            const badPartGuess = part && part.end && this.currentTime_() - part.end > segmentInfo.playlist.partTargetDuration * 3; // If we previously appended a segment/part that ends more than 3 part/targetDurations before\n            // the currentTime_ that means that our conservative guess was too conservative.\n            // In that case, reset the loader state so that we try to use any information gained\n            // from the previous request to create a new, more accurate, sync-point.\n\n            if (badSegmentGuess || badPartGuess) {\n                this.logger_(`bad ${badSegmentGuess ? 'segment' : 'part'} ${segmentInfoString(segmentInfo)}`);\n                this.resetEverything();\n                return;\n            }\n            const isWalkingForward = this.mediaIndex !== null; // Don't do a rendition switch unless we have enough time to get a sync segment\n            // and conservatively guess\n\n            if (isWalkingForward) {\n                this.trigger('bandwidthupdate');\n            }\n            this.trigger('progress');\n            this.mediaIndex = segmentInfo.mediaIndex;\n            this.partIndex = segmentInfo.partIndex; // any time an update finishes and the last segment is in the\n            // buffer, end the stream. this ensures the \"ended\" event will\n            // fire if playback reaches that point.\n\n            if (this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex)) {\n                this.endOfStream();\n            } // used for testing\n\n            this.trigger('appended');\n            if (segmentInfo.hasAppendedData_) {\n                this.mediaAppends++;\n            }\n            if (!this.paused()) {\n                this.monitorBuffer_();\n            }\n        }\n        /**\n         * Records the current throughput of the decrypt, transmux, and append\n         * portion of the semgment pipeline. `throughput.rate` is a the cumulative\n         * moving average of the throughput. `throughput.count` is the number of\n         * data points in the average.\n         *\n         * @private\n         * @param {Object} segmentInfo the object returned by loadSegment\n         */\n\n        recordThroughput_(segmentInfo) {\n            if (segmentInfo.duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {\n                this.logger_(`Ignoring segment's throughput because its duration of ${segmentInfo.duration}` + ` is less than the min to record ${MIN_SEGMENT_DURATION_TO_SAVE_STATS}`);\n                return;\n            }\n            const rate = this.throughput.rate; // Add one to the time to ensure that we don't accidentally attempt to divide\n            // by zero in the case where the throughput is ridiculously high\n\n            const segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1; // Multiply by 8000 to convert from bytes/millisecond to bits/second\n\n            const segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1000); // This is just a cumulative moving average calculation:\n            //   newAvg = oldAvg + (sample - oldAvg) / (sampleCount + 1)\n\n            this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;\n        }\n        /**\n         * Adds a cue to the segment-metadata track with some metadata information about the\n         * segment\n         *\n         * @private\n         * @param {Object} segmentInfo\n         *        the object returned by loadSegment\n         * @method addSegmentMetadataCue_\n         */\n\n        addSegmentMetadataCue_(segmentInfo) {\n            if (!this.segmentMetadataTrack_) {\n                return;\n            }\n            const segment = segmentInfo.segment;\n            const start = segment.start;\n            const end = segment.end; // Do not try adding the cue if the start and end times are invalid.\n\n            if (!finite(start) || !finite(end)) {\n                return;\n            }\n            removeCuesFromTrack(start, end, this.segmentMetadataTrack_);\n            const Cue = window.WebKitDataCue || window.VTTCue;\n            const value = {\n                custom: segment.custom,\n                dateTimeObject: segment.dateTimeObject,\n                dateTimeString: segment.dateTimeString,\n                bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,\n                resolution: segmentInfo.playlist.attributes.RESOLUTION,\n                codecs: segmentInfo.playlist.attributes.CODECS,\n                byteLength: segmentInfo.byteLength,\n                uri: segmentInfo.uri,\n                timeline: segmentInfo.timeline,\n                playlist: segmentInfo.playlist.id,\n                start,\n                end\n            };\n            const data = JSON.stringify(value);\n            const cue = new Cue(start, end, data); // Attach the metadata to the value property of the cue to keep consistency between\n            // the differences of WebKitDataCue in safari and VTTCue in other browsers\n\n            cue.value = value;\n            this.segmentMetadataTrack_.addCue(cue);\n        }\n    }\n    function noop() {}\n    const toTitleCase = function (string) {\n        if (typeof string !== 'string') {\n            return string;\n        }\n        return string.replace(/./, w => w.toUpperCase());\n    };\n\n    /**\n     * @file source-updater.js\n     */\n    const bufferTypes = ['video', 'audio'];\n    const updating = (type, sourceUpdater) => {\n        const sourceBuffer = sourceUpdater[`${type}Buffer`];\n        return sourceBuffer && sourceBuffer.updating || sourceUpdater.queuePending[type];\n    };\n    const nextQueueIndexOfType = (type, queue) => {\n        for (let i = 0; i < queue.length; i++) {\n            const queueEntry = queue[i];\n            if (queueEntry.type === 'mediaSource') {\n                // If the next entry is a media source entry (uses multiple source buffers), block\n                // processing to allow it to go through first.\n                return null;\n            }\n            if (queueEntry.type === type) {\n                return i;\n            }\n        }\n        return null;\n    };\n    const shiftQueue = (type, sourceUpdater) => {\n        if (sourceUpdater.queue.length === 0) {\n            return;\n        }\n        let queueIndex = 0;\n        let queueEntry = sourceUpdater.queue[queueIndex];\n        if (queueEntry.type === 'mediaSource') {\n            if (!sourceUpdater.updating() && sourceUpdater.mediaSource.readyState !== 'closed') {\n                sourceUpdater.queue.shift();\n                queueEntry.action(sourceUpdater);\n                if (queueEntry.doneFn) {\n                    queueEntry.doneFn();\n                } // Only specific source buffer actions must wait for async updateend events. Media\n                // Source actions process synchronously. Therefore, both audio and video source\n                // buffers are now clear to process the next queue entries.\n\n                shiftQueue('audio', sourceUpdater);\n                shiftQueue('video', sourceUpdater);\n            } // Media Source actions require both source buffers, so if the media source action\n            // couldn't process yet (because one or both source buffers are busy), block other\n            // queue actions until both are available and the media source action can process.\n\n            return;\n        }\n        if (type === 'mediaSource') {\n            // If the queue was shifted by a media source action (this happens when pushing a\n            // media source action onto the queue), then it wasn't from an updateend event from an\n            // audio or video source buffer, so there's no change from previous state, and no\n            // processing should be done.\n            return;\n        } // Media source queue entries don't need to consider whether the source updater is\n        // started (i.e., source buffers are created) as they don't need the source buffers, but\n        // source buffer queue entries do.\n\n        if (!sourceUpdater.ready() || sourceUpdater.mediaSource.readyState === 'closed' || updating(type, sourceUpdater)) {\n            return;\n        }\n        if (queueEntry.type !== type) {\n            queueIndex = nextQueueIndexOfType(type, sourceUpdater.queue);\n            if (queueIndex === null) {\n                // Either there's no queue entry that uses this source buffer type in the queue, or\n                // there's a media source queue entry before the next entry of this type, in which\n                // case wait for that action to process first.\n                return;\n            }\n            queueEntry = sourceUpdater.queue[queueIndex];\n        }\n        sourceUpdater.queue.splice(queueIndex, 1); // Keep a record that this source buffer type is in use.\n        //\n        // The queue pending operation must be set before the action is performed in the event\n        // that the action results in a synchronous event that is acted upon. For instance, if\n        // an exception is thrown that can be handled, it's possible that new actions will be\n        // appended to an empty queue and immediately executed, but would not have the correct\n        // pending information if this property was set after the action was performed.\n\n        sourceUpdater.queuePending[type] = queueEntry;\n        queueEntry.action(type, sourceUpdater);\n        if (!queueEntry.doneFn) {\n            // synchronous operation, process next entry\n            sourceUpdater.queuePending[type] = null;\n            shiftQueue(type, sourceUpdater);\n            return;\n        }\n    };\n    const cleanupBuffer = (type, sourceUpdater) => {\n        const buffer = sourceUpdater[`${type}Buffer`];\n        const titleType = toTitleCase(type);\n        if (!buffer) {\n            return;\n        }\n        buffer.removeEventListener('updateend', sourceUpdater[`on${titleType}UpdateEnd_`]);\n        buffer.removeEventListener('error', sourceUpdater[`on${titleType}Error_`]);\n        sourceUpdater.codecs[type] = null;\n        sourceUpdater[`${type}Buffer`] = null;\n    };\n    const inSourceBuffers = (mediaSource, sourceBuffer) => mediaSource && sourceBuffer && Array.prototype.indexOf.call(mediaSource.sourceBuffers, sourceBuffer) !== -1;\n    const actions = {\n        appendBuffer: (bytes, segmentInfo, onError) => (type, sourceUpdater) => {\n            const sourceBuffer = sourceUpdater[`${type}Buffer`]; // can't do anything if the media source / source buffer is null\n            // or the media source does not contain this source buffer.\n\n            if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n                return;\n            }\n            sourceUpdater.logger_(`Appending segment ${segmentInfo.mediaIndex}'s ${bytes.length} bytes to ${type}Buffer`);\n            try {\n                sourceBuffer.appendBuffer(bytes);\n            } catch (e) {\n                sourceUpdater.logger_(`Error with code ${e.code} ` + (e.code === QUOTA_EXCEEDED_ERR ? '(QUOTA_EXCEEDED_ERR) ' : '') + `when appending segment ${segmentInfo.mediaIndex} to ${type}Buffer`);\n                sourceUpdater.queuePending[type] = null;\n                onError(e);\n            }\n        },\n        remove: (start, end) => (type, sourceUpdater) => {\n            const sourceBuffer = sourceUpdater[`${type}Buffer`]; // can't do anything if the media source / source buffer is null\n            // or the media source does not contain this source buffer.\n\n            if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n                return;\n            }\n            sourceUpdater.logger_(`Removing ${start} to ${end} from ${type}Buffer`);\n            try {\n                sourceBuffer.remove(start, end);\n            } catch (e) {\n                sourceUpdater.logger_(`Remove ${start} to ${end} from ${type}Buffer failed`);\n            }\n        },\n        timestampOffset: offset => (type, sourceUpdater) => {\n            const sourceBuffer = sourceUpdater[`${type}Buffer`]; // can't do anything if the media source / source buffer is null\n            // or the media source does not contain this source buffer.\n\n            if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n                return;\n            }\n            sourceUpdater.logger_(`Setting ${type}timestampOffset to ${offset}`);\n            sourceBuffer.timestampOffset = offset;\n        },\n        callback: callback => (type, sourceUpdater) => {\n            callback();\n        },\n        endOfStream: error => sourceUpdater => {\n            if (sourceUpdater.mediaSource.readyState !== 'open') {\n                return;\n            }\n            sourceUpdater.logger_(`Calling mediaSource endOfStream(${error || ''})`);\n            try {\n                sourceUpdater.mediaSource.endOfStream(error);\n            } catch (e) {\n                videojs.log.warn('Failed to call media source endOfStream', e);\n            }\n        },\n        duration: duration => sourceUpdater => {\n            sourceUpdater.logger_(`Setting mediaSource duration to ${duration}`);\n            try {\n                sourceUpdater.mediaSource.duration = duration;\n            } catch (e) {\n                videojs.log.warn('Failed to set media source duration', e);\n            }\n        },\n        abort: () => (type, sourceUpdater) => {\n            if (sourceUpdater.mediaSource.readyState !== 'open') {\n                return;\n            }\n            const sourceBuffer = sourceUpdater[`${type}Buffer`]; // can't do anything if the media source / source buffer is null\n            // or the media source does not contain this source buffer.\n\n            if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n                return;\n            }\n            sourceUpdater.logger_(`calling abort on ${type}Buffer`);\n            try {\n                sourceBuffer.abort();\n            } catch (e) {\n                videojs.log.warn(`Failed to abort on ${type}Buffer`, e);\n            }\n        },\n        addSourceBuffer: (type, codec) => sourceUpdater => {\n            const titleType = toTitleCase(type);\n            const mime = getMimeForCodec(codec);\n            sourceUpdater.logger_(`Adding ${type}Buffer with codec ${codec} to mediaSource`);\n            const sourceBuffer = sourceUpdater.mediaSource.addSourceBuffer(mime);\n            sourceBuffer.addEventListener('updateend', sourceUpdater[`on${titleType}UpdateEnd_`]);\n            sourceBuffer.addEventListener('error', sourceUpdater[`on${titleType}Error_`]);\n            sourceUpdater.codecs[type] = codec;\n            sourceUpdater[`${type}Buffer`] = sourceBuffer;\n        },\n        removeSourceBuffer: type => sourceUpdater => {\n            const sourceBuffer = sourceUpdater[`${type}Buffer`];\n            cleanupBuffer(type, sourceUpdater); // can't do anything if the media source / source buffer is null\n            // or the media source does not contain this source buffer.\n\n            if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n                return;\n            }\n            sourceUpdater.logger_(`Removing ${type}Buffer with codec ${sourceUpdater.codecs[type]} from mediaSource`);\n            try {\n                sourceUpdater.mediaSource.removeSourceBuffer(sourceBuffer);\n            } catch (e) {\n                videojs.log.warn(`Failed to removeSourceBuffer ${type}Buffer`, e);\n            }\n        },\n        changeType: codec => (type, sourceUpdater) => {\n            const sourceBuffer = sourceUpdater[`${type}Buffer`];\n            const mime = getMimeForCodec(codec); // can't do anything if the media source / source buffer is null\n            // or the media source does not contain this source buffer.\n\n            if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {\n                return;\n            } // do not update codec if we don't need to.\n\n            if (sourceUpdater.codecs[type] === codec) {\n                return;\n            }\n            sourceUpdater.logger_(`changing ${type}Buffer codec from ${sourceUpdater.codecs[type]} to ${codec}`);\n            sourceBuffer.changeType(mime);\n            sourceUpdater.codecs[type] = codec;\n        }\n    };\n    const pushQueue = ({\n                           type,\n                           sourceUpdater,\n                           action,\n                           doneFn,\n                           name\n                       }) => {\n        sourceUpdater.queue.push({\n            type,\n            action,\n            doneFn,\n            name\n        });\n        shiftQueue(type, sourceUpdater);\n    };\n    const onUpdateend = (type, sourceUpdater) => e => {\n        // Although there should, in theory, be a pending action for any updateend receieved,\n        // there are some actions that may trigger updateend events without set definitions in\n        // the w3c spec. For instance, setting the duration on the media source may trigger\n        // updateend events on source buffers. This does not appear to be in the spec. As such,\n        // if we encounter an updateend without a corresponding pending action from our queue\n        // for that source buffer type, process the next action.\n        if (sourceUpdater.queuePending[type]) {\n            const doneFn = sourceUpdater.queuePending[type].doneFn;\n            sourceUpdater.queuePending[type] = null;\n            if (doneFn) {\n                // if there's an error, report it\n                doneFn(sourceUpdater[`${type}Error_`]);\n            }\n        }\n        shiftQueue(type, sourceUpdater);\n    };\n    /**\n     * A queue of callbacks to be serialized and applied when a\n     * MediaSource and its associated SourceBuffers are not in the\n     * updating state. It is used by the segment loader to update the\n     * underlying SourceBuffers when new data is loaded, for instance.\n     *\n     * @class SourceUpdater\n     * @param {MediaSource} mediaSource the MediaSource to create the SourceBuffer from\n     * @param {string} mimeType the desired MIME type of the underlying SourceBuffer\n     */\n\n    class SourceUpdater extends videojs.EventTarget {\n        constructor(mediaSource) {\n            super();\n            this.mediaSource = mediaSource;\n            this.sourceopenListener_ = () => shiftQueue('mediaSource', this);\n            this.mediaSource.addEventListener('sourceopen', this.sourceopenListener_);\n            this.logger_ = logger('SourceUpdater'); // initial timestamp offset is 0\n\n            this.audioTimestampOffset_ = 0;\n            this.videoTimestampOffset_ = 0;\n            this.queue = [];\n            this.queuePending = {\n                audio: null,\n                video: null\n            };\n            this.delayedAudioAppendQueue_ = [];\n            this.videoAppendQueued_ = false;\n            this.codecs = {};\n            this.onVideoUpdateEnd_ = onUpdateend('video', this);\n            this.onAudioUpdateEnd_ = onUpdateend('audio', this);\n            this.onVideoError_ = e => {\n                // used for debugging\n                this.videoError_ = e;\n            };\n            this.onAudioError_ = e => {\n                // used for debugging\n                this.audioError_ = e;\n            };\n            this.createdSourceBuffers_ = false;\n            this.initializedEme_ = false;\n            this.triggeredReady_ = false;\n        }\n        initializedEme() {\n            this.initializedEme_ = true;\n            this.triggerReady();\n        }\n        hasCreatedSourceBuffers() {\n            // if false, likely waiting on one of the segment loaders to get enough data to create\n            // source buffers\n            return this.createdSourceBuffers_;\n        }\n        hasInitializedAnyEme() {\n            return this.initializedEme_;\n        }\n        ready() {\n            return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();\n        }\n        createSourceBuffers(codecs) {\n            if (this.hasCreatedSourceBuffers()) {\n                // already created them before\n                return;\n            } // the intial addOrChangeSourceBuffers will always be\n            // two add buffers.\n\n            this.addOrChangeSourceBuffers(codecs);\n            this.createdSourceBuffers_ = true;\n            this.trigger('createdsourcebuffers');\n            this.triggerReady();\n        }\n        triggerReady() {\n            // only allow ready to be triggered once, this prevents the case\n            // where:\n            // 1. we trigger createdsourcebuffers\n            // 2. ie 11 synchronously initializates eme\n            // 3. the synchronous initialization causes us to trigger ready\n            // 4. We go back to the ready check in createSourceBuffers and ready is triggered again.\n            if (this.ready() && !this.triggeredReady_) {\n                this.triggeredReady_ = true;\n                this.trigger('ready');\n            }\n        }\n        /**\n         * Add a type of source buffer to the media source.\n         *\n         * @param {string} type\n         *        The type of source buffer to add.\n         *\n         * @param {string} codec\n         *        The codec to add the source buffer with.\n         */\n\n        addSourceBuffer(type, codec) {\n            pushQueue({\n                type: 'mediaSource',\n                sourceUpdater: this,\n                action: actions.addSourceBuffer(type, codec),\n                name: 'addSourceBuffer'\n            });\n        }\n        /**\n         * call abort on a source buffer.\n         *\n         * @param {string} type\n         *        The type of source buffer to call abort on.\n         */\n\n        abort(type) {\n            pushQueue({\n                type,\n                sourceUpdater: this,\n                action: actions.abort(type),\n                name: 'abort'\n            });\n        }\n        /**\n         * Call removeSourceBuffer and remove a specific type\n         * of source buffer on the mediaSource.\n         *\n         * @param {string} type\n         *        The type of source buffer to remove.\n         */\n\n        removeSourceBuffer(type) {\n            if (!this.canRemoveSourceBuffer()) {\n                videojs.log.error('removeSourceBuffer is not supported!');\n                return;\n            }\n            pushQueue({\n                type: 'mediaSource',\n                sourceUpdater: this,\n                action: actions.removeSourceBuffer(type),\n                name: 'removeSourceBuffer'\n            });\n        }\n        /**\n         * Whether or not the removeSourceBuffer function is supported\n         * on the mediaSource.\n         *\n         * @return {boolean}\n         *          if removeSourceBuffer can be called.\n         */\n\n        canRemoveSourceBuffer() {\n            // IE reports that it supports removeSourceBuffer, but often throws\n            // errors when attempting to use the function. So we report that it\n            // does not support removeSourceBuffer. As of Firefox 83 removeSourceBuffer\n            // throws errors, so we report that it does not support this as well.\n            return !videojs.browser.IE_VERSION && !videojs.browser.IS_FIREFOX && window.MediaSource && window.MediaSource.prototype && typeof window.MediaSource.prototype.removeSourceBuffer === 'function';\n        }\n        /**\n         * Whether or not the changeType function is supported\n         * on our SourceBuffers.\n         *\n         * @return {boolean}\n         *         if changeType can be called.\n         */\n\n        static canChangeType() {\n            return window.SourceBuffer && window.SourceBuffer.prototype && typeof window.SourceBuffer.prototype.changeType === 'function';\n        }\n        /**\n         * Whether or not the changeType function is supported\n         * on our SourceBuffers.\n         *\n         * @return {boolean}\n         *         if changeType can be called.\n         */\n\n        canChangeType() {\n            return this.constructor.canChangeType();\n        }\n        /**\n         * Call the changeType function on a source buffer, given the code and type.\n         *\n         * @param {string} type\n         *        The type of source buffer to call changeType on.\n         *\n         * @param {string} codec\n         *        The codec string to change type with on the source buffer.\n         */\n\n        changeType(type, codec) {\n            if (!this.canChangeType()) {\n                videojs.log.error('changeType is not supported!');\n                return;\n            }\n            pushQueue({\n                type,\n                sourceUpdater: this,\n                action: actions.changeType(codec),\n                name: 'changeType'\n            });\n        }\n        /**\n         * Add source buffers with a codec or, if they are already created,\n         * call changeType on source buffers using changeType.\n         *\n         * @param {Object} codecs\n         *        Codecs to switch to\n         */\n\n        addOrChangeSourceBuffers(codecs) {\n            if (!codecs || typeof codecs !== 'object' || Object.keys(codecs).length === 0) {\n                throw new Error('Cannot addOrChangeSourceBuffers to undefined codecs');\n            }\n            Object.keys(codecs).forEach(type => {\n                const codec = codecs[type];\n                if (!this.hasCreatedSourceBuffers()) {\n                    return this.addSourceBuffer(type, codec);\n                }\n                if (this.canChangeType()) {\n                    this.changeType(type, codec);\n                }\n            });\n        }\n        /**\n         * Queue an update to append an ArrayBuffer.\n         *\n         * @param {MediaObject} object containing audioBytes and/or videoBytes\n         * @param {Function} done the function to call when done\n         * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-appendBuffer-void-ArrayBuffer-data\n         */\n\n        appendBuffer(options, doneFn) {\n            const {\n                segmentInfo,\n                type,\n                bytes\n            } = options;\n            this.processedAppend_ = true;\n            if (type === 'audio' && this.videoBuffer && !this.videoAppendQueued_) {\n                this.delayedAudioAppendQueue_.push([options, doneFn]);\n                this.logger_(`delayed audio append of ${bytes.length} until video append`);\n                return;\n            } // In the case of certain errors, for instance, QUOTA_EXCEEDED_ERR, updateend will\n            // not be fired. This means that the queue will be blocked until the next action\n            // taken by the segment-loader. Provide a mechanism for segment-loader to handle\n            // these errors by calling the doneFn with the specific error.\n\n            const onError = doneFn;\n            pushQueue({\n                type,\n                sourceUpdater: this,\n                action: actions.appendBuffer(bytes, segmentInfo || {\n                    mediaIndex: -1\n                }, onError),\n                doneFn,\n                name: 'appendBuffer'\n            });\n            if (type === 'video') {\n                this.videoAppendQueued_ = true;\n                if (!this.delayedAudioAppendQueue_.length) {\n                    return;\n                }\n                const queue = this.delayedAudioAppendQueue_.slice();\n                this.logger_(`queuing delayed audio ${queue.length} appendBuffers`);\n                this.delayedAudioAppendQueue_.length = 0;\n                queue.forEach(que => {\n                    this.appendBuffer.apply(this, que);\n                });\n            }\n        }\n        /**\n         * Get the audio buffer's buffered timerange.\n         *\n         * @return {TimeRange}\n         *         The audio buffer's buffered time range\n         */\n\n        audioBuffered() {\n            // no media source/source buffer or it isn't in the media sources\n            // source buffer list\n            if (!inSourceBuffers(this.mediaSource, this.audioBuffer)) {\n                return createTimeRanges();\n            }\n            return this.audioBuffer.buffered ? this.audioBuffer.buffered : createTimeRanges();\n        }\n        /**\n         * Get the video buffer's buffered timerange.\n         *\n         * @return {TimeRange}\n         *         The video buffer's buffered time range\n         */\n\n        videoBuffered() {\n            // no media source/source buffer or it isn't in the media sources\n            // source buffer list\n            if (!inSourceBuffers(this.mediaSource, this.videoBuffer)) {\n                return createTimeRanges();\n            }\n            return this.videoBuffer.buffered ? this.videoBuffer.buffered : createTimeRanges();\n        }\n        /**\n         * Get a combined video/audio buffer's buffered timerange.\n         *\n         * @return {TimeRange}\n         *         the combined time range\n         */\n\n        buffered() {\n            const video = inSourceBuffers(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null;\n            const audio = inSourceBuffers(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;\n            if (audio && !video) {\n                return this.audioBuffered();\n            }\n            if (video && !audio) {\n                return this.videoBuffered();\n            }\n            return bufferIntersection(this.audioBuffered(), this.videoBuffered());\n        }\n        /**\n         * Add a callback to the queue that will set duration on the mediaSource.\n         *\n         * @param {number} duration\n         *        The duration to set\n         *\n         * @param {Function} [doneFn]\n         *        function to run after duration has been set.\n         */\n\n        setDuration(duration, doneFn = noop) {\n            // In order to set the duration on the media source, it's necessary to wait for all\n            // source buffers to no longer be updating. \"If the updating attribute equals true on\n            // any SourceBuffer in sourceBuffers, then throw an InvalidStateError exception and\n            // abort these steps.\" (source: https://www.w3.org/TR/media-source/#attributes).\n            pushQueue({\n                type: 'mediaSource',\n                sourceUpdater: this,\n                action: actions.duration(duration),\n                name: 'duration',\n                doneFn\n            });\n        }\n        /**\n         * Add a mediaSource endOfStream call to the queue\n         *\n         * @param {Error} [error]\n         *        Call endOfStream with an error\n         *\n         * @param {Function} [doneFn]\n         *        A function that should be called when the\n         *        endOfStream call has finished.\n         */\n\n        endOfStream(error = null, doneFn = noop) {\n            if (typeof error !== 'string') {\n                error = undefined;\n            } // In order to set the duration on the media source, it's necessary to wait for all\n            // source buffers to no longer be updating. \"If the updating attribute equals true on\n            // any SourceBuffer in sourceBuffers, then throw an InvalidStateError exception and\n            // abort these steps.\" (source: https://www.w3.org/TR/media-source/#attributes).\n\n            pushQueue({\n                type: 'mediaSource',\n                sourceUpdater: this,\n                action: actions.endOfStream(error),\n                name: 'endOfStream',\n                doneFn\n            });\n        }\n        /**\n         * Queue an update to remove a time range from the buffer.\n         *\n         * @param {number} start where to start the removal\n         * @param {number} end where to end the removal\n         * @param {Function} [done=noop] optional callback to be executed when the remove\n         * operation is complete\n         * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end\n         */\n\n        removeAudio(start, end, done = noop) {\n            if (!this.audioBuffered().length || this.audioBuffered().end(0) === 0) {\n                done();\n                return;\n            }\n            pushQueue({\n                type: 'audio',\n                sourceUpdater: this,\n                action: actions.remove(start, end),\n                doneFn: done,\n                name: 'remove'\n            });\n        }\n        /**\n         * Queue an update to remove a time range from the buffer.\n         *\n         * @param {number} start where to start the removal\n         * @param {number} end where to end the removal\n         * @param {Function} [done=noop] optional callback to be executed when the remove\n         * operation is complete\n         * @see http://www.w3.org/TR/media-source/#widl-SourceBuffer-remove-void-double-start-unrestricted-double-end\n         */\n\n        removeVideo(start, end, done = noop) {\n            if (!this.videoBuffered().length || this.videoBuffered().end(0) === 0) {\n                done();\n                return;\n            }\n            pushQueue({\n                type: 'video',\n                sourceUpdater: this,\n                action: actions.remove(start, end),\n                doneFn: done,\n                name: 'remove'\n            });\n        }\n        /**\n         * Whether the underlying sourceBuffer is updating or not\n         *\n         * @return {boolean} the updating status of the SourceBuffer\n         */\n\n        updating() {\n            // the audio/video source buffer is updating\n            if (updating('audio', this) || updating('video', this)) {\n                return true;\n            }\n            return false;\n        }\n        /**\n         * Set/get the timestampoffset on the audio SourceBuffer\n         *\n         * @return {number} the timestamp offset\n         */\n\n        audioTimestampOffset(offset) {\n            if (typeof offset !== 'undefined' && this.audioBuffer &&\n                // no point in updating if it's the same\n                this.audioTimestampOffset_ !== offset) {\n                pushQueue({\n                    type: 'audio',\n                    sourceUpdater: this,\n                    action: actions.timestampOffset(offset),\n                    name: 'timestampOffset'\n                });\n                this.audioTimestampOffset_ = offset;\n            }\n            return this.audioTimestampOffset_;\n        }\n        /**\n         * Set/get the timestampoffset on the video SourceBuffer\n         *\n         * @return {number} the timestamp offset\n         */\n\n        videoTimestampOffset(offset) {\n            if (typeof offset !== 'undefined' && this.videoBuffer &&\n                // no point in updating if it's the same\n                this.videoTimestampOffset !== offset) {\n                pushQueue({\n                    type: 'video',\n                    sourceUpdater: this,\n                    action: actions.timestampOffset(offset),\n                    name: 'timestampOffset'\n                });\n                this.videoTimestampOffset_ = offset;\n            }\n            return this.videoTimestampOffset_;\n        }\n        /**\n         * Add a function to the queue that will be called\n         * when it is its turn to run in the audio queue.\n         *\n         * @param {Function} callback\n         *        The callback to queue.\n         */\n\n        audioQueueCallback(callback) {\n            if (!this.audioBuffer) {\n                return;\n            }\n            pushQueue({\n                type: 'audio',\n                sourceUpdater: this,\n                action: actions.callback(callback),\n                name: 'callback'\n            });\n        }\n        /**\n         * Add a function to the queue that will be called\n         * when it is its turn to run in the video queue.\n         *\n         * @param {Function} callback\n         *        The callback to queue.\n         */\n\n        videoQueueCallback(callback) {\n            if (!this.videoBuffer) {\n                return;\n            }\n            pushQueue({\n                type: 'video',\n                sourceUpdater: this,\n                action: actions.callback(callback),\n                name: 'callback'\n            });\n        }\n        /**\n         * dispose of the source updater and the underlying sourceBuffer\n         */\n\n        dispose() {\n            this.trigger('dispose');\n            bufferTypes.forEach(type => {\n                this.abort(type);\n                if (this.canRemoveSourceBuffer()) {\n                    this.removeSourceBuffer(type);\n                } else {\n                    this[`${type}QueueCallback`](() => cleanupBuffer(type, this));\n                }\n            });\n            this.videoAppendQueued_ = false;\n            this.delayedAudioAppendQueue_.length = 0;\n            if (this.sourceopenListener_) {\n                this.mediaSource.removeEventListener('sourceopen', this.sourceopenListener_);\n            }\n            this.off();\n        }\n    }\n    const uint8ToUtf8 = uintArray => decodeURIComponent(escape(String.fromCharCode.apply(null, uintArray)));\n\n    /**\n     * @file vtt-segment-loader.js\n     */\n    const VTT_LINE_TERMINATORS = new Uint8Array('\\n\\n'.split('').map(char => char.charCodeAt(0)));\n    class NoVttJsError extends Error {\n        constructor() {\n            super('Trying to parse received VTT cues, but there is no WebVTT. Make sure vtt.js is loaded.');\n        }\n    }\n    /**\n     * An object that manages segment loading and appending.\n     *\n     * @class VTTSegmentLoader\n     * @param {Object} options required and optional options\n     * @extends videojs.EventTarget\n     */\n\n    class VTTSegmentLoader extends SegmentLoader {\n        constructor(settings, options = {}) {\n            super(settings, options); // SegmentLoader requires a MediaSource be specified or it will throw an error;\n            // however, VTTSegmentLoader has no need of a media source, so delete the reference\n\n            this.mediaSource_ = null;\n            this.subtitlesTrack_ = null;\n            this.loaderType_ = 'subtitle';\n            this.featuresNativeTextTracks_ = settings.featuresNativeTextTracks;\n            this.loadVttJs = settings.loadVttJs; // The VTT segment will have its own time mappings. Saving VTT segment timing info in\n            // the sync controller leads to improper behavior.\n\n            this.shouldSaveSegmentTimingInfo_ = false;\n        }\n        createTransmuxer_() {\n            // don't need to transmux any subtitles\n            return null;\n        }\n        /**\n         * Indicates which time ranges are buffered\n         *\n         * @return {TimeRange}\n         *         TimeRange object representing the current buffered ranges\n         */\n\n        buffered_() {\n            if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length) {\n                return createTimeRanges();\n            }\n            const cues = this.subtitlesTrack_.cues;\n            const start = cues[0].startTime;\n            const end = cues[cues.length - 1].startTime;\n            return createTimeRanges([[start, end]]);\n        }\n        /**\n         * Gets and sets init segment for the provided map\n         *\n         * @param {Object} map\n         *        The map object representing the init segment to get or set\n         * @param {boolean=} set\n         *        If true, the init segment for the provided map should be saved\n         * @return {Object}\n         *         map object for desired init segment\n         */\n\n        initSegmentForMap(map, set = false) {\n            if (!map) {\n                return null;\n            }\n            const id = initSegmentId(map);\n            let storedMap = this.initSegments_[id];\n            if (set && !storedMap && map.bytes) {\n                // append WebVTT line terminators to the media initialization segment if it exists\n                // to follow the WebVTT spec (https://w3c.github.io/webvtt/#file-structure) that\n                // requires two or more WebVTT line terminators between the WebVTT header and the\n                // rest of the file\n                const combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength;\n                const combinedSegment = new Uint8Array(combinedByteLength);\n                combinedSegment.set(map.bytes);\n                combinedSegment.set(VTT_LINE_TERMINATORS, map.bytes.byteLength);\n                this.initSegments_[id] = storedMap = {\n                    resolvedUri: map.resolvedUri,\n                    byterange: map.byterange,\n                    bytes: combinedSegment\n                };\n            }\n            return storedMap || map;\n        }\n        /**\n         * Returns true if all configuration required for loading is present, otherwise false.\n         *\n         * @return {boolean} True if the all configuration is ready for loading\n         * @private\n         */\n\n        couldBeginLoading_() {\n            return this.playlist_ && this.subtitlesTrack_ && !this.paused();\n        }\n        /**\n         * Once all the starting parameters have been specified, begin\n         * operation. This method should only be invoked from the INIT\n         * state.\n         *\n         * @private\n         */\n\n        init_() {\n            this.state = 'READY';\n            this.resetEverything();\n            return this.monitorBuffer_();\n        }\n        /**\n         * Set a subtitle track on the segment loader to add subtitles to\n         *\n         * @param {TextTrack=} track\n         *        The text track to add loaded subtitles to\n         * @return {TextTrack}\n         *        Returns the subtitles track\n         */\n\n        track(track) {\n            if (typeof track === 'undefined') {\n                return this.subtitlesTrack_;\n            }\n            this.subtitlesTrack_ = track; // if we were unpaused but waiting for a sourceUpdater, start\n            // buffering now\n\n            if (this.state === 'INIT' && this.couldBeginLoading_()) {\n                this.init_();\n            }\n            return this.subtitlesTrack_;\n        }\n        /**\n         * Remove any data in the source buffer between start and end times\n         *\n         * @param {number} start - the start time of the region to remove from the buffer\n         * @param {number} end - the end time of the region to remove from the buffer\n         */\n\n        remove(start, end) {\n            removeCuesFromTrack(start, end, this.subtitlesTrack_);\n        }\n        /**\n         * fill the buffer with segements unless the sourceBuffers are\n         * currently updating\n         *\n         * Note: this function should only ever be called by monitorBuffer_\n         * and never directly\n         *\n         * @private\n         */\n\n        fillBuffer_() {\n            // see if we need to begin loading immediately\n            const segmentInfo = this.chooseNextRequest_();\n            if (!segmentInfo) {\n                return;\n            }\n            if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {\n                // We don't have the timestamp offset that we need to sync subtitles.\n                // Rerun on a timestamp offset or user interaction.\n                const checkTimestampOffset = () => {\n                    this.state = 'READY';\n                    if (!this.paused()) {\n                        // if not paused, queue a buffer check as soon as possible\n                        this.monitorBuffer_();\n                    }\n                };\n                this.syncController_.one('timestampoffset', checkTimestampOffset);\n                this.state = 'WAITING_ON_TIMELINE';\n                return;\n            }\n            this.loadSegment_(segmentInfo);\n        } // never set a timestamp offset for vtt segments.\n\n        timestampOffsetForSegment_() {\n            return null;\n        }\n        chooseNextRequest_() {\n            return this.skipEmptySegments_(super.chooseNextRequest_());\n        }\n        /**\n         * Prevents the segment loader from requesting segments we know contain no subtitles\n         * by walking forward until we find the next segment that we don't know whether it is\n         * empty or not.\n         *\n         * @param {Object} segmentInfo\n         *        a segment info object that describes the current segment\n         * @return {Object}\n         *         a segment info object that describes the current segment\n         */\n\n        skipEmptySegments_(segmentInfo) {\n            while (segmentInfo && segmentInfo.segment.empty) {\n                // stop at the last possible segmentInfo\n                if (segmentInfo.mediaIndex + 1 >= segmentInfo.playlist.segments.length) {\n                    segmentInfo = null;\n                    break;\n                }\n                segmentInfo = this.generateSegmentInfo_({\n                    playlist: segmentInfo.playlist,\n                    mediaIndex: segmentInfo.mediaIndex + 1,\n                    startOfSegment: segmentInfo.startOfSegment + segmentInfo.duration,\n                    isSyncRequest: segmentInfo.isSyncRequest\n                });\n            }\n            return segmentInfo;\n        }\n        stopForError(error) {\n            this.error(error);\n            this.state = 'READY';\n            this.pause();\n            this.trigger('error');\n        }\n        /**\n         * append a decrypted segement to the SourceBuffer through a SourceUpdater\n         *\n         * @private\n         */\n\n        segmentRequestFinished_(error, simpleSegment, result) {\n            if (!this.subtitlesTrack_) {\n                this.state = 'READY';\n                return;\n            }\n            this.saveTransferStats_(simpleSegment.stats); // the request was aborted\n\n            if (!this.pendingSegment_) {\n                this.state = 'READY';\n                this.mediaRequestsAborted += 1;\n                return;\n            }\n            if (error) {\n                if (error.code === REQUEST_ERRORS.TIMEOUT) {\n                    this.handleTimeout_();\n                }\n                if (error.code === REQUEST_ERRORS.ABORTED) {\n                    this.mediaRequestsAborted += 1;\n                } else {\n                    this.mediaRequestsErrored += 1;\n                }\n                this.stopForError(error);\n                return;\n            }\n            const segmentInfo = this.pendingSegment_; // although the VTT segment loader bandwidth isn't really used, it's good to\n            // maintain functionality between segment loaders\n\n            this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats); // if this request included a segment key, save that data in the cache\n\n            if (simpleSegment.key) {\n                this.segmentKey(simpleSegment.key, true);\n            }\n            this.state = 'APPENDING'; // used for tests\n\n            this.trigger('appending');\n            const segment = segmentInfo.segment;\n            if (segment.map) {\n                segment.map.bytes = simpleSegment.map.bytes;\n            }\n            segmentInfo.bytes = simpleSegment.bytes; // Make sure that vttjs has loaded, otherwise, load it and wait till it finished loading\n\n            if (typeof window.WebVTT !== 'function' && typeof this.loadVttJs === 'function') {\n                this.state = 'WAITING_ON_VTTJS'; // should be fine to call multiple times\n                // script will be loaded once but multiple listeners will be added to the queue, which is expected.\n\n                this.loadVttJs().then(() => this.segmentRequestFinished_(error, simpleSegment, result), () => this.stopForError({\n                    message: 'Error loading vtt.js'\n                }));\n                return;\n            }\n            segment.requested = true;\n            try {\n                this.parseVTTCues_(segmentInfo);\n            } catch (e) {\n                this.stopForError({\n                    message: e.message\n                });\n                return;\n            }\n            this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);\n            if (segmentInfo.cues.length) {\n                segmentInfo.timingInfo = {\n                    start: segmentInfo.cues[0].startTime,\n                    end: segmentInfo.cues[segmentInfo.cues.length - 1].endTime\n                };\n            } else {\n                segmentInfo.timingInfo = {\n                    start: segmentInfo.startOfSegment,\n                    end: segmentInfo.startOfSegment + segmentInfo.duration\n                };\n            }\n            if (segmentInfo.isSyncRequest) {\n                this.trigger('syncinfoupdate');\n                this.pendingSegment_ = null;\n                this.state = 'READY';\n                return;\n            }\n            segmentInfo.byteLength = segmentInfo.bytes.byteLength;\n            this.mediaSecondsLoaded += segment.duration; // Create VTTCue instances for each cue in the new segment and add them to\n            // the subtitle track\n\n            segmentInfo.cues.forEach(cue => {\n                this.subtitlesTrack_.addCue(this.featuresNativeTextTracks_ ? new window.VTTCue(cue.startTime, cue.endTime, cue.text) : cue);\n            }); // Remove any duplicate cues from the subtitle track. The WebVTT spec allows\n            // cues to have identical time-intervals, but if the text is also identical\n            // we can safely assume it is a duplicate that can be removed (ex. when a cue\n            // \"overlaps\" VTT segments)\n\n            removeDuplicateCuesFromTrack(this.subtitlesTrack_);\n            this.handleAppendsDone_();\n        }\n        handleData_() {// noop as we shouldn't be getting video/audio data captions\n            // that we do not support here.\n        }\n        updateTimingInfoEnd_() {// noop\n        }\n        /**\n         * Uses the WebVTT parser to parse the segment response\n         *\n         * @throws NoVttJsError\n         *\n         * @param {Object} segmentInfo\n         *        a segment info object that describes the current segment\n         * @private\n         */\n\n        parseVTTCues_(segmentInfo) {\n            let decoder;\n            let decodeBytesToString = false;\n            if (typeof window.WebVTT !== 'function') {\n                // caller is responsible for exception handling.\n                throw new NoVttJsError();\n            }\n            if (typeof window.TextDecoder === 'function') {\n                decoder = new window.TextDecoder('utf8');\n            } else {\n                decoder = window.WebVTT.StringDecoder();\n                decodeBytesToString = true;\n            }\n            const parser = new window.WebVTT.Parser(window, window.vttjs, decoder);\n            segmentInfo.cues = [];\n            segmentInfo.timestampmap = {\n                MPEGTS: 0,\n                LOCAL: 0\n            };\n            parser.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);\n            parser.ontimestampmap = map => {\n                segmentInfo.timestampmap = map;\n            };\n            parser.onparsingerror = error => {\n                videojs.log.warn('Error encountered when parsing cues: ' + error.message);\n            };\n            if (segmentInfo.segment.map) {\n                let mapData = segmentInfo.segment.map.bytes;\n                if (decodeBytesToString) {\n                    mapData = uint8ToUtf8(mapData);\n                }\n                parser.parse(mapData);\n            }\n            let segmentData = segmentInfo.bytes;\n            if (decodeBytesToString) {\n                segmentData = uint8ToUtf8(segmentData);\n            }\n            parser.parse(segmentData);\n            parser.flush();\n        }\n        /**\n         * Updates the start and end times of any cues parsed by the WebVTT parser using\n         * the information parsed from the X-TIMESTAMP-MAP header and a TS to media time mapping\n         * from the SyncController\n         *\n         * @param {Object} segmentInfo\n         *        a segment info object that describes the current segment\n         * @param {Object} mappingObj\n         *        object containing a mapping from TS to media time\n         * @param {Object} playlist\n         *        the playlist object containing the segment\n         * @private\n         */\n\n        updateTimeMapping_(segmentInfo, mappingObj, playlist) {\n            const segment = segmentInfo.segment;\n            if (!mappingObj) {\n                // If the sync controller does not have a mapping of TS to Media Time for the\n                // timeline, then we don't have enough information to update the cue\n                // start/end times\n                return;\n            }\n            if (!segmentInfo.cues.length) {\n                // If there are no cues, we also do not have enough information to figure out\n                // segment timing. Mark that the segment contains no cues so we don't re-request\n                // an empty segment.\n                segment.empty = true;\n                return;\n            }\n            const timestampmap = segmentInfo.timestampmap;\n            const diff = timestampmap.MPEGTS / clock_1 - timestampmap.LOCAL + mappingObj.mapping;\n            segmentInfo.cues.forEach(cue => {\n                // First convert cue time to TS time using the timestamp-map provided within the vtt\n                cue.startTime += diff;\n                cue.endTime += diff;\n            });\n            if (!playlist.syncInfo) {\n                const firstStart = segmentInfo.cues[0].startTime;\n                const lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;\n                playlist.syncInfo = {\n                    mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,\n                    time: Math.min(firstStart, lastStart - segment.duration)\n                };\n            }\n        }\n    }\n\n    /**\n     * @file ad-cue-tags.js\n     */\n    /**\n     * Searches for an ad cue that overlaps with the given mediaTime\n     *\n     * @param {Object} track\n     *        the track to find the cue for\n     *\n     * @param {number} mediaTime\n     *        the time to find the cue at\n     *\n     * @return {Object|null}\n     *         the found cue or null\n     */\n\n    const findAdCue = function (track, mediaTime) {\n        const cues = track.cues;\n        for (let i = 0; i < cues.length; i++) {\n            const cue = cues[i];\n            if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) {\n                return cue;\n            }\n        }\n        return null;\n    };\n    const updateAdCues = function (media, track, offset = 0) {\n        if (!media.segments) {\n            return;\n        }\n        let mediaTime = offset;\n        let cue;\n        for (let i = 0; i < media.segments.length; i++) {\n            const segment = media.segments[i];\n            if (!cue) {\n                // Since the cues will span for at least the segment duration, adding a fudge\n                // factor of half segment duration will prevent duplicate cues from being\n                // created when timing info is not exact (e.g. cue start time initialized\n                // at 10.006677, but next call mediaTime is 10.003332 )\n                cue = findAdCue(track, mediaTime + segment.duration / 2);\n            }\n            if (cue) {\n                if ('cueIn' in segment) {\n                    // Found a CUE-IN so end the cue\n                    cue.endTime = mediaTime;\n                    cue.adEndTime = mediaTime;\n                    mediaTime += segment.duration;\n                    cue = null;\n                    continue;\n                }\n                if (mediaTime < cue.endTime) {\n                    // Already processed this mediaTime for this cue\n                    mediaTime += segment.duration;\n                    continue;\n                } // otherwise extend cue until a CUE-IN is found\n\n                cue.endTime += segment.duration;\n            } else {\n                if ('cueOut' in segment) {\n                    cue = new window.VTTCue(mediaTime, mediaTime + segment.duration, segment.cueOut);\n                    cue.adStartTime = mediaTime; // Assumes tag format to be\n                    // #EXT-X-CUE-OUT:30\n\n                    cue.adEndTime = mediaTime + parseFloat(segment.cueOut);\n                    track.addCue(cue);\n                }\n                if ('cueOutCont' in segment) {\n                    // Entered into the middle of an ad cue\n                    // Assumes tag formate to be\n                    // #EXT-X-CUE-OUT-CONT:10/30\n                    const [adOffset, adTotal] = segment.cueOutCont.split('/').map(parseFloat);\n                    cue = new window.VTTCue(mediaTime, mediaTime + segment.duration, '');\n                    cue.adStartTime = mediaTime - adOffset;\n                    cue.adEndTime = cue.adStartTime + adTotal;\n                    track.addCue(cue);\n                }\n            }\n            mediaTime += segment.duration;\n        }\n    };\n\n    /**\n     * @file sync-controller.js\n     */\n        // synchronize expired playlist segments.\n        // the max media sequence diff is 48 hours of live stream\n        // content with two second segments. Anything larger than that\n        // will likely be invalid.\n\n    const MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC = 86400;\n    const syncPointStrategies = [\n        // Stategy \"VOD\": Handle the VOD-case where the sync-point is *always*\n        //                the equivalence display-time 0 === segment-index 0\n        {\n            name: 'VOD',\n            run: (syncController, playlist, duration, currentTimeline, currentTime) => {\n                if (duration !== Infinity) {\n                    const syncPoint = {\n                        time: 0,\n                        segmentIndex: 0,\n                        partIndex: null\n                    };\n                    return syncPoint;\n                }\n                return null;\n            }\n        },\n        // Stategy \"ProgramDateTime\": We have a program-date-time tag in this playlist\n        {\n            name: 'ProgramDateTime',\n            run: (syncController, playlist, duration, currentTimeline, currentTime) => {\n                if (!Object.keys(syncController.timelineToDatetimeMappings).length) {\n                    return null;\n                }\n                let syncPoint = null;\n                let lastDistance = null;\n                const partsAndSegments = getPartsAndSegments(playlist);\n                currentTime = currentTime || 0;\n                for (let i = 0; i < partsAndSegments.length; i++) {\n                    // start from the end and loop backwards for live\n                    // or start from the front and loop forwards for non-live\n                    const index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);\n                    const partAndSegment = partsAndSegments[index];\n                    const segment = partAndSegment.segment;\n                    const datetimeMapping = syncController.timelineToDatetimeMappings[segment.timeline];\n                    if (!datetimeMapping || !segment.dateTimeObject) {\n                        continue;\n                    }\n                    const segmentTime = segment.dateTimeObject.getTime() / 1000;\n                    let start = segmentTime + datetimeMapping; // take part duration into account.\n\n                    if (segment.parts && typeof partAndSegment.partIndex === 'number') {\n                        for (let z = 0; z < partAndSegment.partIndex; z++) {\n                            start += segment.parts[z].duration;\n                        }\n                    }\n                    const distance = Math.abs(currentTime - start); // Once the distance begins to increase, or if distance is 0, we have passed\n                    // currentTime and can stop looking for better candidates\n\n                    if (lastDistance !== null && (distance === 0 || lastDistance < distance)) {\n                        break;\n                    }\n                    lastDistance = distance;\n                    syncPoint = {\n                        time: start,\n                        segmentIndex: partAndSegment.segmentIndex,\n                        partIndex: partAndSegment.partIndex\n                    };\n                }\n                return syncPoint;\n            }\n        },\n        // Stategy \"Segment\": We have a known time mapping for a timeline and a\n        //                    segment in the current timeline with timing data\n        {\n            name: 'Segment',\n            run: (syncController, playlist, duration, currentTimeline, currentTime) => {\n                let syncPoint = null;\n                let lastDistance = null;\n                currentTime = currentTime || 0;\n                const partsAndSegments = getPartsAndSegments(playlist);\n                for (let i = 0; i < partsAndSegments.length; i++) {\n                    // start from the end and loop backwards for live\n                    // or start from the front and loop forwards for non-live\n                    const index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);\n                    const partAndSegment = partsAndSegments[index];\n                    const segment = partAndSegment.segment;\n                    const start = partAndSegment.part && partAndSegment.part.start || segment && segment.start;\n                    if (segment.timeline === currentTimeline && typeof start !== 'undefined') {\n                        const distance = Math.abs(currentTime - start); // Once the distance begins to increase, we have passed\n                        // currentTime and can stop looking for better candidates\n\n                        if (lastDistance !== null && lastDistance < distance) {\n                            break;\n                        }\n                        if (!syncPoint || lastDistance === null || lastDistance >= distance) {\n                            lastDistance = distance;\n                            syncPoint = {\n                                time: start,\n                                segmentIndex: partAndSegment.segmentIndex,\n                                partIndex: partAndSegment.partIndex\n                            };\n                        }\n                    }\n                }\n                return syncPoint;\n            }\n        },\n        // Stategy \"Discontinuity\": We have a discontinuity with a known\n        //                          display-time\n        {\n            name: 'Discontinuity',\n            run: (syncController, playlist, duration, currentTimeline, currentTime) => {\n                let syncPoint = null;\n                currentTime = currentTime || 0;\n                if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {\n                    let lastDistance = null;\n                    for (let i = 0; i < playlist.discontinuityStarts.length; i++) {\n                        const segmentIndex = playlist.discontinuityStarts[i];\n                        const discontinuity = playlist.discontinuitySequence + i + 1;\n                        const discontinuitySync = syncController.discontinuities[discontinuity];\n                        if (discontinuitySync) {\n                            const distance = Math.abs(currentTime - discontinuitySync.time); // Once the distance begins to increase, we have passed\n                            // currentTime and can stop looking for better candidates\n\n                            if (lastDistance !== null && lastDistance < distance) {\n                                break;\n                            }\n                            if (!syncPoint || lastDistance === null || lastDistance >= distance) {\n                                lastDistance = distance;\n                                syncPoint = {\n                                    time: discontinuitySync.time,\n                                    segmentIndex,\n                                    partIndex: null\n                                };\n                            }\n                        }\n                    }\n                }\n                return syncPoint;\n            }\n        },\n        // Stategy \"Playlist\": We have a playlist with a known mapping of\n        //                     segment index to display time\n        {\n            name: 'Playlist',\n            run: (syncController, playlist, duration, currentTimeline, currentTime) => {\n                if (playlist.syncInfo) {\n                    const syncPoint = {\n                        time: playlist.syncInfo.time,\n                        segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence,\n                        partIndex: null\n                    };\n                    return syncPoint;\n                }\n                return null;\n            }\n        }];\n    class SyncController extends videojs.EventTarget {\n        constructor(options = {}) {\n            super(); // ...for synching across variants\n\n            this.timelines = [];\n            this.discontinuities = [];\n            this.timelineToDatetimeMappings = {};\n            this.logger_ = logger('SyncController');\n        }\n        /**\n         * Find a sync-point for the playlist specified\n         *\n         * A sync-point is defined as a known mapping from display-time to\n         * a segment-index in the current playlist.\n         *\n         * @param {Playlist} playlist\n         *        The playlist that needs a sync-point\n         * @param {number} duration\n         *        Duration of the MediaSource (Infinite if playing a live source)\n         * @param {number} currentTimeline\n         *        The last timeline from which a segment was loaded\n         * @return {Object}\n         *          A sync-point object\n         */\n\n        getSyncPoint(playlist, duration, currentTimeline, currentTime) {\n            const syncPoints = this.runStrategies_(playlist, duration, currentTimeline, currentTime);\n            if (!syncPoints.length) {\n                // Signal that we need to attempt to get a sync-point manually\n                // by fetching a segment in the playlist and constructing\n                // a sync-point from that information\n                return null;\n            } // Now find the sync-point that is closest to the currentTime because\n            // that should result in the most accurate guess about which segment\n            // to fetch\n\n            return this.selectSyncPoint_(syncPoints, {\n                key: 'time',\n                value: currentTime\n            });\n        }\n        /**\n         * Calculate the amount of time that has expired off the playlist during playback\n         *\n         * @param {Playlist} playlist\n         *        Playlist object to calculate expired from\n         * @param {number} duration\n         *        Duration of the MediaSource (Infinity if playling a live source)\n         * @return {number|null}\n         *          The amount of time that has expired off the playlist during playback. Null\n         *          if no sync-points for the playlist can be found.\n         */\n\n        getExpiredTime(playlist, duration) {\n            if (!playlist || !playlist.segments) {\n                return null;\n            }\n            const syncPoints = this.runStrategies_(playlist, duration, playlist.discontinuitySequence, 0); // Without sync-points, there is not enough information to determine the expired time\n\n            if (!syncPoints.length) {\n                return null;\n            }\n            const syncPoint = this.selectSyncPoint_(syncPoints, {\n                key: 'segmentIndex',\n                value: 0\n            }); // If the sync-point is beyond the start of the playlist, we want to subtract the\n            // duration from index 0 to syncPoint.segmentIndex instead of adding.\n\n            if (syncPoint.segmentIndex > 0) {\n                syncPoint.time *= -1;\n            }\n            return Math.abs(syncPoint.time + sumDurations({\n                defaultDuration: playlist.targetDuration,\n                durationList: playlist.segments,\n                startIndex: syncPoint.segmentIndex,\n                endIndex: 0\n            }));\n        }\n        /**\n         * Runs each sync-point strategy and returns a list of sync-points returned by the\n         * strategies\n         *\n         * @private\n         * @param {Playlist} playlist\n         *        The playlist that needs a sync-point\n         * @param {number} duration\n         *        Duration of the MediaSource (Infinity if playing a live source)\n         * @param {number} currentTimeline\n         *        The last timeline from which a segment was loaded\n         * @return {Array}\n         *          A list of sync-point objects\n         */\n\n        runStrategies_(playlist, duration, currentTimeline, currentTime) {\n            const syncPoints = []; // Try to find a sync-point in by utilizing various strategies...\n\n            for (let i = 0; i < syncPointStrategies.length; i++) {\n                const strategy = syncPointStrategies[i];\n                const syncPoint = strategy.run(this, playlist, duration, currentTimeline, currentTime);\n                if (syncPoint) {\n                    syncPoint.strategy = strategy.name;\n                    syncPoints.push({\n                        strategy: strategy.name,\n                        syncPoint\n                    });\n                }\n            }\n            return syncPoints;\n        }\n        /**\n         * Selects the sync-point nearest the specified target\n         *\n         * @private\n         * @param {Array} syncPoints\n         *        List of sync-points to select from\n         * @param {Object} target\n         *        Object specifying the property and value we are targeting\n         * @param {string} target.key\n         *        Specifies the property to target. Must be either 'time' or 'segmentIndex'\n         * @param {number} target.value\n         *        The value to target for the specified key.\n         * @return {Object}\n         *          The sync-point nearest the target\n         */\n\n        selectSyncPoint_(syncPoints, target) {\n            let bestSyncPoint = syncPoints[0].syncPoint;\n            let bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);\n            let bestStrategy = syncPoints[0].strategy;\n            for (let i = 1; i < syncPoints.length; i++) {\n                const newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);\n                if (newDistance < bestDistance) {\n                    bestDistance = newDistance;\n                    bestSyncPoint = syncPoints[i].syncPoint;\n                    bestStrategy = syncPoints[i].strategy;\n                }\n            }\n            this.logger_(`syncPoint for [${target.key}: ${target.value}] chosen with strategy` + ` [${bestStrategy}]: [time:${bestSyncPoint.time},` + ` segmentIndex:${bestSyncPoint.segmentIndex}` + (typeof bestSyncPoint.partIndex === 'number' ? `,partIndex:${bestSyncPoint.partIndex}` : '') + ']');\n            return bestSyncPoint;\n        }\n        /**\n         * Save any meta-data present on the segments when segments leave\n         * the live window to the playlist to allow for synchronization at the\n         * playlist level later.\n         *\n         * @param {Playlist} oldPlaylist - The previous active playlist\n         * @param {Playlist} newPlaylist - The updated and most current playlist\n         */\n\n        saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {\n            const mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence; // Ignore large media sequence gaps\n\n            if (mediaSequenceDiff > MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC) {\n                videojs.log.warn(`Not saving expired segment info. Media sequence gap ${mediaSequenceDiff} is too large.`);\n                return;\n            } // When a segment expires from the playlist and it has a start time\n            // save that information as a possible sync-point reference in future\n\n            for (let i = mediaSequenceDiff - 1; i >= 0; i--) {\n                const lastRemovedSegment = oldPlaylist.segments[i];\n                if (lastRemovedSegment && typeof lastRemovedSegment.start !== 'undefined') {\n                    newPlaylist.syncInfo = {\n                        mediaSequence: oldPlaylist.mediaSequence + i,\n                        time: lastRemovedSegment.start\n                    };\n                    this.logger_(`playlist refresh sync: [time:${newPlaylist.syncInfo.time},` + ` mediaSequence: ${newPlaylist.syncInfo.mediaSequence}]`);\n                    this.trigger('syncinfoupdate');\n                    break;\n                }\n            }\n        }\n        /**\n         * Save the mapping from playlist's ProgramDateTime to display. This should only happen\n         * before segments start to load.\n         *\n         * @param {Playlist} playlist - The currently active playlist\n         */\n\n        setDateTimeMappingForStart(playlist) {\n            // It's possible for the playlist to be updated before playback starts, meaning time\n            // zero is not yet set. If, during these playlist refreshes, a discontinuity is\n            // crossed, then the old time zero mapping (for the prior timeline) would be retained\n            // unless the mappings are cleared.\n            this.timelineToDatetimeMappings = {};\n            if (playlist.segments && playlist.segments.length && playlist.segments[0].dateTimeObject) {\n                const firstSegment = playlist.segments[0];\n                const playlistTimestamp = firstSegment.dateTimeObject.getTime() / 1000;\n                this.timelineToDatetimeMappings[firstSegment.timeline] = -playlistTimestamp;\n            }\n        }\n        /**\n         * Calculates and saves timeline mappings, playlist sync info, and segment timing values\n         * based on the latest timing information.\n         *\n         * @param {Object} options\n         *        Options object\n         * @param {SegmentInfo} options.segmentInfo\n         *        The current active request information\n         * @param {boolean} options.shouldSaveTimelineMapping\n         *        If there's a timeline change, determines if the timeline mapping should be\n         *        saved for timeline mapping and program date time mappings.\n         */\n\n        saveSegmentTimingInfo({\n                                  segmentInfo,\n                                  shouldSaveTimelineMapping\n                              }) {\n            const didCalculateSegmentTimeMapping = this.calculateSegmentTimeMapping_(segmentInfo, segmentInfo.timingInfo, shouldSaveTimelineMapping);\n            const segment = segmentInfo.segment;\n            if (didCalculateSegmentTimeMapping) {\n                this.saveDiscontinuitySyncInfo_(segmentInfo); // If the playlist does not have sync information yet, record that information\n                // now with segment timing information\n\n                if (!segmentInfo.playlist.syncInfo) {\n                    segmentInfo.playlist.syncInfo = {\n                        mediaSequence: segmentInfo.playlist.mediaSequence + segmentInfo.mediaIndex,\n                        time: segment.start\n                    };\n                }\n            }\n            const dateTime = segment.dateTimeObject;\n            if (segment.discontinuity && shouldSaveTimelineMapping && dateTime) {\n                this.timelineToDatetimeMappings[segment.timeline] = -(dateTime.getTime() / 1000);\n            }\n        }\n        timestampOffsetForTimeline(timeline) {\n            if (typeof this.timelines[timeline] === 'undefined') {\n                return null;\n            }\n            return this.timelines[timeline].time;\n        }\n        mappingForTimeline(timeline) {\n            if (typeof this.timelines[timeline] === 'undefined') {\n                return null;\n            }\n            return this.timelines[timeline].mapping;\n        }\n        /**\n         * Use the \"media time\" for a segment to generate a mapping to \"display time\" and\n         * save that display time to the segment.\n         *\n         * @private\n         * @param {SegmentInfo} segmentInfo\n         *        The current active request information\n         * @param {Object} timingInfo\n         *        The start and end time of the current segment in \"media time\"\n         * @param {boolean} shouldSaveTimelineMapping\n         *        If there's a timeline change, determines if the timeline mapping should be\n         *        saved in timelines.\n         * @return {boolean}\n         *          Returns false if segment time mapping could not be calculated\n         */\n\n        calculateSegmentTimeMapping_(segmentInfo, timingInfo, shouldSaveTimelineMapping) {\n            // TODO: remove side effects\n            const segment = segmentInfo.segment;\n            const part = segmentInfo.part;\n            let mappingObj = this.timelines[segmentInfo.timeline];\n            let start;\n            let end;\n            if (typeof segmentInfo.timestampOffset === 'number') {\n                mappingObj = {\n                    time: segmentInfo.startOfSegment,\n                    mapping: segmentInfo.startOfSegment - timingInfo.start\n                };\n                if (shouldSaveTimelineMapping) {\n                    this.timelines[segmentInfo.timeline] = mappingObj;\n                    this.trigger('timestampoffset');\n                    this.logger_(`time mapping for timeline ${segmentInfo.timeline}: ` + `[time: ${mappingObj.time}] [mapping: ${mappingObj.mapping}]`);\n                }\n                start = segmentInfo.startOfSegment;\n                end = timingInfo.end + mappingObj.mapping;\n            } else if (mappingObj) {\n                start = timingInfo.start + mappingObj.mapping;\n                end = timingInfo.end + mappingObj.mapping;\n            } else {\n                return false;\n            }\n            if (part) {\n                part.start = start;\n                part.end = end;\n            } // If we don't have a segment start yet or the start value we got\n            // is less than our current segment.start value, save a new start value.\n            // We have to do this because parts will have segment timing info saved\n            // multiple times and we want segment start to be the earliest part start\n            // value for that segment.\n\n            if (!segment.start || start < segment.start) {\n                segment.start = start;\n            }\n            segment.end = end;\n            return true;\n        }\n        /**\n         * Each time we have discontinuity in the playlist, attempt to calculate the location\n         * in display of the start of the discontinuity and save that. We also save an accuracy\n         * value so that we save values with the most accuracy (closest to 0.)\n         *\n         * @private\n         * @param {SegmentInfo} segmentInfo - The current active request information\n         */\n\n        saveDiscontinuitySyncInfo_(segmentInfo) {\n            const playlist = segmentInfo.playlist;\n            const segment = segmentInfo.segment; // If the current segment is a discontinuity then we know exactly where\n            // the start of the range and it's accuracy is 0 (greater accuracy values\n            // mean more approximation)\n\n            if (segment.discontinuity) {\n                this.discontinuities[segment.timeline] = {\n                    time: segment.start,\n                    accuracy: 0\n                };\n            } else if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {\n                // Search for future discontinuities that we can provide better timing\n                // information for and save that information for sync purposes\n                for (let i = 0; i < playlist.discontinuityStarts.length; i++) {\n                    const segmentIndex = playlist.discontinuityStarts[i];\n                    const discontinuity = playlist.discontinuitySequence + i + 1;\n                    const mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;\n                    const accuracy = Math.abs(mediaIndexDiff);\n                    if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {\n                        let time;\n                        if (mediaIndexDiff < 0) {\n                            time = segment.start - sumDurations({\n                                defaultDuration: playlist.targetDuration,\n                                durationList: playlist.segments,\n                                startIndex: segmentInfo.mediaIndex,\n                                endIndex: segmentIndex\n                            });\n                        } else {\n                            time = segment.end + sumDurations({\n                                defaultDuration: playlist.targetDuration,\n                                durationList: playlist.segments,\n                                startIndex: segmentInfo.mediaIndex + 1,\n                                endIndex: segmentIndex\n                            });\n                        }\n                        this.discontinuities[discontinuity] = {\n                            time,\n                            accuracy\n                        };\n                    }\n                }\n            }\n        }\n        dispose() {\n            this.trigger('dispose');\n            this.off();\n        }\n    }\n\n    /**\n     * The TimelineChangeController acts as a source for segment loaders to listen for and\n     * keep track of latest and pending timeline changes. This is useful to ensure proper\n     * sync, as each loader may need to make a consideration for what timeline the other\n     * loader is on before making changes which could impact the other loader's media.\n     *\n     * @class TimelineChangeController\n     * @extends videojs.EventTarget\n     */\n\n    class TimelineChangeController extends videojs.EventTarget {\n        constructor() {\n            super();\n            this.pendingTimelineChanges_ = {};\n            this.lastTimelineChanges_ = {};\n        }\n        clearPendingTimelineChange(type) {\n            this.pendingTimelineChanges_[type] = null;\n            this.trigger('pendingtimelinechange');\n        }\n        pendingTimelineChange({\n                                  type,\n                                  from,\n                                  to\n                              }) {\n            if (typeof from === 'number' && typeof to === 'number') {\n                this.pendingTimelineChanges_[type] = {\n                    type,\n                    from,\n                    to\n                };\n                this.trigger('pendingtimelinechange');\n            }\n            return this.pendingTimelineChanges_[type];\n        }\n        lastTimelineChange({\n                               type,\n                               from,\n                               to\n                           }) {\n            if (typeof from === 'number' && typeof to === 'number') {\n                this.lastTimelineChanges_[type] = {\n                    type,\n                    from,\n                    to\n                };\n                delete this.pendingTimelineChanges_[type];\n                this.trigger('timelinechange');\n            }\n            return this.lastTimelineChanges_[type];\n        }\n        dispose() {\n            this.trigger('dispose');\n            this.pendingTimelineChanges_ = {};\n            this.lastTimelineChanges_ = {};\n            this.off();\n        }\n    }\n\n    /* rollup-plugin-worker-factory start for worker!/Users/ddashkevich/projects/http-streaming/src/decrypter-worker.js */\n    const workerCode = transform(getWorkerString(function () {\n        /**\n         * @file stream.js\n         */\n\n        /**\n         * A lightweight readable stream implemention that handles event dispatching.\n         *\n         * @class Stream\n         */\n\n        var Stream = /*#__PURE__*/function () {\n            function Stream() {\n                this.listeners = {};\n            }\n            /**\n             * Add a listener for a specified event type.\n             *\n             * @param {string} type the event name\n             * @param {Function} listener the callback to be invoked when an event of\n             * the specified type occurs\n             */\n\n            var _proto = Stream.prototype;\n            _proto.on = function on(type, listener) {\n                if (!this.listeners[type]) {\n                    this.listeners[type] = [];\n                }\n                this.listeners[type].push(listener);\n            }\n            /**\n             * Remove a listener for a specified event type.\n             *\n             * @param {string} type the event name\n             * @param {Function} listener  a function previously registered for this\n             * type of event through `on`\n             * @return {boolean} if we could turn it off or not\n             */;\n\n            _proto.off = function off(type, listener) {\n                if (!this.listeners[type]) {\n                    return false;\n                }\n                var index = this.listeners[type].indexOf(listener); // TODO: which is better?\n                // In Video.js we slice listener functions\n                // on trigger so that it does not mess up the order\n                // while we loop through.\n                //\n                // Here we slice on off so that the loop in trigger\n                // can continue using it's old reference to loop without\n                // messing up the order.\n\n                this.listeners[type] = this.listeners[type].slice(0);\n                this.listeners[type].splice(index, 1);\n                return index > -1;\n            }\n            /**\n             * Trigger an event of the specified type on this stream. Any additional\n             * arguments to this function are passed as parameters to event listeners.\n             *\n             * @param {string} type the event name\n             */;\n\n            _proto.trigger = function trigger(type) {\n                var callbacks = this.listeners[type];\n                if (!callbacks) {\n                    return;\n                } // Slicing the arguments on every invocation of this method\n                // can add a significant amount of overhead. Avoid the\n                // intermediate object creation for the common case of a\n                // single callback argument\n\n                if (arguments.length === 2) {\n                    var length = callbacks.length;\n                    for (var i = 0; i < length; ++i) {\n                        callbacks[i].call(this, arguments[1]);\n                    }\n                } else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var _length = callbacks.length;\n                    for (var _i = 0; _i < _length; ++_i) {\n                        callbacks[_i].apply(this, args);\n                    }\n                }\n            }\n            /**\n             * Destroys the stream and cleans up.\n             */;\n\n            _proto.dispose = function dispose() {\n                this.listeners = {};\n            }\n            /**\n             * Forwards all `data` events on this stream to the destination stream. The\n             * destination stream should provide a method `push` to receive the data\n             * events as they arrive.\n             *\n             * @param {Stream} destination the stream that will receive all `data` events\n             * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n             */;\n\n            _proto.pipe = function pipe(destination) {\n                this.on('data', function (data) {\n                    destination.push(data);\n                });\n            };\n            return Stream;\n        }();\n        /*! @name pkcs7 @version 1.0.4 @license Apache-2.0 */\n\n        /**\n         * Returns the subarray of a Uint8Array without PKCS#7 padding.\n         *\n         * @param padded {Uint8Array} unencrypted bytes that have been padded\n         * @return {Uint8Array} the unpadded bytes\n         * @see http://tools.ietf.org/html/rfc5652\n         */\n\n        function unpad(padded) {\n            return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);\n        }\n        /*! @name aes-decrypter @version 4.0.1 @license Apache-2.0 */\n\n        /**\n         * @file aes.js\n         *\n         * This file contains an adaptation of the AES decryption algorithm\n         * from the Standford Javascript Cryptography Library. That work is\n         * covered by the following copyright and permissions notice:\n         *\n         * Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.\n         * All rights reserved.\n         *\n         * Redistribution and use in source and binary forms, with or without\n         * modification, are permitted provided that the following conditions are\n         * met:\n         *\n         * 1. Redistributions of source code must retain the above copyright\n         *    notice, this list of conditions and the following disclaimer.\n         *\n         * 2. Redistributions in binary form must reproduce the above\n         *    copyright notice, this list of conditions and the following\n         *    disclaimer in the documentation and/or other materials provided\n         *    with the distribution.\n         *\n         * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\n         * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n         * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n         * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE\n         * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n         * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n         * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n         * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n         * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n         * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n         * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n         *\n         * The views and conclusions contained in the software and documentation\n         * are those of the authors and should not be interpreted as representing\n         * official policies, either expressed or implied, of the authors.\n         */\n\n        /**\n         * Expand the S-box tables.\n         *\n         * @private\n         */\n\n        const precompute = function () {\n            const tables = [[[], [], [], [], []], [[], [], [], [], []]];\n            const encTable = tables[0];\n            const decTable = tables[1];\n            const sbox = encTable[4];\n            const sboxInv = decTable[4];\n            let i;\n            let x;\n            let xInv;\n            const d = [];\n            const th = [];\n            let x2;\n            let x4;\n            let x8;\n            let s;\n            let tEnc;\n            let tDec; // Compute double and third tables\n\n            for (i = 0; i < 256; i++) {\n                th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;\n            }\n            for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\n                // Compute sbox\n                s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;\n                s = s >> 8 ^ s & 255 ^ 99;\n                sbox[x] = s;\n                sboxInv[s] = x; // Compute MixColumns\n\n                x8 = d[x4 = d[x2 = d[x]]];\n                tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n                tEnc = d[s] * 0x101 ^ s * 0x1010100;\n                for (i = 0; i < 4; i++) {\n                    encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n                    decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;\n                }\n            } // Compactify. Considerable speedup on Firefox.\n\n            for (i = 0; i < 5; i++) {\n                encTable[i] = encTable[i].slice(0);\n                decTable[i] = decTable[i].slice(0);\n            }\n            return tables;\n        };\n        let aesTables = null;\n        /**\n         * Schedule out an AES key for both encryption and decryption. This\n         * is a low-level class. Use a cipher mode to do bulk encryption.\n         *\n         * @class AES\n         * @param key {Array} The key as an array of 4, 6 or 8 words.\n         */\n\n        class AES {\n            constructor(key) {\n                /**\n                 * The expanded S-box and inverse S-box tables. These will be computed\n                 * on the client so that we don't have to send them down the wire.\n                 *\n                 * There are two tables, _tables[0] is for encryption and\n                 * _tables[1] is for decryption.\n                 *\n                 * The first 4 sub-tables are the expanded S-box with MixColumns. The\n                 * last (_tables[01][4]) is the S-box itself.\n                 *\n                 * @private\n                 */\n                // if we have yet to precompute the S-box tables\n                // do so now\n                if (!aesTables) {\n                    aesTables = precompute();\n                } // then make a copy of that object for use\n\n                this._tables = [[aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice()], [aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice()]];\n                let i;\n                let j;\n                let tmp;\n                const sbox = this._tables[0][4];\n                const decTable = this._tables[1];\n                const keyLen = key.length;\n                let rcon = 1;\n                if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n                    throw new Error('Invalid aes key size');\n                }\n                const encKey = key.slice(0);\n                const decKey = [];\n                this._key = [encKey, decKey]; // schedule encryption keys\n\n                for (i = keyLen; i < 4 * keyLen + 28; i++) {\n                    tmp = encKey[i - 1]; // apply sbox\n\n                    if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {\n                        tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255]; // shift rows and add rcon\n\n                        if (i % keyLen === 0) {\n                            tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;\n                            rcon = rcon << 1 ^ (rcon >> 7) * 283;\n                        }\n                    }\n                    encKey[i] = encKey[i - keyLen] ^ tmp;\n                } // schedule decryption keys\n\n                for (j = 0; i; j++, i--) {\n                    tmp = encKey[j & 3 ? i : i - 4];\n                    if (i <= 4 || j < 4) {\n                        decKey[j] = tmp;\n                    } else {\n                        decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];\n                    }\n                }\n            }\n            /**\n             * Decrypt 16 bytes, specified as four 32-bit words.\n             *\n             * @param {number} encrypted0 the first word to decrypt\n             * @param {number} encrypted1 the second word to decrypt\n             * @param {number} encrypted2 the third word to decrypt\n             * @param {number} encrypted3 the fourth word to decrypt\n             * @param {Int32Array} out the array to write the decrypted words\n             * into\n             * @param {number} offset the offset into the output array to start\n             * writing results\n             * @return {Array} The plaintext.\n             */\n\n            decrypt(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {\n                const key = this._key[1]; // state variables a,b,c,d are loaded with pre-whitened data\n\n                let a = encrypted0 ^ key[0];\n                let b = encrypted3 ^ key[1];\n                let c = encrypted2 ^ key[2];\n                let d = encrypted1 ^ key[3];\n                let a2;\n                let b2;\n                let c2; // key.length === 2 ?\n\n                const nInnerRounds = key.length / 4 - 2;\n                let i;\n                let kIndex = 4;\n                const table = this._tables[1]; // load up the tables\n\n                const table0 = table[0];\n                const table1 = table[1];\n                const table2 = table[2];\n                const table3 = table[3];\n                const sbox = table[4]; // Inner rounds. Cribbed from OpenSSL.\n\n                for (i = 0; i < nInnerRounds; i++) {\n                    a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];\n                    b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];\n                    c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];\n                    d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];\n                    kIndex += 4;\n                    a = a2;\n                    b = b2;\n                    c = c2;\n                } // Last round.\n\n                for (i = 0; i < 4; i++) {\n                    out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];\n                    a2 = a;\n                    a = b;\n                    b = c;\n                    c = d;\n                    d = a2;\n                }\n            }\n        }\n        /**\n         * @file async-stream.js\n         */\n\n        /**\n         * A wrapper around the Stream class to use setTimeout\n         * and run stream \"jobs\" Asynchronously\n         *\n         * @class AsyncStream\n         * @extends Stream\n         */\n\n        class AsyncStream extends Stream {\n            constructor() {\n                super(Stream);\n                this.jobs = [];\n                this.delay = 1;\n                this.timeout_ = null;\n            }\n            /**\n             * process an async job\n             *\n             * @private\n             */\n\n            processJob_() {\n                this.jobs.shift()();\n                if (this.jobs.length) {\n                    this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\n                } else {\n                    this.timeout_ = null;\n                }\n            }\n            /**\n             * push a job into the stream\n             *\n             * @param {Function} job the job to push into the stream\n             */\n\n            push(job) {\n                this.jobs.push(job);\n                if (!this.timeout_) {\n                    this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);\n                }\n            }\n        }\n        /**\n         * @file decrypter.js\n         *\n         * An asynchronous implementation of AES-128 CBC decryption with\n         * PKCS#7 padding.\n         */\n\n        /**\n         * Convert network-order (big-endian) bytes into their little-endian\n         * representation.\n         */\n\n        const ntoh = function (word) {\n            return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n        };\n        /**\n         * Decrypt bytes using AES-128 with CBC and PKCS#7 padding.\n         *\n         * @param {Uint8Array} encrypted the encrypted bytes\n         * @param {Uint32Array} key the bytes of the decryption key\n         * @param {Uint32Array} initVector the initialization vector (IV) to\n         * use for the first round of CBC.\n         * @return {Uint8Array} the decrypted bytes\n         *\n         * @see http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n         * @see http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29\n         * @see https://tools.ietf.org/html/rfc2315\n         */\n\n        const decrypt = function (encrypted, key, initVector) {\n            // word-level access to the encrypted bytes\n            const encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);\n            const decipher = new AES(Array.prototype.slice.call(key)); // byte and word-level access for the decrypted output\n\n            const decrypted = new Uint8Array(encrypted.byteLength);\n            const decrypted32 = new Int32Array(decrypted.buffer); // temporary variables for working with the IV, encrypted, and\n            // decrypted data\n\n            let init0;\n            let init1;\n            let init2;\n            let init3;\n            let encrypted0;\n            let encrypted1;\n            let encrypted2;\n            let encrypted3; // iteration variable\n\n            let wordIx; // pull out the words of the IV to ensure we don't modify the\n            // passed-in reference and easier access\n\n            init0 = initVector[0];\n            init1 = initVector[1];\n            init2 = initVector[2];\n            init3 = initVector[3]; // decrypt four word sequences, applying cipher-block chaining (CBC)\n            // to each decrypted block\n\n            for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {\n                // convert big-endian (network order) words into little-endian\n                // (javascript order)\n                encrypted0 = ntoh(encrypted32[wordIx]);\n                encrypted1 = ntoh(encrypted32[wordIx + 1]);\n                encrypted2 = ntoh(encrypted32[wordIx + 2]);\n                encrypted3 = ntoh(encrypted32[wordIx + 3]); // decrypt the block\n\n                decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx); // XOR with the IV, and restore network byte-order to obtain the\n                // plaintext\n\n                decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);\n                decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);\n                decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);\n                decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3); // setup the IV for the next round\n\n                init0 = encrypted0;\n                init1 = encrypted1;\n                init2 = encrypted2;\n                init3 = encrypted3;\n            }\n            return decrypted;\n        };\n        /**\n         * The `Decrypter` class that manages decryption of AES\n         * data through `AsyncStream` objects and the `decrypt`\n         * function\n         *\n         * @param {Uint8Array} encrypted the encrypted bytes\n         * @param {Uint32Array} key the bytes of the decryption key\n         * @param {Uint32Array} initVector the initialization vector (IV) to\n         * @param {Function} done the function to run when done\n         * @class Decrypter\n         */\n\n        class Decrypter {\n            constructor(encrypted, key, initVector, done) {\n                const step = Decrypter.STEP;\n                const encrypted32 = new Int32Array(encrypted.buffer);\n                const decrypted = new Uint8Array(encrypted.byteLength);\n                let i = 0;\n                this.asyncStream_ = new AsyncStream(); // split up the encryption job and do the individual chunks asynchronously\n\n                this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\n                for (i = step; i < encrypted32.length; i += step) {\n                    initVector = new Uint32Array([ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1])]);\n                    this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));\n                } // invoke the done() callback when everything is finished\n\n                this.asyncStream_.push(function () {\n                    // remove pkcs#7 padding from the decrypted bytes\n                    done(null, unpad(decrypted));\n                });\n            }\n            /**\n             * a getter for step the maximum number of bytes to process at one time\n             *\n             * @return {number} the value of step 32000\n             */\n\n            static get STEP() {\n                // 4 * 8000;\n                return 32000;\n            }\n            /**\n             * @private\n             */\n\n            decryptChunk_(encrypted, key, initVector, decrypted) {\n                return function () {\n                    const bytes = decrypt(encrypted, key, initVector);\n                    decrypted.set(bytes, encrypted.byteOffset);\n                };\n            }\n        }\n        var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n        var win;\n        if (typeof window !== \"undefined\") {\n            win = window;\n        } else if (typeof commonjsGlobal !== \"undefined\") {\n            win = commonjsGlobal;\n        } else if (typeof self !== \"undefined\") {\n            win = self;\n        } else {\n            win = {};\n        }\n        var window_1 = win;\n        var isArrayBufferView = function isArrayBufferView(obj) {\n            if (ArrayBuffer.isView === 'function') {\n                return ArrayBuffer.isView(obj);\n            }\n            return obj && obj.buffer instanceof ArrayBuffer;\n        };\n        var BigInt = window_1.BigInt || Number;\n        [BigInt('0x1'), BigInt('0x100'), BigInt('0x10000'), BigInt('0x1000000'), BigInt('0x100000000'), BigInt('0x10000000000'), BigInt('0x1000000000000'), BigInt('0x100000000000000'), BigInt('0x10000000000000000')];\n        (function () {\n            var a = new Uint16Array([0xFFCC]);\n            var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n            if (b[0] === 0xFF) {\n                return 'big';\n            }\n            if (b[0] === 0xCC) {\n                return 'little';\n            }\n            return 'unknown';\n        })();\n        /**\n         * Creates an object for sending to a web worker modifying properties that are TypedArrays\n         * into a new object with seperated properties for the buffer, byteOffset, and byteLength.\n         *\n         * @param {Object} message\n         *        Object of properties and values to send to the web worker\n         * @return {Object}\n         *         Modified message with TypedArray values expanded\n         * @function createTransferableMessage\n         */\n\n        const createTransferableMessage = function (message) {\n            const transferable = {};\n            Object.keys(message).forEach(key => {\n                const value = message[key];\n                if (isArrayBufferView(value)) {\n                    transferable[key] = {\n                        bytes: value.buffer,\n                        byteOffset: value.byteOffset,\n                        byteLength: value.byteLength\n                    };\n                } else {\n                    transferable[key] = value;\n                }\n            });\n            return transferable;\n        };\n        /* global self */\n\n        /**\n         * Our web worker interface so that things can talk to aes-decrypter\n         * that will be running in a web worker. the scope is passed to this by\n         * webworkify.\n         */\n\n        self.onmessage = function (event) {\n            const data = event.data;\n            const encrypted = new Uint8Array(data.encrypted.bytes, data.encrypted.byteOffset, data.encrypted.byteLength);\n            const key = new Uint32Array(data.key.bytes, data.key.byteOffset, data.key.byteLength / 4);\n            const iv = new Uint32Array(data.iv.bytes, data.iv.byteOffset, data.iv.byteLength / 4);\n            /* eslint-disable no-new, handle-callback-err */\n\n            new Decrypter(encrypted, key, iv, function (err, bytes) {\n                self.postMessage(createTransferableMessage({\n                    source: data.source,\n                    decrypted: bytes\n                }), [bytes.buffer]);\n            });\n            /* eslint-enable */\n        };\n    }));\n\n    var Decrypter = factory(workerCode);\n    /* rollup-plugin-worker-factory end for worker!/Users/ddashkevich/projects/http-streaming/src/decrypter-worker.js */\n\n    /**\n     * Convert the properties of an HLS track into an audioTrackKind.\n     *\n     * @private\n     */\n\n    const audioTrackKind_ = properties => {\n        let kind = properties.default ? 'main' : 'alternative';\n        if (properties.characteristics && properties.characteristics.indexOf('public.accessibility.describes-video') >= 0) {\n            kind = 'main-desc';\n        }\n        return kind;\n    };\n    /**\n     * Pause provided segment loader and playlist loader if active\n     *\n     * @param {SegmentLoader} segmentLoader\n     *        SegmentLoader to pause\n     * @param {Object} mediaType\n     *        Active media type\n     * @function stopLoaders\n     */\n\n    const stopLoaders = (segmentLoader, mediaType) => {\n        segmentLoader.abort();\n        segmentLoader.pause();\n        if (mediaType && mediaType.activePlaylistLoader) {\n            mediaType.activePlaylistLoader.pause();\n            mediaType.activePlaylistLoader = null;\n        }\n    };\n    /**\n     * Start loading provided segment loader and playlist loader\n     *\n     * @param {PlaylistLoader} playlistLoader\n     *        PlaylistLoader to start loading\n     * @param {Object} mediaType\n     *        Active media type\n     * @function startLoaders\n     */\n\n    const startLoaders = (playlistLoader, mediaType) => {\n        // Segment loader will be started after `loadedmetadata` or `loadedplaylist` from the\n        // playlist loader\n        mediaType.activePlaylistLoader = playlistLoader;\n        playlistLoader.load();\n    };\n    /**\n     * Returns a function to be called when the media group changes. It performs a\n     * non-destructive (preserve the buffer) resync of the SegmentLoader. This is because a\n     * change of group is merely a rendition switch of the same content at another encoding,\n     * rather than a change of content, such as switching audio from English to Spanish.\n     *\n     * @param {string} type\n     *        MediaGroup type\n     * @param {Object} settings\n     *        Object containing required information for media groups\n     * @return {Function}\n     *         Handler for a non-destructive resync of SegmentLoader when the active media\n     *         group changes.\n     * @function onGroupChanged\n     */\n\n    const onGroupChanged = (type, settings) => () => {\n        const {\n            segmentLoaders: {\n                [type]: segmentLoader,\n                main: mainSegmentLoader\n            },\n            mediaTypes: {\n                [type]: mediaType\n            }\n        } = settings;\n        const activeTrack = mediaType.activeTrack();\n        const activeGroup = mediaType.getActiveGroup();\n        const previousActiveLoader = mediaType.activePlaylistLoader;\n        const lastGroup = mediaType.lastGroup_; // the group did not change do nothing\n\n        if (activeGroup && lastGroup && activeGroup.id === lastGroup.id) {\n            return;\n        }\n        mediaType.lastGroup_ = activeGroup;\n        mediaType.lastTrack_ = activeTrack;\n        stopLoaders(segmentLoader, mediaType);\n        if (!activeGroup || activeGroup.isMainPlaylist) {\n            // there is no group active or active group is a main playlist and won't change\n            return;\n        }\n        if (!activeGroup.playlistLoader) {\n            if (previousActiveLoader) {\n                // The previous group had a playlist loader but the new active group does not\n                // this means we are switching from demuxed to muxed audio. In this case we want to\n                // do a destructive reset of the main segment loader and not restart the audio\n                // loaders.\n                mainSegmentLoader.resetEverything();\n            }\n            return;\n        } // Non-destructive resync\n\n        segmentLoader.resyncLoader();\n        startLoaders(activeGroup.playlistLoader, mediaType);\n    };\n    const onGroupChanging = (type, settings) => () => {\n        const {\n            segmentLoaders: {\n                [type]: segmentLoader\n            },\n            mediaTypes: {\n                [type]: mediaType\n            }\n        } = settings;\n        mediaType.lastGroup_ = null;\n        segmentLoader.abort();\n        segmentLoader.pause();\n    };\n    /**\n     * Returns a function to be called when the media track changes. It performs a\n     * destructive reset of the SegmentLoader to ensure we start loading as close to\n     * currentTime as possible.\n     *\n     * @param {string} type\n     *        MediaGroup type\n     * @param {Object} settings\n     *        Object containing required information for media groups\n     * @return {Function}\n     *         Handler for a destructive reset of SegmentLoader when the active media\n     *         track changes.\n     * @function onTrackChanged\n     */\n\n    const onTrackChanged = (type, settings) => () => {\n        const {\n            mainPlaylistLoader,\n            segmentLoaders: {\n                [type]: segmentLoader,\n                main: mainSegmentLoader\n            },\n            mediaTypes: {\n                [type]: mediaType\n            }\n        } = settings;\n        const activeTrack = mediaType.activeTrack();\n        const activeGroup = mediaType.getActiveGroup();\n        const previousActiveLoader = mediaType.activePlaylistLoader;\n        const lastTrack = mediaType.lastTrack_; // track did not change, do nothing\n\n        if (lastTrack && activeTrack && lastTrack.id === activeTrack.id) {\n            return;\n        }\n        mediaType.lastGroup_ = activeGroup;\n        mediaType.lastTrack_ = activeTrack;\n        stopLoaders(segmentLoader, mediaType);\n        if (!activeGroup) {\n            // there is no group active so we do not want to restart loaders\n            return;\n        }\n        if (activeGroup.isMainPlaylist) {\n            // track did not change, do nothing\n            if (!activeTrack || !lastTrack || activeTrack.id === lastTrack.id) {\n                return;\n            }\n            const pc = settings.vhs.playlistController_;\n            const newPlaylist = pc.selectPlaylist(); // media will not change do nothing\n\n            if (pc.media() === newPlaylist) {\n                return;\n            }\n            mediaType.logger_(`track change. Switching main audio from ${lastTrack.id} to ${activeTrack.id}`);\n            mainPlaylistLoader.pause();\n            mainSegmentLoader.resetEverything();\n            pc.fastQualityChange_(newPlaylist);\n            return;\n        }\n        if (type === 'AUDIO') {\n            if (!activeGroup.playlistLoader) {\n                // when switching from demuxed audio/video to muxed audio/video (noted by no\n                // playlist loader for the audio group), we want to do a destructive reset of the\n                // main segment loader and not restart the audio loaders\n                mainSegmentLoader.setAudio(true); // don't have to worry about disabling the audio of the audio segment loader since\n                // it should be stopped\n\n                mainSegmentLoader.resetEverything();\n                return;\n            } // although the segment loader is an audio segment loader, call the setAudio\n            // function to ensure it is prepared to re-append the init segment (or handle other\n            // config changes)\n\n            segmentLoader.setAudio(true);\n            mainSegmentLoader.setAudio(false);\n        }\n        if (previousActiveLoader === activeGroup.playlistLoader) {\n            // Nothing has actually changed. This can happen because track change events can fire\n            // multiple times for a \"single\" change. One for enabling the new active track, and\n            // one for disabling the track that was active\n            startLoaders(activeGroup.playlistLoader, mediaType);\n            return;\n        }\n        if (segmentLoader.track) {\n            // For WebVTT, set the new text track in the segmentloader\n            segmentLoader.track(activeTrack);\n        } // destructive reset\n\n        segmentLoader.resetEverything();\n        startLoaders(activeGroup.playlistLoader, mediaType);\n    };\n    const onError = {\n        /**\n         * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\n         * an error.\n         *\n         * @param {string} type\n         *        MediaGroup type\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @return {Function}\n         *         Error handler. Logs warning (or error if the playlist is excluded) to\n         *         console and switches back to default audio track.\n         * @function onError.AUDIO\n         */\n        AUDIO: (type, settings) => () => {\n            const {\n                segmentLoaders: {\n                    [type]: segmentLoader\n                },\n                mediaTypes: {\n                    [type]: mediaType\n                },\n                excludePlaylist\n            } = settings;\n            stopLoaders(segmentLoader, mediaType); // switch back to default audio track\n\n            const activeTrack = mediaType.activeTrack();\n            const activeGroup = mediaType.activeGroup();\n            const id = (activeGroup.filter(group => group.default)[0] || activeGroup[0]).id;\n            const defaultTrack = mediaType.tracks[id];\n            if (activeTrack === defaultTrack) {\n                // Default track encountered an error. All we can do now is exclude the current\n                // rendition and hope another will switch audio groups\n                excludePlaylist({\n                    error: {\n                        message: 'Problem encountered loading the default audio track.'\n                    }\n                });\n                return;\n            }\n            videojs.log.warn('Problem encountered loading the alternate audio track.' + 'Switching back to default.');\n            for (const trackId in mediaType.tracks) {\n                mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;\n            }\n            mediaType.onTrackChanged();\n        },\n        /**\n         * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters\n         * an error.\n         *\n         * @param {string} type\n         *        MediaGroup type\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @return {Function}\n         *         Error handler. Logs warning to console and disables the active subtitle track\n         * @function onError.SUBTITLES\n         */\n        SUBTITLES: (type, settings) => () => {\n            const {\n                segmentLoaders: {\n                    [type]: segmentLoader\n                },\n                mediaTypes: {\n                    [type]: mediaType\n                }\n            } = settings;\n            videojs.log.warn('Problem encountered loading the subtitle track.' + 'Disabling subtitle track.');\n            stopLoaders(segmentLoader, mediaType);\n            const track = mediaType.activeTrack();\n            if (track) {\n                track.mode = 'disabled';\n            }\n            mediaType.onTrackChanged();\n        }\n    };\n    const setupListeners = {\n        /**\n         * Setup event listeners for audio playlist loader\n         *\n         * @param {string} type\n         *        MediaGroup type\n         * @param {PlaylistLoader|null} playlistLoader\n         *        PlaylistLoader to register listeners on\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @function setupListeners.AUDIO\n         */\n        AUDIO: (type, playlistLoader, settings) => {\n            if (!playlistLoader) {\n                // no playlist loader means audio will be muxed with the video\n                return;\n            }\n            const {\n                tech,\n                requestOptions,\n                segmentLoaders: {\n                    [type]: segmentLoader\n                }\n            } = settings;\n            playlistLoader.on('loadedmetadata', () => {\n                const media = playlistLoader.media();\n                segmentLoader.playlist(media, requestOptions); // if the video is already playing, or if this isn't a live video and preload\n                // permits, start downloading segments\n\n                if (!tech.paused() || media.endList && tech.preload() !== 'none') {\n                    segmentLoader.load();\n                }\n            });\n            playlistLoader.on('loadedplaylist', () => {\n                segmentLoader.playlist(playlistLoader.media(), requestOptions); // If the player isn't paused, ensure that the segment loader is running\n\n                if (!tech.paused()) {\n                    segmentLoader.load();\n                }\n            });\n            playlistLoader.on('error', onError[type](type, settings));\n        },\n        /**\n         * Setup event listeners for subtitle playlist loader\n         *\n         * @param {string} type\n         *        MediaGroup type\n         * @param {PlaylistLoader|null} playlistLoader\n         *        PlaylistLoader to register listeners on\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @function setupListeners.SUBTITLES\n         */\n        SUBTITLES: (type, playlistLoader, settings) => {\n            const {\n                tech,\n                requestOptions,\n                segmentLoaders: {\n                    [type]: segmentLoader\n                },\n                mediaTypes: {\n                    [type]: mediaType\n                }\n            } = settings;\n            playlistLoader.on('loadedmetadata', () => {\n                const media = playlistLoader.media();\n                segmentLoader.playlist(media, requestOptions);\n                segmentLoader.track(mediaType.activeTrack()); // if the video is already playing, or if this isn't a live video and preload\n                // permits, start downloading segments\n\n                if (!tech.paused() || media.endList && tech.preload() !== 'none') {\n                    segmentLoader.load();\n                }\n            });\n            playlistLoader.on('loadedplaylist', () => {\n                segmentLoader.playlist(playlistLoader.media(), requestOptions); // If the player isn't paused, ensure that the segment loader is running\n\n                if (!tech.paused()) {\n                    segmentLoader.load();\n                }\n            });\n            playlistLoader.on('error', onError[type](type, settings));\n        }\n    };\n    const initialize = {\n        /**\n         * Setup PlaylistLoaders and AudioTracks for the audio groups\n         *\n         * @param {string} type\n         *        MediaGroup type\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @function initialize.AUDIO\n         */\n        'AUDIO': (type, settings) => {\n            const {\n                vhs,\n                sourceType,\n                segmentLoaders: {\n                    [type]: segmentLoader\n                },\n                requestOptions,\n                main: {\n                    mediaGroups\n                },\n                mediaTypes: {\n                    [type]: {\n                        groups,\n                        tracks,\n                        logger_\n                    }\n                },\n                mainPlaylistLoader\n            } = settings;\n            const audioOnlyMain = isAudioOnly(mainPlaylistLoader.main); // force a default if we have none\n\n            if (!mediaGroups[type] || Object.keys(mediaGroups[type]).length === 0) {\n                mediaGroups[type] = {\n                    main: {\n                        default: {\n                            default: true\n                        }\n                    }\n                };\n                if (audioOnlyMain) {\n                    mediaGroups[type].main.default.playlists = mainPlaylistLoader.main.playlists;\n                }\n            }\n            for (const groupId in mediaGroups[type]) {\n                if (!groups[groupId]) {\n                    groups[groupId] = [];\n                }\n                for (const variantLabel in mediaGroups[type][groupId]) {\n                    let properties = mediaGroups[type][groupId][variantLabel];\n                    let playlistLoader;\n                    if (audioOnlyMain) {\n                        logger_(`AUDIO group '${groupId}' label '${variantLabel}' is a main playlist`);\n                        properties.isMainPlaylist = true;\n                        playlistLoader = null; // if vhs-json was provided as the source, and the media playlist was resolved,\n                        // use the resolved media playlist object\n                    } else if (sourceType === 'vhs-json' && properties.playlists) {\n                        playlistLoader = new PlaylistLoader(properties.playlists[0], vhs, requestOptions);\n                    } else if (properties.resolvedUri) {\n                        playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions); // TODO: dash isn't the only type with properties.playlists\n                        // should we even have properties.playlists in this check.\n                    } else if (properties.playlists && sourceType === 'dash') {\n                        playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, mainPlaylistLoader);\n                    } else {\n                        // no resolvedUri means the audio is muxed with the video when using this\n                        // audio track\n                        playlistLoader = null;\n                    }\n                    properties = merge({\n                        id: variantLabel,\n                        playlistLoader\n                    }, properties);\n                    setupListeners[type](type, properties.playlistLoader, settings);\n                    groups[groupId].push(properties);\n                    if (typeof tracks[variantLabel] === 'undefined') {\n                        const track = new videojs.AudioTrack({\n                            id: variantLabel,\n                            kind: audioTrackKind_(properties),\n                            enabled: false,\n                            language: properties.language,\n                            default: properties.default,\n                            label: variantLabel\n                        });\n                        tracks[variantLabel] = track;\n                    }\n                }\n            } // setup single error event handler for the segment loader\n\n            segmentLoader.on('error', onError[type](type, settings));\n        },\n        /**\n         * Setup PlaylistLoaders and TextTracks for the subtitle groups\n         *\n         * @param {string} type\n         *        MediaGroup type\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @function initialize.SUBTITLES\n         */\n        'SUBTITLES': (type, settings) => {\n            const {\n                tech,\n                vhs,\n                sourceType,\n                segmentLoaders: {\n                    [type]: segmentLoader\n                },\n                requestOptions,\n                main: {\n                    mediaGroups\n                },\n                mediaTypes: {\n                    [type]: {\n                        groups,\n                        tracks\n                    }\n                },\n                mainPlaylistLoader\n            } = settings;\n            for (const groupId in mediaGroups[type]) {\n                if (!groups[groupId]) {\n                    groups[groupId] = [];\n                }\n                for (const variantLabel in mediaGroups[type][groupId]) {\n                    if (mediaGroups[type][groupId][variantLabel].forced) {\n                        // Subtitle playlists with the forced attribute are not selectable in Safari.\n                        // According to Apple's HLS Authoring Specification:\n                        //   If content has forced subtitles and regular subtitles in a given language,\n                        //   the regular subtitles track in that language MUST contain both the forced\n                        //   subtitles and the regular subtitles for that language.\n                        // Because of this requirement and that Safari does not add forced subtitles,\n                        // forced subtitles are skipped here to maintain consistent experience across\n                        // all platforms\n                        continue;\n                    }\n                    let properties = mediaGroups[type][groupId][variantLabel];\n                    let playlistLoader;\n                    if (sourceType === 'hls') {\n                        playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions);\n                    } else if (sourceType === 'dash') {\n                        const playlists = properties.playlists.filter(p => p.excludeUntil !== Infinity);\n                        if (!playlists.length) {\n                            return;\n                        }\n                        playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, mainPlaylistLoader);\n                    } else if (sourceType === 'vhs-json') {\n                        playlistLoader = new PlaylistLoader(\n                            // if the vhs-json object included the media playlist, use the media playlist\n                            // as provided, otherwise use the resolved URI to load the playlist\n                            properties.playlists ? properties.playlists[0] : properties.resolvedUri, vhs, requestOptions);\n                    }\n                    properties = merge({\n                        id: variantLabel,\n                        playlistLoader\n                    }, properties);\n                    setupListeners[type](type, properties.playlistLoader, settings);\n                    groups[groupId].push(properties);\n                    if (typeof tracks[variantLabel] === 'undefined') {\n                        const track = tech.addRemoteTextTrack({\n                            id: variantLabel,\n                            kind: 'subtitles',\n                            default: properties.default && properties.autoselect,\n                            language: properties.language,\n                            label: variantLabel\n                        }, false).track;\n                        tracks[variantLabel] = track;\n                    }\n                }\n            } // setup single error event handler for the segment loader\n\n            segmentLoader.on('error', onError[type](type, settings));\n        },\n        /**\n         * Setup TextTracks for the closed-caption groups\n         *\n         * @param {String} type\n         *        MediaGroup type\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @function initialize['CLOSED-CAPTIONS']\n         */\n        'CLOSED-CAPTIONS': (type, settings) => {\n            const {\n                tech,\n                main: {\n                    mediaGroups\n                },\n                mediaTypes: {\n                    [type]: {\n                        groups,\n                        tracks\n                    }\n                }\n            } = settings;\n            for (const groupId in mediaGroups[type]) {\n                if (!groups[groupId]) {\n                    groups[groupId] = [];\n                }\n                for (const variantLabel in mediaGroups[type][groupId]) {\n                    const properties = mediaGroups[type][groupId][variantLabel]; // Look for either 608 (CCn) or 708 (SERVICEn) caption services\n\n                    if (!/^(?:CC|SERVICE)/.test(properties.instreamId)) {\n                        continue;\n                    }\n                    const captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};\n                    let newProps = {\n                        label: variantLabel,\n                        language: properties.language,\n                        instreamId: properties.instreamId,\n                        default: properties.default && properties.autoselect\n                    };\n                    if (captionServices[newProps.instreamId]) {\n                        newProps = merge(newProps, captionServices[newProps.instreamId]);\n                    }\n                    if (newProps.default === undefined) {\n                        delete newProps.default;\n                    } // No PlaylistLoader is required for Closed-Captions because the captions are\n                    // embedded within the video stream\n\n                    groups[groupId].push(merge({\n                        id: variantLabel\n                    }, properties));\n                    if (typeof tracks[variantLabel] === 'undefined') {\n                        const track = tech.addRemoteTextTrack({\n                            id: newProps.instreamId,\n                            kind: 'captions',\n                            default: newProps.default,\n                            language: newProps.language,\n                            label: newProps.label\n                        }, false).track;\n                        tracks[variantLabel] = track;\n                    }\n                }\n            }\n        }\n    };\n    const groupMatch = (list, media) => {\n        for (let i = 0; i < list.length; i++) {\n            if (playlistMatch(media, list[i])) {\n                return true;\n            }\n            if (list[i].playlists && groupMatch(list[i].playlists, media)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Returns a function used to get the active group of the provided type\n     *\n     * @param {string} type\n     *        MediaGroup type\n     * @param {Object} settings\n     *        Object containing required information for media groups\n     * @return {Function}\n     *         Function that returns the active media group for the provided type. Takes an\n     *         optional parameter {TextTrack} track. If no track is provided, a list of all\n     *         variants in the group, otherwise the variant corresponding to the provided\n     *         track is returned.\n     * @function activeGroup\n     */\n\n    const activeGroup = (type, settings) => track => {\n        const {\n            mainPlaylistLoader,\n            mediaTypes: {\n                [type]: {\n                    groups\n                }\n            }\n        } = settings;\n        const media = mainPlaylistLoader.media();\n        if (!media) {\n            return null;\n        }\n        let variants = null; // set to variants to main media active group\n\n        if (media.attributes[type]) {\n            variants = groups[media.attributes[type]];\n        }\n        const groupKeys = Object.keys(groups);\n        if (!variants) {\n            // find the mainPlaylistLoader media\n            // that is in a media group if we are dealing\n            // with audio only\n            if (type === 'AUDIO' && groupKeys.length > 1 && isAudioOnly(settings.main)) {\n                for (let i = 0; i < groupKeys.length; i++) {\n                    const groupPropertyList = groups[groupKeys[i]];\n                    if (groupMatch(groupPropertyList, media)) {\n                        variants = groupPropertyList;\n                        break;\n                    }\n                } // use the main group if it exists\n            } else if (groups.main) {\n                variants = groups.main; // only one group, use that one\n            } else if (groupKeys.length === 1) {\n                variants = groups[groupKeys[0]];\n            }\n        }\n        if (typeof track === 'undefined') {\n            return variants;\n        }\n        if (track === null || !variants) {\n            // An active track was specified so a corresponding group is expected. track === null\n            // means no track is currently active so there is no corresponding group\n            return null;\n        }\n        return variants.filter(props => props.id === track.id)[0] || null;\n    };\n    const activeTrack = {\n        /**\n         * Returns a function used to get the active track of type provided\n         *\n         * @param {string} type\n         *        MediaGroup type\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @return {Function}\n         *         Function that returns the active media track for the provided type. Returns\n         *         null if no track is active\n         * @function activeTrack.AUDIO\n         */\n        AUDIO: (type, settings) => () => {\n            const {\n                mediaTypes: {\n                    [type]: {\n                        tracks\n                    }\n                }\n            } = settings;\n            for (const id in tracks) {\n                if (tracks[id].enabled) {\n                    return tracks[id];\n                }\n            }\n            return null;\n        },\n        /**\n         * Returns a function used to get the active track of type provided\n         *\n         * @param {string} type\n         *        MediaGroup type\n         * @param {Object} settings\n         *        Object containing required information for media groups\n         * @return {Function}\n         *         Function that returns the active media track for the provided type. Returns\n         *         null if no track is active\n         * @function activeTrack.SUBTITLES\n         */\n        SUBTITLES: (type, settings) => () => {\n            const {\n                mediaTypes: {\n                    [type]: {\n                        tracks\n                    }\n                }\n            } = settings;\n            for (const id in tracks) {\n                if (tracks[id].mode === 'showing' || tracks[id].mode === 'hidden') {\n                    return tracks[id];\n                }\n            }\n            return null;\n        }\n    };\n    const getActiveGroup = (type, {\n        mediaTypes\n    }) => () => {\n        const activeTrack_ = mediaTypes[type].activeTrack();\n        if (!activeTrack_) {\n            return null;\n        }\n        return mediaTypes[type].activeGroup(activeTrack_);\n    };\n    /**\n     * Setup PlaylistLoaders and Tracks for media groups (Audio, Subtitles,\n     * Closed-Captions) specified in the main manifest.\n     *\n     * @param {Object} settings\n     *        Object containing required information for setting up the media groups\n     * @param {Tech} settings.tech\n     *        The tech of the player\n     * @param {Object} settings.requestOptions\n     *        XHR request options used by the segment loaders\n     * @param {PlaylistLoader} settings.mainPlaylistLoader\n     *        PlaylistLoader for the main source\n     * @param {VhsHandler} settings.vhs\n     *        VHS SourceHandler\n     * @param {Object} settings.main\n     *        The parsed main manifest\n     * @param {Object} settings.mediaTypes\n     *        Object to store the loaders, tracks, and utility methods for each media type\n     * @param {Function} settings.excludePlaylist\n     *        Excludes the current rendition and forces a rendition switch.\n     * @function setupMediaGroups\n     */\n\n    const setupMediaGroups = settings => {\n        ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(type => {\n            initialize[type](type, settings);\n        });\n        const {\n            mediaTypes,\n            mainPlaylistLoader,\n            tech,\n            vhs,\n            segmentLoaders: {\n                ['AUDIO']: audioSegmentLoader,\n                main: mainSegmentLoader\n            }\n        } = settings; // setup active group and track getters and change event handlers\n\n        ['AUDIO', 'SUBTITLES'].forEach(type => {\n            mediaTypes[type].activeGroup = activeGroup(type, settings);\n            mediaTypes[type].activeTrack = activeTrack[type](type, settings);\n            mediaTypes[type].onGroupChanged = onGroupChanged(type, settings);\n            mediaTypes[type].onGroupChanging = onGroupChanging(type, settings);\n            mediaTypes[type].onTrackChanged = onTrackChanged(type, settings);\n            mediaTypes[type].getActiveGroup = getActiveGroup(type, settings);\n        }); // DO NOT enable the default subtitle or caption track.\n        // DO enable the default audio track\n\n        const audioGroup = mediaTypes.AUDIO.activeGroup();\n        if (audioGroup) {\n            const groupId = (audioGroup.filter(group => group.default)[0] || audioGroup[0]).id;\n            mediaTypes.AUDIO.tracks[groupId].enabled = true;\n            mediaTypes.AUDIO.onGroupChanged();\n            mediaTypes.AUDIO.onTrackChanged();\n            const activeAudioGroup = mediaTypes.AUDIO.getActiveGroup(); // a similar check for handling setAudio on each loader is run again each time the\n            // track is changed, but needs to be handled here since the track may not be considered\n            // changed on the first call to onTrackChanged\n\n            if (!activeAudioGroup.playlistLoader) {\n                // either audio is muxed with video or the stream is audio only\n                mainSegmentLoader.setAudio(true);\n            } else {\n                // audio is demuxed\n                mainSegmentLoader.setAudio(false);\n                audioSegmentLoader.setAudio(true);\n            }\n        }\n        mainPlaylistLoader.on('mediachange', () => {\n            ['AUDIO', 'SUBTITLES'].forEach(type => mediaTypes[type].onGroupChanged());\n        });\n        mainPlaylistLoader.on('mediachanging', () => {\n            ['AUDIO', 'SUBTITLES'].forEach(type => mediaTypes[type].onGroupChanging());\n        }); // custom audio track change event handler for usage event\n\n        const onAudioTrackChanged = () => {\n            mediaTypes.AUDIO.onTrackChanged();\n            tech.trigger({\n                type: 'usage',\n                name: 'vhs-audio-change'\n            });\n        };\n        tech.audioTracks().addEventListener('change', onAudioTrackChanged);\n        tech.remoteTextTracks().addEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\n        vhs.on('dispose', () => {\n            tech.audioTracks().removeEventListener('change', onAudioTrackChanged);\n            tech.remoteTextTracks().removeEventListener('change', mediaTypes.SUBTITLES.onTrackChanged);\n        }); // clear existing audio tracks and add the ones we just created\n\n        tech.clearTracks('audio');\n        for (const id in mediaTypes.AUDIO.tracks) {\n            tech.audioTracks().addTrack(mediaTypes.AUDIO.tracks[id]);\n        }\n    };\n    /**\n     * Creates skeleton object used to store the loaders, tracks, and utility methods for each\n     * media type\n     *\n     * @return {Object}\n     *         Object to store the loaders, tracks, and utility methods for each media type\n     * @function createMediaTypes\n     */\n\n    const createMediaTypes = () => {\n        const mediaTypes = {};\n        ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].forEach(type => {\n            mediaTypes[type] = {\n                groups: {},\n                tracks: {},\n                activePlaylistLoader: null,\n                activeGroup: noop,\n                activeTrack: noop,\n                getActiveGroup: noop,\n                onGroupChanged: noop,\n                onTrackChanged: noop,\n                lastTrack_: null,\n                logger_: logger(`MediaGroups[${type}]`)\n            };\n        });\n        return mediaTypes;\n    };\n\n    /**\n     * @file playlist-controller.js\n     */\n    const ABORT_EARLY_EXCLUSION_SECONDS = 60 * 2;\n    let Vhs$1; // SegmentLoader stats that need to have each loader's\n    // values summed to calculate the final value\n\n    const loaderStats = ['mediaRequests', 'mediaRequestsAborted', 'mediaRequestsTimedout', 'mediaRequestsErrored', 'mediaTransferDuration', 'mediaBytesTransferred', 'mediaAppends'];\n    const sumLoaderStat = function (stat) {\n        return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];\n    };\n    const shouldSwitchToMedia = function ({\n                                              currentPlaylist,\n                                              buffered,\n                                              currentTime,\n                                              nextPlaylist,\n                                              bufferLowWaterLine,\n                                              bufferHighWaterLine,\n                                              duration,\n                                              bufferBasedABR,\n                                              log\n                                          }) {\n        // we have no other playlist to switch to\n        if (!nextPlaylist) {\n            videojs.log.warn('We received no playlist to switch to. Please check your stream.');\n            return false;\n        }\n        const sharedLogLine = `allowing switch ${currentPlaylist && currentPlaylist.id || 'null'} -> ${nextPlaylist.id}`;\n        if (!currentPlaylist) {\n            log(`${sharedLogLine} as current playlist is not set`);\n            return true;\n        } // no need to switch if playlist is the same\n\n        if (nextPlaylist.id === currentPlaylist.id) {\n            return false;\n        } // determine if current time is in a buffered range.\n\n        const isBuffered = Boolean(findRange(buffered, currentTime).length); // If the playlist is live, then we want to not take low water line into account.\n        // This is because in LIVE, the player plays 3 segments from the end of the\n        // playlist, and if `BUFFER_LOW_WATER_LINE` is greater than the duration availble\n        // in those segments, a viewer will never experience a rendition upswitch.\n\n        if (!currentPlaylist.endList) {\n            // For LLHLS live streams, don't switch renditions before playback has started, as it almost\n            // doubles the time to first playback.\n            if (!isBuffered && typeof currentPlaylist.partTargetDuration === 'number') {\n                log(`not ${sharedLogLine} as current playlist is live llhls, but currentTime isn't in buffered.`);\n                return false;\n            }\n            log(`${sharedLogLine} as current playlist is live`);\n            return true;\n        }\n        const forwardBuffer = timeAheadOf(buffered, currentTime);\n        const maxBufferLowWaterLine = bufferBasedABR ? Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Config.MAX_BUFFER_LOW_WATER_LINE; // For the same reason as LIVE, we ignore the low water line when the VOD\n        // duration is below the max potential low water line\n\n        if (duration < maxBufferLowWaterLine) {\n            log(`${sharedLogLine} as duration < max low water line (${duration} < ${maxBufferLowWaterLine})`);\n            return true;\n        }\n        const nextBandwidth = nextPlaylist.attributes.BANDWIDTH;\n        const currBandwidth = currentPlaylist.attributes.BANDWIDTH; // when switching down, if our buffer is lower than the high water line,\n        // we can switch down\n\n        if (nextBandwidth < currBandwidth && (!bufferBasedABR || forwardBuffer < bufferHighWaterLine)) {\n            let logLine = `${sharedLogLine} as next bandwidth < current bandwidth (${nextBandwidth} < ${currBandwidth})`;\n            if (bufferBasedABR) {\n                logLine += ` and forwardBuffer < bufferHighWaterLine (${forwardBuffer} < ${bufferHighWaterLine})`;\n            }\n            log(logLine);\n            return true;\n        } // and if our buffer is higher than the low water line,\n        // we can switch up\n\n        if ((!bufferBasedABR || nextBandwidth > currBandwidth) && forwardBuffer >= bufferLowWaterLine) {\n            let logLine = `${sharedLogLine} as forwardBuffer >= bufferLowWaterLine (${forwardBuffer} >= ${bufferLowWaterLine})`;\n            if (bufferBasedABR) {\n                logLine += ` and next bandwidth > current bandwidth (${nextBandwidth} > ${currBandwidth})`;\n            }\n            log(logLine);\n            return true;\n        }\n        log(`not ${sharedLogLine} as no switching criteria met`);\n        return false;\n    };\n    /**\n     * the main playlist controller controller all interactons\n     * between playlists and segmentloaders. At this time this mainly\n     * involves a main playlist and a series of audio playlists\n     * if they are available\n     *\n     * @class PlaylistController\n     * @extends videojs.EventTarget\n     */\n\n    class PlaylistController extends videojs.EventTarget {\n        constructor(options) {\n            super();\n            const {\n                src,\n                withCredentials,\n                tech,\n                bandwidth,\n                externVhs,\n                useCueTags,\n                playlistExclusionDuration,\n                enableLowInitialPlaylist,\n                sourceType,\n                cacheEncryptionKeys,\n                bufferBasedABR,\n                leastPixelDiffSelector,\n                captionServices\n            } = options;\n            if (!src) {\n                throw new Error('A non-empty playlist URL or JSON manifest string is required');\n            }\n            let {\n                maxPlaylistRetries\n            } = options;\n            if (maxPlaylistRetries === null || typeof maxPlaylistRetries === 'undefined') {\n                maxPlaylistRetries = Infinity;\n            }\n            Vhs$1 = externVhs;\n            this.bufferBasedABR = Boolean(bufferBasedABR);\n            this.leastPixelDiffSelector = Boolean(leastPixelDiffSelector);\n            this.withCredentials = withCredentials;\n            this.tech_ = tech;\n            this.vhs_ = tech.vhs;\n            this.sourceType_ = sourceType;\n            this.useCueTags_ = useCueTags;\n            this.playlistExclusionDuration = playlistExclusionDuration;\n            this.maxPlaylistRetries = maxPlaylistRetries;\n            this.enableLowInitialPlaylist = enableLowInitialPlaylist;\n            if (this.useCueTags_) {\n                this.cueTagsTrack_ = this.tech_.addTextTrack('metadata', 'ad-cues');\n                this.cueTagsTrack_.inBandMetadataTrackDispatchType = '';\n            }\n            this.requestOptions_ = {\n                withCredentials,\n                maxPlaylistRetries,\n                timeout: null\n            };\n            this.on('error', this.pauseLoading);\n            this.mediaTypes_ = createMediaTypes();\n            this.mediaSource = new window.MediaSource();\n            this.handleDurationChange_ = this.handleDurationChange_.bind(this);\n            this.handleSourceOpen_ = this.handleSourceOpen_.bind(this);\n            this.handleSourceEnded_ = this.handleSourceEnded_.bind(this);\n            this.mediaSource.addEventListener('durationchange', this.handleDurationChange_); // load the media source into the player\n\n            this.mediaSource.addEventListener('sourceopen', this.handleSourceOpen_);\n            this.mediaSource.addEventListener('sourceended', this.handleSourceEnded_); // we don't have to handle sourceclose since dispose will handle termination of\n            // everything, and the MediaSource should not be detached without a proper disposal\n\n            this.seekable_ = createTimeRanges();\n            this.hasPlayed_ = false;\n            this.syncController_ = new SyncController(options);\n            this.segmentMetadataTrack_ = tech.addRemoteTextTrack({\n                kind: 'metadata',\n                label: 'segment-metadata'\n            }, false).track;\n            this.decrypter_ = new Decrypter();\n            this.sourceUpdater_ = new SourceUpdater(this.mediaSource);\n            this.inbandTextTracks_ = {};\n            this.timelineChangeController_ = new TimelineChangeController();\n            const segmentLoaderSettings = {\n                vhs: this.vhs_,\n                parse708captions: options.parse708captions,\n                useDtsForTimestampOffset: options.useDtsForTimestampOffset,\n                captionServices,\n                mediaSource: this.mediaSource,\n                currentTime: this.tech_.currentTime.bind(this.tech_),\n                seekable: () => this.seekable(),\n                seeking: () => this.tech_.seeking(),\n                duration: () => this.duration(),\n                hasPlayed: () => this.hasPlayed_,\n                goalBufferLength: () => this.goalBufferLength(),\n                bandwidth,\n                syncController: this.syncController_,\n                decrypter: this.decrypter_,\n                sourceType: this.sourceType_,\n                inbandTextTracks: this.inbandTextTracks_,\n                cacheEncryptionKeys,\n                sourceUpdater: this.sourceUpdater_,\n                timelineChangeController: this.timelineChangeController_,\n                exactManifestTimings: options.exactManifestTimings\n            }; // The source type check not only determines whether a special DASH playlist loader\n            // should be used, but also covers the case where the provided src is a vhs-json\n            // manifest object (instead of a URL). In the case of vhs-json, the default\n            // PlaylistLoader should be used.\n\n            this.mainPlaylistLoader_ = this.sourceType_ === 'dash' ? new DashPlaylistLoader(src, this.vhs_, this.requestOptions_) : new PlaylistLoader(src, this.vhs_, this.requestOptions_);\n            this.setupMainPlaylistLoaderListeners_(); // setup segment loaders\n            // combined audio/video or just video when alternate audio track is selected\n\n            this.mainSegmentLoader_ = new SegmentLoader(merge(segmentLoaderSettings, {\n                segmentMetadataTrack: this.segmentMetadataTrack_,\n                loaderType: 'main'\n            }), options); // alternate audio track\n\n            this.audioSegmentLoader_ = new SegmentLoader(merge(segmentLoaderSettings, {\n                loaderType: 'audio'\n            }), options);\n            this.subtitleSegmentLoader_ = new VTTSegmentLoader(merge(segmentLoaderSettings, {\n                loaderType: 'vtt',\n                featuresNativeTextTracks: this.tech_.featuresNativeTextTracks,\n                loadVttJs: () => new Promise((resolve, reject) => {\n                    function onLoad() {\n                        tech.off('vttjserror', onError);\n                        resolve();\n                    }\n                    function onError() {\n                        tech.off('vttjsloaded', onLoad);\n                        reject();\n                    }\n                    tech.one('vttjsloaded', onLoad);\n                    tech.one('vttjserror', onError); // safe to call multiple times, script will be loaded only once:\n\n                    tech.addWebVttScript_();\n                })\n            }), options);\n            this.setupSegmentLoaderListeners_();\n            if (this.bufferBasedABR) {\n                this.mainPlaylistLoader_.one('loadedplaylist', () => this.startABRTimer_());\n                this.tech_.on('pause', () => this.stopABRTimer_());\n                this.tech_.on('play', () => this.startABRTimer_());\n            } // Create SegmentLoader stat-getters\n            // mediaRequests_\n            // mediaRequestsAborted_\n            // mediaRequestsTimedout_\n            // mediaRequestsErrored_\n            // mediaTransferDuration_\n            // mediaBytesTransferred_\n            // mediaAppends_\n\n            loaderStats.forEach(stat => {\n                this[stat + '_'] = sumLoaderStat.bind(this, stat);\n            });\n            this.logger_ = logger('pc');\n            this.triggeredFmp4Usage = false;\n            if (this.tech_.preload() === 'none') {\n                this.loadOnPlay_ = () => {\n                    this.loadOnPlay_ = null;\n                    this.mainPlaylistLoader_.load();\n                };\n                this.tech_.one('play', this.loadOnPlay_);\n            } else {\n                this.mainPlaylistLoader_.load();\n            }\n            this.timeToLoadedData__ = -1;\n            this.mainAppendsToLoadedData__ = -1;\n            this.audioAppendsToLoadedData__ = -1;\n            const event = this.tech_.preload() === 'none' ? 'play' : 'loadstart'; // start the first frame timer on loadstart or play (for preload none)\n\n            this.tech_.one(event, () => {\n                const timeToLoadedDataStart = Date.now();\n                this.tech_.one('loadeddata', () => {\n                    this.timeToLoadedData__ = Date.now() - timeToLoadedDataStart;\n                    this.mainAppendsToLoadedData__ = this.mainSegmentLoader_.mediaAppends;\n                    this.audioAppendsToLoadedData__ = this.audioSegmentLoader_.mediaAppends;\n                });\n            });\n        }\n        mainAppendsToLoadedData_() {\n            return this.mainAppendsToLoadedData__;\n        }\n        audioAppendsToLoadedData_() {\n            return this.audioAppendsToLoadedData__;\n        }\n        appendsToLoadedData_() {\n            const main = this.mainAppendsToLoadedData_();\n            const audio = this.audioAppendsToLoadedData_();\n            if (main === -1 || audio === -1) {\n                return -1;\n            }\n            return main + audio;\n        }\n        timeToLoadedData_() {\n            return this.timeToLoadedData__;\n        }\n        /**\n         * Run selectPlaylist and switch to the new playlist if we should\n         *\n         * @param {string} [reason=abr] a reason for why the ABR check is made\n         * @private\n         */\n\n        checkABR_(reason = 'abr') {\n            const nextPlaylist = this.selectPlaylist();\n            if (nextPlaylist && this.shouldSwitchToMedia_(nextPlaylist)) {\n                this.switchMedia_(nextPlaylist, reason);\n            }\n        }\n        switchMedia_(playlist, cause, delay) {\n            const oldMedia = this.media();\n            const oldId = oldMedia && (oldMedia.id || oldMedia.uri);\n            const newId = playlist.id || playlist.uri;\n            if (oldId && oldId !== newId) {\n                this.logger_(`switch media ${oldId} -> ${newId} from ${cause}`);\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: `vhs-rendition-change-${cause}`\n                });\n            }\n            this.mainPlaylistLoader_.media(playlist, delay);\n        }\n        /**\n         * Start a timer that periodically calls checkABR_\n         *\n         * @private\n         */\n\n        startABRTimer_() {\n            this.stopABRTimer_();\n            this.abrTimer_ = window.setInterval(() => this.checkABR_(), 250);\n        }\n        /**\n         * Stop the timer that periodically calls checkABR_\n         *\n         * @private\n         */\n\n        stopABRTimer_() {\n            // if we're scrubbing, we don't need to pause.\n            // This getter will be added to Video.js in version 7.11.\n            if (this.tech_.scrubbing && this.tech_.scrubbing()) {\n                return;\n            }\n            window.clearInterval(this.abrTimer_);\n            this.abrTimer_ = null;\n        }\n        /**\n         * Get a list of playlists for the currently selected audio playlist\n         *\n         * @return {Array} the array of audio playlists\n         */\n\n        getAudioTrackPlaylists_() {\n            const main = this.main();\n            const defaultPlaylists = main && main.playlists || []; // if we don't have any audio groups then we can only\n            // assume that the audio tracks are contained in main\n            // playlist array, use that or an empty array.\n\n            if (!main || !main.mediaGroups || !main.mediaGroups.AUDIO) {\n                return defaultPlaylists;\n            }\n            const AUDIO = main.mediaGroups.AUDIO;\n            const groupKeys = Object.keys(AUDIO);\n            let track; // get the current active track\n\n            if (Object.keys(this.mediaTypes_.AUDIO.groups).length) {\n                track = this.mediaTypes_.AUDIO.activeTrack(); // or get the default track from main if mediaTypes_ isn't setup yet\n            } else {\n                // default group is `main` or just the first group.\n                const defaultGroup = AUDIO.main || groupKeys.length && AUDIO[groupKeys[0]];\n                for (const label in defaultGroup) {\n                    if (defaultGroup[label].default) {\n                        track = {\n                            label\n                        };\n                        break;\n                    }\n                }\n            } // no active track no playlists.\n\n            if (!track) {\n                return defaultPlaylists;\n            }\n            const playlists = []; // get all of the playlists that are possible for the\n            // active track.\n\n            for (const group in AUDIO) {\n                if (AUDIO[group][track.label]) {\n                    const properties = AUDIO[group][track.label];\n                    if (properties.playlists && properties.playlists.length) {\n                        playlists.push.apply(playlists, properties.playlists);\n                    } else if (properties.uri) {\n                        playlists.push(properties);\n                    } else if (main.playlists.length) {\n                        // if an audio group does not have a uri\n                        // see if we have main playlists that use it as a group.\n                        // if we do then add those to the playlists list.\n                        for (let i = 0; i < main.playlists.length; i++) {\n                            const playlist = main.playlists[i];\n                            if (playlist.attributes && playlist.attributes.AUDIO && playlist.attributes.AUDIO === group) {\n                                playlists.push(playlist);\n                            }\n                        }\n                    }\n                }\n            }\n            if (!playlists.length) {\n                return defaultPlaylists;\n            }\n            return playlists;\n        }\n        /**\n         * Register event handlers on the main playlist loader. A helper\n         * function for construction time.\n         *\n         * @private\n         */\n\n        setupMainPlaylistLoaderListeners_() {\n            this.mainPlaylistLoader_.on('loadedmetadata', () => {\n                const media = this.mainPlaylistLoader_.media();\n                const requestTimeout = media.targetDuration * 1.5 * 1000; // If we don't have any more available playlists, we don't want to\n                // timeout the request.\n\n                if (isLowestEnabledRendition(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media())) {\n                    this.requestOptions_.timeout = 0;\n                } else {\n                    this.requestOptions_.timeout = requestTimeout;\n                } // if this isn't a live video and preload permits, start\n                // downloading segments\n\n                if (media.endList && this.tech_.preload() !== 'none') {\n                    this.mainSegmentLoader_.playlist(media, this.requestOptions_);\n                    this.mainSegmentLoader_.load();\n                }\n                setupMediaGroups({\n                    sourceType: this.sourceType_,\n                    segmentLoaders: {\n                        AUDIO: this.audioSegmentLoader_,\n                        SUBTITLES: this.subtitleSegmentLoader_,\n                        main: this.mainSegmentLoader_\n                    },\n                    tech: this.tech_,\n                    requestOptions: this.requestOptions_,\n                    mainPlaylistLoader: this.mainPlaylistLoader_,\n                    vhs: this.vhs_,\n                    main: this.main(),\n                    mediaTypes: this.mediaTypes_,\n                    excludePlaylist: this.excludePlaylist.bind(this)\n                });\n                this.triggerPresenceUsage_(this.main(), media);\n                this.setupFirstPlay();\n                if (!this.mediaTypes_.AUDIO.activePlaylistLoader || this.mediaTypes_.AUDIO.activePlaylistLoader.media()) {\n                    this.trigger('selectedinitialmedia');\n                } else {\n                    // We must wait for the active audio playlist loader to\n                    // finish setting up before triggering this event so the\n                    // representations API and EME setup is correct\n                    this.mediaTypes_.AUDIO.activePlaylistLoader.one('loadedmetadata', () => {\n                        this.trigger('selectedinitialmedia');\n                    });\n                }\n            });\n            this.mainPlaylistLoader_.on('loadedplaylist', () => {\n                if (this.loadOnPlay_) {\n                    this.tech_.off('play', this.loadOnPlay_);\n                }\n                let updatedPlaylist = this.mainPlaylistLoader_.media();\n                if (!updatedPlaylist) {\n                    // exclude any variants that are not supported by the browser before selecting\n                    // an initial media as the playlist selectors do not consider browser support\n                    this.excludeUnsupportedVariants_();\n                    let selectedMedia;\n                    if (this.enableLowInitialPlaylist) {\n                        selectedMedia = this.selectInitialPlaylist();\n                    }\n                    if (!selectedMedia) {\n                        selectedMedia = this.selectPlaylist();\n                    }\n                    if (!selectedMedia || !this.shouldSwitchToMedia_(selectedMedia)) {\n                        return;\n                    }\n                    this.initialMedia_ = selectedMedia;\n                    this.switchMedia_(this.initialMedia_, 'initial'); // Under the standard case where a source URL is provided, loadedplaylist will\n                    // fire again since the playlist will be requested. In the case of vhs-json\n                    // (where the manifest object is provided as the source), when the media\n                    // playlist's `segments` list is already available, a media playlist won't be\n                    // requested, and loadedplaylist won't fire again, so the playlist handler must be\n                    // called on its own here.\n\n                    const haveJsonSource = this.sourceType_ === 'vhs-json' && this.initialMedia_.segments;\n                    if (!haveJsonSource) {\n                        return;\n                    }\n                    updatedPlaylist = this.initialMedia_;\n                }\n                this.handleUpdatedMediaPlaylist(updatedPlaylist);\n            });\n            this.mainPlaylistLoader_.on('error', () => {\n                const error = this.mainPlaylistLoader_.error;\n                this.excludePlaylist({\n                    playlistToExclude: error.playlist,\n                    error\n                });\n            });\n            this.mainPlaylistLoader_.on('mediachanging', () => {\n                this.mainSegmentLoader_.abort();\n                this.mainSegmentLoader_.pause();\n            });\n            this.mainPlaylistLoader_.on('mediachange', () => {\n                const media = this.mainPlaylistLoader_.media();\n                const requestTimeout = media.targetDuration * 1.5 * 1000; // If we don't have any more available playlists, we don't want to\n                // timeout the request.\n\n                if (isLowestEnabledRendition(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media())) {\n                    this.requestOptions_.timeout = 0;\n                } else {\n                    this.requestOptions_.timeout = requestTimeout;\n                }\n                this.mainPlaylistLoader_.load(); // TODO: Create a new event on the PlaylistLoader that signals\n                // that the segments have changed in some way and use that to\n                // update the SegmentLoader instead of doing it twice here and\n                // on `loadedplaylist`\n\n                this.mainSegmentLoader_.playlist(media, this.requestOptions_);\n                this.mainSegmentLoader_.load();\n                this.tech_.trigger({\n                    type: 'mediachange',\n                    bubbles: true\n                });\n            });\n            this.mainPlaylistLoader_.on('playlistunchanged', () => {\n                const updatedPlaylist = this.mainPlaylistLoader_.media(); // ignore unchanged playlists that have already been\n                // excluded for not-changing. We likely just have a really slowly updating\n                // playlist.\n\n                if (updatedPlaylist.lastExcludeReason_ === 'playlist-unchanged') {\n                    return;\n                }\n                const playlistOutdated = this.stuckAtPlaylistEnd_(updatedPlaylist);\n                if (playlistOutdated) {\n                    // Playlist has stopped updating and we're stuck at its end. Try to\n                    // exclude it and switch to another playlist in the hope that that\n                    // one is updating (and give the player a chance to re-adjust to the\n                    // safe live point).\n                    this.excludePlaylist({\n                        error: {\n                            message: 'Playlist no longer updating.',\n                            reason: 'playlist-unchanged'\n                        }\n                    }); // useful for monitoring QoS\n\n                    this.tech_.trigger('playliststuck');\n                }\n            });\n            this.mainPlaylistLoader_.on('renditiondisabled', () => {\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-rendition-disabled'\n                });\n            });\n            this.mainPlaylistLoader_.on('renditionenabled', () => {\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-rendition-enabled'\n                });\n            });\n        }\n        /**\n         * Given an updated media playlist (whether it was loaded for the first time, or\n         * refreshed for live playlists), update any relevant properties and state to reflect\n         * changes in the media that should be accounted for (e.g., cues and duration).\n         *\n         * @param {Object} updatedPlaylist the updated media playlist object\n         *\n         * @private\n         */\n\n        handleUpdatedMediaPlaylist(updatedPlaylist) {\n            if (this.useCueTags_) {\n                this.updateAdCues_(updatedPlaylist);\n            } // TODO: Create a new event on the PlaylistLoader that signals\n            // that the segments have changed in some way and use that to\n            // update the SegmentLoader instead of doing it twice here and\n            // on `mediachange`\n\n            this.mainSegmentLoader_.playlist(updatedPlaylist, this.requestOptions_);\n            this.updateDuration(!updatedPlaylist.endList); // If the player isn't paused, ensure that the segment loader is running,\n            // as it is possible that it was temporarily stopped while waiting for\n            // a playlist (e.g., in case the playlist errored and we re-requested it).\n\n            if (!this.tech_.paused()) {\n                this.mainSegmentLoader_.load();\n                if (this.audioSegmentLoader_) {\n                    this.audioSegmentLoader_.load();\n                }\n            }\n        }\n        /**\n         * A helper function for triggerring presence usage events once per source\n         *\n         * @private\n         */\n\n        triggerPresenceUsage_(main, media) {\n            const mediaGroups = main.mediaGroups || {};\n            let defaultDemuxed = true;\n            const audioGroupKeys = Object.keys(mediaGroups.AUDIO);\n            for (const mediaGroup in mediaGroups.AUDIO) {\n                for (const label in mediaGroups.AUDIO[mediaGroup]) {\n                    const properties = mediaGroups.AUDIO[mediaGroup][label];\n                    if (!properties.uri) {\n                        defaultDemuxed = false;\n                    }\n                }\n            }\n            if (defaultDemuxed) {\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-demuxed'\n                });\n            }\n            if (Object.keys(mediaGroups.SUBTITLES).length) {\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-webvtt'\n                });\n            }\n            if (Vhs$1.Playlist.isAes(media)) {\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-aes'\n                });\n            }\n            if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) {\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-alternate-audio'\n                });\n            }\n            if (this.useCueTags_) {\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-playlist-cue-tags'\n                });\n            }\n        }\n        shouldSwitchToMedia_(nextPlaylist) {\n            const currentPlaylist = this.mainPlaylistLoader_.media() || this.mainPlaylistLoader_.pendingMedia_;\n            const currentTime = this.tech_.currentTime();\n            const bufferLowWaterLine = this.bufferLowWaterLine();\n            const bufferHighWaterLine = this.bufferHighWaterLine();\n            const buffered = this.tech_.buffered();\n            return shouldSwitchToMedia({\n                buffered,\n                currentTime,\n                currentPlaylist,\n                nextPlaylist,\n                bufferLowWaterLine,\n                bufferHighWaterLine,\n                duration: this.duration(),\n                bufferBasedABR: this.bufferBasedABR,\n                log: this.logger_\n            });\n        }\n        /**\n         * Register event handlers on the segment loaders. A helper function\n         * for construction time.\n         *\n         * @private\n         */\n\n        setupSegmentLoaderListeners_() {\n            this.mainSegmentLoader_.on('bandwidthupdate', () => {\n                // Whether or not buffer based ABR or another ABR is used, on a bandwidth change it's\n                // useful to check to see if a rendition switch should be made.\n                this.checkABR_('bandwidthupdate');\n                this.tech_.trigger('bandwidthupdate');\n            });\n            this.mainSegmentLoader_.on('timeout', () => {\n                if (this.bufferBasedABR) {\n                    // If a rendition change is needed, then it would've be done on `bandwidthupdate`.\n                    // Here the only consideration is that for buffer based ABR there's no guarantee\n                    // of an immediate switch (since the bandwidth is averaged with a timeout\n                    // bandwidth value of 1), so force a load on the segment loader to keep it going.\n                    this.mainSegmentLoader_.load();\n                }\n            }); // `progress` events are not reliable enough of a bandwidth measure to trigger buffer\n            // based ABR.\n\n            if (!this.bufferBasedABR) {\n                this.mainSegmentLoader_.on('progress', () => {\n                    this.trigger('progress');\n                });\n            }\n            this.mainSegmentLoader_.on('error', () => {\n                const error = this.mainSegmentLoader_.error();\n                this.excludePlaylist({\n                    playlistToExclude: error.playlist,\n                    error\n                });\n            });\n            this.mainSegmentLoader_.on('appenderror', () => {\n                this.error = this.mainSegmentLoader_.error_;\n                this.trigger('error');\n            });\n            this.mainSegmentLoader_.on('syncinfoupdate', () => {\n                this.onSyncInfoUpdate_();\n            });\n            this.mainSegmentLoader_.on('timestampoffset', () => {\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-timestamp-offset'\n                });\n            });\n            this.audioSegmentLoader_.on('syncinfoupdate', () => {\n                this.onSyncInfoUpdate_();\n            });\n            this.audioSegmentLoader_.on('appenderror', () => {\n                this.error = this.audioSegmentLoader_.error_;\n                this.trigger('error');\n            });\n            this.mainSegmentLoader_.on('ended', () => {\n                this.logger_('main segment loader ended');\n                this.onEndOfStream();\n            });\n            this.mainSegmentLoader_.on('earlyabort', event => {\n                // never try to early abort with the new ABR algorithm\n                if (this.bufferBasedABR) {\n                    return;\n                }\n                this.delegateLoaders_('all', ['abort']);\n                this.excludePlaylist({\n                    error: {\n                        message: 'Aborted early because there isn\\'t enough bandwidth to complete ' + 'the request without rebuffering.'\n                    },\n                    playlistExclusionDuration: ABORT_EARLY_EXCLUSION_SECONDS\n                });\n            });\n            const updateCodecs = () => {\n                if (!this.sourceUpdater_.hasCreatedSourceBuffers()) {\n                    return this.tryToCreateSourceBuffers_();\n                }\n                const codecs = this.getCodecsOrExclude_(); // no codecs means that the playlist was excluded\n\n                if (!codecs) {\n                    return;\n                }\n                this.sourceUpdater_.addOrChangeSourceBuffers(codecs);\n            };\n            this.mainSegmentLoader_.on('trackinfo', updateCodecs);\n            this.audioSegmentLoader_.on('trackinfo', updateCodecs);\n            this.mainSegmentLoader_.on('fmp4', () => {\n                if (!this.triggeredFmp4Usage) {\n                    this.tech_.trigger({\n                        type: 'usage',\n                        name: 'vhs-fmp4'\n                    });\n                    this.triggeredFmp4Usage = true;\n                }\n            });\n            this.audioSegmentLoader_.on('fmp4', () => {\n                if (!this.triggeredFmp4Usage) {\n                    this.tech_.trigger({\n                        type: 'usage',\n                        name: 'vhs-fmp4'\n                    });\n                    this.triggeredFmp4Usage = true;\n                }\n            });\n            this.audioSegmentLoader_.on('ended', () => {\n                this.logger_('audioSegmentLoader ended');\n                this.onEndOfStream();\n            });\n        }\n        mediaSecondsLoaded_() {\n            return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);\n        }\n        /**\n         * Call load on our SegmentLoaders\n         */\n\n        load() {\n            this.mainSegmentLoader_.load();\n            if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n                this.audioSegmentLoader_.load();\n            }\n            if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n                this.subtitleSegmentLoader_.load();\n            }\n        }\n        /**\n         * Re-tune playback quality level for the current player\n         * conditions. This method will perform destructive actions like removing\n         * already buffered content in order to readjust the currently active\n         * playlist quickly. This is good for manual quality changes\n         *\n         * @private\n         */\n\n        fastQualityChange_(media = this.selectPlaylist()) {\n            if (media === this.mainPlaylistLoader_.media()) {\n                this.logger_('skipping fastQualityChange because new media is same as old');\n                return;\n            }\n            this.switchMedia_(media, 'fast-quality'); // Delete all buffered data to allow an immediate quality switch, then seek to give\n            // the browser a kick to remove any cached frames from the previous rendtion (.04 seconds\n            // ahead is roughly the minimum that will accomplish this across a variety of content\n            // in IE and Edge, but seeking in place is sufficient on all other browsers)\n            // Edge/IE bug: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/14600375/\n            // Chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=651904\n\n            this.mainSegmentLoader_.resetEverything(() => {\n                // Since this is not a typical seek, we avoid the seekTo method which can cause segments\n                // from the previously enabled rendition to load before the new playlist has finished loading\n                if (videojs.browser.IE_VERSION || videojs.browser.IS_EDGE) {\n                    this.tech_.setCurrentTime(this.tech_.currentTime() + 0.04);\n                } else {\n                    this.tech_.setCurrentTime(this.tech_.currentTime());\n                }\n            }); // don't need to reset audio as it is reset when media changes\n        }\n        /**\n         * Begin playback.\n         */\n\n        play() {\n            if (this.setupFirstPlay()) {\n                return;\n            }\n            if (this.tech_.ended()) {\n                this.tech_.setCurrentTime(0);\n            }\n            if (this.hasPlayed_) {\n                this.load();\n            }\n            const seekable = this.tech_.seekable(); // if the viewer has paused and we fell out of the live window,\n            // seek forward to the live point\n\n            if (this.tech_.duration() === Infinity) {\n                if (this.tech_.currentTime() < seekable.start(0)) {\n                    return this.tech_.setCurrentTime(seekable.end(seekable.length - 1));\n                }\n            }\n        }\n        /**\n         * Seek to the latest media position if this is a live video and the\n         * player and video are loaded and initialized.\n         */\n\n        setupFirstPlay() {\n            const media = this.mainPlaylistLoader_.media(); // Check that everything is ready to begin buffering for the first call to play\n            //  If 1) there is no active media\n            //     2) the player is paused\n            //     3) the first play has already been setup\n            // then exit early\n\n            if (!media || this.tech_.paused() || this.hasPlayed_) {\n                return false;\n            } // when the video is a live stream\n\n            if (!media.endList) {\n                const seekable = this.seekable();\n                if (!seekable.length) {\n                    // without a seekable range, the player cannot seek to begin buffering at the live\n                    // point\n                    return false;\n                }\n                if (videojs.browser.IE_VERSION && this.tech_.readyState() === 0) {\n                    // IE11 throws an InvalidStateError if you try to set currentTime while the\n                    // readyState is 0, so it must be delayed until the tech fires loadedmetadata.\n                    this.tech_.one('loadedmetadata', () => {\n                        this.trigger('firstplay');\n                        this.tech_.setCurrentTime(seekable.end(0));\n                        this.hasPlayed_ = true;\n                    });\n                    return false;\n                } // trigger firstplay to inform the source handler to ignore the next seek event\n\n                this.trigger('firstplay'); // seek to the live point\n\n                this.tech_.setCurrentTime(seekable.end(0));\n            }\n            this.hasPlayed_ = true; // we can begin loading now that everything is ready\n\n            this.load();\n            return true;\n        }\n        /**\n         * handle the sourceopen event on the MediaSource\n         *\n         * @private\n         */\n\n        handleSourceOpen_() {\n            // Only attempt to create the source buffer if none already exist.\n            // handleSourceOpen is also called when we are \"re-opening\" a source buffer\n            // after `endOfStream` has been called (in response to a seek for instance)\n            this.tryToCreateSourceBuffers_(); // if autoplay is enabled, begin playback. This is duplicative of\n            // code in video.js but is required because play() must be invoked\n            // *after* the media source has opened.\n\n            if (this.tech_.autoplay()) {\n                const playPromise = this.tech_.play(); // Catch/silence error when a pause interrupts a play request\n                // on browsers which return a promise\n\n                if (typeof playPromise !== 'undefined' && typeof playPromise.then === 'function') {\n                    playPromise.then(null, e => {});\n                }\n            }\n            this.trigger('sourceopen');\n        }\n        /**\n         * handle the sourceended event on the MediaSource\n         *\n         * @private\n         */\n\n        handleSourceEnded_() {\n            if (!this.inbandTextTracks_.metadataTrack_) {\n                return;\n            }\n            const cues = this.inbandTextTracks_.metadataTrack_.cues;\n            if (!cues || !cues.length) {\n                return;\n            }\n            const duration = this.duration();\n            cues[cues.length - 1].endTime = isNaN(duration) || Math.abs(duration) === Infinity ? Number.MAX_VALUE : duration;\n        }\n        /**\n         * handle the durationchange event on the MediaSource\n         *\n         * @private\n         */\n\n        handleDurationChange_() {\n            this.tech_.trigger('durationchange');\n        }\n        /**\n         * Calls endOfStream on the media source when all active stream types have called\n         * endOfStream\n         *\n         * @param {string} streamType\n         *        Stream type of the segment loader that called endOfStream\n         * @private\n         */\n\n        onEndOfStream() {\n            let isEndOfStream = this.mainSegmentLoader_.ended_;\n            if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n                const mainMediaInfo = this.mainSegmentLoader_.getCurrentMediaInfo_(); // if the audio playlist loader exists, then alternate audio is active\n\n                if (!mainMediaInfo || mainMediaInfo.hasVideo) {\n                    // if we do not know if the main segment loader contains video yet or if we\n                    // definitively know the main segment loader contains video, then we need to wait\n                    // for both main and audio segment loaders to call endOfStream\n                    isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_;\n                } else {\n                    // otherwise just rely on the audio loader\n                    isEndOfStream = this.audioSegmentLoader_.ended_;\n                }\n            }\n            if (!isEndOfStream) {\n                return;\n            }\n            this.stopABRTimer_();\n            this.sourceUpdater_.endOfStream();\n        }\n        /**\n         * Check if a playlist has stopped being updated\n         *\n         * @param {Object} playlist the media playlist object\n         * @return {boolean} whether the playlist has stopped being updated or not\n         */\n\n        stuckAtPlaylistEnd_(playlist) {\n            const seekable = this.seekable();\n            if (!seekable.length) {\n                // playlist doesn't have enough information to determine whether we are stuck\n                return false;\n            }\n            const expired = this.syncController_.getExpiredTime(playlist, this.duration());\n            if (expired === null) {\n                return false;\n            } // does not use the safe live end to calculate playlist end, since we\n            // don't want to say we are stuck while there is still content\n\n            const absolutePlaylistEnd = Vhs$1.Playlist.playlistEnd(playlist, expired);\n            const currentTime = this.tech_.currentTime();\n            const buffered = this.tech_.buffered();\n            if (!buffered.length) {\n                // return true if the playhead reached the absolute end of the playlist\n                return absolutePlaylistEnd - currentTime <= SAFE_TIME_DELTA;\n            }\n            const bufferedEnd = buffered.end(buffered.length - 1); // return true if there is too little buffer left and buffer has reached absolute\n            // end of playlist\n\n            return bufferedEnd - currentTime <= SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= SAFE_TIME_DELTA;\n        }\n        /**\n         * Exclude a playlist for a set amount of time, making it unavailable for selection by\n         * the rendition selection algorithm, then force a new playlist (rendition) selection.\n         *\n         * @param {Object=} playlistToExclude\n         *                  the playlist to exclude, defaults to the currently selected playlist\n         * @param {Object=} error\n         *                  an optional error\n         * @param {number=} playlistExclusionDuration\n         *                  an optional number of seconds to exclude the playlist\n         */\n\n        excludePlaylist({\n                            playlistToExclude = this.mainPlaylistLoader_.media(),\n                            error = {},\n                            playlistExclusionDuration\n                        }) {\n            // If the `error` was generated by the playlist loader, it will contain\n            // the playlist we were trying to load (but failed) and that should be\n            // excluded instead of the currently selected playlist which is likely\n            // out-of-date in this scenario\n            playlistToExclude = playlistToExclude || this.mainPlaylistLoader_.media();\n            playlistExclusionDuration = playlistExclusionDuration || error.playlistExclusionDuration || this.playlistExclusionDuration; // If there is no current playlist, then an error occurred while we were\n            // trying to load the main OR while we were disposing of the tech\n\n            if (!playlistToExclude) {\n                this.error = error;\n                if (this.mediaSource.readyState !== 'open') {\n                    this.trigger('error');\n                } else {\n                    this.sourceUpdater_.endOfStream('network');\n                }\n                return;\n            }\n            playlistToExclude.playlistErrors_++;\n            const playlists = this.mainPlaylistLoader_.main.playlists;\n            const enabledPlaylists = playlists.filter(isEnabled);\n            const isFinalRendition = enabledPlaylists.length === 1 && enabledPlaylists[0] === playlistToExclude; // Don't exclude the only playlist unless it was excluded\n            // forever\n\n            if (playlists.length === 1 && playlistExclusionDuration !== Infinity) {\n                videojs.log.warn(`Problem encountered with playlist ${playlistToExclude.id}. ` + 'Trying again since it is the only playlist.');\n                this.tech_.trigger('retryplaylist'); // if this is a final rendition, we should delay\n\n                return this.mainPlaylistLoader_.load(isFinalRendition);\n            }\n            if (isFinalRendition) {\n                // Since we're on the final non-excluded playlist, and we're about to exclude\n                // it, instead of erring the player or retrying this playlist, clear out the current\n                // exclusion list. This allows other playlists to be attempted in case any have been\n                // fixed.\n                let reincluded = false;\n                playlists.forEach(playlist => {\n                    // skip current playlist which is about to be excluded\n                    if (playlist === playlistToExclude) {\n                        return;\n                    }\n                    const excludeUntil = playlist.excludeUntil; // a playlist cannot be reincluded if it wasn't excluded to begin with.\n\n                    if (typeof excludeUntil !== 'undefined' && excludeUntil !== Infinity) {\n                        reincluded = true;\n                        delete playlist.excludeUntil;\n                    }\n                });\n                if (reincluded) {\n                    videojs.log.warn('Removing other playlists from the exclusion list because the last ' + 'rendition is about to be excluded.'); // Technically we are retrying a playlist, in that we are simply retrying a previous\n                    // playlist. This is needed for users relying on the retryplaylist event to catch a\n                    // case where the player might be stuck and looping through \"dead\" playlists.\n\n                    this.tech_.trigger('retryplaylist');\n                }\n            } // Exclude this playlist\n\n            let excludeUntil;\n            if (playlistToExclude.playlistErrors_ > this.maxPlaylistRetries) {\n                excludeUntil = Infinity;\n            } else {\n                excludeUntil = Date.now() + playlistExclusionDuration * 1000;\n            }\n            playlistToExclude.excludeUntil = excludeUntil;\n            if (error.reason) {\n                playlistToExclude.lastExcludeReason_ = error.reason;\n            }\n            this.tech_.trigger('excludeplaylist');\n            this.tech_.trigger({\n                type: 'usage',\n                name: 'vhs-rendition-excluded'\n            }); // TODO: only load a new playlist if we're excluding the current playlist\n            // If this function was called with a playlist that's not the current active playlist\n            // (e.g., media().id !== playlistToExclude.id),\n            // then a new playlist should not be selected and loaded, as there's nothing wrong with the current playlist.\n\n            const nextPlaylist = this.selectPlaylist();\n            if (!nextPlaylist) {\n                this.error = 'Playback cannot continue. No available working or supported playlists.';\n                this.trigger('error');\n                return;\n            }\n            const logFn = error.internal ? this.logger_ : videojs.log.warn;\n            const errorMessage = error.message ? ' ' + error.message : '';\n            logFn(`${error.internal ? 'Internal problem' : 'Problem'} encountered with playlist ${playlistToExclude.id}.` + `${errorMessage} Switching to playlist ${nextPlaylist.id}.`); // if audio group changed reset audio loaders\n\n            if (nextPlaylist.attributes.AUDIO !== playlistToExclude.attributes.AUDIO) {\n                this.delegateLoaders_('audio', ['abort', 'pause']);\n            } // if subtitle group changed reset subtitle loaders\n\n            if (nextPlaylist.attributes.SUBTITLES !== playlistToExclude.attributes.SUBTITLES) {\n                this.delegateLoaders_('subtitle', ['abort', 'pause']);\n            }\n            this.delegateLoaders_('main', ['abort', 'pause']);\n            const delayDuration = nextPlaylist.targetDuration / 2 * 1000 || 5 * 1000;\n            const shouldDelay = typeof nextPlaylist.lastRequest === 'number' && Date.now() - nextPlaylist.lastRequest <= delayDuration; // delay if it's a final rendition or if the last refresh is sooner than half targetDuration\n\n            return this.switchMedia_(nextPlaylist, 'exclude', isFinalRendition || shouldDelay);\n        }\n        /**\n         * Pause all segment/playlist loaders\n         */\n\n        pauseLoading() {\n            this.delegateLoaders_('all', ['abort', 'pause']);\n            this.stopABRTimer_();\n        }\n        /**\n         * Call a set of functions in order on playlist loaders, segment loaders,\n         * or both types of loaders.\n         *\n         * @param {string} filter\n         *        Filter loaders that should call fnNames using a string. Can be:\n         *        * all - run on all loaders\n         *        * audio - run on all audio loaders\n         *        * subtitle - run on all subtitle loaders\n         *        * main - run on the main loaders\n         *\n         * @param {Array|string} fnNames\n         *        A string or array of function names to call.\n         */\n\n        delegateLoaders_(filter, fnNames) {\n            const loaders = [];\n            const dontFilterPlaylist = filter === 'all';\n            if (dontFilterPlaylist || filter === 'main') {\n                loaders.push(this.mainPlaylistLoader_);\n            }\n            const mediaTypes = [];\n            if (dontFilterPlaylist || filter === 'audio') {\n                mediaTypes.push('AUDIO');\n            }\n            if (dontFilterPlaylist || filter === 'subtitle') {\n                mediaTypes.push('CLOSED-CAPTIONS');\n                mediaTypes.push('SUBTITLES');\n            }\n            mediaTypes.forEach(mediaType => {\n                const loader = this.mediaTypes_[mediaType] && this.mediaTypes_[mediaType].activePlaylistLoader;\n                if (loader) {\n                    loaders.push(loader);\n                }\n            });\n            ['main', 'audio', 'subtitle'].forEach(name => {\n                const loader = this[`${name}SegmentLoader_`];\n                if (loader && (filter === name || filter === 'all')) {\n                    loaders.push(loader);\n                }\n            });\n            loaders.forEach(loader => fnNames.forEach(fnName => {\n                if (typeof loader[fnName] === 'function') {\n                    loader[fnName]();\n                }\n            }));\n        }\n        /**\n         * set the current time on all segment loaders\n         *\n         * @param {TimeRange} currentTime the current time to set\n         * @return {TimeRange} the current time\n         */\n\n        setCurrentTime(currentTime) {\n            const buffered = findRange(this.tech_.buffered(), currentTime);\n            if (!(this.mainPlaylistLoader_ && this.mainPlaylistLoader_.media())) {\n                // return immediately if the metadata is not ready yet\n                return 0;\n            } // it's clearly an edge-case but don't thrown an error if asked to\n            // seek within an empty playlist\n\n            if (!this.mainPlaylistLoader_.media().segments) {\n                return 0;\n            } // if the seek location is already buffered, continue buffering as usual\n\n            if (buffered && buffered.length) {\n                return currentTime;\n            } // cancel outstanding requests so we begin buffering at the new\n            // location\n\n            this.mainSegmentLoader_.resetEverything();\n            this.mainSegmentLoader_.abort();\n            if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n                this.audioSegmentLoader_.resetEverything();\n                this.audioSegmentLoader_.abort();\n            }\n            if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {\n                this.subtitleSegmentLoader_.resetEverything();\n                this.subtitleSegmentLoader_.abort();\n            } // start segment loader loading in case they are paused\n\n            this.load();\n        }\n        /**\n         * get the current duration\n         *\n         * @return {TimeRange} the duration\n         */\n\n        duration() {\n            if (!this.mainPlaylistLoader_) {\n                return 0;\n            }\n            const media = this.mainPlaylistLoader_.media();\n            if (!media) {\n                // no playlists loaded yet, so can't determine a duration\n                return 0;\n            } // Don't rely on the media source for duration in the case of a live playlist since\n            // setting the native MediaSource's duration to infinity ends up with consequences to\n            // seekable behavior. See https://github.com/w3c/media-source/issues/5 for details.\n            //\n            // This is resolved in the spec by https://github.com/w3c/media-source/pull/92,\n            // however, few browsers have support for setLiveSeekableRange()\n            // https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/setLiveSeekableRange\n            //\n            // Until a time when the duration of the media source can be set to infinity, and a\n            // seekable range specified across browsers, just return Infinity.\n\n            if (!media.endList) {\n                return Infinity;\n            } // Since this is a VOD video, it is safe to rely on the media source's duration (if\n            // available). If it's not available, fall back to a playlist-calculated estimate.\n\n            if (this.mediaSource) {\n                return this.mediaSource.duration;\n            }\n            return Vhs$1.Playlist.duration(media);\n        }\n        /**\n         * check the seekable range\n         *\n         * @return {TimeRange} the seekable range\n         */\n\n        seekable() {\n            return this.seekable_;\n        }\n        onSyncInfoUpdate_() {\n            let audioSeekable; // TODO check for creation of both source buffers before updating seekable\n            //\n            // A fix was made to this function where a check for\n            // this.sourceUpdater_.hasCreatedSourceBuffers\n            // was added to ensure that both source buffers were created before seekable was\n            // updated. However, it originally had a bug where it was checking for a true and\n            // returning early instead of checking for false. Setting it to check for false to\n            // return early though created other issues. A call to play() would check for seekable\n            // end without verifying that a seekable range was present. In addition, even checking\n            // for that didn't solve some issues, as handleFirstPlay is sometimes worked around\n            // due to a media update calling load on the segment loaders, skipping a seek to live,\n            // thereby starting live streams at the beginning of the stream rather than at the end.\n            //\n            // This conditional should be fixed to wait for the creation of two source buffers at\n            // the same time as the other sections of code are fixed to properly seek to live and\n            // not throw an error due to checking for a seekable end when no seekable range exists.\n            //\n            // For now, fall back to the older behavior, with the understanding that the seekable\n            // range may not be completely correct, leading to a suboptimal initial live point.\n\n            if (!this.mainPlaylistLoader_) {\n                return;\n            }\n            let media = this.mainPlaylistLoader_.media();\n            if (!media) {\n                return;\n            }\n            let expired = this.syncController_.getExpiredTime(media, this.duration());\n            if (expired === null) {\n                // not enough information to update seekable\n                return;\n            }\n            const main = this.mainPlaylistLoader_.main;\n            const mainSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(main, media));\n            if (mainSeekable.length === 0) {\n                return;\n            }\n            if (this.mediaTypes_.AUDIO.activePlaylistLoader) {\n                media = this.mediaTypes_.AUDIO.activePlaylistLoader.media();\n                expired = this.syncController_.getExpiredTime(media, this.duration());\n                if (expired === null) {\n                    return;\n                }\n                audioSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(main, media));\n                if (audioSeekable.length === 0) {\n                    return;\n                }\n            }\n            let oldEnd;\n            let oldStart;\n            if (this.seekable_ && this.seekable_.length) {\n                oldEnd = this.seekable_.end(0);\n                oldStart = this.seekable_.start(0);\n            }\n            if (!audioSeekable) {\n                // seekable has been calculated based on buffering video data so it\n                // can be returned directly\n                this.seekable_ = mainSeekable;\n            } else if (audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0)) {\n                // seekables are pretty far off, rely on main\n                this.seekable_ = mainSeekable;\n            } else {\n                this.seekable_ = createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);\n            } // seekable is the same as last time\n\n            if (this.seekable_ && this.seekable_.length) {\n                if (this.seekable_.end(0) === oldEnd && this.seekable_.start(0) === oldStart) {\n                    return;\n                }\n            }\n            this.logger_(`seekable updated [${printableRange(this.seekable_)}]`);\n            this.tech_.trigger('seekablechanged');\n        }\n        /**\n         * Update the player duration\n         */\n\n        updateDuration(isLive) {\n            if (this.updateDuration_) {\n                this.mediaSource.removeEventListener('sourceopen', this.updateDuration_);\n                this.updateDuration_ = null;\n            }\n            if (this.mediaSource.readyState !== 'open') {\n                this.updateDuration_ = this.updateDuration.bind(this, isLive);\n                this.mediaSource.addEventListener('sourceopen', this.updateDuration_);\n                return;\n            }\n            if (isLive) {\n                const seekable = this.seekable();\n                if (!seekable.length) {\n                    return;\n                } // Even in the case of a live playlist, the native MediaSource's duration should not\n                // be set to Infinity (even though this would be expected for a live playlist), since\n                // setting the native MediaSource's duration to infinity ends up with consequences to\n                // seekable behavior. See https://github.com/w3c/media-source/issues/5 for details.\n                //\n                // This is resolved in the spec by https://github.com/w3c/media-source/pull/92,\n                // however, few browsers have support for setLiveSeekableRange()\n                // https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/setLiveSeekableRange\n                //\n                // Until a time when the duration of the media source can be set to infinity, and a\n                // seekable range specified across browsers, the duration should be greater than or\n                // equal to the last possible seekable value.\n                // MediaSource duration starts as NaN\n                // It is possible (and probable) that this case will never be reached for many\n                // sources, since the MediaSource reports duration as the highest value without\n                // accounting for timestamp offset. For example, if the timestamp offset is -100 and\n                // we buffered times 0 to 100 with real times of 100 to 200, even though current\n                // time will be between 0 and 100, the native media source may report the duration\n                // as 200. However, since we report duration separate from the media source (as\n                // Infinity), and as long as the native media source duration value is greater than\n                // our reported seekable range, seeks will work as expected. The large number as\n                // duration for live is actually a strategy used by some players to work around the\n                // issue of live seekable ranges cited above.\n\n                if (isNaN(this.mediaSource.duration) || this.mediaSource.duration < seekable.end(seekable.length - 1)) {\n                    this.sourceUpdater_.setDuration(seekable.end(seekable.length - 1));\n                }\n                return;\n            }\n            const buffered = this.tech_.buffered();\n            let duration = Vhs$1.Playlist.duration(this.mainPlaylistLoader_.media());\n            if (buffered.length > 0) {\n                duration = Math.max(duration, buffered.end(buffered.length - 1));\n            }\n            if (this.mediaSource.duration !== duration) {\n                this.sourceUpdater_.setDuration(duration);\n            }\n        }\n        /**\n         * dispose of the PlaylistController and everything\n         * that it controls\n         */\n\n        dispose() {\n            this.trigger('dispose');\n            this.decrypter_.terminate();\n            this.mainPlaylistLoader_.dispose();\n            this.mainSegmentLoader_.dispose();\n            if (this.loadOnPlay_) {\n                this.tech_.off('play', this.loadOnPlay_);\n            }\n            ['AUDIO', 'SUBTITLES'].forEach(type => {\n                const groups = this.mediaTypes_[type].groups;\n                for (const id in groups) {\n                    groups[id].forEach(group => {\n                        if (group.playlistLoader) {\n                            group.playlistLoader.dispose();\n                        }\n                    });\n                }\n            });\n            this.audioSegmentLoader_.dispose();\n            this.subtitleSegmentLoader_.dispose();\n            this.sourceUpdater_.dispose();\n            this.timelineChangeController_.dispose();\n            this.stopABRTimer_();\n            if (this.updateDuration_) {\n                this.mediaSource.removeEventListener('sourceopen', this.updateDuration_);\n            }\n            this.mediaSource.removeEventListener('durationchange', this.handleDurationChange_); // load the media source into the player\n\n            this.mediaSource.removeEventListener('sourceopen', this.handleSourceOpen_);\n            this.mediaSource.removeEventListener('sourceended', this.handleSourceEnded_);\n            this.off();\n        }\n        /**\n         * return the main playlist object if we have one\n         *\n         * @return {Object} the main playlist object that we parsed\n         */\n\n        main() {\n            return this.mainPlaylistLoader_.main;\n        }\n        /**\n         * return the currently selected playlist\n         *\n         * @return {Object} the currently selected playlist object that we parsed\n         */\n\n        media() {\n            // playlist loader will not return media if it has not been fully loaded\n            return this.mainPlaylistLoader_.media() || this.initialMedia_;\n        }\n        areMediaTypesKnown_() {\n            const usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;\n            const hasMainMediaInfo = !!this.mainSegmentLoader_.getCurrentMediaInfo_(); // if we are not using an audio loader, then we have audio media info\n            // otherwise check on the segment loader.\n\n            const hasAudioMediaInfo = !usingAudioLoader ? true : !!this.audioSegmentLoader_.getCurrentMediaInfo_(); // one or both loaders has not loaded sufficently to get codecs\n\n            if (!hasMainMediaInfo || !hasAudioMediaInfo) {\n                return false;\n            }\n            return true;\n        }\n        getCodecsOrExclude_() {\n            const media = {\n                main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},\n                audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}\n            };\n            const playlist = this.mainSegmentLoader_.getPendingSegmentPlaylist() || this.media(); // set \"main\" media equal to video\n\n            media.video = media.main;\n            const playlistCodecs = codecsForPlaylist(this.main(), playlist);\n            const codecs = {};\n            const usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;\n            if (media.main.hasVideo) {\n                codecs.video = playlistCodecs.video || media.main.videoCodec || DEFAULT_VIDEO_CODEC;\n            }\n            if (media.main.isMuxed) {\n                codecs.video += `,${playlistCodecs.audio || media.main.audioCodec || DEFAULT_AUDIO_CODEC}`;\n            }\n            if (media.main.hasAudio && !media.main.isMuxed || media.audio.hasAudio || usingAudioLoader) {\n                codecs.audio = playlistCodecs.audio || media.main.audioCodec || media.audio.audioCodec || DEFAULT_AUDIO_CODEC; // set audio isFmp4 so we use the correct \"supports\" function below\n\n                media.audio.isFmp4 = media.main.hasAudio && !media.main.isMuxed ? media.main.isFmp4 : media.audio.isFmp4;\n            } // no codecs, no playback.\n\n            if (!codecs.audio && !codecs.video) {\n                this.excludePlaylist({\n                    playlistToExclude: playlist,\n                    error: {\n                        message: 'Could not determine codecs for playlist.'\n                    },\n                    playlistExclusionDuration: Infinity\n                });\n                return;\n            } // fmp4 relies on browser support, while ts relies on muxer support\n\n            const supportFunction = (isFmp4, codec) => isFmp4 ? browserSupportsCodec(codec) : muxerSupportsCodec(codec);\n            const unsupportedCodecs = {};\n            let unsupportedAudio;\n            ['video', 'audio'].forEach(function (type) {\n                if (codecs.hasOwnProperty(type) && !supportFunction(media[type].isFmp4, codecs[type])) {\n                    const supporter = media[type].isFmp4 ? 'browser' : 'muxer';\n                    unsupportedCodecs[supporter] = unsupportedCodecs[supporter] || [];\n                    unsupportedCodecs[supporter].push(codecs[type]);\n                    if (type === 'audio') {\n                        unsupportedAudio = supporter;\n                    }\n                }\n            });\n            if (usingAudioLoader && unsupportedAudio && playlist.attributes.AUDIO) {\n                const audioGroup = playlist.attributes.AUDIO;\n                this.main().playlists.forEach(variant => {\n                    const variantAudioGroup = variant.attributes && variant.attributes.AUDIO;\n                    if (variantAudioGroup === audioGroup && variant !== playlist) {\n                        variant.excludeUntil = Infinity;\n                    }\n                });\n                this.logger_(`excluding audio group ${audioGroup} as ${unsupportedAudio} does not support codec(s): \"${codecs.audio}\"`);\n            } // if we have any unsupported codecs exclude this playlist.\n\n            if (Object.keys(unsupportedCodecs).length) {\n                const message = Object.keys(unsupportedCodecs).reduce((acc, supporter) => {\n                    if (acc) {\n                        acc += ', ';\n                    }\n                    acc += `${supporter} does not support codec(s): \"${unsupportedCodecs[supporter].join(',')}\"`;\n                    return acc;\n                }, '') + '.';\n                this.excludePlaylist({\n                    playlistToExclude: playlist,\n                    error: {\n                        internal: true,\n                        message\n                    },\n                    playlistExclusionDuration: Infinity\n                });\n                return;\n            } // check if codec switching is happening\n\n            if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {\n                const switchMessages = [];\n                ['video', 'audio'].forEach(type => {\n                    const newCodec = (parseCodecs(this.sourceUpdater_.codecs[type] || '')[0] || {}).type;\n                    const oldCodec = (parseCodecs(codecs[type] || '')[0] || {}).type;\n                    if (newCodec && oldCodec && newCodec.toLowerCase() !== oldCodec.toLowerCase()) {\n                        switchMessages.push(`\"${this.sourceUpdater_.codecs[type]}\" -> \"${codecs[type]}\"`);\n                    }\n                });\n                if (switchMessages.length) {\n                    this.excludePlaylist({\n                        playlistToExclude: playlist,\n                        error: {\n                            message: `Codec switching not supported: ${switchMessages.join(', ')}.`,\n                            internal: true\n                        },\n                        playlistExclusionDuration: Infinity\n                    });\n                    return;\n                }\n            } // TODO: when using the muxer shouldn't we just return\n            // the codecs that the muxer outputs?\n\n            return codecs;\n        }\n        /**\n         * Create source buffers and exlude any incompatible renditions.\n         *\n         * @private\n         */\n\n        tryToCreateSourceBuffers_() {\n            // media source is not ready yet or sourceBuffers are already\n            // created.\n            if (this.mediaSource.readyState !== 'open' || this.sourceUpdater_.hasCreatedSourceBuffers()) {\n                return;\n            }\n            if (!this.areMediaTypesKnown_()) {\n                return;\n            }\n            const codecs = this.getCodecsOrExclude_(); // no codecs means that the playlist was excluded\n\n            if (!codecs) {\n                return;\n            }\n            this.sourceUpdater_.createSourceBuffers(codecs);\n            const codecString = [codecs.video, codecs.audio].filter(Boolean).join(',');\n            this.excludeIncompatibleVariants_(codecString);\n        }\n        /**\n         * Excludes playlists with codecs that are unsupported by the muxer and browser.\n         */\n\n        excludeUnsupportedVariants_() {\n            const playlists = this.main().playlists;\n            const ids = []; // TODO: why don't we have a property to loop through all\n            // playlist? Why did we ever mix indexes and keys?\n\n            Object.keys(playlists).forEach(key => {\n                const variant = playlists[key]; // check if we already processed this playlist.\n\n                if (ids.indexOf(variant.id) !== -1) {\n                    return;\n                }\n                ids.push(variant.id);\n                const codecs = codecsForPlaylist(this.main, variant);\n                const unsupported = [];\n                if (codecs.audio && !muxerSupportsCodec(codecs.audio) && !browserSupportsCodec(codecs.audio)) {\n                    unsupported.push(`audio codec ${codecs.audio}`);\n                }\n                if (codecs.video && !muxerSupportsCodec(codecs.video) && !browserSupportsCodec(codecs.video)) {\n                    unsupported.push(`video codec ${codecs.video}`);\n                }\n                if (codecs.text && codecs.text === 'stpp.ttml.im1t') {\n                    unsupported.push(`text codec ${codecs.text}`);\n                }\n                if (unsupported.length) {\n                    variant.excludeUntil = Infinity;\n                    this.logger_(`excluding ${variant.id} for unsupported: ${unsupported.join(', ')}`);\n                }\n            });\n        }\n        /**\n         * Exclude playlists that are known to be codec or\n         * stream-incompatible with the SourceBuffer configuration. For\n         * instance, Media Source Extensions would cause the video element to\n         * stall waiting for video data if you switched from a variant with\n         * video and audio to an audio-only one.\n         *\n         * @param {Object} media a media playlist compatible with the current\n         * set of SourceBuffers. Variants in the current main playlist that\n         * do not appear to have compatible codec or stream configurations\n         * will be excluded from the default playlist selection algorithm\n         * indefinitely.\n         * @private\n         */\n\n        excludeIncompatibleVariants_(codecString) {\n            const ids = [];\n            const playlists = this.main().playlists;\n            const codecs = unwrapCodecList(parseCodecs(codecString));\n            const codecCount_ = codecCount(codecs);\n            const videoDetails = codecs.video && parseCodecs(codecs.video)[0] || null;\n            const audioDetails = codecs.audio && parseCodecs(codecs.audio)[0] || null;\n            Object.keys(playlists).forEach(key => {\n                const variant = playlists[key]; // check if we already processed this playlist.\n                // or it if it is already excluded forever.\n\n                if (ids.indexOf(variant.id) !== -1 || variant.excludeUntil === Infinity) {\n                    return;\n                }\n                ids.push(variant.id);\n                const exclusionReasons = []; // get codecs from the playlist for this variant\n\n                const variantCodecs = codecsForPlaylist(this.mainPlaylistLoader_.main, variant);\n                const variantCodecCount = codecCount(variantCodecs); // if no codecs are listed, we cannot determine that this\n                // variant is incompatible. Wait for mux.js to probe\n\n                if (!variantCodecs.audio && !variantCodecs.video) {\n                    return;\n                } // TODO: we can support this by removing the\n                // old media source and creating a new one, but it will take some work.\n                // The number of streams cannot change\n\n                if (variantCodecCount !== codecCount_) {\n                    exclusionReasons.push(`codec count \"${variantCodecCount}\" !== \"${codecCount_}\"`);\n                } // only exclude playlists by codec change, if codecs cannot switch\n                // during playback.\n\n                if (!this.sourceUpdater_.canChangeType()) {\n                    const variantVideoDetails = variantCodecs.video && parseCodecs(variantCodecs.video)[0] || null;\n                    const variantAudioDetails = variantCodecs.audio && parseCodecs(variantCodecs.audio)[0] || null; // the video codec cannot change\n\n                    if (variantVideoDetails && videoDetails && variantVideoDetails.type.toLowerCase() !== videoDetails.type.toLowerCase()) {\n                        exclusionReasons.push(`video codec \"${variantVideoDetails.type}\" !== \"${videoDetails.type}\"`);\n                    } // the audio codec cannot change\n\n                    if (variantAudioDetails && audioDetails && variantAudioDetails.type.toLowerCase() !== audioDetails.type.toLowerCase()) {\n                        exclusionReasons.push(`audio codec \"${variantAudioDetails.type}\" !== \"${audioDetails.type}\"`);\n                    }\n                }\n                if (exclusionReasons.length) {\n                    variant.excludeUntil = Infinity;\n                    this.logger_(`excluding ${variant.id}: ${exclusionReasons.join(' && ')}`);\n                }\n            });\n        }\n        updateAdCues_(media) {\n            let offset = 0;\n            const seekable = this.seekable();\n            if (seekable.length) {\n                offset = seekable.start(0);\n            }\n            updateAdCues(media, this.cueTagsTrack_, offset);\n        }\n        /**\n         * Calculates the desired forward buffer length based on current time\n         *\n         * @return {number} Desired forward buffer length in seconds\n         */\n\n        goalBufferLength() {\n            const currentTime = this.tech_.currentTime();\n            const initial = Config.GOAL_BUFFER_LENGTH;\n            const rate = Config.GOAL_BUFFER_LENGTH_RATE;\n            const max = Math.max(initial, Config.MAX_GOAL_BUFFER_LENGTH);\n            return Math.min(initial + currentTime * rate, max);\n        }\n        /**\n         * Calculates the desired buffer low water line based on current time\n         *\n         * @return {number} Desired buffer low water line in seconds\n         */\n\n        bufferLowWaterLine() {\n            const currentTime = this.tech_.currentTime();\n            const initial = Config.BUFFER_LOW_WATER_LINE;\n            const rate = Config.BUFFER_LOW_WATER_LINE_RATE;\n            const max = Math.max(initial, Config.MAX_BUFFER_LOW_WATER_LINE);\n            const newMax = Math.max(initial, Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);\n            return Math.min(initial + currentTime * rate, this.bufferBasedABR ? newMax : max);\n        }\n        bufferHighWaterLine() {\n            return Config.BUFFER_HIGH_WATER_LINE;\n        }\n    }\n\n    /**\n     * Returns a function that acts as the Enable/disable playlist function.\n     *\n     * @param {PlaylistLoader} loader - The main playlist loader\n     * @param {string} playlistID - id of the playlist\n     * @param {Function} changePlaylistFn - A function to be called after a\n     * playlist's enabled-state has been changed. Will NOT be called if a\n     * playlist's enabled-state is unchanged\n     * @param {boolean=} enable - Value to set the playlist enabled-state to\n     * or if undefined returns the current enabled-state for the playlist\n     * @return {Function} Function for setting/getting enabled\n     */\n\n    const enableFunction = (loader, playlistID, changePlaylistFn) => enable => {\n        const playlist = loader.main.playlists[playlistID];\n        const incompatible = isIncompatible(playlist);\n        const currentlyEnabled = isEnabled(playlist);\n        if (typeof enable === 'undefined') {\n            return currentlyEnabled;\n        }\n        if (enable) {\n            delete playlist.disabled;\n        } else {\n            playlist.disabled = true;\n        }\n        if (enable !== currentlyEnabled && !incompatible) {\n            // Ensure the outside world knows about our changes\n            changePlaylistFn();\n            if (enable) {\n                loader.trigger('renditionenabled');\n            } else {\n                loader.trigger('renditiondisabled');\n            }\n        }\n        return enable;\n    };\n    /**\n     * The representation object encapsulates the publicly visible information\n     * in a media playlist along with a setter/getter-type function (enabled)\n     * for changing the enabled-state of a particular playlist entry\n     *\n     * @class Representation\n     */\n\n    class Representation {\n        constructor(vhsHandler, playlist, id) {\n            const {\n                playlistController_: pc\n            } = vhsHandler;\n            const qualityChangeFunction = pc.fastQualityChange_.bind(pc); // some playlist attributes are optional\n\n            if (playlist.attributes) {\n                const resolution = playlist.attributes.RESOLUTION;\n                this.width = resolution && resolution.width;\n                this.height = resolution && resolution.height;\n                this.bandwidth = playlist.attributes.BANDWIDTH;\n                this.frameRate = playlist.attributes['FRAME-RATE'];\n            }\n            this.codecs = codecsForPlaylist(pc.main(), playlist);\n            this.playlist = playlist; // The id is simply the ordinality of the media playlist\n            // within the main playlist\n\n            this.id = id; // Partially-apply the enableFunction to create a playlist-\n            // specific variant\n\n            this.enabled = enableFunction(vhsHandler.playlists, playlist.id, qualityChangeFunction);\n        }\n    }\n    /**\n     * A mixin function that adds the `representations` api to an instance\n     * of the VhsHandler class\n     *\n     * @param {VhsHandler} vhsHandler - An instance of VhsHandler to add the\n     * representation API into\n     */\n\n    const renditionSelectionMixin = function (vhsHandler) {\n        // Add a single API-specific function to the VhsHandler instance\n        vhsHandler.representations = () => {\n            const main = vhsHandler.playlistController_.main();\n            const playlists = isAudioOnly(main) ? vhsHandler.playlistController_.getAudioTrackPlaylists_() : main.playlists;\n            if (!playlists) {\n                return [];\n            }\n            return playlists.filter(media => !isIncompatible(media)).map((e, i) => new Representation(vhsHandler, e, e.id));\n        };\n    };\n\n    /**\n     * @file playback-watcher.js\n     *\n     * Playback starts, and now my watch begins. It shall not end until my death. I shall\n     * take no wait, hold no uncleared timeouts, father no bad seeks. I shall wear no crowns\n     * and win no glory. I shall live and die at my post. I am the corrector of the underflow.\n     * I am the watcher of gaps. I am the shield that guards the realms of seekable. I pledge\n     * my life and honor to the Playback Watch, for this Player and all the Players to come.\n     */\n\n    const timerCancelEvents = ['seeking', 'seeked', 'pause', 'playing', 'error'];\n    /**\n     * @class PlaybackWatcher\n     */\n\n    class PlaybackWatcher {\n        /**\n         * Represents an PlaybackWatcher object.\n         *\n         * @class\n         * @param {Object} options an object that includes the tech and settings\n         */\n        constructor(options) {\n            this.playlistController_ = options.playlistController;\n            this.tech_ = options.tech;\n            this.seekable = options.seekable;\n            this.allowSeeksWithinUnsafeLiveWindow = options.allowSeeksWithinUnsafeLiveWindow;\n            this.liveRangeSafeTimeDelta = options.liveRangeSafeTimeDelta;\n            this.media = options.media;\n            this.consecutiveUpdates = 0;\n            this.lastRecordedTime = null;\n            this.checkCurrentTimeTimeout_ = null;\n            this.logger_ = logger('PlaybackWatcher');\n            this.logger_('initialize');\n            const playHandler = () => this.monitorCurrentTime_();\n            const canPlayHandler = () => this.monitorCurrentTime_();\n            const waitingHandler = () => this.techWaiting_();\n            const cancelTimerHandler = () => this.resetTimeUpdate_();\n            const pc = this.playlistController_;\n            const loaderTypes = ['main', 'subtitle', 'audio'];\n            const loaderChecks = {};\n            loaderTypes.forEach(type => {\n                loaderChecks[type] = {\n                    reset: () => this.resetSegmentDownloads_(type),\n                    updateend: () => this.checkSegmentDownloads_(type)\n                };\n                pc[`${type}SegmentLoader_`].on('appendsdone', loaderChecks[type].updateend); // If a rendition switch happens during a playback stall where the buffer\n                // isn't changing we want to reset. We cannot assume that the new rendition\n                // will also be stalled, until after new appends.\n\n                pc[`${type}SegmentLoader_`].on('playlistupdate', loaderChecks[type].reset); // Playback stalls should not be detected right after seeking.\n                // This prevents one segment playlists (single vtt or single segment content)\n                // from being detected as stalling. As the buffer will not change in those cases, since\n                // the buffer is the entire video duration.\n\n                this.tech_.on(['seeked', 'seeking'], loaderChecks[type].reset);\n            });\n            /**\n             * We check if a seek was into a gap through the following steps:\n             * 1. We get a seeking event and we do not get a seeked event. This means that\n             *    a seek was attempted but not completed.\n             * 2. We run `fixesBadSeeks_` on segment loader appends. This means that we already\n             *    removed everything from our buffer and appended a segment, and should be ready\n             *    to check for gaps.\n             */\n\n            const setSeekingHandlers = fn => {\n                ['main', 'audio'].forEach(type => {\n                    pc[`${type}SegmentLoader_`][fn]('appended', this.seekingAppendCheck_);\n                });\n            };\n            this.seekingAppendCheck_ = () => {\n                if (this.fixesBadSeeks_()) {\n                    this.consecutiveUpdates = 0;\n                    this.lastRecordedTime = this.tech_.currentTime();\n                    setSeekingHandlers('off');\n                }\n            };\n            this.clearSeekingAppendCheck_ = () => setSeekingHandlers('off');\n            this.watchForBadSeeking_ = () => {\n                this.clearSeekingAppendCheck_();\n                setSeekingHandlers('on');\n            };\n            this.tech_.on('seeked', this.clearSeekingAppendCheck_);\n            this.tech_.on('seeking', this.watchForBadSeeking_);\n            this.tech_.on('waiting', waitingHandler);\n            this.tech_.on(timerCancelEvents, cancelTimerHandler);\n            this.tech_.on('canplay', canPlayHandler);\n            /*\n        An edge case exists that results in gaps not being skipped when they exist at the beginning of a stream. This case\n        is surfaced in one of two ways:\n         1)  The `waiting` event is fired before the player has buffered content, making it impossible\n            to find or skip the gap. The `waiting` event is followed by a `play` event. On first play\n            we can check if playback is stalled due to a gap, and skip the gap if necessary.\n        2)  A source with a gap at the beginning of the stream is loaded programatically while the player\n            is in a playing state. To catch this case, it's important that our one-time play listener is setup\n            even if the player is in a playing state\n      */\n\n            this.tech_.one('play', playHandler); // Define the dispose function to clean up our events\n\n            this.dispose = () => {\n                this.clearSeekingAppendCheck_();\n                this.logger_('dispose');\n                this.tech_.off('waiting', waitingHandler);\n                this.tech_.off(timerCancelEvents, cancelTimerHandler);\n                this.tech_.off('canplay', canPlayHandler);\n                this.tech_.off('play', playHandler);\n                this.tech_.off('seeking', this.watchForBadSeeking_);\n                this.tech_.off('seeked', this.clearSeekingAppendCheck_);\n                loaderTypes.forEach(type => {\n                    pc[`${type}SegmentLoader_`].off('appendsdone', loaderChecks[type].updateend);\n                    pc[`${type}SegmentLoader_`].off('playlistupdate', loaderChecks[type].reset);\n                    this.tech_.off(['seeked', 'seeking'], loaderChecks[type].reset);\n                });\n                if (this.checkCurrentTimeTimeout_) {\n                    window.clearTimeout(this.checkCurrentTimeTimeout_);\n                }\n                this.resetTimeUpdate_();\n            };\n        }\n        /**\n         * Periodically check current time to see if playback stopped\n         *\n         * @private\n         */\n\n        monitorCurrentTime_() {\n            this.checkCurrentTime_();\n            if (this.checkCurrentTimeTimeout_) {\n                window.clearTimeout(this.checkCurrentTimeTimeout_);\n            } // 42 = 24 fps // 250 is what Webkit uses // FF uses 15\n\n            this.checkCurrentTimeTimeout_ = window.setTimeout(this.monitorCurrentTime_.bind(this), 250);\n        }\n        /**\n         * Reset stalled download stats for a specific type of loader\n         *\n         * @param {string} type\n         *        The segment loader type to check.\n         *\n         * @listens SegmentLoader#playlistupdate\n         * @listens Tech#seeking\n         * @listens Tech#seeked\n         */\n\n        resetSegmentDownloads_(type) {\n            const loader = this.playlistController_[`${type}SegmentLoader_`];\n            if (this[`${type}StalledDownloads_`] > 0) {\n                this.logger_(`resetting possible stalled download count for ${type} loader`);\n            }\n            this[`${type}StalledDownloads_`] = 0;\n            this[`${type}Buffered_`] = loader.buffered_();\n        }\n        /**\n         * Checks on every segment `appendsdone` to see\n         * if segment appends are making progress. If they are not\n         * and we are still downloading bytes. We exclude the playlist.\n         *\n         * @param {string} type\n         *        The segment loader type to check.\n         *\n         * @listens SegmentLoader#appendsdone\n         */\n\n        checkSegmentDownloads_(type) {\n            const pc = this.playlistController_;\n            const loader = pc[`${type}SegmentLoader_`];\n            const buffered = loader.buffered_();\n            const isBufferedDifferent = isRangeDifferent(this[`${type}Buffered_`], buffered);\n            this[`${type}Buffered_`] = buffered; // if another watcher is going to fix the issue or\n            // the buffered value for this loader changed\n            // appends are working\n\n            if (isBufferedDifferent) {\n                this.resetSegmentDownloads_(type);\n                return;\n            }\n            this[`${type}StalledDownloads_`]++;\n            this.logger_(`found #${this[`${type}StalledDownloads_`]} ${type} appends that did not increase buffer (possible stalled download)`, {\n                playlistId: loader.playlist_ && loader.playlist_.id,\n                buffered: timeRangesToArray(buffered)\n            }); // after 10 possibly stalled appends with no reset, exclude\n\n            if (this[`${type}StalledDownloads_`] < 10) {\n                return;\n            }\n            this.logger_(`${type} loader stalled download exclusion`);\n            this.resetSegmentDownloads_(type);\n            this.tech_.trigger({\n                type: 'usage',\n                name: `vhs-${type}-download-exclusion`\n            });\n            if (type === 'subtitle') {\n                return;\n            } // TODO: should we exclude audio tracks rather than main tracks\n            // when type is audio?\n\n            pc.excludePlaylist({\n                error: {\n                    message: `Excessive ${type} segment downloading detected.`\n                },\n                playlistExclusionDuration: Infinity\n            });\n        }\n        /**\n         * The purpose of this function is to emulate the \"waiting\" event on\n         * browsers that do not emit it when they are waiting for more\n         * data to continue playback\n         *\n         * @private\n         */\n\n        checkCurrentTime_() {\n            if (this.tech_.paused() || this.tech_.seeking()) {\n                return;\n            }\n            const currentTime = this.tech_.currentTime();\n            const buffered = this.tech_.buffered();\n            if (this.lastRecordedTime === currentTime && (!buffered.length || currentTime + SAFE_TIME_DELTA >= buffered.end(buffered.length - 1))) {\n                // If current time is at the end of the final buffered region, then any playback\n                // stall is most likely caused by buffering in a low bandwidth environment. The tech\n                // should fire a `waiting` event in this scenario, but due to browser and tech\n                // inconsistencies. Calling `techWaiting_` here allows us to simulate\n                // responding to a native `waiting` event when the tech fails to emit one.\n                return this.techWaiting_();\n            }\n            if (this.consecutiveUpdates >= 5 && currentTime === this.lastRecordedTime) {\n                this.consecutiveUpdates++;\n                this.waiting_();\n            } else if (currentTime === this.lastRecordedTime) {\n                this.consecutiveUpdates++;\n            } else {\n                this.consecutiveUpdates = 0;\n                this.lastRecordedTime = currentTime;\n            }\n        }\n        /**\n         * Resets the 'timeupdate' mechanism designed to detect that we are stalled\n         *\n         * @private\n         */\n\n        resetTimeUpdate_() {\n            this.consecutiveUpdates = 0;\n        }\n        /**\n         * Fixes situations where there's a bad seek\n         *\n         * @return {boolean} whether an action was taken to fix the seek\n         * @private\n         */\n\n        fixesBadSeeks_() {\n            const seeking = this.tech_.seeking();\n            if (!seeking) {\n                return false;\n            } // TODO: It's possible that these seekable checks should be moved out of this function\n            // and into a function that runs on seekablechange. It's also possible that we only need\n            // afterSeekableWindow as the buffered check at the bottom is good enough to handle before\n            // seekable range.\n\n            const seekable = this.seekable();\n            const currentTime = this.tech_.currentTime();\n            const isAfterSeekableRange = this.afterSeekableWindow_(seekable, currentTime, this.media(), this.allowSeeksWithinUnsafeLiveWindow);\n            let seekTo;\n            if (isAfterSeekableRange) {\n                const seekableEnd = seekable.end(seekable.length - 1); // sync to live point (if VOD, our seekable was updated and we're simply adjusting)\n\n                seekTo = seekableEnd;\n            }\n            if (this.beforeSeekableWindow_(seekable, currentTime)) {\n                const seekableStart = seekable.start(0); // sync to the beginning of the live window\n                // provide a buffer of .1 seconds to handle rounding/imprecise numbers\n\n                seekTo = seekableStart + (\n                    // if the playlist is too short and the seekable range is an exact time (can\n                    // happen in live with a 3 segment playlist), then don't use a time delta\n                    seekableStart === seekable.end(0) ? 0 : SAFE_TIME_DELTA);\n            }\n            if (typeof seekTo !== 'undefined') {\n                this.logger_(`Trying to seek outside of seekable at time ${currentTime} with ` + `seekable range ${printableRange(seekable)}. Seeking to ` + `${seekTo}.`);\n                this.tech_.setCurrentTime(seekTo);\n                return true;\n            }\n            const sourceUpdater = this.playlistController_.sourceUpdater_;\n            const buffered = this.tech_.buffered();\n            const audioBuffered = sourceUpdater.audioBuffer ? sourceUpdater.audioBuffered() : null;\n            const videoBuffered = sourceUpdater.videoBuffer ? sourceUpdater.videoBuffered() : null;\n            const media = this.media(); // verify that at least two segment durations or one part duration have been\n            // appended before checking for a gap.\n\n            const minAppendedDuration = media.partTargetDuration ? media.partTargetDuration : (media.targetDuration - TIME_FUDGE_FACTOR) * 2; // verify that at least two segment durations have been\n            // appended before checking for a gap.\n\n            const bufferedToCheck = [audioBuffered, videoBuffered];\n            for (let i = 0; i < bufferedToCheck.length; i++) {\n                // skip null buffered\n                if (!bufferedToCheck[i]) {\n                    continue;\n                }\n                const timeAhead = timeAheadOf(bufferedToCheck[i], currentTime); // if we are less than two video/audio segment durations or one part\n                // duration behind we haven't appended enough to call this a bad seek.\n\n                if (timeAhead < minAppendedDuration) {\n                    return false;\n                }\n            }\n            const nextRange = findNextRange(buffered, currentTime); // we have appended enough content, but we don't have anything buffered\n            // to seek over the gap\n\n            if (nextRange.length === 0) {\n                return false;\n            }\n            seekTo = nextRange.start(0) + SAFE_TIME_DELTA;\n            this.logger_(`Buffered region starts (${nextRange.start(0)}) ` + ` just beyond seek point (${currentTime}). Seeking to ${seekTo}.`);\n            this.tech_.setCurrentTime(seekTo);\n            return true;\n        }\n        /**\n         * Handler for situations when we determine the player is waiting.\n         *\n         * @private\n         */\n\n        waiting_() {\n            if (this.techWaiting_()) {\n                return;\n            } // All tech waiting checks failed. Use last resort correction\n\n            const currentTime = this.tech_.currentTime();\n            const buffered = this.tech_.buffered();\n            const currentRange = findRange(buffered, currentTime); // Sometimes the player can stall for unknown reasons within a contiguous buffered\n            // region with no indication that anything is amiss (seen in Firefox). Seeking to\n            // currentTime is usually enough to kickstart the player. This checks that the player\n            // is currently within a buffered region before attempting a corrective seek.\n            // Chrome does not appear to continue `timeupdate` events after a `waiting` event\n            // until there is ~ 3 seconds of forward buffer available. PlaybackWatcher should also\n            // make sure there is ~3 seconds of forward buffer before taking any corrective action\n            // to avoid triggering an `unknownwaiting` event when the network is slow.\n\n            if (currentRange.length && currentTime + 3 <= currentRange.end(0)) {\n                this.resetTimeUpdate_();\n                this.tech_.setCurrentTime(currentTime);\n                this.logger_(`Stopped at ${currentTime} while inside a buffered region ` + `[${currentRange.start(0)} -> ${currentRange.end(0)}]. Attempting to resume ` + 'playback by seeking to the current time.'); // unknown waiting corrections may be useful for monitoring QoS\n\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-unknown-waiting'\n                });\n                return;\n            }\n        }\n        /**\n         * Handler for situations when the tech fires a `waiting` event\n         *\n         * @return {boolean}\n         *         True if an action (or none) was needed to correct the waiting. False if no\n         *         checks passed\n         * @private\n         */\n\n        techWaiting_() {\n            const seekable = this.seekable();\n            const currentTime = this.tech_.currentTime();\n            if (this.tech_.seeking()) {\n                // Tech is seeking or already waiting on another action, no action needed\n                return true;\n            }\n            if (this.beforeSeekableWindow_(seekable, currentTime)) {\n                const livePoint = seekable.end(seekable.length - 1);\n                this.logger_(`Fell out of live window at time ${currentTime}. Seeking to ` + `live point (seekable end) ${livePoint}`);\n                this.resetTimeUpdate_();\n                this.tech_.setCurrentTime(livePoint); // live window resyncs may be useful for monitoring QoS\n\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-live-resync'\n                });\n                return true;\n            }\n            const sourceUpdater = this.tech_.vhs.playlistController_.sourceUpdater_;\n            const buffered = this.tech_.buffered();\n            const videoUnderflow = this.videoUnderflow_({\n                audioBuffered: sourceUpdater.audioBuffered(),\n                videoBuffered: sourceUpdater.videoBuffered(),\n                currentTime\n            });\n            if (videoUnderflow) {\n                // Even though the video underflowed and was stuck in a gap, the audio overplayed\n                // the gap, leading currentTime into a buffered range. Seeking to currentTime\n                // allows the video to catch up to the audio position without losing any audio\n                // (only suffering ~3 seconds of frozen video and a pause in audio playback).\n                this.resetTimeUpdate_();\n                this.tech_.setCurrentTime(currentTime); // video underflow may be useful for monitoring QoS\n\n                this.tech_.trigger({\n                    type: 'usage',\n                    name: 'vhs-video-underflow'\n                });\n                return true;\n            }\n            const nextRange = findNextRange(buffered, currentTime); // check for gap\n\n            if (nextRange.length > 0) {\n                this.logger_(`Stopped at ${currentTime} and seeking to ${nextRange.start(0)}`);\n                this.resetTimeUpdate_();\n                this.skipTheGap_(currentTime);\n                return true;\n            } // All checks failed. Returning false to indicate failure to correct waiting\n\n            return false;\n        }\n        afterSeekableWindow_(seekable, currentTime, playlist, allowSeeksWithinUnsafeLiveWindow = false) {\n            if (!seekable.length) {\n                // we can't make a solid case if there's no seekable, default to false\n                return false;\n            }\n            let allowedEnd = seekable.end(seekable.length - 1) + SAFE_TIME_DELTA;\n            const isLive = !playlist.endList;\n            if (isLive && allowSeeksWithinUnsafeLiveWindow) {\n                allowedEnd = seekable.end(seekable.length - 1) + playlist.targetDuration * 3;\n            }\n            if (currentTime > allowedEnd) {\n                return true;\n            }\n            return false;\n        }\n        beforeSeekableWindow_(seekable, currentTime) {\n            if (seekable.length &&\n                // can't fall before 0 and 0 seekable start identifies VOD stream\n                seekable.start(0) > 0 && currentTime < seekable.start(0) - this.liveRangeSafeTimeDelta) {\n                return true;\n            }\n            return false;\n        }\n        videoUnderflow_({\n                            videoBuffered,\n                            audioBuffered,\n                            currentTime\n                        }) {\n            // audio only content will not have video underflow :)\n            if (!videoBuffered) {\n                return;\n            }\n            let gap; // find a gap in demuxed content.\n\n            if (videoBuffered.length && audioBuffered.length) {\n                // in Chrome audio will continue to play for ~3s when we run out of video\n                // so we have to check that the video buffer did have some buffer in the\n                // past.\n                const lastVideoRange = findRange(videoBuffered, currentTime - 3);\n                const videoRange = findRange(videoBuffered, currentTime);\n                const audioRange = findRange(audioBuffered, currentTime);\n                if (audioRange.length && !videoRange.length && lastVideoRange.length) {\n                    gap = {\n                        start: lastVideoRange.end(0),\n                        end: audioRange.end(0)\n                    };\n                } // find a gap in muxed content.\n            } else {\n                const nextRange = findNextRange(videoBuffered, currentTime); // Even if there is no available next range, there is still a possibility we are\n                // stuck in a gap due to video underflow.\n\n                if (!nextRange.length) {\n                    gap = this.gapFromVideoUnderflow_(videoBuffered, currentTime);\n                }\n            }\n            if (gap) {\n                this.logger_(`Encountered a gap in video from ${gap.start} to ${gap.end}. ` + `Seeking to current time ${currentTime}`);\n                return true;\n            }\n            return false;\n        }\n        /**\n         * Timer callback. If playback still has not proceeded, then we seek\n         * to the start of the next buffered region.\n         *\n         * @private\n         */\n\n        skipTheGap_(scheduledCurrentTime) {\n            const buffered = this.tech_.buffered();\n            const currentTime = this.tech_.currentTime();\n            const nextRange = findNextRange(buffered, currentTime);\n            this.resetTimeUpdate_();\n            if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) {\n                return;\n            }\n            this.logger_('skipTheGap_:', 'currentTime:', currentTime, 'scheduled currentTime:', scheduledCurrentTime, 'nextRange start:', nextRange.start(0)); // only seek if we still have not played\n\n            this.tech_.setCurrentTime(nextRange.start(0) + TIME_FUDGE_FACTOR);\n            this.tech_.trigger({\n                type: 'usage',\n                name: 'vhs-gap-skip'\n            });\n        }\n        gapFromVideoUnderflow_(buffered, currentTime) {\n            // At least in Chrome, if there is a gap in the video buffer, the audio will continue\n            // playing for ~3 seconds after the video gap starts. This is done to account for\n            // video buffer underflow/underrun (note that this is not done when there is audio\n            // buffer underflow/underrun -- in that case the video will stop as soon as it\n            // encounters the gap, as audio stalls are more noticeable/jarring to a user than\n            // video stalls). The player's time will reflect the playthrough of audio, so the\n            // time will appear as if we are in a buffered region, even if we are stuck in a\n            // \"gap.\"\n            //\n            // Example:\n            // video buffer:   0 => 10.1, 10.2 => 20\n            // audio buffer:   0 => 20\n            // overall buffer: 0 => 10.1, 10.2 => 20\n            // current time: 13\n            //\n            // Chrome's video froze at 10 seconds, where the video buffer encountered the gap,\n            // however, the audio continued playing until it reached ~3 seconds past the gap\n            // (13 seconds), at which point it stops as well. Since current time is past the\n            // gap, findNextRange will return no ranges.\n            //\n            // To check for this issue, we see if there is a gap that starts somewhere within\n            // a 3 second range (3 seconds +/- 1 second) back from our current time.\n            const gaps = findGaps(buffered);\n            for (let i = 0; i < gaps.length; i++) {\n                const start = gaps.start(i);\n                const end = gaps.end(i); // gap is starts no more than 4 seconds back\n\n                if (currentTime - start < 4 && currentTime - start > 2) {\n                    return {\n                        start,\n                        end\n                    };\n                }\n            }\n            return null;\n        }\n    }\n    const defaultOptions = {\n        errorInterval: 30,\n        getSource(next) {\n            const tech = this.tech({\n                IWillNotUseThisInPlugins: true\n            });\n            const sourceObj = tech.currentSource_ || this.currentSource();\n            return next(sourceObj);\n        }\n    };\n    /**\n     * Main entry point for the plugin\n     *\n     * @param {Player} player a reference to a videojs Player instance\n     * @param {Object} [options] an object with plugin options\n     * @private\n     */\n\n    const initPlugin = function (player, options) {\n        let lastCalled = 0;\n        let seekTo = 0;\n        const localOptions = merge(defaultOptions, options);\n        player.ready(() => {\n            player.trigger({\n                type: 'usage',\n                name: 'vhs-error-reload-initialized'\n            });\n        });\n        /**\n         * Player modifications to perform that must wait until `loadedmetadata`\n         * has been triggered\n         *\n         * @private\n         */\n\n        const loadedMetadataHandler = function () {\n            if (seekTo) {\n                player.currentTime(seekTo);\n            }\n        };\n        /**\n         * Set the source on the player element, play, and seek if necessary\n         *\n         * @param {Object} sourceObj An object specifying the source url and mime-type to play\n         * @private\n         */\n\n        const setSource = function (sourceObj) {\n            if (sourceObj === null || sourceObj === undefined) {\n                return;\n            }\n            seekTo = player.duration() !== Infinity && player.currentTime() || 0;\n            player.one('loadedmetadata', loadedMetadataHandler);\n            player.src(sourceObj);\n            player.trigger({\n                type: 'usage',\n                name: 'vhs-error-reload'\n            });\n            player.play();\n        };\n        /**\n         * Attempt to get a source from either the built-in getSource function\n         * or a custom function provided via the options\n         *\n         * @private\n         */\n\n        const errorHandler = function () {\n            // Do not attempt to reload the source if a source-reload occurred before\n            // 'errorInterval' time has elapsed since the last source-reload\n            if (Date.now() - lastCalled < localOptions.errorInterval * 1000) {\n                player.trigger({\n                    type: 'usage',\n                    name: 'vhs-error-reload-canceled'\n                });\n                return;\n            }\n            if (!localOptions.getSource || typeof localOptions.getSource !== 'function') {\n                videojs.log.error('ERROR: reloadSourceOnError - The option getSource must be a function!');\n                return;\n            }\n            lastCalled = Date.now();\n            return localOptions.getSource.call(player, setSource);\n        };\n        /**\n         * Unbind any event handlers that were bound by the plugin\n         *\n         * @private\n         */\n\n        const cleanupEvents = function () {\n            player.off('loadedmetadata', loadedMetadataHandler);\n            player.off('error', errorHandler);\n            player.off('dispose', cleanupEvents);\n        };\n        /**\n         * Cleanup before re-initializing the plugin\n         *\n         * @param {Object} [newOptions] an object with plugin options\n         * @private\n         */\n\n        const reinitPlugin = function (newOptions) {\n            cleanupEvents();\n            initPlugin(player, newOptions);\n        };\n        player.on('error', errorHandler);\n        player.on('dispose', cleanupEvents); // Overwrite the plugin function so that we can correctly cleanup before\n        // initializing the plugin\n\n        player.reloadSourceOnError = reinitPlugin;\n    };\n    /**\n     * Reload the source when an error is detected as long as there\n     * wasn't an error previously within the last 30 seconds\n     *\n     * @param {Object} [options] an object with plugin options\n     */\n\n    const reloadSourceOnError = function (options) {\n        initPlugin(this, options);\n    };\n    var version$4 = \"3.0.2\";\n    var version$3 = \"6.3.0\";\n    var version$2 = \"1.0.1\";\n    var version$1 = \"6.0.0\";\n    var version = \"4.0.1\";\n\n    /**\n     * @file videojs-http-streaming.js\n     *\n     * The main file for the VHS project.\n     * License: https://github.com/videojs/videojs-http-streaming/blob/main/LICENSE\n     */\n    const Vhs = {\n        PlaylistLoader,\n        Playlist,\n        utils,\n        STANDARD_PLAYLIST_SELECTOR: lastBandwidthSelector,\n        INITIAL_PLAYLIST_SELECTOR: lowestBitrateCompatibleVariantSelector,\n        lastBandwidthSelector,\n        movingAverageBandwidthSelector,\n        comparePlaylistBandwidth,\n        comparePlaylistResolution,\n        xhr: xhrFactory()\n    }; // Define getter/setters for config properties\n\n    Object.keys(Config).forEach(prop => {\n        Object.defineProperty(Vhs, prop, {\n            get() {\n                videojs.log.warn(`using Vhs.${prop} is UNSAFE be sure you know what you are doing`);\n                return Config[prop];\n            },\n            set(value) {\n                videojs.log.warn(`using Vhs.${prop} is UNSAFE be sure you know what you are doing`);\n                if (typeof value !== 'number' || value < 0) {\n                    videojs.log.warn(`value of Vhs.${prop} must be greater than or equal to 0`);\n                    return;\n                }\n                Config[prop] = value;\n            }\n        });\n    });\n    const LOCAL_STORAGE_KEY = 'videojs-vhs';\n    /**\n     * Updates the selectedIndex of the QualityLevelList when a mediachange happens in vhs.\n     *\n     * @param {QualityLevelList} qualityLevels The QualityLevelList to update.\n     * @param {PlaylistLoader} playlistLoader PlaylistLoader containing the new media info.\n     * @function handleVhsMediaChange\n     */\n\n    const handleVhsMediaChange = function (qualityLevels, playlistLoader) {\n        const newPlaylist = playlistLoader.media();\n        let selectedIndex = -1;\n        for (let i = 0; i < qualityLevels.length; i++) {\n            if (qualityLevels[i].id === newPlaylist.id) {\n                selectedIndex = i;\n                break;\n            }\n        }\n        qualityLevels.selectedIndex_ = selectedIndex;\n        qualityLevels.trigger({\n            selectedIndex,\n            type: 'change'\n        });\n    };\n    /**\n     * Adds quality levels to list once playlist metadata is available\n     *\n     * @param {QualityLevelList} qualityLevels The QualityLevelList to attach events to.\n     * @param {Object} vhs Vhs object to listen to for media events.\n     * @function handleVhsLoadedMetadata\n     */\n\n    const handleVhsLoadedMetadata = function (qualityLevels, vhs) {\n        vhs.representations().forEach(rep => {\n            qualityLevels.addQualityLevel(rep);\n        });\n        handleVhsMediaChange(qualityLevels, vhs.playlists);\n    }; // VHS is a source handler, not a tech. Make sure attempts to use it\n    // as one do not cause exceptions.\n\n    Vhs.canPlaySource = function () {\n        return videojs.log.warn('VHS is no longer a tech. Please remove it from ' + 'your player\\'s techOrder.');\n    };\n    const emeKeySystems = (keySystemOptions, mainPlaylist, audioPlaylist) => {\n        if (!keySystemOptions) {\n            return keySystemOptions;\n        }\n        let codecs = {};\n        if (mainPlaylist && mainPlaylist.attributes && mainPlaylist.attributes.CODECS) {\n            codecs = unwrapCodecList(parseCodecs(mainPlaylist.attributes.CODECS));\n        }\n        if (audioPlaylist && audioPlaylist.attributes && audioPlaylist.attributes.CODECS) {\n            codecs.audio = audioPlaylist.attributes.CODECS;\n        }\n        const videoContentType = getMimeForCodec(codecs.video);\n        const audioContentType = getMimeForCodec(codecs.audio); // upsert the content types based on the selected playlist\n\n        const keySystemContentTypes = {};\n        for (const keySystem in keySystemOptions) {\n            keySystemContentTypes[keySystem] = {};\n            if (audioContentType) {\n                keySystemContentTypes[keySystem].audioContentType = audioContentType;\n            }\n            if (videoContentType) {\n                keySystemContentTypes[keySystem].videoContentType = videoContentType;\n            } // Default to using the video playlist's PSSH even though they may be different, as\n            // videojs-contrib-eme will only accept one in the options.\n            //\n            // This shouldn't be an issue for most cases as early intialization will handle all\n            // unique PSSH values, and if they aren't, then encrypted events should have the\n            // specific information needed for the unique license.\n\n            if (mainPlaylist.contentProtection && mainPlaylist.contentProtection[keySystem] && mainPlaylist.contentProtection[keySystem].pssh) {\n                keySystemContentTypes[keySystem].pssh = mainPlaylist.contentProtection[keySystem].pssh;\n            } // videojs-contrib-eme accepts the option of specifying: 'com.some.cdm': 'url'\n            // so we need to prevent overwriting the URL entirely\n\n            if (typeof keySystemOptions[keySystem] === 'string') {\n                keySystemContentTypes[keySystem].url = keySystemOptions[keySystem];\n            }\n        }\n        return merge(keySystemOptions, keySystemContentTypes);\n    };\n    /**\n     * @typedef {Object} KeySystems\n     *\n     * keySystems configuration for https://github.com/videojs/videojs-contrib-eme\n     * Note: not all options are listed here.\n     *\n     * @property {Uint8Array} [pssh]\n     *           Protection System Specific Header\n     */\n\n    /**\n     * Goes through all the playlists and collects an array of KeySystems options objects\n     * containing each playlist's keySystems and their pssh values, if available.\n     *\n     * @param {Object[]} playlists\n     *        The playlists to look through\n     * @param {string[]} keySystems\n     *        The keySystems to collect pssh values for\n     *\n     * @return {KeySystems[]}\n     *         An array of KeySystems objects containing available key systems and their\n     *         pssh values\n     */\n\n    const getAllPsshKeySystemsOptions = (playlists, keySystems) => {\n        return playlists.reduce((keySystemsArr, playlist) => {\n            if (!playlist.contentProtection) {\n                return keySystemsArr;\n            }\n            const keySystemsOptions = keySystems.reduce((keySystemsObj, keySystem) => {\n                const keySystemOptions = playlist.contentProtection[keySystem];\n                if (keySystemOptions && keySystemOptions.pssh) {\n                    keySystemsObj[keySystem] = {\n                        pssh: keySystemOptions.pssh\n                    };\n                }\n                return keySystemsObj;\n            }, {});\n            if (Object.keys(keySystemsOptions).length) {\n                keySystemsArr.push(keySystemsOptions);\n            }\n            return keySystemsArr;\n        }, []);\n    };\n    /**\n     * Returns a promise that waits for the\n     * [eme plugin](https://github.com/videojs/videojs-contrib-eme) to create a key session.\n     *\n     * Works around https://bugs.chromium.org/p/chromium/issues/detail?id=895449 in non-IE11\n     * browsers.\n     *\n     * As per the above ticket, this is particularly important for Chrome, where, if\n     * unencrypted content is appended before encrypted content and the key session has not\n     * been created, a MEDIA_ERR_DECODE will be thrown once the encrypted content is reached\n     * during playback.\n     *\n     * @param {Object} player\n     *        The player instance\n     * @param {Object[]} sourceKeySystems\n     *        The key systems options from the player source\n     * @param {Object} [audioMedia]\n     *        The active audio media playlist (optional)\n     * @param {Object[]} mainPlaylists\n     *        The playlists found on the main playlist object\n     *\n     * @return {Object}\n     *         Promise that resolves when the key session has been created\n     */\n\n    const waitForKeySessionCreation = ({\n                                           player,\n                                           sourceKeySystems,\n                                           audioMedia,\n                                           mainPlaylists\n                                       }) => {\n        if (!player.eme.initializeMediaKeys) {\n            return Promise.resolve();\n        } // TODO should all audio PSSH values be initialized for DRM?\n        //\n        // All unique video rendition pssh values are initialized for DRM, but here only\n        // the initial audio playlist license is initialized. In theory, an encrypted\n        // event should be fired if the user switches to an alternative audio playlist\n        // where a license is required, but this case hasn't yet been tested. In addition, there\n        // may be many alternate audio playlists unlikely to be used (e.g., multiple different\n        // languages).\n\n        const playlists = audioMedia ? mainPlaylists.concat([audioMedia]) : mainPlaylists;\n        const keySystemsOptionsArr = getAllPsshKeySystemsOptions(playlists, Object.keys(sourceKeySystems));\n        const initializationFinishedPromises = [];\n        const keySessionCreatedPromises = []; // Since PSSH values are interpreted as initData, EME will dedupe any duplicates. The\n        // only place where it should not be deduped is for ms-prefixed APIs, but the early\n        // return for IE11 above, and the existence of modern EME APIs in addition to\n        // ms-prefixed APIs on Edge should prevent this from being a concern.\n        // initializeMediaKeys also won't use the webkit-prefixed APIs.\n\n        keySystemsOptionsArr.forEach(keySystemsOptions => {\n            keySessionCreatedPromises.push(new Promise((resolve, reject) => {\n                player.tech_.one('keysessioncreated', resolve);\n            }));\n            initializationFinishedPromises.push(new Promise((resolve, reject) => {\n                player.eme.initializeMediaKeys({\n                    keySystems: keySystemsOptions\n                }, err => {\n                    if (err) {\n                        reject(err);\n                        return;\n                    }\n                    resolve();\n                });\n            }));\n        }); // The reasons Promise.race is chosen over Promise.any:\n        //\n        // * Promise.any is only available in Safari 14+.\n        // * None of these promises are expected to reject. If they do reject, it might be\n        //   better here for the race to surface the rejection, rather than mask it by using\n        //   Promise.any.\n\n        return Promise.race([\n            // If a session was previously created, these will all finish resolving without\n            // creating a new session, otherwise it will take until the end of all license\n            // requests, which is why the key session check is used (to make setup much faster).\n            Promise.all(initializationFinishedPromises),\n            // Once a single session is created, the browser knows DRM will be used.\n            Promise.race(keySessionCreatedPromises)]);\n    };\n    /**\n     * If the [eme](https://github.com/videojs/videojs-contrib-eme) plugin is available, and\n     * there are keySystems on the source, sets up source options to prepare the source for\n     * eme.\n     *\n     * @param {Object} player\n     *        The player instance\n     * @param {Object[]} sourceKeySystems\n     *        The key systems options from the player source\n     * @param {Object} media\n     *        The active media playlist\n     * @param {Object} [audioMedia]\n     *        The active audio media playlist (optional)\n     *\n     * @return {boolean}\n     *         Whether or not options were configured and EME is available\n     */\n\n    const setupEmeOptions = ({\n                                 player,\n                                 sourceKeySystems,\n                                 media,\n                                 audioMedia\n                             }) => {\n        const sourceOptions = emeKeySystems(sourceKeySystems, media, audioMedia);\n        if (!sourceOptions) {\n            return false;\n        }\n        player.currentSource().keySystems = sourceOptions; // eme handles the rest of the setup, so if it is missing\n        // do nothing.\n\n        if (sourceOptions && !player.eme) {\n            videojs.log.warn('DRM encrypted source cannot be decrypted without a DRM plugin');\n            return false;\n        }\n        return true;\n    };\n    const getVhsLocalStorage = () => {\n        if (!window.localStorage) {\n            return null;\n        }\n        const storedObject = window.localStorage.getItem(LOCAL_STORAGE_KEY);\n        if (!storedObject) {\n            return null;\n        }\n        try {\n            return JSON.parse(storedObject);\n        } catch (e) {\n            // someone may have tampered with the value\n            return null;\n        }\n    };\n    const updateVhsLocalStorage = options => {\n        if (!window.localStorage) {\n            return false;\n        }\n        let objectToStore = getVhsLocalStorage();\n        objectToStore = objectToStore ? merge(objectToStore, options) : options;\n        try {\n            window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(objectToStore));\n        } catch (e) {\n            // Throws if storage is full (e.g., always on iOS 5+ Safari private mode, where\n            // storage is set to 0).\n            // https://developer.mozilla.org/en-US/docs/Web/API/Storage/setItem#Exceptions\n            // No need to perform any operation.\n            return false;\n        }\n        return objectToStore;\n    };\n    /**\n     * Parses VHS-supported media types from data URIs. See\n     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n     * for information on data URIs.\n     *\n     * @param {string} dataUri\n     *        The data URI\n     *\n     * @return {string|Object}\n     *         The parsed object/string, or the original string if no supported media type\n     *         was found\n     */\n\n    const expandDataUri = dataUri => {\n        if (dataUri.toLowerCase().indexOf('data:application/vnd.videojs.vhs+json,') === 0) {\n            return JSON.parse(dataUri.substring(dataUri.indexOf(',') + 1));\n        } // no known case for this data URI, return the string as-is\n\n        return dataUri;\n    };\n    /**\n     * Whether the browser has built-in HLS support.\n     */\n\n    Vhs.supportsNativeHls = function () {\n        if (!document || !document.createElement) {\n            return false;\n        }\n        const video = document.createElement('video'); // native HLS is definitely not supported if HTML5 video isn't\n\n        if (!videojs.getTech('Html5').isSupported()) {\n            return false;\n        } // HLS manifests can go by many mime-types\n\n        const canPlay = [\n            // Apple santioned\n            'application/vnd.apple.mpegurl',\n            // Apple sanctioned for backwards compatibility\n            'audio/mpegurl',\n            // Very common\n            'audio/x-mpegurl',\n            // Very common\n            'application/x-mpegurl',\n            // Included for completeness\n            'video/x-mpegurl', 'video/mpegurl', 'application/mpegurl'];\n        return canPlay.some(function (canItPlay) {\n            return /maybe|probably/i.test(video.canPlayType(canItPlay));\n        });\n    }();\n    Vhs.supportsNativeDash = function () {\n        if (!document || !document.createElement || !videojs.getTech('Html5').isSupported()) {\n            return false;\n        }\n        return /maybe|probably/i.test(document.createElement('video').canPlayType('application/dash+xml'));\n    }();\n    Vhs.supportsTypeNatively = type => {\n        if (type === 'hls') {\n            return Vhs.supportsNativeHls;\n        }\n        if (type === 'dash') {\n            return Vhs.supportsNativeDash;\n        }\n        return false;\n    };\n    /**\n     * VHS is a source handler, not a tech. Make sure attempts to use it\n     * as one do not cause exceptions.\n     */\n\n    Vhs.isSupported = function () {\n        return videojs.log.warn('VHS is no longer a tech. Please remove it from ' + 'your player\\'s techOrder.');\n    };\n    const Component = videojs.getComponent('Component');\n    /**\n     * The Vhs Handler object, where we orchestrate all of the parts\n     * of VHS to interact with video.js\n     *\n     * @class VhsHandler\n     * @extends videojs.Component\n     * @param {Object} source the soruce object\n     * @param {Tech} tech the parent tech object\n     * @param {Object} options optional and required options\n     */\n\n    class VhsHandler extends Component {\n        constructor(source, tech, options) {\n            super(tech, options.vhs); // if a tech level `initialBandwidth` option was passed\n            // use that over the VHS level `bandwidth` option\n\n            if (typeof options.initialBandwidth === 'number') {\n                this.options_.bandwidth = options.initialBandwidth;\n            }\n            this.logger_ = logger('VhsHandler'); // we need access to the player in some cases,\n            // so, get it from Video.js via the `playerId`\n\n            if (tech.options_ && tech.options_.playerId) {\n                const _player = videojs.getPlayer(tech.options_.playerId);\n                this.player_ = _player;\n            }\n            this.tech_ = tech;\n            this.source_ = source;\n            this.stats = {};\n            this.ignoreNextSeekingEvent_ = false;\n            this.setOptions_();\n            if (this.options_.overrideNative && tech.overrideNativeAudioTracks && tech.overrideNativeVideoTracks) {\n                tech.overrideNativeAudioTracks(true);\n                tech.overrideNativeVideoTracks(true);\n            } else if (this.options_.overrideNative && (tech.featuresNativeVideoTracks || tech.featuresNativeAudioTracks)) {\n                // overriding native VHS only works if audio tracks have been emulated\n                // error early if we're misconfigured\n                throw new Error('Overriding native VHS requires emulated tracks. ' + 'See https://git.io/vMpjB');\n            } // listen for fullscreenchange events for this player so that we\n            // can adjust our quality selection quickly\n\n            this.on(document, ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'], event => {\n                const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;\n                if (fullscreenElement && fullscreenElement.contains(this.tech_.el())) {\n                    this.playlistController_.fastQualityChange_();\n                } else {\n                    // When leaving fullscreen, since the in page pixel dimensions should be smaller\n                    // than full screen, see if there should be a rendition switch down to preserve\n                    // bandwidth.\n                    this.playlistController_.checkABR_();\n                }\n            });\n            this.on(this.tech_, 'seeking', function () {\n                if (this.ignoreNextSeekingEvent_) {\n                    this.ignoreNextSeekingEvent_ = false;\n                    return;\n                }\n                this.setCurrentTime(this.tech_.currentTime());\n            });\n            this.on(this.tech_, 'error', function () {\n                // verify that the error was real and we are loaded\n                // enough to have pc loaded.\n                if (this.tech_.error() && this.playlistController_) {\n                    this.playlistController_.pauseLoading();\n                }\n            });\n            this.on(this.tech_, 'play', this.play);\n        }\n        setOptions_() {\n            // defaults\n            this.options_.withCredentials = this.options_.withCredentials || false;\n            this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions === false ? false : true;\n            this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || false;\n            this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage !== 'undefined' ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || false;\n            this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || false;\n            this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || false;\n            this.options_.customTagParsers = this.options_.customTagParsers || [];\n            this.options_.customTagMappers = this.options_.customTagMappers || [];\n            this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || false;\n            this.options_.llhls = this.options_.llhls === false ? false : true;\n            this.options_.bufferBasedABR = this.options_.bufferBasedABR || false;\n            if (typeof this.options_.playlistExclusionDuration !== 'number') {\n                this.options_.playlistExclusionDuration = 5 * 60;\n            }\n            if (typeof this.options_.bandwidth !== 'number') {\n                if (this.options_.useBandwidthFromLocalStorage) {\n                    const storedObject = getVhsLocalStorage();\n                    if (storedObject && storedObject.bandwidth) {\n                        this.options_.bandwidth = storedObject.bandwidth;\n                        this.tech_.trigger({\n                            type: 'usage',\n                            name: 'vhs-bandwidth-from-local-storage'\n                        });\n                    }\n                    if (storedObject && storedObject.throughput) {\n                        this.options_.throughput = storedObject.throughput;\n                        this.tech_.trigger({\n                            type: 'usage',\n                            name: 'vhs-throughput-from-local-storage'\n                        });\n                    }\n                }\n            } // if bandwidth was not set by options or pulled from local storage, start playlist\n            // selection at a reasonable bandwidth\n\n            if (typeof this.options_.bandwidth !== 'number') {\n                this.options_.bandwidth = Config.INITIAL_BANDWIDTH;\n            } // If the bandwidth number is unchanged from the initial setting\n            // then this takes precedence over the enableLowInitialPlaylist option\n\n            this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Config.INITIAL_BANDWIDTH; // grab options passed to player.src\n\n            ['withCredentials', 'useDevicePixelRatio', 'limitRenditionByPlayerDimensions', 'bandwidth', 'customTagParsers', 'customTagMappers', 'cacheEncryptionKeys', 'playlistSelector', 'initialPlaylistSelector', 'bufferBasedABR', 'liveRangeSafeTimeDelta', 'llhls', 'useNetworkInformationApi', 'useDtsForTimestampOffset', 'exactManifestTimings', 'leastPixelDiffSelector'].forEach(option => {\n                if (typeof this.source_[option] !== 'undefined') {\n                    this.options_[option] = this.source_[option];\n                }\n            });\n            this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions;\n            this.useDevicePixelRatio = this.options_.useDevicePixelRatio;\n        }\n        /**\n         * called when player.src gets called, handle a new source\n         *\n         * @param {Object} src the source object to handle\n         */\n\n        src(src, type) {\n            // do nothing if the src is falsey\n            if (!src) {\n                return;\n            }\n            this.setOptions_(); // add main playlist controller options\n\n            this.options_.src = expandDataUri(this.source_.src);\n            this.options_.tech = this.tech_;\n            this.options_.externVhs = Vhs;\n            this.options_.sourceType = simpleTypeFromSourceType(type); // Whenever we seek internally, we should update the tech\n\n            this.options_.seekTo = time => {\n                this.tech_.setCurrentTime(time);\n            };\n            this.playlistController_ = new PlaylistController(this.options_);\n            const playbackWatcherOptions = merge({\n                liveRangeSafeTimeDelta: SAFE_TIME_DELTA\n            }, this.options_, {\n                seekable: () => this.seekable(),\n                media: () => this.playlistController_.media(),\n                playlistController: this.playlistController_\n            });\n            this.playbackWatcher_ = new PlaybackWatcher(playbackWatcherOptions);\n            this.playlistController_.on('error', () => {\n                const player = videojs.players[this.tech_.options_.playerId];\n                let error = this.playlistController_.error;\n                if (typeof error === 'object' && !error.code) {\n                    error.code = 3;\n                } else if (typeof error === 'string') {\n                    error = {\n                        message: error,\n                        code: 3\n                    };\n                }\n                player.error(error);\n            });\n            const defaultSelector = this.options_.bufferBasedABR ? Vhs.movingAverageBandwidthSelector(0.55) : Vhs.STANDARD_PLAYLIST_SELECTOR; // `this` in selectPlaylist should be the VhsHandler for backwards\n            // compatibility with < v2\n\n            this.playlistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : defaultSelector.bind(this);\n            this.playlistController_.selectInitialPlaylist = Vhs.INITIAL_PLAYLIST_SELECTOR.bind(this); // re-expose some internal objects for backwards compatibility with < v2\n\n            this.playlists = this.playlistController_.mainPlaylistLoader_;\n            this.mediaSource = this.playlistController_.mediaSource; // Proxy assignment of some properties to the main playlist\n            // controller. Using a custom property for backwards compatibility\n            // with < v2\n\n            Object.defineProperties(this, {\n                selectPlaylist: {\n                    get() {\n                        return this.playlistController_.selectPlaylist;\n                    },\n                    set(selectPlaylist) {\n                        this.playlistController_.selectPlaylist = selectPlaylist.bind(this);\n                    }\n                },\n                throughput: {\n                    get() {\n                        return this.playlistController_.mainSegmentLoader_.throughput.rate;\n                    },\n                    set(throughput) {\n                        this.playlistController_.mainSegmentLoader_.throughput.rate = throughput; // By setting `count` to 1 the throughput value becomes the starting value\n                        // for the cumulative average\n\n                        this.playlistController_.mainSegmentLoader_.throughput.count = 1;\n                    }\n                },\n                bandwidth: {\n                    get() {\n                        let playerBandwidthEst = this.playlistController_.mainSegmentLoader_.bandwidth;\n                        const networkInformation = window.navigator.connection || window.navigator.mozConnection || window.navigator.webkitConnection;\n                        const tenMbpsAsBitsPerSecond = 10e6;\n                        if (this.options_.useNetworkInformationApi && networkInformation) {\n                            // downlink returns Mbps\n                            // https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/downlink\n                            const networkInfoBandwidthEstBitsPerSec = networkInformation.downlink * 1000 * 1000; // downlink maxes out at 10 Mbps. In the event that both networkInformationApi and the player\n                            // estimate a bandwidth greater than 10 Mbps, use the larger of the two estimates to ensure that\n                            // high quality streams are not filtered out.\n\n                            if (networkInfoBandwidthEstBitsPerSec >= tenMbpsAsBitsPerSecond && playerBandwidthEst >= tenMbpsAsBitsPerSecond) {\n                                playerBandwidthEst = Math.max(playerBandwidthEst, networkInfoBandwidthEstBitsPerSec);\n                            } else {\n                                playerBandwidthEst = networkInfoBandwidthEstBitsPerSec;\n                            }\n                        }\n                        return playerBandwidthEst;\n                    },\n                    set(bandwidth) {\n                        this.playlistController_.mainSegmentLoader_.bandwidth = bandwidth; // setting the bandwidth manually resets the throughput counter\n                        // `count` is set to zero that current value of `rate` isn't included\n                        // in the cumulative average\n\n                        this.playlistController_.mainSegmentLoader_.throughput = {\n                            rate: 0,\n                            count: 0\n                        };\n                    }\n                },\n                /**\n                 * `systemBandwidth` is a combination of two serial processes bit-rates. The first\n                 * is the network bitrate provided by `bandwidth` and the second is the bitrate of\n                 * the entire process after that - decryption, transmuxing, and appending - provided\n                 * by `throughput`.\n                 *\n                 * Since the two process are serial, the overall system bandwidth is given by:\n                 *   sysBandwidth = 1 / (1 / bandwidth + 1 / throughput)\n                 */\n                systemBandwidth: {\n                    get() {\n                        const invBandwidth = 1 / (this.bandwidth || 1);\n                        let invThroughput;\n                        if (this.throughput > 0) {\n                            invThroughput = 1 / this.throughput;\n                        } else {\n                            invThroughput = 0;\n                        }\n                        const systemBitrate = Math.floor(1 / (invBandwidth + invThroughput));\n                        return systemBitrate;\n                    },\n                    set() {\n                        videojs.log.error('The \"systemBandwidth\" property is read-only');\n                    }\n                }\n            });\n            if (this.options_.bandwidth) {\n                this.bandwidth = this.options_.bandwidth;\n            }\n            if (this.options_.throughput) {\n                this.throughput = this.options_.throughput;\n            }\n            Object.defineProperties(this.stats, {\n                bandwidth: {\n                    get: () => this.bandwidth || 0,\n                    enumerable: true\n                },\n                mediaRequests: {\n                    get: () => this.playlistController_.mediaRequests_() || 0,\n                    enumerable: true\n                },\n                mediaRequestsAborted: {\n                    get: () => this.playlistController_.mediaRequestsAborted_() || 0,\n                    enumerable: true\n                },\n                mediaRequestsTimedout: {\n                    get: () => this.playlistController_.mediaRequestsTimedout_() || 0,\n                    enumerable: true\n                },\n                mediaRequestsErrored: {\n                    get: () => this.playlistController_.mediaRequestsErrored_() || 0,\n                    enumerable: true\n                },\n                mediaTransferDuration: {\n                    get: () => this.playlistController_.mediaTransferDuration_() || 0,\n                    enumerable: true\n                },\n                mediaBytesTransferred: {\n                    get: () => this.playlistController_.mediaBytesTransferred_() || 0,\n                    enumerable: true\n                },\n                mediaSecondsLoaded: {\n                    get: () => this.playlistController_.mediaSecondsLoaded_() || 0,\n                    enumerable: true\n                },\n                mediaAppends: {\n                    get: () => this.playlistController_.mediaAppends_() || 0,\n                    enumerable: true\n                },\n                mainAppendsToLoadedData: {\n                    get: () => this.playlistController_.mainAppendsToLoadedData_() || 0,\n                    enumerable: true\n                },\n                audioAppendsToLoadedData: {\n                    get: () => this.playlistController_.audioAppendsToLoadedData_() || 0,\n                    enumerable: true\n                },\n                appendsToLoadedData: {\n                    get: () => this.playlistController_.appendsToLoadedData_() || 0,\n                    enumerable: true\n                },\n                timeToLoadedData: {\n                    get: () => this.playlistController_.timeToLoadedData_() || 0,\n                    enumerable: true\n                },\n                buffered: {\n                    get: () => timeRangesToArray(this.tech_.buffered()),\n                    enumerable: true\n                },\n                currentTime: {\n                    get: () => this.tech_.currentTime(),\n                    enumerable: true\n                },\n                currentSource: {\n                    get: () => this.tech_.currentSource_,\n                    enumerable: true\n                },\n                currentTech: {\n                    get: () => this.tech_.name_,\n                    enumerable: true\n                },\n                duration: {\n                    get: () => this.tech_.duration(),\n                    enumerable: true\n                },\n                main: {\n                    get: () => this.playlists.main,\n                    enumerable: true\n                },\n                playerDimensions: {\n                    get: () => this.tech_.currentDimensions(),\n                    enumerable: true\n                },\n                seekable: {\n                    get: () => timeRangesToArray(this.tech_.seekable()),\n                    enumerable: true\n                },\n                timestamp: {\n                    get: () => Date.now(),\n                    enumerable: true\n                },\n                videoPlaybackQuality: {\n                    get: () => this.tech_.getVideoPlaybackQuality(),\n                    enumerable: true\n                }\n            });\n            this.tech_.one('canplay', this.playlistController_.setupFirstPlay.bind(this.playlistController_));\n            this.tech_.on('bandwidthupdate', () => {\n                if (this.options_.useBandwidthFromLocalStorage) {\n                    updateVhsLocalStorage({\n                        bandwidth: this.bandwidth,\n                        throughput: Math.round(this.throughput)\n                    });\n                }\n            });\n            this.playlistController_.on('selectedinitialmedia', () => {\n                // Add the manual rendition mix-in to VhsHandler\n                renditionSelectionMixin(this);\n            });\n            this.playlistController_.sourceUpdater_.on('createdsourcebuffers', () => {\n                this.setupEme_();\n            }); // the bandwidth of the primary segment loader is our best\n            // estimate of overall bandwidth\n\n            this.on(this.playlistController_, 'progress', function () {\n                this.tech_.trigger('progress');\n            }); // In the live case, we need to ignore the very first `seeking` event since\n            // that will be the result of the seek-to-live behavior\n\n            this.on(this.playlistController_, 'firstplay', function () {\n                this.ignoreNextSeekingEvent_ = true;\n            });\n            this.setupQualityLevels_(); // do nothing if the tech has been disposed already\n            // this can occur if someone sets the src in player.ready(), for instance\n\n            if (!this.tech_.el()) {\n                return;\n            }\n            this.mediaSourceUrl_ = window.URL.createObjectURL(this.playlistController_.mediaSource);\n            this.tech_.src(this.mediaSourceUrl_);\n        }\n        createKeySessions_() {\n            const audioPlaylistLoader = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;\n            this.logger_('waiting for EME key session creation');\n            waitForKeySessionCreation({\n                player: this.player_,\n                sourceKeySystems: this.source_.keySystems,\n                audioMedia: audioPlaylistLoader && audioPlaylistLoader.media(),\n                mainPlaylists: this.playlists.main.playlists\n            }).then(() => {\n                this.logger_('created EME key session');\n                this.playlistController_.sourceUpdater_.initializedEme();\n            }).catch(err => {\n                this.logger_('error while creating EME key session', err);\n                this.player_.error({\n                    message: 'Failed to initialize media keys for EME',\n                    code: 3\n                });\n            });\n        }\n        handleWaitingForKey_() {\n            // If waitingforkey is fired, it's possible that the data that's necessary to retrieve\n            // the key is in the manifest. While this should've happened on initial source load, it\n            // may happen again in live streams where the keys change, and the manifest info\n            // reflects the update.\n            //\n            // Because videojs-contrib-eme compares the PSSH data we send to that of PSSH data it's\n            // already requested keys for, we don't have to worry about this generating extraneous\n            // requests.\n            this.logger_('waitingforkey fired, attempting to create any new key sessions');\n            this.createKeySessions_();\n        }\n        /**\n         * If necessary and EME is available, sets up EME options and waits for key session\n         * creation.\n         *\n         * This function also updates the source updater so taht it can be used, as for some\n         * browsers, EME must be configured before content is appended (if appending unencrypted\n         * content before encrypted content).\n         */\n\n        setupEme_() {\n            const audioPlaylistLoader = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;\n            const didSetupEmeOptions = setupEmeOptions({\n                player: this.player_,\n                sourceKeySystems: this.source_.keySystems,\n                media: this.playlists.media(),\n                audioMedia: audioPlaylistLoader && audioPlaylistLoader.media()\n            });\n            this.player_.tech_.on('keystatuschange', e => {\n                if (e.status !== 'output-restricted') {\n                    return;\n                }\n                const mainPlaylist = this.playlistController_.main();\n                if (!mainPlaylist || !mainPlaylist.playlists) {\n                    return;\n                }\n                const excludedHDPlaylists = []; // Assume all HD streams are unplayable and exclude them from ABR selection\n\n                mainPlaylist.playlists.forEach(playlist => {\n                    if (playlist && playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height >= 720) {\n                        if (!playlist.excludeUntil || playlist.excludeUntil < Infinity) {\n                            playlist.excludeUntil = Infinity;\n                            excludedHDPlaylists.push(playlist);\n                        }\n                    }\n                });\n                if (excludedHDPlaylists.length) {\n                    videojs.log.warn('DRM keystatus changed to \"output-restricted.\" Removing the following HD playlists ' + 'that will most likely fail to play and clearing the buffer. ' + 'This may be due to HDCP restrictions on the stream and the capabilities of the current device.', ...excludedHDPlaylists); // Clear the buffer before switching playlists, since it may already contain unplayable segments\n\n                    this.playlistController_.fastQualityChange_();\n                }\n            });\n            this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this);\n            this.player_.tech_.on('waitingforkey', this.handleWaitingForKey_); // In IE11 this is too early to initialize media keys, and IE11 does not support\n            // promises.\n\n            if (videojs.browser.IE_VERSION === 11 || !didSetupEmeOptions) {\n                // If EME options were not set up, we've done all we could to initialize EME.\n                this.playlistController_.sourceUpdater_.initializedEme();\n                return;\n            }\n            this.createKeySessions_();\n        }\n        /**\n         * Initializes the quality levels and sets listeners to update them.\n         *\n         * @method setupQualityLevels_\n         * @private\n         */\n\n        setupQualityLevels_() {\n            const player = videojs.players[this.tech_.options_.playerId]; // if there isn't a player or there isn't a qualityLevels plugin\n            // or qualityLevels_ listeners have already been setup, do nothing.\n\n            if (!player || !player.qualityLevels || this.qualityLevels_) {\n                return;\n            }\n            this.qualityLevels_ = player.qualityLevels();\n            this.playlistController_.on('selectedinitialmedia', () => {\n                handleVhsLoadedMetadata(this.qualityLevels_, this);\n            });\n            this.playlists.on('mediachange', () => {\n                handleVhsMediaChange(this.qualityLevels_, this.playlists);\n            });\n        }\n        /**\n         * return the version\n         */\n\n        static version() {\n            return {\n                '@videojs/http-streaming': version$4,\n                'mux.js': version$3,\n                'mpd-parser': version$2,\n                'm3u8-parser': version$1,\n                'aes-decrypter': version\n            };\n        }\n        /**\n         * return the version\n         */\n\n        version() {\n            return this.constructor.version();\n        }\n        canChangeType() {\n            return SourceUpdater.canChangeType();\n        }\n        /**\n         * Begin playing the video.\n         */\n\n        play() {\n            this.playlistController_.play();\n        }\n        /**\n         * a wrapper around the function in PlaylistController\n         */\n\n        setCurrentTime(currentTime) {\n            this.playlistController_.setCurrentTime(currentTime);\n        }\n        /**\n         * a wrapper around the function in PlaylistController\n         */\n\n        duration() {\n            return this.playlistController_.duration();\n        }\n        /**\n         * a wrapper around the function in PlaylistController\n         */\n\n        seekable() {\n            return this.playlistController_.seekable();\n        }\n        /**\n         * Abort all outstanding work and cleanup.\n         */\n\n        dispose() {\n            if (this.playbackWatcher_) {\n                this.playbackWatcher_.dispose();\n            }\n            if (this.playlistController_) {\n                this.playlistController_.dispose();\n            }\n            if (this.qualityLevels_) {\n                this.qualityLevels_.dispose();\n            }\n            if (this.tech_ && this.tech_.vhs) {\n                delete this.tech_.vhs;\n            }\n            if (this.mediaSourceUrl_ && window.URL.revokeObjectURL) {\n                window.URL.revokeObjectURL(this.mediaSourceUrl_);\n                this.mediaSourceUrl_ = null;\n            }\n            if (this.tech_) {\n                this.tech_.off('waitingforkey', this.handleWaitingForKey_);\n            }\n            super.dispose();\n        }\n        convertToProgramTime(time, callback) {\n            return getProgramTime({\n                playlist: this.playlistController_.media(),\n                time,\n                callback\n            });\n        } // the player must be playing before calling this\n\n        seekToProgramTime(programTime, callback, pauseAfterSeek = true, retryCount = 2) {\n            return seekToProgramTime({\n                programTime,\n                playlist: this.playlistController_.media(),\n                retryCount,\n                pauseAfterSeek,\n                seekTo: this.options_.seekTo,\n                tech: this.options_.tech,\n                callback\n            });\n        }\n    }\n    /**\n     * The Source Handler object, which informs video.js what additional\n     * MIME types are supported and sets up playback. It is registered\n     * automatically to the appropriate tech based on the capabilities of\n     * the browser it is running in. It is not necessary to use or modify\n     * this object in normal usage.\n     */\n\n    const VhsSourceHandler = {\n        name: 'videojs-http-streaming',\n        VERSION: version$4,\n        canHandleSource(srcObj, options = {}) {\n            const localOptions = merge(videojs.options, options);\n            return VhsSourceHandler.canPlayType(srcObj.type, localOptions);\n        },\n        handleSource(source, tech, options = {}) {\n            const localOptions = merge(videojs.options, options);\n            tech.vhs = new VhsHandler(source, tech, localOptions);\n            tech.vhs.xhr = xhrFactory();\n            tech.vhs.src(source.src, source.type);\n            return tech.vhs;\n        },\n        canPlayType(type, options) {\n            const simpleType = simpleTypeFromSourceType(type);\n            if (!simpleType) {\n                return '';\n            }\n            const overrideNative = VhsSourceHandler.getOverrideNative(options);\n            const supportsTypeNatively = Vhs.supportsTypeNatively(simpleType);\n            const canUseMsePlayback = !supportsTypeNatively || overrideNative;\n            return canUseMsePlayback ? 'maybe' : '';\n        },\n        getOverrideNative(options = {}) {\n            const {\n                vhs = {}\n            } = options;\n            const defaultOverrideNative = !(videojs.browser.IS_ANY_SAFARI || videojs.browser.IS_IOS);\n            const {\n                overrideNative = defaultOverrideNative\n            } = vhs;\n            return overrideNative;\n        }\n    };\n    /**\n     * Check to see if the native MediaSource object exists and supports\n     * an MP4 container with both H.264 video and AAC-LC audio.\n     *\n     * @return {boolean} if  native media sources are supported\n     */\n\n    const supportsNativeMediaSources = () => {\n        return browserSupportsCodec('avc1.4d400d,mp4a.40.2');\n    }; // register source handlers with the appropriate techs\n\n    if (supportsNativeMediaSources()) {\n        videojs.getTech('Html5').registerSourceHandler(VhsSourceHandler, 0);\n    }\n    videojs.VhsHandler = VhsHandler;\n    videojs.VhsSourceHandler = VhsSourceHandler;\n    videojs.Vhs = Vhs;\n    if (!videojs.use) {\n        videojs.registerComponent('Vhs', Vhs);\n    }\n    videojs.options.vhs = videojs.options.vhs || {};\n    if (!videojs.getPlugin || !videojs.getPlugin('reloadSourceOnError')) {\n        videojs.registerPlugin('reloadSourceOnError', reloadSourceOnError);\n    }\n\n    return videojs;\n\n}));\n"],"names":["global","factory","exports","module","define","amd","globalThis","self","videojs","this","hooks_","hooks","type","fn","concat","removeHook","index","indexOf","slice","splice","FullscreenApi","prefixed","apiMap","specApi","browserApi","i","length","document","history","log$1","createLogger$1","name","logByType","level","log","args","lvl","levels","lvlRegExp","RegExp","unshift","toUpperCase","push","window","console","info","test","Array","isArray","LogByTypeFactory","createLogger","subname","all","off","debug","warn","error","DEFAULT","hasOwnProperty","Error","filter","fname","historyItem","clear","disable","enable","toString$1","Object","prototype","toString","keys","object","isObject$1","each","forEach","key","reduce","initial","accum","value","isPlain","call","constructor","merge$2","result","sources","source","defineLazyProperty","obj","getValue","setter","set","defineProperty","enumerable","writable","options","configurable","get","Obj","freeze","__proto__","isObject","merge","ANDROID_VERSION","IS_IPOD","IOS_VERSION","IS_ANDROID","IS_FIREFOX","IS_EDGE","IS_CHROMIUM","IS_CHROME","CHROMIUM_VERSION","CHROME_VERSION","IE_VERSION","IS_SAFARI","IS_WINDOWS","IS_IPAD","IS_IPHONE","TOUCH_ENABLED","Boolean","isReal","navigator","maxTouchPoints","DocumentTouch","UAD","userAgentData","platform","brands","find","b","brand","version","USER_AGENT","userAgent","match","major","parseFloat","minor","exec","IS_IOS","IS_ANY_SAFARI","browser","isNonBlankString","str","trim","isEl","nodeType","isInFrame","parent","x","createQuerier","method","selector","context","querySelector","ctx","createEl","tagName","properties","attributes","content","el","createElement","getOwnPropertyNames","propName","val","textContent","attrName","setAttribute","appendContent","text","innerText","prependTo","child","firstChild","insertBefore","appendChild","hasClass","element","classToCheck","throwIfWhitespace","classList","contains","addClass","classesToAdd","add","prev","current","split","removeClass","classesToRemove","remove","toggleClass","classToToggle","predicate","undefined","className","toggle","setAttributes","attrValue","removeAttribute","getAttributes","tag","knownBooleans","attrs","attrVal","getAttribute","attribute","blockTextSelection","body","focus","onselectstart","unblockTextSelection","getBoundingClientRect","parentNode","rect","k","height","computedStyle","width","findPosition","offsetParent","left","top","offsetWidth","offsetHeight","fullscreenElement","offsetLeft","offsetTop","getPointerPosition","event","translated","y","item","nodeName","toLowerCase","transform","values","map","Number","position","boxTarget","target","box","boxW","boxH","offsetY","offsetX","changedTouches","pageX","pageY","Math","max","min","isTextNode$1","emptyEl","removeChild","normalizeContent","createTextNode","node","insertContent","isSingleLeftClick","button","buttons","$","$$","prop","getComputedStyle","computedStyleValue","e","getPropertyValue","Dom","isTextNode","videojs$1","_windowLoaded","autoSetup","vids","getElementsByTagName","audios","divs","mediaEls","mediaEl","autoSetupTimeout","player","wait","vjs","setTimeout","setWindowLoaded","removeEventListener","readyState","addEventListener","createStyleElement","style","setTextContent","styleSheet","cssText","DomData","WeakMap","_supportsPassive","_guid","newGUID","_cleanUpEvents","elem","has","data","handlers","dispatcher","detachEvent","disabled","delete","_handleMultipleEvents","types","callback","fixEvent","fixed_","returnTrue","returnFalse","isPropagationStopped","isImmediatePropagationStopped","old","preventDefault","srcElement","relatedTarget","fromElement","toElement","returnValue","defaultPrevented","stopPropagation","cancelBubble","stopImmediatePropagation","clientX","doc","documentElement","scrollLeft","clientLeft","clientY","scrollTop","clientTop","which","charCode","keyCode","passiveEvents","on","guid","hash","handlersCopy","m","n","opts","supportsPassive","passive","attachEvent","removeType","t","trigger","elemData","ownerDocument","bubbles","targetData","one","func","apply","arguments","any","Events","bind_","uid","bound","bind","throttle","last","performance","now","debounce","immediate","timeout","cancel","clearTimeout","debounced","later","Fn","UPDATE_REFRESH_INTERVAL","EVENT_MAP","EventTarget$2","ael","allowedEvents_","queueTrigger","Map","oldTimeout","size","dispatchEvent","objName","name_","isEvented","eventBusEl_","every","isValidEventType","validateTarget","fnName","validateEventType","validateListener","listener","normalizeListenArgs","isTargetingSelf","shift","listen","EventedMixin","removeListenerOnDispose","removeRemoverOnTargetDispose","wrapper","_this","largs","_this2","targetOrType","typeOrListener","evented","eventBusKey","assign","eventedCallbacks","el_","StatefulMixin","state","setState","stateUpdates","changes","from","to","stateful","defaultState","handleStateChanged","string","replace","w","toTitleCase$1","titleCaseEquals","str1","str2","Str","toTitleCase","commonjsGlobal","createCommonjsModule","keycode","searchInput","hasKeyCode","names","foundNamedKey","search","String","codes","aliases","charCodeAt","isEventKey","nameOrCode","code","fromCharCode","title","alias","Component$1","ready","play","player_","isDisposed_","parentComponent_","options_","id_","id","c","handleLanguagechange","children_","childIndex_","childNameIndex_","setTimeoutIds_","Set","setIntervalIds_","rafIds_","namedRafs_","clearingTimersOnDispose_","initChildren","reportTouchActivity","enableTouchActivity","dispose","readyQueue_","restoreEl","replaceChild","isDisposed","localize","tokens","defaultValue","language","languages","primaryCode","primaryLang","localizedString","ret","contentEl","contentEl_","children","getChildById","getChild","getDescendant","acc","currentChild","addChild","component","componentName","componentClassName","componentClass","ComponentClass","getComponent","refNode","childFound","compEl","parentOptions","handleAdd","playerOptions","newChild","workingChildren","Tech","some","wchild","isTech","buildCSSClass","sync","isReady_","triggerReady","readyQueue","show","hide","lockShowing","unlockShowing","num","skipListeners","dimension","dimensions","widthOrHeight","pxIndex","parseInt","currentDimension","computedWidthOrHeight","isNaN","rule","currentDimensions","currentWidth","currentHeight","blur","handleKeyDown","handleKeyPress","emitTapEvents","touchStart","firstTouch","couldBeTap","touches","xdiff","ydiff","sqrt","noTap","reportUserActivity","report","touchHolding","clearInterval","setInterval","touchEnd","timeoutId","clearTimersOnDispose_","interval","intervalId","requestAnimationFrame","requestNamedAnimationFrame","cancelNamedAnimationFrame","cancelAnimationFrame","_ref4","idName","cancelName","ComponentToRegister","isComp","isPrototypeOf","reason","components_","Player","players","playerNames","pname","getRange","valueIndex","ranges","rangeIndex","maxIndex","rangeCheck","createTimeRangesObj","timeRangesObj","start","end","Symbol","iterator","createTimeRanges$1","registerComponent","defaultImplementation","seconds","guide","s","floor","h","gm","gh","Infinity","implementation","setFormatTime","customImplementation","resetFormatTime","formatTime","Time","createTimeRanges","createTimeRange","bufferedPercent","buffered","duration","bufferedDuration","MediaError","message","defaultMessages","status","errorTypes","errNum","tuple","reviver","json","JSON","parse","err","isPromise","then","silencePromise","trackToJson_","track","cues","cue","startTime","endTime","textTrackConverter","tech","trackEls","trackObjs","trackEl","src","textTracks","addedTrack","addRemoteTextTrack","addCue","ModalDialog","handleKeyDown_","close_","close","opened_","hasBeenOpened_","hasBeenFilled_","closeable","uncloseable","role","descEl_","description","super","tabIndex","label","previouslyActiveEl_","desc","open","fillAlways","fill","wasPlaying_","paused","pauseOnOpen","pause","hadControls_","controls","conditionalFocus_","opened","conditionalBlur_","temporary","closeable_","temp","controlText","fillWith","parentEl","nextSiblingEl","nextSibling","empty","closeButton","content_","activeEl","activeElement","playerEl","focusableEls","focusableEls_","focusIndex","shiftKey","allChildren","querySelectorAll","HTMLAnchorElement","HTMLAreaElement","hasAttribute","HTMLInputElement","HTMLSelectElement","HTMLTextAreaElement","HTMLButtonElement","HTMLIFrameElement","HTMLObjectElement","HTMLEmbedElement","TrackList","tracks","tracks_","addTrack","labelchange_","removeTrack","rtrack","l","getTrackById","change","addtrack","removetrack","labelchange","disableOthers$1","list","enabled","disableOthers","selected","TextTrackList","queueChange_","triggerSelectedlanguagechange","triggerSelectedlanguagechange_","kind","selectedlanguagechange_","TextTrackCueList","setCues_","length_","oldLength","cues_","defineProp","getCueById","VideoTrackKind","alternative","captions","main","sign","subtitles","commentary","AudioTrackKind","TextTrackKind","descriptions","chapters","metadata","TextTrackMode","hidden","showing","Track","trackProps","newLabel","parseUrl","url","props","a","href","details","protocol","host","location","getAbsoluteURL","getFileExtension","path","pathParts","pop","isCrossOrigin","winLoc","urlInfo","srcProtocol","crossOrigin","Url","window_1","_extends_1","_extends","__esModule","_extends$1","isFunction_1","alert","confirm","prompt","httpHandler","decodeResponseBody","response","responseBody","statusCode","cause","TextDecoder","charset","contentTypeHeader","contentType","_contentType$split","getCharset","headers","decode","Uint8Array","createXHR","lib","default_1","initParams","uri","params","_createXHR","called","getBody","xhr","responseText","responseType","responseXML","firefoxBugTakenEffect","getXml","isJson","errorFunc","evt","timeoutTimer","failureResponse","loadFunc","aborted","useXDR","rawRequest","getAllResponseHeaders","row","parseHeaders","cors","XDomainRequest","XMLHttpRequest","stringify","onreadystatechange","onload","onerror","onprogress","onabort","ontimeout","username","password","withCredentials","abort","setRequestHeader","isEmpty","beforeSend","send","array","forEachArray","default","parseCues","srcContent","parser","WebVTT","Parser","vttjs","StringDecoder","errors","oncue","onparsingerror","onflush","groupCollapsed","groupEnd","flush","loadTrack","tech_","loaded_","TextTrack","settings","srclang","mode","default_","activeCues_","preload_","preloadTextTracks","activeCues","changed","timeupdateHandler","rvf_","requestVideoFrameCallback","stopTracking","startTracking","defineProperties","newMode","ct","currentTime","active","cancelVideoFrameCallback","originalCue","VTTCue","originalCue_","removeCue","cuechange","AudioTrack","newEnabled","VideoTrack","newSelected","HTMLTrackElement","NONE","LOADED","load","LOADING","ERROR","NORMAL","audio","ListClass","changing_","enabledChange_","TrackClass","capitalName","video","selectedChange_","getterName","privateName","REMOTE","remoteText","remoteTextEl","trackElements","trackElements_","addTrackElement_","trackElement","getTrackElementByTrack_","trackElement_","removeTrackElement_","ALL","doccy","topLevel","document_1","_objCreate","create","F","o","ParsingError","errorData","parseTimeStamp","input","computeSeconds","f","Settings","parseOptions","keyValueDelim","groupDelim","groups","kv","parseCue","regionList","oInput","consumeTimeStamp","ts","Errors","BadTimeStamp","skipWhitespace","substr","v","region","alt","vals","vals0","integer","percent","vertical","line","lineAlign","snapToLines","align","center","middle","right","positionAlign","consumeCueSettings","BadSignature","dflt","defaultKey","TEXTAREA_ELEMENT","TAG_NAME","u","ruby","rt","lang","DEFAULT_COLOR_CLASS","white","lime","cyan","red","yellow","magenta","blue","black","TAG_ANNOTATION","NEEDS_PARENT","parseContent","nextToken","shouldAdd","localName","annotation","rootDiv","tagStack","innerHTML","createProcessingInstruction","classes","cl","bgColor","colorName","propValue","join","strongRTLRanges","isStrongRTLChar","currentRange","determineBidi","cueDiv","nodeStack","childNodes","pushNodes","nextTextNode","StyleBox","CueStyleBox","styleOptions","styles","color","backgroundColor","bottom","display","writingMode","unicodeBidi","applyStyles","div","direction","textAlign","font","whiteSpace","textPos","formatStyle","move","BoxPosition","lh","rects","getClientRects","lineHeight","moveBoxToLinePosition","styleBox","containerBox","boxPositions","boxPosition","linePos","textTrackList","mediaElement","trackList","count","computeLinePos","axis","step","round","maxPosition","initialAxis","abs","ceil","reverse","calculatedPercentage","bestPosition","specifiedPosition","percentage","overlapsOppositeAxis","within","overlapsAny","p","intersectPercentage","findBestPosition","toCSSCompatValues","WebVTT$1","unit","toMove","overlaps","b2","boxes","container","reference","getSimpleBoxPosition","decodeURIComponent","encodeURIComponent","convertCueToDOMTree","cuetext","processCues","overlay","paddedOverlay","margin","hasBeenReset","displayState","shouldCompute","fontSize","decoder","buffer","reportOrThrowError","collectNextLine","pos","parseHeader","ontimestampmap","parseTimestampMap","xy","anchor","VTTRegion","lines","regionAnchorX","regionAnchorY","viewportAnchorX","viewportAnchorY","scroll","onregion","parseRegion","stream","alreadyCollectedLine","hasSubstring","vtt","directionSetting","alignSetting","findAlignSetting","_id","_pauseOnExit","_startTime","_endTime","_text","_region","_vertical","_snapToLines","_line","_lineAlign","_position","_positionAlign","_size","_align","TypeError","setting","findDirectionSetting","SyntaxError","getCueAsHTML","vttcue","scrollSetting","isValidPercentValue","vttregion","_width","_lines","_regionAnchorX","_regionAnchorY","_viewportAnchorX","_viewportAnchorY","_scroll","findScrollSetting","browserIndex","cueShim","regionShim","nativeVTTCue","nativeVTTRegion","shim","restore","onDurationChange_","onDurationChange","trackProgress_","trackProgress","trackCurrentTime_","trackCurrentTime","stopTrackingCurrentTime_","stopTrackingCurrentTime","disposeSourceHandler_","disposeSourceHandler","queuedHanders_","hasStarted_","featuresProgressEvents","manualProgressOn","featuresTimeupdateEvents","manualTimeUpdatesOn","nativeCaptions","nativeTextTracks","featuresNativeTextTracks","emulateTextTracks","autoRemoteTextTracks_","initTrackListeners","nativeControlsForTouch","triggerSourceset","manualProgress","manualProgressOff","stopTrackingProgress","progressInterval","numBufferedPercent","bufferedPercent_","duration_","manualTimeUpdates","manualTimeUpdatesOff","currentTimeInterval","manuallyTriggered","clearTracks","removeRemoteTextTrack","cleanupAutoTextTracks","reset","setCrossOrigin","error_","played","setScrubbing","_isScrubbing","scrubbing","setCurrentTime","_seconds","trackListChanges","addWebVttScript_","script","remoteTracks","remoteTextTracks","handleAddTrack","handleRemoveTrack","updateDisplay","textTracksChanges","addTextTrack","createTrackHelper","createRemoteTextTrack","manualCleanup","htmlTrackElement","remoteTextTrackEls","getVideoPlaybackQuality","requestPictureInPicture","Promise","reject","disablePictureInPicture","setDisablePictureInPicture","cb","setPoster","playsinline","setPlaysinline","overrideNativeAudioTracks","override","overrideNativeVideoTracks","canPlayType","_type","srcObj","techs_","canPlaySource","defaultTechOrder_","featuresVolumeControl","featuresMuteControl","featuresFullscreenResize","featuresPlaybackRate","featuresSourceset","featuresVideoFrameCallback","withSourceHandlers","_Tech","registerSourceHandler","handler","sourceHandlers","can","selectSourceHandler","canHandleSource","sh","originalFn","sourceHandler_","setSource","nativeSourceHandler","currentSource_","handleSource","registerTech","middlewares","middlewareInstances","TERMINATOR","next","setSourceHelper","mediate","middleware","arg","callMethod","middlewareValue","middlewareIterator","terminated","executeRight","allowedGetters","muted","seekable","volume","ended","allowedSetters","setMuted","setVolume","allowedMediators","mw","mws","getOrCreateFactory","mwFactory","mwf","mwi","lastRun","mwrest","_src","MimetypesKind","opus","ogv","mp4","mov","m4v","mkv","m4a","mp3","aac","caf","flac","oga","wav","m3u8","mpd","jpg","jpeg","gif","png","svg","webp","getMimetype","ext","mimetype","filterSource","newsrc","srcobj","fixSource","j","techOrder","techName","getTech","isSupported","loadTech_","ClickableComponent","handleMouseOver_","handleMouseOver","handleMouseOut_","handleMouseOut","handleClick_","handleClick","tabIndex_","createControlTextEl","controlTextEl_","controlText_","localizedText","nonIconControl","noUITitleAttributes","enabled_","clickHandler","PosterImage","update","update_","crossorigin","poster","setSrc","loading","fontMap","monospace","sansSerif","serif","monospaceSansSerif","monospaceSerif","proportionalSansSerif","proportionalSerif","casual","smallcaps","constructColor","opacity","hex","tryUpdateStyle","updateDisplayHandler","toggleDisplay","preselectTrack","screenOrientation","screen","orientation","changeOrientationEvent","modes","userPref","cache_","selectedLanguage","firstDesc","firstCaptions","preferredTrack","clearDisplay","allowMultipleShowingTracks","showingTracks","updateForTrack","descriptionsTrack","captionsSubtitlesTrack","updateDisplayState","overrides","textTrackSettings","getValues","textOpacity","backgroundOpacity","windowColor","windowOpacity","edgeStyle","textShadow","fontPercent","fontFamily","fontVariant","cueEl","isAudio","playerType","dir","Button","BigPlayButton","mouseused_","handleMouseDown","playPromise","playToggle","playFocus","PlayToggle","replay","handlePlay","handlePause","handleEnded","handleSeeked","TimeDisplay","updateContent","updateTextNode_","span","labelText_","textNode_","time","formattedTime_","oldNode","CurrentTimeDisplay","getCache","DurationDisplay","RemainingTimeDisplay","displayNegative","remainingTimeDisplay","remainingTime","updateShowing","SeekToLive","updateLiveEdgeStatus","liveTracker","updateLiveEdgeStatusHandler_","textEl_","atLiveEdge","seekToLiveEdge","clamp","number","Num","Slider","handleMouseDown_","handleMouseUp_","handleMouseUp","handleMouseMove_","handleMouseMove","bar","barName","playerEvent","progress","getProgress","progress_","sizeKey","toFixed","getPercent","calculateDistance","stepBack","stepForward","bool","vertical_","percentify","partEls_","loadedText","separator","percentageEl_","isLive","seekableEnd","bufferedEnd","percent_","part","dataset","seekBarRect","seekBarPoint","tooltipRect","playerRect","seekBarPointPx","spaceLeftOfPoint","spaceRightOfPoint","pullTooltipBy","write","updateTime","liveWindow","secondsBehind","PlayProgressBar","timeTooltip","MouseTimeDisplay","SeekBar","setEventHandlers_","updateInterval","enableIntervalHandler_","enableInterval_","disableIntervalHandler_","disableInterval_","toggleVisibility_","visibilityState","getCurrentTime_","liveCurrentTime","currentTime_","userSeek_","nextSeekedFromUser","seekableStart","videoWasPlaying","newTime","mouseDown","distance","mouseTimeDisplay","handleAction","gotoFraction","STEP_SECONDS","ProgressControl","throttledHandleMouseSeek","handleMouseSeek","handleMouseUpHandler_","handleMouseDownHandler_","seekBar","playProgressBar","seekBarEl","removeListenersAddedOnMousedownAndTouchstart","PictureInPictureToggle","handlePictureInPictureChange","handlePictureInPictureEnabledChange","currentType","substring","audioPosterMode","audioOnlyMode","isInPictureInPicture","exitPictureInPicture","pictureInPictureEnabled","enableDocumentPictureInPicture","FullscreenToggle","handleFullscreenChange","fsApi_","fullscreenEnabled","isFullscreen","exitFullscreen","requestFullscreen","rangeBarRect","rangeBarPoint","volumeBarPointPx","updateVolume","MouseVolumeLevelDisplay","VolumeBar","updateLastVolume_","updateARIAAttributes","mouseVolumeLevelDisplay","volumeBarEl","volumeBarRect","volumeBarPoint","checkMuted","ariaValue","volumeAsPercentage_","volumeBeforeDrag","lastVolume_","VolumeControl","volumeBar","checkVolumeSupport","throttledHandleMouseMove","orientationClass","MuteToggle","checkMuteSupport","vol","lastVolume","volumeToSet","updateIcon_","updateControlText_","VolumePanel","inline","volumeControl","handleKeyPressHandler_","volumePanelState_","muteToggle","handleVolumeControlKeyUp","sliderActive_","sliderInactive_","validOptions","skipTime","getSkipForwardTime","includes","controlBar","skipButtons","forward","currentVideoTime","SkipBackward","getSkipBackwardTime","backward","Menu","menuButton_","menuButton","focusedChild_","boundHandleBlur_","handleBlur","boundHandleTapClick_","handleTapClick","addEventListenerForItem","removeEventListenerForItem","addItem","childComponent","contentElType","append","btn","buttonPressed_","unpressButton","childComponents","foundComponent","stepChild","MenuButton","buttonClass","handleMenuKeyUp_","handleMenuKeyUp","menu","handleMouseLeave","handleSubmenuKeyDown","createMenu","items","hideThreshold_","titleEl","titleComponent","createItems","buildWrapperCSSClass","menuButtonClass","pressButton","handleSubmenuKeyPress","TrackButton","updateHandler","MenuKeys","MenuItem","selectable","isSelected_","multiSelectable","TextTrackMenuItem","kinds","changeHandler","_this3","handleTracksChange","selectedLanguageChangeHandler","handleSelectedLanguageChange","onchange","Event","createEvent","initEvent","referenceTrack","shouldBeSelected","OffTextTrackMenuItem","allHidden","TextTrackButton","TrackMenuItem","label_","kinds_","kind_","ChaptersTrackMenuItem","ChaptersButton","selectCurrentItem_","track_","findChaptersTrack","setTrack","updateHandler_","remoteTextTrackEl","getMenuCaption","mi","DescriptionsButton","SubtitlesButton","CaptionSettingsMenuItem","CaptionsButton","SubsCapsMenuItem","parentSpan","SubsCapsButton","language_","AudioTrackMenuItem","audioTracks","_this4","featuresNativeAudioTracks","AudioTrackButton","PlaybackRateMenuItem","rate","playbackRate","PlaybackRateMenuButton","labelElId_","updateVisibility","updateLabel","handlePlaybackRateschange","labelEl_","rates","playbackRates","playbackRateSupported","Spacer","ControlBar","ErrorDisplay","COLOR_BLACK","COLOR_BLUE","COLOR_CYAN","COLOR_GREEN","COLOR_MAGENTA","COLOR_RED","COLOR_WHITE","COLOR_YELLOW","OPACITY_OPAQUE","OPACITY_SEMI","OPACITY_TRANS","selectConfigs","parseOptionValue","endDialog","setDefaults","persistTextTrackSettings","saveSettings","config","restoreSettings","createElSelect_","legendId","selectLabelledbyIds","optionId","createElFgColor_","createElBgColor_","createElWinColor_","createElColors_","createElFont_","createElControls_","defaultsDescription","selectedIndex","setValues","setSelectedOption","localStorage","getItem","setItem","removeItem","ttDisplay","subsCapsBtn","subsCapsButton","ccBtn","captionsButton","RESIZE_OBSERVER_AVAILABLE","ResizeObserver","loadListener_","resizeObserver_","debouncedHandler_","resizeHandler","observe","contentWindow","unloadListener_","unobserve","disconnect","resizeObserver","defaults","trackingThreshold","liveTolerance","trackLiveHandler_","trackLive_","handlePlay_","handleFirstTimeupdate_","handleFirstTimeupdate","handleSeeked_","seekToLiveEdge_","reset_","handleDurationchange","toggleTracking","deltaTime","lastTime_","pastSeekEnd_","pastSeekEnd","isBehind","seekedBehindLive_","timeupdateSeen_","behindLiveEdge_","liveui","isTracking","hasStarted","trackingInterval_","timeDiff","nextSeekedFromUser_","lastSeekEnd_","seekableEnds","sort","seekableStarts","behindLiveEdge","updateDom_","els","techEl","techAriaAttrs","techAriaAttr","sourcesetLoad","srcUrls","innerHTMLDescriptorPolyfill","cloneNode","dummy","docFrag","createDocumentFragment","Element","getDescriptor","priority","descriptor","getOwnPropertyDescriptor","firstSourceWatch","resetSourceWatch_","innerDescriptor","HTMLMediaElement","getInnerHTMLDescriptor","appendWrapper","appendFn","retval","srcDescriptorPolyfill","setupSourceset","resetSourceset_","srcDescriptor","getSrcDescriptor","oldSetAttribute","oldLoad","currentSrc","Html5","crossoriginTracks","initNetworkState_","handleLateInit_","enableSourceset","setupSourcesetHandling_","isScrubbing_","hasChildNodes","nodes","nodesLength","removeNodes","proxyNativeTracks_","restoreMetadataTracksInIOSNativePlayer_","setControls","proxyWebkitFullscreen_","disposeMediaElement","metadataTracksPreFullscreenState","takeMetadataTrackSnapshot","storedMode","restoreTrackMode","storedTrack","overrideNative_","lowerCaseType","eventName","proxyNativeTracksForType_","elTracks","techTracks","listeners","currentTarget","removeOldTracks","removeTracks","found","playerElIngest","movingMediaElementInDOM","clone","techId","class","playerId","preload","settingsAttrs","attr","networkState","loadstartFired","setLoadstartFired","triggerLoadstart","eventsToTrigger","isScrubbing","fastSeek","checkProgress","NaN","endFn","beginFn","webkitPresentationMode","nativeIOSFullscreen","supportsFullScreen","webkitEnterFullScreen","enterFullScreen","HAVE_METADATA","exitFullScreen","webkitDisplayingFullscreen","webkitExitFullScreen","webkitKeys","resetMediaElement","videoPlaybackQuality","webkitDroppedFrameCount","webkitDecodedFrameCount","droppedVideoFrames","totalVideoFrames","creationTime","TEST_VID","canControlVolume","canControl","canMuteVolume","canControlPlaybackRate","canOverrideAttributes","noop","supportsNativeTextTracks","supportsNativeVideoTracks","videoTracks","supportsNativeAudioTracks","TECH_EVENTS_RETRIGGER","TECH_EVENTS_QUEUE","canplay","canplaythrough","playing","seeked","BREAKPOINT_ORDER","BREAKPOINT_CLASSES","charAt","DEFAULT_BREAKPOINTS","tiny","xsmall","small","medium","large","xlarge","huge","getTagSettings","closest","boundDocumentFullscreenChange_","documentFullscreenChange_","boundFullWindowOnEscKey_","fullWindowOnEscKey","boundUpdateStyleEl_","updateStyleEl_","boundApplyInitTime_","applyInitTime_","boundUpdateCurrentBreakpoint_","updateCurrentBreakpoint_","boundHandleTechClick_","handleTechClick_","boundHandleTechDoubleClick_","handleTechDoubleClick_","boundHandleTechTouchStart_","handleTechTouchStart_","boundHandleTechTouchMove_","handleTechTouchMove_","boundHandleTechTouchEnd_","handleTechTouchEnd_","boundHandleTechTap_","handleTechTap_","isFullscreen_","isPosterFromTech_","queuedCallbacks_","userActive_","debugEnabled_","audioOnlyMode_","audioPosterMode_","audioOnlyCache_","playerHeight","hiddenChildren","tagAttributes","languagesToLower","languages_","resetCache_","poster_","controls_","changingSrc_","playCallbacks_","playTerminatedQueue_","autoplay","plugins","scrubbing_","fullscreenchange","fluid_","playerOptionsCopy","middleware_","majorVersion","userActive","listenForUserActivity_","breakpoints","responsive","styleEl_","playerElIngest_","divEmbed","tabindex","VIDEOJS_NO_DYNAMIC_STYLE","defaultsStyleEl","head","fill_","fluid","aspectRatio","links","linkEl","techGet_","techCall_","posterImage","privDimension","parsedVal","ratio","aspectRatio_","width_","height_","idClass","videoWidth","videoHeight","ratioParts","ratioMultiplier","unloadTech_","titleTechName","camelTechName","techName_","normalizeAutoplay","techOptions","loop","techCanOverridePoster","TechClass","handleTechReady_","textTracksJson_","eventObj","seeking","handleTechLoadStart_","handleTechSourceset_","handleTechWaiting_","handleTechEnded_","handleTechSeeking_","handleTechPlay_","handleTechPause_","handleTechDurationChange_","handleTechFullscreenChange_","handleTechFullscreenError_","handleTechEnterPictureInPicture_","handleTechLeavePictureInPicture_","handleTechError_","handleTechPosterChange_","handleTechTextData_","handleTechRateChange_","usingNativeControls","addTechControlsListeners_","safety","removeTechControlsListeners_","manualAutoplay_","resolveMuted","previouslyMuted","restoreMuted","mutedPromise","catch","promise","updateSourceCaches_","matchingSources","findMimetype","sourceElSources","sourceEls","matchingSourceEls","sourceObj","updateSourceCaches","playerSrc","currentSource","eventSrc","lastSource_","techSrc","techGet","request","lastPlaybackRate","queued","timeWhenWaiting","timeUpdateListener","handleTechCanPlay_","handleTechCanPlayThrough_","handleTechPlaying_","handleTechSeeked_","userActions","click","doubleClick","userWasActive","cancelable","toggleFullscreenClass_","targetPlayer","isFs","matches","fullscreen","msMatchesSelector","togglePictureInPictureClass_","initTime","inactivityTimeout","defaultPlaybackRate","media","reduceRight","resolve","play_","isSrcReady","isSafariOrIOS","waitToPlay_","resetProgressBar_","runPlayTerminatedQueue_","runPlayCallbacks_","queue","q","callbacks","percentAsDecimal","defaultMuted","isFS","oldValue","fullscreenOptions","offHandler","errorHandler","requestFullscreenHelper_","fsOptions","preferFullWindow","enterFullWindow","exitFullscreenHelper_","exitFullWindow","isFullWindow","docOrigOverflow","overflow","isPiP","isInPictureInPicture_","documentPictureInPicture","pipContainer","titleBar","requestWindow","initialAspectRatio","copyStyleSheets","pipWindow","pipVideo","replaceWith","hotkeys","isContentEditable","excludeElement","handleHotkeys","fullscreenKey","keydownEvent","muteKey","playPauseKey","FSToggle","selectSource","techs","_ref6","findFirstPassingTechSourcePair","outerArray","innerArray","tester","outerChoice","innerChoice","foundSourceAndTech","finder","sourceOrder","handleSrc_","isRetry","resetRetryOnError_","middlewareSource","src_","notSupportedMessage","setTech","retry","stopListeningForErrors","sourceTech","doReset_","resetControlBarUI_","resetPlaybackRate_","resetVolumeBar_","currentTimeDisplay","durationDisplay","progressControl","loadProgressBar","currentSources","techAutoplay","newPoster","usingNativeControls_","hookFunction","newErr","suppressNotSupportedError","triggerSuppressedError","errorDisplay","userActivity_","mouseInProgress","lastMoveX","lastMoveY","handleActivity","handleMouseUpAndMouseLeave","screenX","screenY","isAudio_","enableAudioOnlyUI_","playerChildren","controlBarHeight","disableAudioOnlyUI_","exitPromises","enablePosterModeUI_","disablePosterModeUI_","toJSON","createModal","modal","currentBreakpoint","candidateBreakpoint","breakpoints_","breakpoint_","removeCurrentBreakpoint_","currentBreakpointClass","responsive_","loadMedia","artist","artwork","tt","getMedia","baseOptions","tagOptions","dataSetup","childName","previousLogLevel_","newRates","html5","userLanguage","navigationUI","pluginStorage","pluginExists","getPlugin","markPluginAsActive","triggerSetupEvent","before","createPluginFactory","PluginSubClass","plugin","instance","getEventHash","Plugin","VERSION","isBasic","basicPluginWrapper","createBasicPlugin","deprecateForMajor","oldName","newName","warned","deprecate","BASE_PLUGIN_NAME","registerPlugin","usingPlugin","hasPlugin","normalizeId","getPlayer","defaultView","PlayerComponent","hook","hookOnce","original","getPlayers","nId","getAllPlayers","comp","use","writeable","mergeOptions","deregisterPlugin","getPlugins","getPluginVersion","addLanguage","EventTarget","dom","_interopDefaultLegacy","videojs__default","QualityLevel","representation","bitrate","bandwidth","frameRate","QualityLevelList","levels_","selectedIndex_","addQualityLevel","qualityLevel","getQualityLevelById","removeQualityLevel","removed","addqualitylevel","removequalitylevel","initPlugin","originalPluginFn","qualityLevels","qualityLevelList","disposeHandler","urlToolkit","URL_REGEX","FIRST_SEGMENT_REGEX","SLASH_DOT_REGEX","SLASH_DOT_DOT_REGEX","URLToolkit","buildAbsoluteURL","baseURL","relativeURL","alwaysNormalize","basePartsForNormalise","parseURL","normalizePath","buildURLFromParts","relativeParts","scheme","baseParts","netLoc","builtParts","query","fragment","baseURLPath","newPath","lastIndexOf","parts","Stream","_proto","_length","_i","pipe","destination","decodeB64ToUint8Array$1","b64Text","decodedString","atob","Buffer","LineStream","nextNewline","TAB","parseByterange","byterangeString","offset","parseAttributes$1","ParseStream","customParsers","tagMappers","mapper","mappedLine","newLine","tagType","playlistType","allowed","URI","BYTERANGE","byterange","RESOLUTION","resolution","BANDWIDTH","dateTimeString","dateTimeObject","Date","IV","Uint32Array","PRECISE","subkey","addParser","expression","customType","dataParser","segment","addTagMapper","camelCaseKeys","setHoldBack","manifest","serverControl","targetDuration","partTargetDuration","hb","phb","minTargetDuration","minPartDuration","lineStream","parseStream","uris","currentMap","currentUri","hasParts","defaultMediaGroups","currentTimeline","allowCache","discontinuityStarts","segments","lastByterangeEnd","lastPartByterangeEnd","preloadHints","timeline","preloadSegment","entry","mediaGroup","rendition","endlist","endList","inf","mediaSequence","discontinuitySequence","METHOD","KEYFORMAT","contentProtection","KEYID","schemeIdUri","keyId","pssh","iv","isFinite","playlist","playlists","mediaGroups","TYPE","NAME","mediaGroupType","autoselect","AUTOSELECT","LANGUAGE","instreamId","CHARACTERISTICS","characteristics","FORCED","forced","discontinuity","targetduration","timeOffset","precise","cueOut","cueOutCont","cueIn","skip","warnOnMissingAttributes_","segmentIndex","partIndex","renditionReports","r","canBlockReload","canSkipDateranges","hint","isPart","otherHint","required","partInf","partTarget","comment","custom","identifier","missing","chunk","regexs","webm","ogg","muxerVideo","muxerAudio","muxerText","mediaTypes","upperMediaTypes","translateLegacyCodec","codec","orig","profile","avcLevel","parseCodecs","codecString","codecs","codecType","mediaType","isAudioCodec","getMimeForCodec","browserSupportsCodec","MediaSource","isTypeSupported","muxerSupportsCodec","MPEGURL_REGEX","DASH_REGEX","simpleTypeFromSourceType","isArrayBufferView","ArrayBuffer","isView","toUint8","bytes","byteOffset","byteLength","BigInt","BYTE_TABLE","Uint16Array","bytesToNumber","_temp","_ref","_ref$signed","signed","_ref$le","le","total","byte","exponent","numberToBytes","_temp2","_ref2$le","byteCount","countBits","countBytes","byteIndex","stringToBytes","stringIsBytes","unescape","view","bytesMatch","_temp3","_ref3","_ref3$offset","_ref3$mask","mask","bByte","resolveUrl$1","baseUrl","relativeUrl","nativeURL","URL","protocolLess","removeLocation","newUrl","decodeB64ToUint8Array","oc","MIME_TYPE","HTML","isHTML","XML_APPLICATION","XML_TEXT","XML_XHTML_APPLICATION","XML_SVG_IMAGE","NAMESPACE$3","SVG","XML","XMLNS","conventions","ac","NAMESPACE","NAMESPACE$2","notEmptyString","orderedSetReducer","toOrderedSet","splitOnASCIIWhitespace","copy","dest","Class","Super","pt","NodeType","ELEMENT_NODE","ATTRIBUTE_NODE","TEXT_NODE","CDATA_SECTION_NODE","ENTITY_REFERENCE_NODE","ENTITY_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","NOTATION_NODE","ExceptionCode","ExceptionMessage","INDEX_SIZE_ERR","DOMSTRING_SIZE_ERR","HIERARCHY_REQUEST_ERR","WRONG_DOCUMENT_ERR","INVALID_CHARACTER_ERR","NO_DATA_ALLOWED_ERR","NO_MODIFICATION_ALLOWED_ERR","NOT_FOUND_ERR","NOT_SUPPORTED_ERR","INUSE_ATTRIBUTE_ERR","DOMException","captureStackTrace","NodeList","LiveNodeList","refresh","_node","_refresh","_updateLiveList","inc","_inc","ls","__set__","NamedNodeMap","_findNodeIndex","_addNamedNode","newAttr","oldAttr","ownerElement","_onRemoveAttribute","namespaceURI","_nsMap","prefix","_onAddAttribute","_removeNamedNode","lastIndex","DOMImplementation$1","Node","_xmlEncoder","_visitNode","Document","_onUpdateChild","cs","_removeChild","previous","previousSibling","lastChild","isDocTypeNode","isElementNode","isElementInsertionPossible","parentChildNodes","docTypeNode","isElementReplacementPossible","assertPreInsertionValidity1to5","hasValidParentNodeType","hasInsertableNodeType","assertPreInsertionValidityInDocument","nodeChildNodes","nodeChildElements","parentElementChild","assertPreReplacementValidityInDocument","hasDoctypeChildThatIsNotChild","_insertBefore","_inDocumentAssertion","cp","newFirst","newLast","pre","Attr","CharacterData","Text","Comment","CDATASection","DocumentType","Notation","Entity","EntityReference","DocumentFragment","ProcessingInstruction","XMLSerializer","nodeSerializeToString","isHtml","nodeFilter","buf","lookupPrefix","visibleNamespaces","namespace","serializeToString","needNamespaceDefine","ns","addSerializedAttribute","qualifiedName","len","prefixedNodeName","defaultNS","ai","nsi","pubid","publicId","sysid","systemId","sub","internalSubset","importNode","deep","node2","attrs2","_ownerElement","setAttributeNode","INVALID_STATE_ERR","SYNTAX_ERR","INVALID_MODIFICATION_ERR","NAMESPACE_ERR","INVALID_ACCESS_ERR","getNamedItem","setNamedItem","setNamedItemNS","getNamedItemNS","removeNamedItem","removeNamedItemNS","hasFeature","feature","createDocument","doctype","root","createElementNS","createDocumentType","nodeValue","refChild","oldChild","normalize","appendData","hasAttributes","lookupNamespaceURI","isDefaultNamespace","importedNode","getElementById","rtv","getElementsByClassName","classNames","classNamesSet","base","nodeClassNames","nodeClassNamesSet","createComment","createCDATASection","createAttribute","specified","createEntityReference","pl","createAttributeNS","getAttributeNode","removeAttributeNode","_appendSingleChild","setAttributeNodeNS","removeAttributeNS","getAttributeNodeNS","hasAttributeNS","getAttributeNS","setAttributeNS","getElementsByTagNameNS","substringData","insertData","replaceData","deleteData","splitText","newText","newNode","getTextContent","$$length","DOMImplementation","entities","XML_ENTITIES","amp","apos","gt","lt","quot","HTML_ENTITIES","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","times","divide","forall","exist","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","infin","ang","and","or","cap","cup","there4","sim","cong","asymp","ne","equiv","ge","sup","nsub","sube","supe","oplus","otimes","perp","sdot","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","tilde","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","euro","trade","larr","uarr","rarr","darr","harr","crarr","lceil","rceil","lfloor","rfloor","loz","spades","clubs","hearts","diams","entityMap","NAMESPACE$1","nameStartChar","nameChar","tagNamePattern","ParseError$1","locator","XMLReader$1","copyLocator","lineNumber","columnNumber","parseElementStartPart","currentNSMap","entityReplacer","addAttribute","qname","startIndex","attributeNames","fatalError","addValue","warning","setTagName","closed","appendElement$1","domBuilder","localNSMap","qName","nsp","nsPrefix","_copy","startPrefixMapping","startElement","endElement","endPrefixMapping","parseHtmlSpecialContent","elStartEnd","elEndStart","characters","fixSelfClosed","closeMap","parseDCC","startCDATA","endCDATA","matchs","lastMatch","startDTD","endDTD","parseInstruction","processingInstruction","ElementAttributes","defaultNSMap","startDocument","defaultNSMapCopy","fixedFromCharCode","surrogate1","surrogate2","appendText","xt","lineEnd","linePattern","lineStart","parseStack","tagStart","currentElement","endMatch","locator2","parse$1","endDocument","getLocalName","getLocator","getQName","getURI","sax","XMLReader","ParseError","normalizeLineEndings","DOMParser$1","DOMHandler","cdata","_locator","_toString","chars","java","appendElement","hander","parseFromString","mimeType","xmlns","setDocumentLocator","errorImpl","isCallback","Function","build","msg","buildErrorHandler","xml","documentURI","ins","ignorableWhitespace","ch","charNode","skippedEntity","comm","impl","dt","DOMParser","__DOMHandler","merge$1","objects","flatten","lists","urlTypeToSegment","_ref10","range","indexRange","resolvedUri","startRange","endRange","MAX_SAFE_INTEGER","parseEndNumber","endNumber","segmentRange","static","timescale","sourceDuration","periodDuration","segmentDuration","dynamic","NOW","clientOffset","availabilityStartTime","periodStart","minimumUpdatePeriod","timeShiftBufferDepth","periodStartWC","segmentCount","availableStart","availableEnd","parseByDuration","startNumber","toSegments","sectionDuration","segmentsFromBase","initialization","presentationTime","initSegment","sourceURL","segmentTimeInfo","addSidxSegmentsToPlaylist$1","sidx","sidxByteRange","sidxEnd","mediaReferences","references","referenceType","firstOffset","referencedSize","subsegmentDuration","endIndex","SUPPORTED_MEDIA_TYPES","getUniqueTimelineStarts","timelineStarts","keyFunction","_ref11","getMediaGroupPlaylists","mediaGroupPlaylists","master","group","groupKey","labelKey","mediaProperties","updateMediaSequenceForPlaylist","_ref12","positionManifestOnTimeline","_ref15","oldManifest","newManifest","oldPlaylists","newPlaylists","_ref13","findIndex","oldPlaylist","findPlaylistWithName","firstNewSegment","oldMatchingSegmentIndex","oldSegment","updateSequenceNumbers","generateSidxKey","byteRangeToString","mergeDiscontiguousPlaylists","addSidxSegmentsToPlaylist","sidxMapping","sidxKey","sidxMatch","addSidxSegmentsToPlaylists","formatAudioPlaylist","isAudioOnly","CODECS","AUDIO","SUBTITLES","formatVttPlaylist","_ref17","m3u8Attributes","formatVideoPlaylist","_ref18","videoOnly","_ref19","audioOnly","_ref20","vttOnly","_ref21","flattenMediaGroupPlaylists","mediaGroupObject","labelContents","toM3u8","_ref23","dashPlaylists","locations","previousManifest","suggestedPresentationDelay","videoPlaylists","audioPlaylists","vttPlaylists","captionServices","VIDEO","organizedAudioGroup","mainPlaylist","formattedPlaylists","roleLabel","formatted","organizeAudioPlaylists","organizedVttGroup","organizeVttPlaylists","playlistTimelineStarts","_ref24","subs","cc","svcObj","svc","service","channel","easyReader","getLiveRValue","parseByTimeline","segmentTimeline","sIndex","S","d","repeat","segmentTime","nextS","identifierPattern","constructTemplateUrl","format","identifierReplacement","segmentsFromTemplate","templateValues","RepresentationID","Bandwidth","mapSegment","parseTemplateInfo","presentationTimeOffset","segmentsFromList","segmentUrls","segmentUrlMap","segmentUrlObject","segmentUrl","mediaRange","SegmentURLToSegmentObject","generateSegments","_ref25","segmentAttributes","segmentsFn","segmentInfo","template","segmentsInfo","toPlaylists","representations","findChildren","_ref26","getContent","parseDuration","year","month","day","hour","minute","second","parsers","mediaPresentationDuration","parseDivisionValue","parsedValue","parseAttributes","parseFn","keySystemsMap","buildBaseUrls","referenceUrls","baseUrlElements","baseUrlElement","getSegmentInformation","adaptationSet","segmentTemplate","segmentList","segmentBase","segmentTimelineParentNode","segmentInitializationParentNode","segmentInitialization","toRepresentations","periodAttributes","periodBaseUrls","periodSegmentInfo","adaptationSetAttributes","adaptationSetBaseUrls","roleAttributes","accessibility","flags","opt","parseCaptionServiceMetadata","labelVal","keySystem","psshNode","adaptationSetSegmentInfo","repBaseUrlElements","repBaseUrls","representationSegmentInfo","inheritBaseUrls","toAdaptationSets","mpdAttributes","mpdBaseUrls","period","adaptationSets","getPeriodStart","_ref27","priorPeriodAttributes","mpdType","inheritAttributes","manifestUri","periodNodes","periods","priorPeriod","representationInfo","stringToMpdXml","manifestString","parseUTCTiming","UTCTimingNode","parseUTCTimingScheme","MAX_UINT32","pow","getUint64","uint8","dv","DataView","getBigUint64","getUint32","parseSidx_1","subarray","referenceId","earliestPresentationTime","referenceCount","getUint16","startsWithSap","sapType","sapDeltaTime","ID3","getId3Offset","returnSize","getId3Size","normalizePath$1","findBox","paths","complete","normalizePaths$1","results","EBML_TAGS","EBML","DocType","Segment","SegmentInfo","Tracks","TrackNumber","DefaultDuration","TrackEntry","TrackType","FlagDefault","CodecID","CodecPrivate","Cluster","Timestamp","TimestampScale","BlockGroup","BlockDuration","Block","SimpleBlock","LENGTH_TABLE","getvint","removeLength","getLength","valueBytes","getInfinityDataSize","innerid","dataHeader","findEbml","normalizePaths","dataStart","dataEnd","NAL_TYPE_ONE","NAL_TYPE_TWO","EMULATION_PREVENTION","discardEmulationPreventionBytes","positions","newLength","newData","sourceIndex","findNal","dataType","nalLimit","nalStart","nalsFound","nalOffset","nalType","CONSTANTS","_isLikely","docType","matroska","fmp4","moof","moov","ac3","avi","riff","findH264Nal","findH265Nal","isLikelyTypes","isLikelyFn","secondsToVideoTs","secondsToAudioTs","videoTsToSeconds","audioTsToSeconds","isLikely","detectContainerForBytes","sampleRate","timestamp","clock_1","resolveUrl","resolveManifestRedirect","req","responseURL","logger","filterRanges","timeRanges","findRange","TIME_FUDGE_FACTOR","findNextRange","printableRange","strArr","timeRangesToArray","timeRangesList","lastBufferedEnd","timeAheadOf","segmentDurationWithParts","getPartsAndSegments","si","getLastParts","lastSegment","getKnownPartCount","_ref28","partCount","liveEdgeDelay","partHoldBack","holdBack","intervalDuration","endSequence","expired","backwardDuration","forwardDuration","totalDuration","sumDurations","defaultDuration","durationList","durations","playlistEnd","useSafeLiveEnd","liveEdgePadding","lastSegmentEndTime","isExcluded","excludeUntil","isIncompatible","isEnabled","excluded","isLowestEnabledRendition","currentBandwidth","MAX_VALUE","playlistMatch","someAudioVariant","groupName","variant","Playlist","getMediaInfoForTime","startingSegmentIndex","startingPartIndex","exactManifestTimings","partsAndSegments","partAndSegment","isDisabled","isAes","estimateSegmentRequestTime","bytesReceived","createPlaylistID","groupID","forEachMediaGroup","setupMediaPlaylist","_ref32","playlistErrors_","setupMediaPlaylists","resolveMediaGroupUris","addPropertiesToMain","createGroupID","phonyUri","audioOnlyMain","groupId","EventTarget$1","updateSegment","skipped","updateSegments","oldSegments","newSegments","newIndex","newSegment","resolveSegmentUris","baseUri","getAllSegments","isPlaylistUnchanged","updateMain$1","newMedia","unchangedCheck","oldMedia","mergedPlaylist","skippedSegments","refreshDelay","lastPart","lastDuration","PlaylistLoader","vhs","logger_","vhs_","vhsOptions","customTagParsers","customTagMappers","llhls","handleMediaupdatetimeout_","parameters","nextMSN","nextPart","_HLS_part","_HLS_msn","canSkipUntil","_HLS_skip","parsedUri","searchParams","addLLHLSQueryDirectives","playlistRequestError","haveMetadata","playlistString","startingState","parseManifest_","_ref31","onwarn","oninfo","customParser","parseManifest","_ref34","_ref35","playlistObject","lastRequest","pendingMedia_","media_","updateMediaUpdateTimeout_","stopRequest","mediaUpdateTimeout","finalRenditionTimeout","oldRequest","shouldDelay","delay","mediaChange","mainPlaylistRef","started","setupInitialPlaylist","srcUri","mainForMedia","videojsXHR","callbackWrapper","reqResponse","responseTime","roundTripTime","requestTime","responseHeaders","timedout","xhrFactory","XhrFunction","beforeRequest","Vhs","newOptions","originalAbort","segmentXhrHeaders","Range","byterangeEnd","byterangeStart","byterangeStr","textRange","formatHexString","formatAsciiString","createTransferableMessage","transferable","initSegmentId","segmentKeyId","hexDump","ascii","utils","tagDump","_ref37","textRanges","getProgramTime","_ref38","matchedSegment","segmentEnd","videoTimingInfo","transmuxedPresentationEnd","estimatedStart","transmuxedPresentationStart","findSegmentForPlayerTime","seekTime","programTimeObject","mediaSeconds","programTime","playerTime","transmuxerPrependedSeconds","offsetFromSegmentStart","getTime","playerTimeToProgramTime","programDateTime","toISOString","seekToProgramTime","_ref39","retryCount","seekTo","pauseAfterSeek","verifyProgramDateTimeTags","lastSegmentStart","lastSegmentDuration","findSegmentForProgramTime","mediaOffset","comparisonTimeStamp","segmentDateTime","segmentTimeEpoch","getOffsetFromTimestamp","seekToTime","callbackOnCompleted","containerRequest","id3Offset","finished","endRequestAndCallback","_bytes","progressListener","newPart","_len","buffers","_key","totalLen","tempBuffer","concatTypedArrays","overrideMimeType","loaded","dashPlaylistUnchanged","aSegment","bSegment","aByterange","bByterange","dashGroupId","playlistId","parseMainXml","_ref41","mainXml","srcUrl","parsedManifestInfo","updateMain","oldMain","newMain","noChanges","playlistUpdate","removeOldMediaGroupLabels","equivalentSidx","compareSidxEntry","oldSidxMapping","newSidxMapping","currentSidxInfo","savedSidxInfo","sidxInfo","DashPlaylistLoader","srcUrlOrPlaylist","mainPlaylistLoader","mainPlaylistLoader_","isMain_","refreshXml_","refreshMedia_","loadedPlaylists_","sidxMapping_","childPlaylist_","requestErrored_","addSidxSegments_","mediaRequest_","fin","internal","playlistExclusionDuration","minimumUpdatePeriodTimeout_","createMupOnMedia_","hasPendingRequest","sidxChanged","isFinalRendition","updateMinimumUpdatePeriodTimeout_","requestMain_","mainChanged","haveMain_","mainXml_","date","mainLoaded_","handleMain_","syncClientServerClock_","done","utcTiming","clientOffset_","serverTime","mpl","mup","createMUPTimeout_","mediaGroupSidx","filterChangedSidxMappings","mediaID","mediaChanged","createMediaUpdateTimeout","Config","GOAL_BUFFER_LENGTH","MAX_GOAL_BUFFER_LENGTH","BACK_BUFFER_LENGTH","GOAL_BUFFER_LENGTH_RATE","INITIAL_BANDWIDTH","BANDWIDTH_VARIANCE","BUFFER_LOW_WATER_LINE","MAX_BUFFER_LOW_WATER_LINE","EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE","BUFFER_LOW_WATER_LINE_RATE","BUFFER_HIGH_WATER_LINE","browserWorkerPolyFill","workerObj","objectUrl","createObjectURL","Blob","blob","BlobBuilder","getBlob","worker","Worker","objURL","terminate","revokeObjectURL","getWorkerString","workerCode$1","Stream$8","init","flushSource","partialFlush","endTimeline","dinf","esds","ftyp","mfhd","minf","mvex","mvhd","trak","tkhd","mdia","mdhd","hdlr","sdtp","stbl","stsd","traf","trex","trun$1","MAJOR_BRAND","MINOR_VERSION","AVC1_BRAND","VIDEO_HDLR","AUDIO_HDLR","HDLR_TYPES","VMHD","SMHD","DREF","STCO","STSC","STSZ","STTS","videoSample","audioSample","audioTrun","videoTrun","trunHeader","MAX_UINT32$1","numbers","avc1","avcC","btrt","dref","mdat","mp4a","pasp","smhd","stco","stsc","stsz","stts","styp","tfdt","tfhd","trun","vmhd","payload","setUint32","audioobjecttype","samplingfrequencyindex","channelcount","samplerate","sequenceNumber","trackFragments","samples","dependsOn","isDependedOn","hasRedundancy","avc1Box","sps","pps","sequenceParameterSets","pictureParameterSets","profileIdc","profileCompatibility","levelIdc","sarRatio","hSpacing","vSpacing","samplesize","trackFragmentHeader","trackFragmentDecodeTime","trackFragmentRun","sampleDependencyTable","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","baseMediaDecodeTime","durationPresent","sizePresent","flagsPresent","compositionTimeOffset","bytesOffest","header","sample","isLeading","paddingValue","isNonSyncSample","degradationPriority","silence","audioTsToVideoTs","videoTsToAudioTs","metadataTsToSeconds","mp4Generator","fileType","movie","sampleForFrame","frame","dataOffset","pts","dts","keyFrame","frameUtils$1","groupNalsIntoFrames","nalUnits","currentNal","currentFrame","frames","nalCount","nalUnitType","groupFramesIntoGops","currentGop","gops","extendFirstKeyFrame","generateSampleTable","baseDataOffset","concatenateNalData","nalsByteLength","numberOfNals","generateSampleTableForFrame","concatenateNalDataForFrame","highPrefix","lowPrefix","zeroFill","timelineStartPts","keepOriginalTimestamps","clock$2","ONE_SECOND_IN_TS","coneOfSilence","metaTable","arr","clock$1","audioFrameUtils$1","prefixWithSilence","audioAppendStartTs","videoBaseMediaDecodeTime","baseMediaDecodeTimeTs","frameDuration","silentFrame","firstFrame","audioGapDuration","audioFillFrameCount","audioFillDuration","trimAdtsFramesByEarliestDts","adtsFrames","earliestAllowedDts","minSegmentDts","minSegmentPts","concatenateFrameData","sumFrameByteLengths","ONE_SECOND_IN_TS$3","trackDecodeInfo$1","clearDtsInfo","maxSegmentDts","maxSegmentPts","calculateTrackBaseMediaDecodeTime","timelineStartInfo","collectDtsInfo","captionPacketParser","parseSei","payloadType","payloadSize","parseUserData","sei","parseCaptionPackets","userData","ccData","emulationPreventionBytesPositions","USER_DATA_REGISTERED_ITU_T_T35","Stream$7","cea708Parser","CaptionStream$2","parse708captions_","parse708captions","captionPackets_","ccStreams_","Cea608Stream","cc708Stream_","Cea708Stream","newCaptionPackets","escapedRBSP","latestDts_","ignoreNextEqualDts_","numSameDts_","flushCCStreams","flushType","flushStream","idx","presortIndex","packet","dispatchCea608Packet","dispatchCea708Packet","activeCea608Channel_","ccStream","setsTextOrXDSActive","setsChannel1Active","setsChannel2Active","CHARACTER_TRANSLATION_708","within708TextBlock","Cea708Window","windowNum","clearText","pendingNewLine","winAttr","penAttr","penLoc","penColor","visible","rowLock","columnLock","relativePositioning","anchorVertical","anchorHorizontal","anchorPoint","rowCount","virtualRowCount","columnCount","windowStyle","penStyle","getText","rows","rowIdx","beforeRowOverflow","addText","backspace","Cea708Service","serviceNum","encoding","currentWindow","windows","createTextDecoder","startPts","win","setCurrentWindow","textDecoder_","serviceProps","captionServiceEncodings","serviceName","serviceEncodings","current708Packet","services","new708Packet","add708Bytes","push708Packet","ptsVals","byte0","byte1","packet708","packetData","blockSize","seq","sizeCode","pushServiceBlock","initService","handleText","multiByteCharacter","extendedCommands","defineWindow","clearWindows","deleteWindows","displayWindows","hideWindows","toggleWindows","setWindowAttributes","setPenAttributes","setPenColor","setPenLocation","isExtended","getPts","flushDisplayed","char","charCodeArray","newCode","isMultiByte","extended","currentByte","nextByte","firstByte","secondByte","fillOpacity","fillRed","fillGreen","fillBlue","borderType","borderRed","borderGreen","borderBlue","wordWrap","printDirection","scrollDirection","justify","effectSpeed","effectDirection","displayEffect","displayedText","winId","endPts","pushCaption","textTag","penSize","italics","underline","edgeType","fontStyle","fgOpacity","fgRed","fgGreen","fgBlue","bgOpacity","bgRed","bgGreen","bgBlue","edgeRed","edgeGreen","edgeBlue","column","CHARACTER_TRANSLATION","getCharFromCode","ROWS","createDisplayBuffer","BOTTOM_ROW","field","dataChannel","field_","dataChannel_","setConstants","swap","char0","char1","lastControlCode_","PADDING_","RESUME_CAPTION_LOADING_","mode_","END_OF_CAPTION_","clearFormatting","displayed_","nonDisplayed_","startPts_","ROLL_UP_2_ROWS_","rollUpRows_","setRollUp","ROLL_UP_3_ROWS_","ROLL_UP_4_ROWS_","CARRIAGE_RETURN_","shiftRowsUp_","BACKSPACE_","row_","ERASE_DISPLAYED_MEMORY_","ERASE_NON_DISPLAYED_MEMORY_","RESUME_DIRECT_CAPTIONING_","isSpecialCharacter","column_","isExtCharacter","isMidRowCode","addFormatting","isOffsetControlCode","isPAC","formatting_","isColorPAC","isNormalChar","topRow_","BASE_","EXT_","CONTROL_","OFFSET_","newBaseRow","popOn","baseRow","rollUp","paintOn","captionStream","CaptionStream","streamTypes","H264_STREAM_TYPE","ADTS_STREAM_TYPE","METADATA_STREAM_TYPE","Stream$6","handleRollover$1","TimestampRolloverStream$1","lastDTS","referenceDTS","type_","MetadataStream","timestampRolloverStream","TimestampRolloverStream","handleRollover","typedArray","fromIndex","currentIndex","typedArrayIndexOf","textEncodingDescriptionByte","percentEncode$1","parseUtf8","parseIso88591$1","parseSyncSafeInteger$1","frameParsers","mimeTypeEndIndex","descriptionEndIndex","pictureType","pictureData","owner","privateData","parseId3","parseId3Frames","frameSize","frameStart","tagSize","parseSyncSafeInteger","StreamTypes$3","id3","bufferSize","dispatchType","dataAlignmentIndicator","timeStamp","TransportPacketStream","TransportParseStream","ElementaryStream","metadataStream","Stream$4","CaptionStream$1","StreamTypes$2","bytesInBuffer","everything","parsePsi","parsePat","parsePmt","packetsWaitingForPmt","programMapTable","payloadUnitStartIndicator","pat","section_number","last_section_number","pmtPid","pmt","tableEnd","streamType","pid","processPes_","STREAM_TYPES","h264","adts","segmentHadPmt","timedMetadata","forceFlush","packetFlushable","trackId","pes","ptsDtsFlags","startPrefix","packetLength","parsePes","flushStreams_","m2ts$1","PAT_PID","MP2T_PACKET_LENGTH","AdtsStream$1","m2ts_1","ONE_SECOND_IN_TS$2","ADTS_SAMPLING_FREQUENCIES$1","handlePartialSegments","frameNum","skipWarn_","frameLength","protectionSkipBytes","oldBuffer","sampleCount","adtsFrameDuration","ExpGolomb$1","workingData","workingBytesAvailable","workingWord","workingBitsAvailable","bitsAvailable","loadWord","workingBytes","availableBytes","skipBits","skipBytes","readBits","bits","valu","skipLeadingZeros","leadingZeroCount","skipUnsignedExpGolomb","skipExpGolomb","readUnsignedExpGolomb","clz","readExpGolomb","readBoolean","readUnsignedByte","H264Stream$1","NalByteStream","PROFILES_WITH_OPTIONAL_SPS_DATA","Stream$2","ExpGolomb","syncPoint","swapBuffer","currentPts","currentDts","readSequenceParameterSet","skipScalingList","nalByteStream","nalUnitTypeCode","expGolombDecoder","lastScale","nextScale","chromaFormatIdc","picOrderCntType","numRefFramesInPicOrderCntCycle","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","frameMbsOnlyFlag","scalingListCount","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","AacStream$1","H264Stream","ADTS_SAMPLING_FREQUENCIES","parseId3TagSize","isLikelyAacData","parseAdtsSize","lowThree","parseType","parseSampleRate","parseAacTimestamp","percentEncode","aacUtils","setTimestamp","bytesLeft","tempLength","VideoSegmentStream","AudioSegmentStream","Transmuxer","CoalesceStream","frameUtils","audioFrameUtils","trackDecodeInfo","m2ts","clock","AdtsStream","AacStream","ONE_SECOND_IN_TS$1","AUDIO_PROPERTIES","VIDEO_PROPERTIES","retriggerForStream","addPipelineLogRetriggers","transmuxer","pipeline","arrayEquals","generateSegmentTimingInfo","startDts","endDts","prependedContentDuration","firstSequenceNumber","setEarliestDts","earliestDts","setVideoBaseMediaDecodeTime","setAudioAppendStart","videoClockCyclesOfSilencePrefixed","gopsToAlignWith","minPTS","gopCache_","nalUnit","gopForFusion","firstGop","lastGop","resetStream_","getGopForFusion_","alignedGops","alignGopsAtEnd","alignGopsAtEnd_","alignGopsAtStart_","gop","dtsDistance","nearestGopObj","currentGopObj","nearestDistance","alignIndex","gopIndex","alignEndIndex","matchFound","trimIndex","alignGopsWith","newGopsToAlignWith","numberOfTracks","remux","remuxTracks","pendingTracks","videoTrack","pendingBoxes","pendingCaptions","pendingMetadata","pendingBytes","emittedTracks","output","audioTrack","caption","captionStreams","cueTime","setRemux","hasFlushed","transmuxPipeline_","setupAacPipeline","aacStream","audioTimestampRolloverStream","timedMetadataTimestampRolloverStream","adtsStream","coalesceStream","headOfPipeline","audioSegmentStream","getLogTrigger_","hasAudio","hasVideo","setupTsPipeline","packetStream","elementaryStream","h264Stream","videoSegmentStream","id3Frame","setBaseMediaDecodeTime","isAac","resetCaptions","getTracks","getTimescaleFromMediaHeader","bin","parseType_1","toUnsigned$2","parseType$2","findBox$2","subresults","toUnsigned$1","getUint64$2","parseTfdt$2","parseSampleFlags","parseTrun$2","dataOffsetPresent","firstSampleFlagsPresent","sampleDurationPresent","sampleSizePresent","sampleFlagsPresent","sampleCompositionTimeOffsetPresent","getInt32","parseTfhd$2","baseDataOffsetPresent","sampleDescriptionIndexPresent","defaultSampleDurationPresent","defaultSampleSizePresent","defaultSampleFlagsPresent","durationIsEmpty","defaultBaseIsMoof","sampleDescriptionIndex","defaultSampleDuration","defaultSampleSize","defaultSampleFlags","baseDataOffsetIsMoof","findBox$1","parseTfdt$1","parseTrun$1","parseTfhd$1","window$2","mapToSample","approximateOffset","parseCaptionNals","videoTrackId","trafs","mdats","captionNals","mdatTrafPairs","matchingTraf","pair","headerInfo","truns","allSamples","parseSamples","avcStream","seiNal","lastMatchedSample","avcView","logs","seiNals","matchingSample","findSeiNals","captionParser","segmentCache","parsedCaptions","parsingPartial","isInitialized","isPartial","isNewInit","videoTrackIds","timescales","parsedData","cachedSegment","trackNals","parseEmbeddedCaptions","pushNals","nals","nal","clearParsedCaptions","resetCaptionStream","clearAllCaptions","uint8ToCString","curChar","retString","getUint64$1","isValidEmsgBox","emsg","hasScheme","scheme_id_uri","isValidV0Box","isDefined","presentation_time_delta","isValidV1Box","presentation_time","emsg$1","parseEmsgBox","boxData","event_duration","emsgBox","message_data","scaleTime","timeDelta","toUnsigned","toHexString","parseType$1","parseTfhd","parseTrun","parseTfdt","window$1","lowestTime","baseTime","scale","traks","tkhdVersion","getUint8","sampleDescriptions","codecConfig","codecBox","probe$2","StreamTypes$1","parsePid","parsePayloadUnitStartIndicator","parseAdaptionField","parseNalUnitType","probe$1","pusi","payloadOffset","parsePesType","parsePesTime","videoPacketContainsKeyFrame","frameBuffer","frameI","frameSyncPoint","foundKeyFrame","StreamTypes","probe","parseAudioPes_","pesType","parsed","endLoop","table","parseVideoPes_","firstKeyFrame","inspectTs_","parsePsi_","tsInspector","baseTimestamp","audioCount","audioTimescale","inspectAac_","audioBaseTimestamp","dtsTime","ptsTime","videoBaseTimestamp","adjustTimestamp_","MessageHandlers","initArray","postMessage","action","gopInfo","timingInfo","videoSegmentTimingInfo","presentation","audioSegmentTimingInfo","trackInfo","audioTimingInfo","wireTransmuxerEvents","pushMp4Captions","trackIds","probeMp4StartTime","probeMp4Tracks","probeTs","baseStartTime","tsStartTime","timeInfo","videoStart","audioStart","clearAllMp4Captions","clearParsedMp4Captions","setTimestampOffset","timestampOffset","appendStart","onmessage","messageHandlers","TransmuxWorker","processTransmux","audioAppendStart","onData","onTrackInfo","onAudioTimingInfo","onVideoTimingInfo","onVideoSegmentTimingInfo","onAudioSegmentTimingInfo","onId3","onCaptions","onDone","onEndedTimeline","onTransmuxerLog","isEndOfTimeline","transmuxedData","waitForEndedTimelineEvent","currentTransmux","videoFrameDtsTime","videoFramePtsTime","handleData_","handleGopInfo_","_ref46","handleDone_","dequeue","transmuxQueue","processAction","enqueueAction","transmux","segmentTransmuxer","term","workerCallback","endAction","listenForEndEvent","isArrayBuffer","transfers","REQUEST_ERRORS","abortAll","activeXhrs","handleErrors","handleKeyResponse","finishProcessingFn","errorObj","parseInitSegment","_ref47","handleSegmentResponse","_ref49","newBytes","stringToArrayBuffer","lastReachedChar","stats","getRequestStats","encryptedBytes","transmuxAndNotify","_ref50","trackInfoFn","timingInfoFn","videoSegmentTimingInfoFn","audioSegmentTimingInfoFn","id3Fn","captionsFn","endedTimelineFn","dataFn","doneFn","fmp4Tracks","isMuxed","audioStartFn","audioEndFn","videoStartFn","videoEndFn","probeResult","id3Frames","handleSegmentBytes","_ref51","bytesAsUint8Array","isLikelyFmp4MediaSegment","isFmp4","audioCodec","videoCodec","finishLoading","_ref52","decrypt","decryptionWorker","decryptionHandler","decrypted","keyBytes","encrypted","waitForCompletion","_ref55","didError","segmentFinish","_ref54","requestId","decryptedBytes","decryptSegment","endOfAllRequests","parseError","handleProgress","_ref57","progressFn","progressEvent","getProgressStats","firstBytesReceivedAt","mediaSegmentRequest","_ref58","xhrOptions","abortFn","keyXhr","mapKeyXhr","initSegmentOptions","initSegmentRequestCallback","_ref48","handleInitSegmentResponse","initSegmentXhr","segmentRequestOptions","segmentXhr","loadendState","activeXhr","_ref56","calledAbortFn","handleLoadEnd","logFn$1","isMaat","mediaAttributes","unwrapCodecList","codecList","_ref59","codecCount","codecObj","codecsForPlaylist","codecInfo","getCodecs","audioGroup","defaultCodecs","audioGroupId","audioType","codecsFromDefault","logFn","representationToString","safeGetComputedStyle","property","stableSort","sortFn","newArray","cmp","comparePlaylistBandwidth","leftBandwidth","rightBandwidth","simpleSelector","playerBandwidth","playerWidth","limitRenditionByPlayerDimensions","playlistController","getAudioTrackPlaylists_","sortedPlaylistReps","rep","enabledPlaylistReps","bandwidthPlaylistReps","highestRemainingBandwidthRep","bandwidthBestRep","chosenRep","haveResolution","resolutionBestRepList","resolutionBestRep","resolutionPlusOneList","resolutionPlusOneSmallest","resolutionPlusOneRep","leastPixelDiffRep","leastPixelDiffSelector","leastPixelDiffList","pixelDiff","lastBandwidthSelector","pixelRatio","useDevicePixelRatio","devicePixelRatio","systemBandwidth","playlistController_","addMetadata","_ref61","inbandTextTracks","metadataArray","videoDuration","Cue","WebKitDataCue","metadataTrack","metadataTrack_","deprecateOldCue","cuesArray","cuesGroupedByStartTime","timeSlot","sortedStartTimes","cueGroup","nextTime","removeCuesFromTrack","finite","segmentInfoString","startOfSegment","mediaIndex","segmentLen","selection","isSyncRequest","independent","hasPartIndex","zeroBasedPartCount","timingInfoPropertyForMedia","shouldWaitForTimelineChange","_ref63","timelineChangeController","loaderType","audioDisabled","lastMainTimelineChange","lastTimelineChange","pendingAudioTimelineChange","pendingTimelineChange","segmentTooLong","_ref64","maxDuration","getTroublesomeSegmentDurationMessage","sourceType","timingInfos","typeTimingInfo","mediaDuration","isSegmentWayTooLong","isSegmentSlightlyTooLong","segmentTooLongMessage","severity","SegmentLoader","mediaSource","throughput","roundTrip","resetStats_","hasPlayed_","hasPlayed","seekable_","seeking_","mediaSource_","loaderType_","currentMediaInfo_","startingMediaInfo_","segmentMetadataTrack_","segmentMetadataTrack","goalBufferLength_","goalBufferLength","sourceType_","sourceUpdater_","sourceUpdater","inbandTextTracks_","state_","timelineChangeController_","shouldSaveSegmentTimingInfo_","useDtsForTimestampOffset_","useDtsForTimestampOffset","captionServices_","checkBufferTimeout_","currentTimeline_","pendingSegment_","xhrOptions_","pendingSegments_","audioDisabled_","isPendingTimestampOffset_","gopBuffer_","timeMapping_","safeAppend_","appendInitSegment_","playlistOfLastInitSegment_","callQueue_","loadQueue_","metadataQueue_","waitingOnRemove_","quotaExceededErrorRetryTimeout_","activeInitSegmentId_","initSegments_","cacheEncryptionKeys_","cacheEncryptionKeys","keyCache_","decrypter_","decrypter","syncController_","syncController","syncPoint_","transmuxer_","createTransmuxer_","triggerSyncInfoUpdate_","isEndOfStream_","ended_","fetchAtBuffer_","newState","hasEnoughInfoToAppend_","processCallQueue_","hasEnoughInfoToLoad_","processLoadQueue_","mediaBytesTransferred","mediaRequests","mediaRequestsAborted","mediaRequestsTimedout","mediaRequestsErrored","mediaTransferDuration","mediaSecondsLoaded","mediaAppends","abort_","setAudio","removeAudio","monitorBuffer_","abortRequests","clearPendingTimelineChange","checkForAbort_","endOfStream","buffered_","getMediaInfo_","videoBuffered","audioBuffered","initSegmentForMap","storedMap","segmentKey","storedKey","couldBeginLoading_","playlist_","init_","resetEverything","newPlaylist","syncInfo","setDateTimeMappingForStart","oldId","resyncLoader","resetLoader","mediaSequenceDiff","saveExpiredSegmentInfo","force","removesRemaining","removeFinished","mapping","updatedBuffer","removeGopBuffer","removeVideo","monitorBufferTick_","fillBuffer_","updating","chooseNextRequest_","loadSegment_","appendedLastSegment","appendedLastPart","bufferedTime","preloaded","haveEnoughBuffer","getSyncPoint","targetTime","timelineSegments","getSyncSegmentCandidate","nextSegment","lastSegmentLastPart","generateSegmentInfo_","forceTimestampOffset","random","overrideCheck","timestampOffsetForSegment_","audioBufferedEnd","audioTimestampOffset","currentTimePts","gopsSafeToAlignWith","videoTimestampOffset","_ref62","timestampOffsetForSegment","earlyAbortWhenNeeded_","measuredBandwidth","requestTimeRemaining","timeUntilRebuffer$1","timeUntilRebuffer","switchCandidate","compatiblePlaylists","enabledPlaylists","rebufferingEstimates","numRequests","rebufferingImpact","noRebufferingPlaylists","estimate","minRebufferMaxBandwidthSelector","timeSavedBySwitching","minimumTimeSaving","handleAbort_","handleProgress_","simpleSegment","handleTrackInfo_","checkForIllegalMediaSwitch","akeys","bkeys","shallowEqual","handleTimingInfo_","timeType","timingInfoProperty","handleCaptions_","captionData","hasAppendedData_","captionTracks","captionTrack","trackName","def","captionService","createCaptionsTrackIfNotExists","captionArray","addCaptionData","handleId3_","inBandMetadataTrackDispatchType","createMetadataTrackIfNotExists","processMetadataQueue_","callQueue","fun","loadQueue","getCurrentMediaInfo_","getPendingSegmentPlaylist","setTimeMapping_","updateMediaSecondsLoaded_","useVideoTimingInfo","firstVideoFrameTimeForData","trueSegmentStart_","currentStart","currentVideoTimestampOffset","updateAppendInitSegmentStatus","updateSourceBufferTimestampOffset_","updateTimingInfoEnd_","saveSegmentTimingInfo","shouldSaveTimelineMapping","appendData_","changedTimestampOffset","getInitSegmentAndUpdateState_","handleQuotaExceededError_","audioBufferStart","audioBufferEnd","videoBufferStart","videoBufferEnd","appendToSourceBuffer_","timeToRemoveUntil","MIN_BACK_BUFFER","handleAppendError_","segmentObj","concatSegments","appendBuffer","handleSegmentTimingInfo_","segmentTimingInfo","transmuxedDecodeStart","transmuxedDecodeEnd","trimBackBuffer_","updateTransmuxerAndRequestSegment_","shouldUpdateTransmuxerTimestampOffset_","createSimplifiedSegmentObj_","isEndOfStream","isWalkingForward","isDiscontinuity","segmentRequestFinished_","_ref69","removeToTime","trimTime","maxTrimTime","safeBackBufferTrimTime","previousSegment","saveTransferStats_","saveBandwidthRelatedStats_","handleTimeout_","updateGopBuffer","waitForAppendsToComplete_","timelineMapping","mappingForTimeline","waitForVideo","waitForAudio","waitingOnAppends","checkAppendsDone_","videoQueueCallback","audioQueueCallback","handleAppendsDone_","illegalMediaSwitchError","startingMedia","illegalMediaSwitch","didChange","getSegmentStartTimeForTimestampOffsetCalculation_","prioritizedTimingInfo","segmentDurationMessage","recordThroughput_","addSegmentMetadataCue_","badSegmentGuess","badPartGuess","segmentProcessingTime","segmentProcessingThroughput","bufferTypes","sourceBuffer","queuePending","shiftQueue","queueIndex","queueEntry","nextQueueIndexOfType","cleanupBuffer","titleType","inSourceBuffers","sourceBuffers","actions","onError","mime","addSourceBuffer","removeSourceBuffer","changeType","pushQueue","_ref72","onUpdateend","SourceUpdater","sourceopenListener_","audioTimestampOffset_","videoTimestampOffset_","delayedAudioAppendQueue_","videoAppendQueued_","onVideoUpdateEnd_","onAudioUpdateEnd_","onVideoError_","videoError_","onAudioError_","audioError_","createdSourceBuffers_","initializedEme_","triggeredReady_","initializedEme","hasCreatedSourceBuffers","hasInitializedAnyEme","createSourceBuffers","addOrChangeSourceBuffers","canRemoveSourceBuffer","SourceBuffer","canChangeType","processedAppend_","videoBuffer","que","audioBuffer","bufferA","bufferB","arity","extents","bufferIntersection","setDuration","uint8ToUtf8","uintArray","escape","VTT_LINE_TERMINATORS","NoVttJsError","VTTSegmentLoader","subtitlesTrack_","featuresNativeTextTracks_","loadVttJs","combinedByteLength","combinedSegment","timestampOffsetForTimeline","checkTimestampOffset","skipEmptySegments_","stopForError","requested","parseVTTCues_","updateTimeMapping_","timelines","duplicates","occurrences","dupe","removeDuplicateCuesFromTrack","decodeBytesToString","timestampmap","MPEGTS","LOCAL","mapData","segmentData","mappingObj","diff","firstStart","lastStart","findAdCue","mediaTime","adStartTime","adEndTime","syncPointStrategies","run","timelineToDatetimeMappings","lastDistance","datetimeMapping","z","discontinuitySync","discontinuities","SyncController","syncPoints","runStrategies_","selectSyncPoint_","getExpiredTime","strategy","bestSyncPoint","bestDistance","bestStrategy","newDistance","lastRemovedSegment","firstSegment","playlistTimestamp","didCalculateSegmentTimeMapping","calculateSegmentTimeMapping_","saveDiscontinuitySyncInfo_","dateTime","accuracy","mediaIndexDiff","TimelineChangeController","pendingTimelineChanges_","lastTimelineChanges_","workerCode","aesTables","AES","tmp","tables","encTable","decTable","sbox","sboxInv","xInv","th","x2","x4","x8","tEnc","tDec","precompute","_tables","keyLen","rcon","encKey","decKey","encrypted0","encrypted1","encrypted2","encrypted3","out","a2","c2","nInnerRounds","kIndex","table0","table1","table2","table3","AsyncStream","jobs","timeout_","processJob_","job","ntoh","word","Decrypter","initVector","STEP","encrypted32","Int32Array","asyncStream_","decryptChunk_","padded","decipher","decrypted32","init0","init1","init2","init3","wordIx","audioTrackKind_","stopLoaders","segmentLoader","activePlaylistLoader","startLoaders","playlistLoader","segmentLoaders","excludePlaylist","activeTrack","activeGroup","defaultTrack","onTrackChanged","setupListeners","requestOptions","initialize","variantLabel","isMainPlaylist","newProps","groupMatch","setupMediaGroups","audioSegmentLoader","mainSegmentLoader","variants","groupKeys","groupPropertyList","onGroupChanged","getActiveGroup","previousActiveLoader","lastGroup","lastGroup_","lastTrack_","onGroupChanging","lastTrack","pc","selectPlaylist","fastQualityChange_","activeTrack_","onAudioTrackChanged","Vhs$1","loaderStats","sumLoaderStat","stat","audioSegmentLoader_","mainSegmentLoader_","PlaylistController","externVhs","useCueTags","enableLowInitialPlaylist","bufferBasedABR","maxPlaylistRetries","useCueTags_","cueTagsTrack_","requestOptions_","pauseLoading","mediaTypes_","createMediaTypes","handleDurationChange_","handleSourceOpen_","handleSourceEnded_","segmentLoaderSettings","setupMainPlaylistLoaderListeners_","subtitleSegmentLoader_","onLoad","setupSegmentLoaderListeners_","startABRTimer_","stopABRTimer_","triggeredFmp4Usage","loadOnPlay_","timeToLoadedData__","mainAppendsToLoadedData__","audioAppendsToLoadedData__","timeToLoadedDataStart","mainAppendsToLoadedData_","audioAppendsToLoadedData_","appendsToLoadedData_","timeToLoadedData_","checkABR_","nextPlaylist","shouldSwitchToMedia_","switchMedia_","newId","abrTimer_","defaultPlaylists","defaultGroup","requestTimeout","triggerPresenceUsage_","setupFirstPlay","updatedPlaylist","selectedMedia","excludeUnsupportedVariants_","selectInitialPlaylist","initialMedia_","handleUpdatedMediaPlaylist","playlistToExclude","lastExcludeReason_","stuckAtPlaylistEnd_","updateAdCues_","updateDuration","defaultDemuxed","audioGroupKeys","currentPlaylist","bufferLowWaterLine","bufferHighWaterLine","sharedLogLine","isBuffered","forwardBuffer","maxBufferLowWaterLine","nextBandwidth","currBandwidth","logLine","shouldSwitchToMedia","onSyncInfoUpdate_","onEndOfStream","delegateLoaders_","updateCodecs","tryToCreateSourceBuffers_","getCodecsOrExclude_","mediaSecondsLoaded_","mainMediaInfo","absolutePlaylistEnd","reincluded","errorMessage","delayDuration","fnNames","loaders","dontFilterPlaylist","loader","audioSeekable","mainSeekable","oldEnd","oldStart","updateDuration_","areMediaTypesKnown_","usingAudioLoader","hasMainMediaInfo","hasAudioMediaInfo","playlistCodecs","unsupportedCodecs","unsupportedAudio","supporter","switchMessages","newCodec","oldCodec","excludeIncompatibleVariants_","ids","unsupported","codecCount_","videoDetails","audioDetails","exclusionReasons","variantCodecs","variantCodecCount","variantVideoDetails","variantAudioDetails","adOffset","adTotal","updateAdCues","newMax","Representation","vhsHandler","qualityChangeFunction","playlistID","changePlaylistFn","incompatible","currentlyEnabled","timerCancelEvents","PlaybackWatcher","allowSeeksWithinUnsafeLiveWindow","liveRangeSafeTimeDelta","consecutiveUpdates","lastRecordedTime","checkCurrentTimeTimeout_","playHandler","monitorCurrentTime_","canPlayHandler","waitingHandler","techWaiting_","cancelTimerHandler","resetTimeUpdate_","loaderTypes","loaderChecks","resetSegmentDownloads_","updateend","checkSegmentDownloads_","setSeekingHandlers","seekingAppendCheck_","fixesBadSeeks_","clearSeekingAppendCheck_","watchForBadSeeking_","checkCurrentTime_","isBufferedDifferent","isRangeDifferent","waiting_","afterSeekableWindow_","beforeSeekableWindow_","minAppendedDuration","bufferedToCheck","nextRange","livePoint","videoUnderflow_","skipTheGap_","allowedEnd","gap","lastVideoRange","videoRange","audioRange","gapFromVideoUnderflow_","scheduledCurrentTime","gaps","findGaps","defaultOptions","errorInterval","getSource","IWillNotUseThisInPlugins","lastCalled","localOptions","loadedMetadataHandler","cleanupEvents","reloadSourceOnError","STANDARD_PLAYLIST_SELECTOR","INITIAL_PLAYLIST_SELECTOR","movingAverageBandwidthSelector","decay","average","lastSystemBandwidth","comparePlaylistResolution","leftWidth","rightWidth","handleVhsMediaChange","waitForKeySessionCreation","_ref80","sourceKeySystems","audioMedia","mainPlaylists","eme","initializeMediaKeys","keySystemsOptionsArr","keySystems","keySystemsArr","keySystemsOptions","keySystemsObj","keySystemOptions","getAllPsshKeySystemsOptions","initializationFinishedPromises","keySessionCreatedPromises","race","setupEmeOptions","_ref81","sourceOptions","audioPlaylist","videoContentType","audioContentType","keySystemContentTypes","emeKeySystems","getVhsLocalStorage","storedObject","supportsNativeHls","canItPlay","supportsNativeDash","supportsTypeNatively","Component","VhsHandler","initialBandwidth","_player","source_","ignoreNextSeekingEvent_","setOptions_","overrideNative","featuresNativeVideoTracks","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","useBandwidthFromLocalStorage","useNetworkInformationApi","option","dataUri","playbackWatcherOptions","playbackWatcher_","defaultSelector","playerBandwidthEst","networkInformation","connection","mozConnection","webkitConnection","networkInfoBandwidthEstBitsPerSec","downlink","invBandwidth","invThroughput","mediaRequests_","mediaRequestsAborted_","mediaRequestsTimedout_","mediaRequestsErrored_","mediaTransferDuration_","mediaBytesTransferred_","mediaAppends_","mainAppendsToLoadedData","audioAppendsToLoadedData","appendsToLoadedData","timeToLoadedData","currentTech","playerDimensions","objectToStore","updateVhsLocalStorage","setupEme_","setupQualityLevels_","mediaSourceUrl_","createKeySessions_","audioPlaylistLoader","handleWaitingForKey_","didSetupEmeOptions","excludedHDPlaylists","qualityLevels_","convertToProgramTime","VhsSourceHandler","simpleType","getOverrideNative","defaultOverrideNative"],"mappings":"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CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAO,MAAQ,CAAC,KAAQ,MAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,MAAS,OAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,CAAC,OAAS,QAAU,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"}